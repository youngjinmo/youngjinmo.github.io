<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Live Study 8주차 - 인터페이스</title>
      <link href="2021/02/livestudy-week-08/"/>
      <url>2021/02/livestudy-week-08/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/peEXNN-oob4/maxresdefault.jpg"></p><ul><li><a href="#interface">인터페이스 정의하는 방법</a><ul><li><a href="#purpose">인터페이스 목적 : 느슨한 결합</a></li></ul></li><li><a href="#implements">인터페이스 구현하는 방법</a><ul><li><a href="#implements">implements</a></li><li><a href="#anonymous-class">익명 클래스</a></li></ul></li><li><a href="#reference">인터페이스 레퍼런스를 통해 구현체를 사용하는 방법</a></li><li><a href="#inheritance">인터페이스 상속</a></li><li><a href="#default-method">인터페이스의 기본 메서드(Default Method), 자바8</a><ul><li><a href="#duplication-method-name">디폴트 메서드가 구현체의 메서드와 이름이 중복될 경우</a></li></ul></li><li><a href="#static-method">인터페이스의 static 메서드, 자바8</a></li><li><a href="#private-method">인터페이스의 private 메서드, 자바 9</a></li><li><a href="#differ-interface-abstractclass">인터페이스와 추상클래스의 차이</a></li></ul><br><h1 id="인터페이스-정의하는-방법"><a href="#인터페이스-정의하는-방법" class="headerlink" title="인터페이스 정의하는 방법"></a><a name="interface"></a>인터페이스 정의하는 방법</h1><p>인터페이스는 <b><a href="https://youngjinmo.github.io/2021/02/livestudy-week-06/#abstractclass">추상 클래스</a>보다 추상화가 더 높은 클래스</b>이다. 추상 클래스가 미완성 설계도라면, 인터페이스는 밑그림만 그려져있는 기본 설계도라고 할 수 있다.</p><h2 id="인터페이스의-목적-느슨한-결합"><a href="#인터페이스의-목적-느슨한-결합" class="headerlink" title="인터페이스의 목적 : 느슨한 결합"></a><a name="purpose"></a>인터페이스의 목적 : 느슨한 결합</h2><ol><li><strong>클래스간 결합(느슨한 결합)을 낮춰준다.</strong> 인터페이스를 통해서 여러 클래스에서 각각 구현하여 사용할 수 있게된다.</li><li><strong>표준화가 가능하다.</strong> 어떤 기능을 구현해야 하는지를 인터페이스를 통해 추론할 수 있다.</li></ol><p>이 느슨한 결합을 설명하는 예제코드가 있어서 가져와봤다. (출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001&start=slayer">남궁성 - Java의 정석</a>)</p><p><strong>강한 결합 관계</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(B b)</span> </span>&#123;  <span class="comment">// A -&gt; B</span></span><br><span class="line">      b.methodB();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;methodB();&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      A a = <span class="keyword">new</span> A();</span><br><span class="line">      a.methodA(<span class="keyword">new</span> B());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodB();</span><br></pre></td></tr></table></figure><p>A가 B에 의존하는 관계이다. 이 경우에 <code>methodA()</code>의 인자를 새로운 클래스 <code>C</code>를 사용하도록 하려면 아래처럼 바꿔야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(C c)</span> </span>&#123;  <span class="comment">// A -&gt; C</span></span><br><span class="line">      b.methodB();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;methodC();&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      A a = <span class="keyword">new</span> A();</span><br><span class="line">      a.methodA(<span class="keyword">new</span> C());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">methodC();</span><br></pre></td></tr></table></figure><p><b><u>Class A와 Class DevAndy 모두 변경</u></b>을 해야했다. 그렇다면 느슨한 결합관계에선 어떨까?</p><p><strong>느슨한 결합 관계</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">(I i)</span> </span>&#123;  <span class="comment">// A -&gt; I</span></span><br><span class="line">      i.methodB();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;methodB();&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;methodC();&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      A a = <span class="keyword">new</span> A();</span><br><span class="line">      I i = <span class="keyword">new</span> C();</span><br><span class="line">      a.methodA(i);  <span class="comment">// a.methodA(new C()); 와 같다.</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class C가 있다는 가정하에, <code>a.methodA()</code> 의 인자값만 변경하면 되었다. </p><blockquote><p><code>I i = new C();</code> 코드의 설명은 <a href="#reference">인터페이스 레퍼런스를 통한 구현체 사용</a>에서 정리했다.</p></blockquote><p>강한 결합관계에서는 Class A와 호출해서 사용하는 클래스인 Class DevAndy 모두 수정을 해야했다면, <b><u>느슨한 결합관계에서는 Class DevAndy에서만 변경하면 되기 때문에 코드의 변경시 더 유리한 장점</u></b>이 있었다.</p><br><p>인터페이스 정의는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BoardService</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 게시글 작성</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@author</span> DevAndy</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBoard</span><span class="params">(HttpSession session, String title, String contents)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인터페이스는 기본적으로 클래스지만, <code>class</code> 대신 <code>interface</code> 라고 작성한다. 추상 클래스가 <code>abstract class</code> 로 작성하는것과 다른 문법이다.</p><p>인터페이스의 접근제한자는 일반 클래스와 마찬가지로 <code>public</code>, <code>default</code>만 가질 수 있다.</p><br><h1 id="인터페이스-구현하는-방법"><a href="#인터페이스-구현하는-방법" class="headerlink" title="인터페이스 구현하는 방법"></a><a name="implements"></a>인터페이스 구현하는 방법</h1><p>인터페이스를 구현하는 방법은 2가지가 있다. 하나는 <code>implements</code> 키워드를 사용하여 구현체 클래스를 생성하는 방식과 하나는 익명클래스로 인터페이스를 구현하는 방법</p><h2 id="implements"><a href="#implements" class="headerlink" title="implements"></a><a name="implements"></a>implements</h2><p>인터페이스를 구현한다는 이야기는 클래스간 상속과 같다. 그러나 추상클래스와 달리 인터페이스는 <code>extends</code> 키워드가 아닌 <code>implements</code> 키워드로 구현한다. (<a href="https://youngjinmo.github.io/2021/02/livestudy-week-06/#differ-interface-abstractclass">인터페이스와 추상클래스의 차이</a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduction</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduction</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello my name is &quot;</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IDE에서 <code>implements</code> 키워드로 인터페이스 구현체를 생성하면, 자동으로 추상 메서드를 구현하도록 도와준다.</p><p>추상 메서드를 구현할 때에 <code>@Override</code> 어노테이션이 자동으로 붙는데, 사실 어노테이션이 없어도 오버라이딩 문법만 맞춰서 메서드를 작성한다면 적용이 된다. 하지만 <code>@Override</code> 어노테이션을 작성하면, 해당 메서드가 오버라이딩 문법에 맞춰서 작성되었는지를 체크해주므로 작성해주는 것이 좋다.</p><h2 id="익명클래스"><a href="#익명클래스" class="headerlink" title="익명클래스"></a><a name="anonymous-class"></a>익명클래스</h2><p>인스턴스를 생성할 때, 생성자를 이용하여 이름없는 클래스인 익명 클래스를 통해서 인터페이스를 구현하는 방식이다.</p><p>익명클래스의 구조는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">인터페이스 인스턴스 = <span class="keyword">new</span> 인터페이스()&#123;</span><br><span class="line">   <span class="comment">// 인터페이스 구현</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>익명클래스로 인터페이스 <code>Player</code>의 추상 메서드(<code>introduction()</code>)를 구현한 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Player player = <span class="keyword">new</span> Player()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduction</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Hello my name is &quot;</span>+name);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      player.introduction(<span class="string">&quot;Andy&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello my name is Andy</span><br></pre></td></tr></table></figure><br><h1 id="인터페이스-레퍼런스를-통해-구현체를-사용하는-방법"><a href="#인터페이스-레퍼런스를-통해-구현체를-사용하는-방법" class="headerlink" title="인터페이스 레퍼런스를 통해 구현체를 사용하는 방법"></a><a name="reference"></a>인터페이스 레퍼런스를 통해 구현체를 사용하는 방법</h1><p>인터페이스 레퍼런스를 통해 구현체를 사용한다는 의미를 이번 스터디를 통해 처음 알게되었다. 위의 코드를 활용해서 인터페이스 레퍼런스를 통해서 구현체를 사용해보도록 하겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduction</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPlayer</span> <span class="keyword">implements</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">introduction</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello my name is &quot;</span>+name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   MyPlayer player = <span class="keyword">new</span> MyPlayer();</span><br><span class="line">   player.introduction(<span class="string">&quot;Andy&quot;</span>);</span><br><span class="line">   </span><br><span class="line">   Player player02 = player;</span><br><span class="line">   player02.introduction(<span class="string">&quot;Steve Jobs&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello my name is Andy</span><br><span class="line">Hello my name is Steve Jobs</span><br></pre></td></tr></table></figure><p>인터페이스인 <code>Player</code>의 인스턴스 <code>player02</code>를 선언하면서 참조변수로 인터페이스 구현체인 <code>MyPlayer</code>의 인스턴스를 참조했다.</p><p>출처 : <a href="https://www.notion.so/4b0cf3f6ff7549adb2951e27519fc0e6">ssonsh - 인터페이스</a></p><br><h1 id="인터페이스-상속"><a href="#인터페이스-상속" class="headerlink" title="인터페이스 상속"></a><a name="inheritance"></a>인터페이스 상속</h1><p>인터페이스도 상속이 된다. 자바에서는 인터페이스간 상속을 허용한다. 역시 인터페이스가 클래스이기 때문에 가능한 것으로 추론한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Athlete</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">preSeason</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">whileSeason</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">FootballPlayer</span> <span class="keyword">extends</span> <span class="title">Athlete</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">postSeaon</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfessionalPlayer</span> <span class="keyword">implements</span> <span class="title">FootballPlayer</span></span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSeaon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;post seaon&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preSeason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;pre season&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whileSeason</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;시즌중!!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayGround</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ProfessionalPlayer proFootballer = <span class="keyword">new</span> ProfessionalPlayer();</span><br><span class="line">      proFootballer.preSeason();</span><br><span class="line">      proFootballer.whileSeason();</span><br><span class="line">      proFootballer.postSeaon();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pre season</span><br><span class="line">시즌중!!</span><br><span class="line">pre season</span><br></pre></td></tr></table></figure><br><h1 id="인터페이스의-디폴트-메서드-Default-Method-자바8"><a href="#인터페이스의-디폴트-메서드-Default-Method-자바8" class="headerlink" title="인터페이스의 디폴트 메서드(Default Method), 자바8"></a><a name="default-method"></a>인터페이스의 디폴트 메서드(Default Method), 자바8</h1><p>인터페이스는 원래 추상 메서드만 선언할 수 있었다고 한다. 그러나 Java 8부터 인터페이스에 <b>디폴트 메서드</b>와 <b>static 메서드</b>도 추가하는것이 가능해졌다.</p><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>Java 8 이전의 <b>인터페이스의 단점은 인터페이스에 변경사항이 발생할 경우, 해당 인터페이스를 구현하고있는 모든 구현체를 수정해야 한다는 단점</b>이 있었다. 예를들면 인터페이스에 추상 메서드를 추가해야 할일이 발생한다면, 인터페이스에도 메서드를 추가해야하지만, 해당 인터페이스를 구현하고 있는 모든 구현체에서 메서드를 추가하고, 구현해야 한다는 부담이 발생한다.</p><p>이 문제를 해결하기 위해 등장한 것이 디폴트 메서드이다. <b><u>디폴트 메서드는 추상메서드가 아니기 때문에 메서드에 변경사항이 발생하더라도 구현체를 변경할 필요가 없다.</u></b></p><h3 id="default-method-문법"><a href="#default-method-문법" class="headerlink" title="default method 문법"></a>default method 문법</h3><p>앞서 디폴트 메서드는 추상 메서드가 아니라고 했다. 따라서 디폴트 메서드는 구현체(메서드 바디)가 필요하다.</p><p>메서드 앞에 <code>default</code> 키워드를 붙이고, 구현체를 작성하면 디폴트 메서드가 추가된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>;          <span class="comment">// 추상 메서드</span></span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="comment">// 디폴트 메서드</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 <code>method02()</code>를 디폴트 메서드로 인터페이스에 추가하면, 모든 구현체에 <code>method02()</code>를 추가할 필요없이 인터페이스만 수정하고, 사용하는 클래스에서 메서드를 사용하면 된다.</p><p>예제 코드를 만들어보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;   <span class="comment">// overriding 메서드 </span></span><br><span class="line">      System.out.println(<span class="string">&quot;method A by MyInterfaceImpl&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;   <span class="comment">// 일반 메서드</span></span><br><span class="line">      System.out.println(<span class="string">&quot;method B by MyInterfaceImpl&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class MyInterfaceImpl는 인터페이스 MyInterface의 구현체이다. <code>methodA()</code>를 오버라이딩하였으며, <code>methodB()</code>를 추가로 가지고 있다. 여기서 디폴트 메서드를 추가해보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;method B by MyInterface&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>디폴트 메서드는 구현체를 건드릴 필요없이 인터페이스에만 추가하면 사용할 수 있다. 그런데 구현체에 있는 메서드와 이름이 똑같은 일이 발생했다. 이렇게 되면 구현체의 인스턴스에서 접근되는 <code>methodB()</code>는 어떤 메서드에 접근될까?</p><h2 id="디폴트-메서드가-구현체의-메서드와-이름이-중복될-경우"><a href="#디폴트-메서드가-구현체의-메서드와-이름이-중복될-경우" class="headerlink" title="디폴트 메서드가 구현체의 메서드와 이름이 중복될 경우"></a><a name="duplication-method-name"></a>디폴트 메서드가 구현체의 메서드와 이름이 중복될 경우</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      MyInterface myInterface = <span class="keyword">new</span> MyInterfaceImpl();</span><br><span class="line">      myInterface.methodA();</span><br><span class="line">      myInterface.methodB();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method A by MyInterfaceImpl</span><br><span class="line">method B by MyInterfaceImpl</span><br></pre></td></tr></table></figure><p>이처럼 <b><u>디폴트 메서드가 구현체의 메서드와 이름이 중복되어 충돌할 경우 디폴트 메서드가 무시</u></b>되고, 구현체의 메서드가 우선된다. 상속 관계에서도 부모 클래스의 메서드가 상속되고, 인터페이스의 디폴트 메서드는 무시된다.</p><br><h1 id="인터페이스의-static-메서드-자바8"><a href="#인터페이스의-static-메서드-자바8" class="headerlink" title="인터페이스의 static 메서드, 자바8"></a><a name="static-method"></a>인터페이스의 static 메서드, 자바8</h1><p>Java 8에 디폴트 메서드와 함께 추가된 static 메서드는 디폴트 메서드에 <code>static</code> 키워드를 선언하면 static 메서드가 된다.</p><p><b><u>구현체의 인스턴스를 생성하지 않고도 인터페이스만으로 바로 메서드를 호출</u></b>할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;static method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      MyInterface.methodB();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static method</span><br></pre></td></tr></table></figure><br><h1 id="인터페이스의-private-메서드-자바-9"><a href="#인터페이스의-private-메서드-자바-9" class="headerlink" title="인터페이스의 private 메서드, 자바 9"></a><a name="private-method"></a>인터페이스의 private 메서드, 자바 9</h1><p>Java 9에서는 인터페이스에 private 메서드가 추가되었다. private 메서드가 추가되면서 <b><u>인터페이스의 메서드를 외부에 공개하지 않을수 있게 되었따.</u></b></p><p>인터페이스의 private 메서드의 특징은 다음과 같다.</p><ul><li>디폴트 메서드처럼 <b>구현체</b>를 가져야 한다.</li><li><b>인터페이스 내부에서만</b> 사용되는 메서드이다.</li><li><strong>private 메서드</strong>는 인터페이스의 <b><u>static 키워드가 없는 메서드</u></b>에서만,<br><strong>private static</strong> 메서드는 인터페이스의 <b><u>모든 메서드</u></b>에서 사용가능하다.</li></ul><p>예제 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;method 02 : default method&quot;</span>);</span><br><span class="line">      method04();</span><br><span class="line">      method05();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method03</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;method 03 : static method&quot;</span>);</span><br><span class="line">      <span class="comment">// method04();  compile error</span></span><br><span class="line">      method05();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method04</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;method 03 : private method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method05</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;method 04 : private static method&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInterfaceImpl</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Live Study 8주차 - 인터페이스 학습중&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      MyInterface myInterface = <span class="keyword">new</span> MyInterfaceImpl();</span><br><span class="line">      </span><br><span class="line">      myInterface.method01();</span><br><span class="line">      myInterface.method02();</span><br><span class="line">      MyInterface.method03();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Live Study 8주차 - 인터페이스 학습중</span><br><span class="line">method 02 : default method</span><br><span class="line">method 03 : private method</span><br><span class="line">method 04 : private static method</span><br><span class="line">method 03 : static method</span><br><span class="line">method 04 : private static method</span><br></pre></td></tr></table></figure><p>인터페이스에서 private 메서드를 사용하면 외부(구현체)에 공개하지 않는 메서드를 가질 수 있게된다.</p><br><h1 id="인터페이스와-추상클래스의-차이"><a href="#인터페이스와-추상클래스의-차이" class="headerlink" title="인터페이스와 추상클래스의 차이"></a><a name="differ-interface-abstractclass"></a>인터페이스와 추상클래스의 차이</h1><p>Java 8 이전까지의 인터페이스와 추상클래스의 차이는 아래와 같았다.</p><table><thead><tr><th>인터페이스</th><th>추상클래스</th></tr></thead><tbody><tr><td>구현 객체의 같은 동작을 보장하기 위함</td><td>추상 클래스를 상속받아서 기능을 이용, 확장시키기 위함</td></tr><tr><td>다중 상속이 가능하다</td><td>다중 상속이 불가능하다</td></tr><tr><td>추상 메서드만 사용 가능하다</td><td>일반 메서드와 일반 변수 모두 사용가능하다</td></tr><tr><td>상수+추상메서드</td><td>일반 변수 + 일반 메서드 + 추상 메서드</td></tr><tr><td>생성자와 일반 변수를 가질 수 없다.</td><td>생성자와 일반 변수를 모두 가질 수 있다</td></tr><tr><td><code>implements</code> 사용</td><td><code>extends</code> 사용</td></tr></tbody></table><p>그러나 Java 8에 추가된 디폴트 메서드, static 메서드 그리고 Java 9에서 추가된 private 메서드까지를 보니 이제 인터페이스와 추상클래스의 차이가 모호해진것 같다. Java 9까지의 인터페이스의 변경사항이 반영된 인터페이스와 추상클래스의 차이를 정리해보니 아래처럼 정리가 되는 것 같다.</p><table><thead><tr><th>인터페이스</th><th>추상클래스</th></tr></thead><tbody><tr><td>구현 객체의 같은 동작을 보장하기 위함</td><td>추상 클래스를 상속받아서 기능을 이용, 확장시키기 위함</td></tr><tr><td>다중 상속이 가능하다</td><td>다중 상속이 불가능하다</td></tr><tr><td><code>implements</code> 사용</td><td><code>extends</code> 사용</td></tr></tbody></table><p>여기까지 정리해보았을때엔 인터페이스가 생성자만 가지지 못할뿐 인터페이스간의 상속이 가능하고, 다중상속도 가능하기 때문에 모든 부분에서 인터페이스가 추상클래스보다 부족하지 않아보인다.</p><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
            <tag> whiteship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Int형 나누기 결과를 소수점 2자리까지만 얻어오기</title>
      <link href="2021/02/string-format-with-casting/"/>
      <url>2021/02/string-format-with-casting/</url>
      
        <content type="html"><![CDATA[<p><img src="https://regmedia.co.uk/2013/01/30/java_logo.jpg?x=442&y=293&crop=1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> num2 = <span class="number">30</span>;</span><br><span class="line">      </span><br><span class="line">      System.out.println(num1/num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>int형 데이터끼리 나누기 연산을 하면, 결과 또한 int형 자료형에 결과값이 담겨지는데 이 때 예상한 값과 다른 값이 담기게 된다. 따라서 명시적 형변환을 통해서 원하는 값을 출력하려고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> num2 = <span class="number">30</span>;</span><br><span class="line">      </span><br><span class="line">      System.out.println((<span class="keyword">double</span>)num1/num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.3333333333</span><br></pre></td></tr></table></figure><p>연산을 할 때, <code>double</code>형을 명시적으로 형변환하면, <code>double</code>과 <code>int</code>형의 연산이기 때문에 연산의 결과도 자료형 크기가 큰 <code>double</code>에 담겨지게 된다. <em>(int형 크기: 4 bytes, double형 크기: 8 bytes)</em></p><p>그러나 원하는 값이 소수점 2자리까지만 원한다면 <code>String</code> 클래스의 <code>format()</code>을 이용해서 만들어낼수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> num2 = <span class="number">30</span>;</span><br><span class="line">      <span class="keyword">double</span> result = (<span class="keyword">double</span>)num1/num2;</span><br><span class="line">      String formattedResult = String.format(<span class="string">&quot;%.2f&quot;</span>, result);</span><br><span class="line">     </span><br><span class="line">      System.out.println(formattedResult);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.33</span><br></pre></td></tr></table></figure><p>소수점 2자리까지만 잘라서 출력하긴 했지만, 이 값의 자료형은 <code>double</code>이 아니라 <code>String</code>이라는 사실을 유의해야한다. 이 값은 그저 출력을 위한 값일뿐이지, 연산을 위한 값으로는 적절치 않다. 문자열 데이터기 때문에 연산이 가능하지 않을뿐더러 <code>0.33333</code>과 <code>0.33</code>은 다른값이기 때문이다.</p><p>따라서 <code>String</code> 클래스의 포맷팅을 하려면, 연산을 마무리하는 시점에 해야할 것 같다.</p><p>출처 : <a href="https://youngjinmo.github.io/2021/01/livestudy-week-02/#casting">Live Study 2주차 - 자바 데이터 타입, 변수 그리고 배열</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> casting </tag>
            
            <tag> String </tag>
            
            <tag> formatting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live Study 7주차 - 패키지</title>
      <link href="2021/02/livestudy-week-07/"/>
      <url>2021/02/livestudy-week-07/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/peEXNN-oob4/maxresdefault.jpg"></p><ul><li><a href="#package">package 키워드</a></li><li><a href="#import">import 키워드</a></li><li><a href="#classpath">클래스패스</a><ul><li><a href="#classpath-env">CLASSPATH 환경변수</a></li><li><a href="#classpath-option">-classpath 옵션</a></li></ul></li><li><a href="#access-modifier">접근지시자</a></li></ul><br><h1 id="package-키워드"><a href="#package-키워드" class="headerlink" title="package 키워드"></a><a name="package"></a>package 키워드</h1><p>패키지는 클래스의 묶음이며, 자바는 <strong>반드시 하나의 패키지에 속해야 한다</strong>.</p><p>패키지의 특징은 다음과 같다.</p><ul><li>점을 구분자로 하여 계층구조로 구성한다.</li><li>패키지는 물리적으로 클래스 파일을 포함하는 하나의 디렉토리이다.</li></ul><p>사실 클래스의 이름에도 패키지가 포함된다. 6주차 과제에서 공부한 Object 클래스의 <code>getClass()</code> 를 출력해보면, 클래스명과 패키지 경로가 포함되서 출력되는걸 볼 수 있다.</p><p><img src="https://user-images.githubusercontent.com/33862991/107508594-9ddaa680-6be4-11eb-99e3-306812c4e0c3.png"></p><h3 id="이름없는-패키지"><a href="#이름없는-패키지" class="headerlink" title="이름없는 패키지"></a>이름없는 패키지</h3><p>위의 코드를 보면 패키지를 작성하지 않고 바로 클래스를 생성해서 컴파일링을 하였다. 자바에서는 반드시 하나의 패키지가 필요한데, 패키지가 작성하지 않았음에도 어떻게 컴파일링을 할 수 있었을까?</p><p>자바는 기본으로 <strong>이름없는 패키지(Unnamed package)</strong> 를 제공한다고 한다. 따라서 <u>특별히 패키지를 작성하지 않으면, 자바에서 모든 인터페이스와 클래스를 이름없는 패키지로 하나의 패키지에 포함</u>시키고 컴파일링을 한다.</p><p><strong>출처</strong></p><ul><li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001">남궁성 - Java의 정석</a></li><li><a href="https://tcpschool.com/java/java_usingClass_package">TCPschool - 패키지</a></li></ul><br><h1 id="import-키워드"><a href="#import-키워드" class="headerlink" title="import 키워드"></a><a name="import"></a>import 키워드</h1><p>개발자가 직접 A to Z를 작성하지 않는 이상 외부 라이브러리를 사용하곤 하는데, 이렇게 외부 라이브러리를 가져올때 사용하는 키워드가 <code>import</code>이다.</p><p>자바의 코드는 아래의 3가지로 구성된다.</p><ul><li>package</li><li>import</li><li>클래스 선언</li></ul><h3 id="bulk-import"><a href="#bulk-import" class="headerlink" title="bulk import"></a>bulk import</h3><p>패키지 경로가 같은 라이브러리가 있다면, Asterisk(<code>*</code>)으로 중복을 처리할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br></pre></td></tr></table></figure><p>위의 패키지는 아래처럼 정리할 수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br></pre></td></tr></table></figure><p>이렇게 하면  <code>java.util.</code>의 클래스를 전부 가져온다. 그러나 아래의 코드를 라이브러리를 불러오지 못한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.*;</span><br></pre></td></tr></table></figure><p><code>*</code>는 작성된 계층의 클래스를 불러올뿐, <strong>하위 클래스를 불러오는데 사용할 수는 없다.</strong></p><h3 id="import-static-문"><a href="#import-static-문" class="headerlink" title="import static 문"></a>import static 문</h3><p>import 패키지를 static 키워드로 불러오면, 패키지를 작성하지 않고도 클래스의 메서드를 호출할 수 있다. 아래의 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello world.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서 import static 키워드를 사용해서 바꿔보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.System.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      out.println(<span class="string">&quot;Hello world.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>패키지 <code>static</code> 키워드를 붙여서 <code>import</code>하면, 사용하면 System 클래스를 작성하지 않고도 바로 사용할 수 있다.</p><br><h1 id="클래스패스"><a href="#클래스패스" class="headerlink" title="클래스패스"></a><a name="classpath"></a>클래스패스</h1><p>클래스패스(CLASSPATH)란, JVM이 프로그램을 실행할 때, class 파일을 찾는데 기준이 되는 파일의 경로를 말한다. </p><p>컴파일 이후 변환된 바이트코드를 런타임에 실행할때, 바이트코드에 포함된 명령을 실행해야하는데, 이 때 CLASSPATH를 통해서 찾는다고 한다.</p><p>클래스 파일을 지정하는 방법은 두가지가 있다.</p><ul><li><a href="#classpath-env%22">CLASSPATH 환경변수</a></li><li><a href="#classpath-option">Java Runtime에 -classpath 옵션 사용</a></li></ul><p>출처 - <a href="https://effectivesquid.tistory.com/entry/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%8C%A8%EC%8A%A4classpath%EB%9E%80">알쓸신잡 - 자바 클래스패스(CLASSPATH)란?</a></p><br><h1 id="CLASSPATH-환경변수"><a href="#CLASSPATH-환경변수" class="headerlink" title="CLASSPATH 환경변수"></a><a name="classpath-env"></a>CLASSPATH 환경변수</h1><p>컴퓨터 시스템 변수 설정을 통해 CLASSPATH 환경변수를 지정하는 방식이다.</p><p>JVM이 시작되면, JVM의 클래스 로더가 환경변수를 호출하는데, 이 환경변수에 설정된 CLASSPATH를 따라서 해당 클래스들을 먼저 클래스 로더가 메모리로 로딩한다.</p><p>맥에서 자바 CLASSPATH를 환경변수로 지정해보겠다.</p><p>iTerm에서 아래의 명령어를 입력하면 내 컴퓨터에 설치된 JDK 목록이 출력된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;libexec&#x2F;java_home -V</span><br></pre></td></tr></table></figure><p>![](/Users/Andy/Desktop/draft/Screen Shot 2021-02-15 at 12.08.26 AM.png)</p><p>오라클에서 JDK 11.0.10을 설치했는데, 이걸로 JDK CLASSPATH를 지정하려고 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p>홈 디렉토리 하위에 <code>.bash_profile</code> 이라는 이름의 파일을 생성했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-11.0.10/Contents/Home</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><p>여기서 JAVA_HOME 을 변수로 지정하고, 이 JAVA_HOME에 변경하고자하는 JDK의 CLASSPATH를 작성한다. 그리고 이 JAVA_HOME을 변수로 이용해서 PATH로 지정을 하는 명령어이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p> 마지막으로 위 명령어를 iTerm에서 입력해야 실제로 반영이되어 <code>java -version</code> 에서 바뀐 JDK버전이 출력된다.</p><p>그러나 여기까지만 하면, iTerm을 종료하고 재실행했을때, jdk가 다시 이전으로 돌아간걸 확인할 수 있다. 현재 맥은 zsh라는 쉘이 적용되어 있는데, 이 zsh은 <code>.zshrc</code> 의 설정을 따른다고 한다. 따라서 이 <code>zshrc</code>를 수정해야만 최종적으로 jdk를 변경한걸 적용할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.zshrc</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/profile</span><br></pre></td></tr></table></figure><p>이젠 iTerm을 종료하고 다시켜더라도 jdk 버전이 변경된걸 확인할 수 있다.</p><p>출처 : <a href="https://codingsquirrel.tistory.com/45">코딩하는 다람쥐 - Mac에서 자바 path 및 환경변수 설정하기</a></p><br><h1 id="classpath-옵션"><a href="#classpath-옵션" class="headerlink" title="-classpath 옵션"></a><a name="classpath-option"></a>-classpath 옵션</h1><p><code>-classpath</code> 옵션키워드를 사용하면 환경설정을 하지않고도 또는 임의로 CLASSPATH를 지정하는것이 가능하다.</p><p><code>DevAndy</code>라는 클래스를 실행하면서 여기에 필요한 클래스가 <code>EngClasses</code>, <code>KorClasses</code>가 있다면, 이 때 실행하는 명령어는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -classpath &#x2F;classes&#x2F;EngClasses;&#x2F;classes&#x2F;KorClasses DevAndy.java</span><br></pre></td></tr></table></figure><p>두개의 CLASSPATH가 필요했기 때문에 각각의 CLASSPATH를 <code>;</code>로 구분했다.</p><p>출처 : <a href="https://kils-log-of-develop.tistory.com/430">killog - 7주차 과제 : 패키지</a></p><br><h1 id="접근지시자"><a href="#접근지시자" class="headerlink" title="접근지시자"></a><a name="access-modifier"></a>접근지시자</h1><p>클래스나 메서드에 작성하던 접근제한자에 대한 테이블이다. Row엔 접근가능 범위를, Column엔 접근 가능여부를 작성했다.</p><style>  #access-modifier {     border: 1px solid black;  }  #access-modifier tr th {    text-align: center;    border: 2px solid black;    word-break: keep-all;  }  #access-modifier tr td {    text-align: center;    border: 1px solid black;    word-break: keep-all;  }</style><table id="access-modifier">  <tr>      <th style="width: 15%;">접근 제한자</th>    <th style="width: 20%;">적용가능 대상</th>    <th style="width: 15%;">해당 클래스</th>    <th style="width: 15%;">같은 패키지</th>    <th style="width: 15%;">자식 클래스(extends/implements)</th>    <th style="width: 15%;">외부 클래스(import)</th>  </tr>    <tr>        <td>public</td>        <td>클래스, 생성자, 메서드, 필드</td>    <td>O</td>    <td>O</td>    <td>O</td>    <td>O</td>    </tr>  <tr>        <td>protected</td>        <td>생성자, 메서드, 필드</td>        <td>O</td>    <td>O</td>    <td>O</td>    <td>X</td>    </tr>  <tr>        <td>default</td>        <td>클래스, 생성자, 메서드, 필드</td>    <td>O</td>    <td>O</td>    <td>X</td>    <td>X</td>    </tr>  <tr>        <td>private</td>        <td>생성자, 메서드, 필드</td>        <td>O</td>    <td>X</td>    <td>X</td>    <td>X</td>    </tr></table><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
            <tag> whiteship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>뉴욕가는 쿠팡($CPNG)에 대한 생각</title>
      <link href="2021/02/coupang-ipo/"/>
      <url>2021/02/coupang-ipo/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/107868830-e3d88880-6eca-11eb-847a-eb2445f2d223.jpg"></p><p>쿠팡이 얼마 전 뉴욕 증권위윈회에 상장신청서인 <a href="https://www.sec.gov/Archives/edgar/data/1834584/000162828021001984/coupang-sx1.htm">S-1 문서</a>를 제출했다고 밝혔다. 이 S-1문서를 보니 꽤 놀라운 포인트들이 있었는데, 문서도 길고 영어로 되어 있어서 어려웠는데, 이를 <a href="https://ebadak.news/2021/02/13/coupang-nyse-cpng/">이바닥늬우스</a>에서 잘 요약해주셔서 이바닥늬우스와 S-1 문서를 보면서 쿠팡의 투자포인트를 정리해보았다.</p><p>쿠팡이 상장하면 투자할 의향이 있긴한데, 투자한다면 어떤 이유로, 또 투자하지 않는다면 어떤 이유로 하지 않을지를 각각 정리해보았다.</p><br><h1 id="쿠팡이-공개한-현-주소"><a href="#쿠팡이-공개한-현-주소" class="headerlink" title="쿠팡이 공개한 현 주소"></a>쿠팡이 공개한 현 주소</h1><p><img src="https://www.sec.gov/Archives/edgar/data/1834584/000162828021001984/cover4b1a.jpg" alt="출처 : SEC"></p><p>쿠팡은 2018년부터 <b><u>3년동안 매출이 4배 성장</u></b>하는동안 <b><u>순손실은 오히려 절반으로 줄어들었다</u></b>. 그동안 쿠팡은 사업을 할 수록 손실만 확대되는 “돈을 못버는 회사”로 취급받아왔었다. 그런데 S-1 문서에서 공개된 최근 3년간의 쿠팡은 아직 돈을 못벌긴 하지만, 사업을 할 수록 손실이 확대되는 회사에서는 벗어난 모습을 보여주고 있다.</p><p>이 S-1 문서에서 보는 인상적인 점은 2가지였다.</p><h2 id="로켓와우-멤버쉽-효과"><a href="#로켓와우-멤버쉽-효과" class="headerlink" title="로켓와우 멤버쉽 효과"></a>로켓와우 멤버쉽 효과</h2><p><img src="https://i0.wp.com/ebadak.news/wp-content/uploads/2021/02/KakaoTalk_Photo_2021-02-13-01-37-01.png?resize=768,120&ssl=1" alt="출처 : 이바닥늬우스"></p><p>쿠팡의 분기별 Active User(한 번이라도 이용한 사람)은 <strong>1,480만명</strong> 이라고 한다. 이 지표는 매년 25%(YOY)씩 증가하고 있다고 한다.</p><p>그리고 지난해 말 기준 이 <strong>Active User의 32%</strong>, 즉 지난 3개월동안 한 번이라도 쿠팡을 이용한 사람의 3명중 1명은 로켓와우 멤버쉽 가입자였다고 한다. 대략 계산해보면 <strong>470만명</strong> 쯤 되는것 같다. (87페이지 of S-1)</p><p>S-1 문서에 의하면, <b><u>로켓와우 멤버쉽 가입자들은 미가입자 대비 쿠팡에서 4배 이상 소비</u></b>한다고 한다.</p><p><img src="https://i1.wp.com/ebadak.news/wp-content/uploads/2021/02/KakaoTalk_Photo_2021-02-13-01-42-29.png?resize=768,319&ssl=1" alt="출처 : 이바닥늬우스"></p><p>위의 테이블은 2016년부터 2019년동안 각각의 해에 가입된 사용자가 해가 지날수록 얼마나 소비를 하는지 보여주는 지표이다.</p><p>예를 들어, 2016년에 가입되어 지금까지 5년간 이용중인 고객은 평균적으로 첫해 대비 3.59배를 소비하고 있으며, 2019년에 가입하여 2년차를 맞이한 고객은 평균적으로 첫해 대비 2.19배를 소비하고 있다고 한다.</p><p>즉 <b><u>사용기간이 늘어날수록 점점 쿠팡에서 소비하는 규모가 늘어나고 있는것</u></b>을 보여준다.</p><p>종합해보면, 로켓와우는 현재 쿠팡의 매출에 상당부분 기여하고 있는 성공한 상품으로 생각된다.</p><h2 id="로켓-와우를-가능케한-쿠팡의-물류"><a href="#로켓-와우를-가능케한-쿠팡의-물류" class="headerlink" title="로켓 와우를 가능케한 쿠팡의 물류"></a>로켓 와우를 가능케한 쿠팡의 물류</h2><p>쿠팡이 자랑하는 로켓배송은 이름 그대로 로켓처럼 빠르게 배송해주는 매력적인 서비스이자, 다른 이커머스와 차별화된 무기로 평가받는다. 그렇다면 쿠팡은 어떻게 당일배송을 구축할 수 있었을까?</p><p><img src="https://news.coupang.com/wp-content/uploads/2019/05/%EC%BF%A0%ED%8C%A1-%EC%82%AC%EC%A7%84%EC%9E%90%EB%A3%8C-%EA%B7%B8%EB%9E%98%ED%94%84_%EC%BF%A0%ED%8C%A1%EB%AC%BC%EB%A5%98%EC%9D%B8%ED%94%84%EB%9D%BC-%EC%A6%9D%EA%B0%80.jpg" alt="출처 : 쿠팡 보도자료"> </p><p>비결은 물류인프라에 있다. 쿠팡은 소프트뱅크로부터 투자를 받을때마다 공격적으로 물류 인프라에 투자했다. 다른 이커머스는 배송을 위탁으로 하여 상대적으로 비용 부담이 적었던것에 비해 쿠팡은 수천억을 들여 물류센터를 짓고, 직매입한 제품을 직접 고용한 배송기사를 통해 배달함으로써 경쟁사 대비 엄청난 비용이 발생했다.</p><p>여기서 직매입이란, 쿠팡에서 직접 물품을 구입한후 이 물품을 판매하는것을 의미한다.<br>타 이커머스들이 천원짜리 상품을 중개 판매해서 10%의 커미션을 받는다고 한다면, 여기서 매출은 백원이 된다. 그러나 쿠팡은 천원짜리 물건을 조금 더 싸게 직매입하여 소비자들에게 집접 판매하므로 매출은 천원이 된다.</p><p>관련기사</p><ul><li><a href="https://news.bizwatch.co.kr/article/consumer/2019/04/05/0012">비즈워치 - ‘못 먹어도 고’ 쿠팡, 수익성 챙기는 위메프, 티몬</a></li><li><a href="https://www.asiae.co.kr/article/2019021811070440794">아시아경제 - 하루 배송 200만개 넘보는 쿠팡.. 비결은 직매입, 물류</a></li></ul><p>왜 쿠팡은 이렇게 위험한 투자를 한걸까? 다른 이커머스들이 주문만 받아내는 것에 그쳤다. 따라서 주문이 끝난 뒤부터는 택배회사들의 서비스 품질이 최종적인 쇼핑경험에 영향을 미칠수밖에 없다. </p><p>쿠팡이 정의한 쇼핑의 정의는 자사 <b>쇼핑몰에서 결제, 주문한 뒤 실제로 물건을 받는것</b>까지를 정의했다. 그래서 쿠팡은 직접 물류센터를 짓고, 물품을 직매입하고, 소비자와 직접 마주할 배송 기사도 직접 고용했다. 이렇게함으로써 고객이 주문하고, 실제로 물건을 받기까지의 모든 과정을 수직화한 국내 유일의 기업이 되었다.</p><p>쿠팡을 수년간 이용하면서 로켓와우 상품이 점점 늘어난다는 느낌은 받았지만, 이 S-1 문서를 보면서 얼마나 커졌는지 확실히 인지하게 되었다. S-1 문서의 111페이지를 보면, <b><u>대한민국 인구의 70%가 쿠팡 물류센터와 7마일(11km) 이내에 살고있다</u></b>고 한다. 쿠팡의 로켓배송을 경험할 수 있는 인구가 무려 대한민국의 70%에 해당되는 것이다.</p><p>쿠팡이 수년간 천문학적인 적자를 감당하면서도 물류 인프라에 투자해서 얻은것은 무엇일까?</p><p><img src="https://user-images.githubusercontent.com/33862991/107868829-e0dd9800-6eca-11eb-90b5-aeee556b3cd6.png" alt="출처 : 네이버쇼핑"></p><p>택배회사에 배송을 위탁한 다른 경쟁사들과 달리 쿠팡은 배송비용을 직접 관리 할 수 있게 되었다. 우리가 로켓와우에 가입하면 무료로 로켓와우 상품을 구입할 수 있는 이유가 여기에 있다. <b><u>쿠팡은 다른 회사와 달리 배송비를 직접 매니징 할 수 있기 때문에 경쟁사와는 독보적인 차별성</u></b>을 갖게되었다.</p><p>경쟁사들이 100원을 가지고 경쟁할때, 쿠팡은 배송비를 직접 관리할 수 있게됨으로써 경쟁사 대비 훨씬 유연한 가격 정책을 펼칠 수 있게 되었다. 자연스럽게 이는 압도적인 가격 경쟁력으로 이어졌다.</p><br><h1 id="여전한-쿠팡의-우려-이커머스의-수익성-기존-주주들의-엑시트-추가"><a href="#여전한-쿠팡의-우려-이커머스의-수익성-기존-주주들의-엑시트-추가" class="headerlink" title="여전한 쿠팡의 우려 : 이커머스의 수익성, 기존 주주들의 엑시트(추가))"></a>여전한 쿠팡의 우려 : 이커머스의 수익성, 기존 주주들의 엑시트(추가))</h1><p>쿠팡은 S-1 문서에서 자신들의 분기별 Active User가 1,480만명이라고했다. 보통은 월간 활성자수인 MAU(Monthly Active User)를 언급하는데, 쿠팡은 왜 Quarter(분기)별 사용자수를 밝힌지는 모르겠다. 그냥 추정컨대 쿠팡의 MAU는 천만명은 안될것으로 예상해본다. </p><p>국내에서 MAU가 천만명 이상인 서비스는 많지 않다. 카카오톡, 카카오뱅크, 토스, 파파고(네이버), 당근마켓 정도이다. 쿠팡이 MAU가 천만이 넘었든 넘지 않았든 엄청난 유저를 확보한건 사실이다. </p><p>그러나 다르게 보면 <strong>쿠팡은 1,480만명을 상대로도 흑자를 만들지 못했다.</strong> 얼마나 많은 Active User를 확보해야 흑자로 턴어라운드 할 수 있을지도 알 수 없을거니와 이미 약 1천 5백만명을 유치한 내수 서비스가 여기서 얼마나 더 고객을 유치할 수 있을지도 알 수 없다.</p><table>  <tr>    <th>인구 (천명)</th>    <th>인경제활동인구 (천명)</th>    <th>취업자 (천명)</th>    <th>실업자 (천명)</th>  </tr>  <tr>      <td>44,968</td>    <td>27,388</td>    <td>25,818</td>    <td>1,570</td>  </tr></table><p> <a href="https://kosis.kr/statHtml/statHtml.do?orgId=101&tblId=DT_1DA7002S&conn_path=I3">통계청 자료</a>에 의하면 2020년 1월 기준 대한민국의 경제활동인구(15세 이상 취업자+실업자)은 2,738만명이라고 한다. 쿠팡이 이들 모두를 Active User로 만들수 있다면 앞으로 2배 성장할 수 있겠지만, 얼마나 걸릴지 알 수 없고, 앞으로 네이버나 오프라인 유통사들(신세계, 롯데)과의 경쟁이 예상되므로 쉽지 않을 것이다.</p><img src="https://d0.awsstatic.com/logos/AWS%20Logo%20Variants/Full%20Color/AWS-Logo_Full-Color_400x240.png" alt="AWS 로고" style="zoom:50%;" /><p>쿠팡이 롤모델로 삼고있는 아마존의 경우 매출액 대비 영업이익의 비중이 5.5%(2020년 기준)라고 하는데 이 영업익의 60%이상이 AWS로부터 발생하고 있다. 전체 매출의 10% 수준인 AWS가 영업익의 60% 이상을 차지한다는 이야기는 아마존 커머스의 수익성이 굉장히 낮다는 이야기로 해석할 수 있다.</p><p>따라서 쿠팡 역시 아마존의 AWS와 같은 새로운 캐시 카우가 필요할 것으로 보인다.</p><p>이외에 주식 상장 이후에 주가 흐름이 어떨지는 모르겠으나 10년간 비상장기업으로 운영하며 외부자금으로 서비스를 운영해온 쿠팡이 이제서야 상장을 나서는 이유가 무엇일까? </p><p><img src="https://image.fnnews.com/resource/media/image/2020/02/12/202002121734548527_l.jpg" alt="출처 : 에프엔뉴스"></p><p>쿠팡의 주요주주는 소프트뱅크 비전펀드(이하 ‘비전펀드’)이다. 소프트뱅크 비전펀드는 사우디 아라비아 국부펀드가 펀드 규모의 절반이상을 출자하고, 소프트뱅크가 운용하는 방식의 조합펀드인데, 지난 2019년 포트폴리오중 하나였던 위워크가 IPO를 앞두고 잇단 악재로 상장에 실패하는 것은 물론 기업가치가 폭락하면서 위워크에 투자했던 비전펀드도 큰 손해를 본 것으로 알려졌다.</p><p>이런 상황에서 쿠팡의 상장은 엄청난 규모의 펀드임에도 불구하고 제대로된 수익실현을 하지못했던 비전펀드에게 엑싯(Exit)의 기회가 될지도 모른다.비전펀드는 물론 약 10년간 비상장사면서 천문학적인 적자 기업이었던 쿠팡에 수억달러를 투자해온 기존 주주들에게도 엑싯 기회가 될 수 있다. 이는 상장 직후 대규모 물량이 시장에 쏟아져 나올수 있다는 리스크가 될 수 있다.</p><br><h1 id="쿠팡-투자-포인트-풀필먼트"><a href="#쿠팡-투자-포인트-풀필먼트" class="headerlink" title="쿠팡 투자 포인트 : 풀필먼트"></a>쿠팡 투자 포인트 : 풀필먼트</h1><p>위에서 쿠팡은 사용자들의 쇼핑 경험을 재정의하기 위해 물류 인프라에 큰 투자를 했다고 작성했다. 또 이를 통해서 배송비를 유연하게 결정할 수 있게되었다고 했다. 쿠팡은 어떻게 배송 비용을 관리하고 있을까?</p><p>쿠팡은 물건을 직매입하고 사용자에게 판매하기 때문에 물건이 물류센터에서 오래동안 있을수록 비용이 발생한다. 따라서 이 비용을 낮추기 위해서는 물류센터에 들어오자마자 최대한 빨리 출고로 이어져야한다. 이렇게 되려면 어떤 물건이 <b><u>어느 지역(물류)에서 얼마나(수요) 판매하는지를 정확히 예측하는 기술</u></b>이 중요해진다. </p><p>이를 위해 쿠팡은 실력있는 개발자를 영입하는데 아낌없이 투자하고 있다. S-1 문서 111 페이지에서도 쿠팡은 자신들의 <strong>머신러닝</strong> 기술로 수요를 예측하여 미리 제품을 물류센터에 배치하는 덕분에 빠른 배송을 구현하고 있다고 표현했다.</p><p><img src="https://cdn.celluloidjunkie.com/wp-content/uploads/2019/08/21040434/CGV-entrance.jpg" alt="CJ CGV"></p><p>쿠팡의 이런 예측 모델링 기술이 정교해진다면 비단 쇼핑에서만 끝나지는 않을수있다. 쿠팡의 물류센터에서 물건의 입고에서 출고에 이르는 시간이 빨라질수록 상업성이 높아질수 있는데, 이는 호텔, 극장, 비행기 티켓 판매에도 필요한 기술이다. 쿠팡의 물류센터에 입고된 물건처럼 호텔이나 극장, 비행기 티켓도 시간이 지나면 해당 상품의 가치는 소멸된다. 쿠팡의 모델링 기술이 정교해질수록 이를 적용할 수 있는 산업도 늘어날수 있을것으로 예상된다. </p><p>쿠팡은 S-1 문서에서 멤버쉽 회원들의 소비력이 비 멤버쉽 회원들보다 평균적으로 4배를 더 많이 소비하고, 연평균 2배씩 쇼핑 규모가 늘어난다고 밝혔으므로 수요 예측 모델링 기술이 정교해지면서 입고와 출고의 프로세스가 더 빨라지면서 거래규모도 함께 늘어나며 규모의 경제를 이끌어낸다면 쿠팡의 운영비용은 단축될 수 있다. </p><p>이런 물류 인프라는 단지 쿠팡만을 위한게 아니라 모두를 위한 물류 인프라가 될수도 있다. <mark>물류센터에 물품이 입고, 보관, 출고되는 과정을 관리하는 행위를 풀필먼트</mark>라고 하는데, 쿠팡이 이런 풀필먼트를 사업화 할 수 있지 않을까 싶다.</p><p><img src="https://fitsmallbusiness.com/wp-content/uploads/2019/05/word-image-1947.png" alt="출처 : Fit Small Business"></p><p>관련기사</p><ul><li><a href="https://byline.network/2018/12/12-36/">바이라인 네트워크 - 신세계와 네이버에 미친 ‘풀필먼트’가 뭐길래</a></li><li><a href="https://www.donga.com/news/Economy/article/all/20200909/102849628/1">동아 - 세계 이커머스업계 화두 ‘e풀필먼트’</a></li></ul><p>쿠팡에서 셀러를 한다고 가정해본다면, 물건을 매입하고 판매하기 직전까지 보관할 창고가 필요해지는데, 이걸 쿠팡 물류센터로 대신할 수 있는 것이다. 그럼 <b><u>셀러는 쿠팡에 어떤 물건을 판매할지만 결정하고, 쿠팡에 물건을 올리면 주문이 들어올때마다 쿠팡 물류센터에서 물건이 준비되어 출고가 이뤄지게 된다.</u></b></p><p>쿠팡의 롤모델인 아마존이 블랙 프라이데이에 과부화로 인해 서버가 죽는 상황을 대비하여 서버를 크게 확대하고, 평소에 유휴 서버를 다른 회사들에게 빌려주면서 시작된 AWS처럼 더 빠른 배송과 미래 지향적인 과감한 투자의 산출물인 쿠팡의 물류센터가 풀필먼트 서비스로 이어진다면 새로운 캐시 카우가 될지도 모르겠다.</p><p>쿠팡이 이미 대한민국 국민의 70%를 자신들의 바운더리로 만든만큼 여러 회사 또는 셀러들에게 매력적인 풀필먼트 서비스를 만들 수 있을것으로 기대된다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> investment </tag>
            
            <tag> coupang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live Study 6주차 - 상속</title>
      <link href="2021/02/livestudy-week-06/"/>
      <url>2021/02/livestudy-week-06/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/peEXNN-oob4/maxresdefault.jpg"></p><ul><li><a href="#inheritance">자바 상속의 특징</a><ul><li><a href="#multiple-inheritance">다중상속</a></li><li><a href="#call-method">상속관계에서 메서드 호출</a></li><li><a href="#casting">업캐스팅/다운캐스팅</a></li></ul></li><li><a href="#super">super 키워드</a></li><li><a href="#overriding">메소드 오버라이딩</a><ul><li><a href="#differ-overriding-and-overloading">메서드 오버라이딩과 메서드 오버로딩</a></li></ul></li><li><a href="#dynamic-method-dispatch">다이나믹 메소드 디스패치 (Dynamic Method Dispatch)</a></li><li><a href="#abstractclass">추상 클래스</a></li><li><a href="#final">final 키워드</a></li><li><a href="#object">Object 클래스</a></li></ul><br><h1 id="자바-상속의-특징"><a href="#자바-상속의-특징" class="headerlink" title="자바 상속의 특징"></a><a name="inheritance"></a>자바 상속의 특징</h1><h3 id="자식-클래스는-부모-클래스의-상태와-기능을-사용-가능"><a href="#자식-클래스는-부모-클래스의-상태와-기능을-사용-가능" class="headerlink" title="자식 클래스는 부모 클래스의 상태와 기능을 사용 가능"></a>자식 클래스는 부모 클래스의 상태와 기능을 사용 가능</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hyundai</span> <span class="keyword">extends</span> <span class="title">Genesis</span> </span>&#123;</span><br><span class="line">   Sedan sonata = <span class="keyword">new</span> Sedan(<span class="string">&quot;소나타&quot;</span>, <span class="number">24_000_000</span>);</span><br><span class="line">   Suv tucson = <span class="keyword">new</span> Suv(<span class="string">&quot;투싼&quot;</span>, <span class="number">25_000_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Genesis</span> </span>&#123;</span><br><span class="line">   Sedan g70 = <span class="keyword">new</span> Sedan(<span class="string">&quot;Genesis G70&quot;</span>, <span class="number">48_500_000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Hyundai hyundai = <span class="keyword">new</span> Hyundai();</span><br><span class="line">      hyundai.g70.drive();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">당신이 선택한 차종은 g70이며, 가격은 48500000원입니다.</span><br></pre></td></tr></table></figure><p><code>Genesis</code> 클래스와 <code>Genesis</code> 클래스를 상속(extends)받는 <code>Hyundai</code> 클래스이다. 그리고 이를 <code>Driver</code> 클래스에서 인스턴스를 생성해서 사용하는 코드이다. </p><blockquote><p>부모클래스로부터 상속받는 자식클래스에서 부모 클래스의 상태와 기능을 확장하여 할 수 있다는 점에서 상속을 할 때 사용하는 키워드가 <code>extends</code> 이다.</p></blockquote><p>위의 코드에서 <code>Sedan</code>과 <code>Suv</code> 클래스 코드는 굳이 첨부하지 않았다.</p><p>main 메서드가 있는 <code>Driver</code> 클래스를 보면, <code>Hyundai</code> 객체의 인스턴스를 생성했는데, <code>Genesis</code>의 <code>g70</code>를 호출한걸 확인할 수 있다. </p><p>이게 가능한 이유는 <code>Hyundai</code> 클래스가 <code>Genesis</code> 를 <strong>상속</strong> 받기 때문에 가능한 일이다.</p><p>반면 Genesis 객체를 인스턴스로 생성해서 sonata를 호출하면 어떨까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Genesis genesis = <span class="keyword">new</span> Genesis();</span><br><span class="line">      genesis.sonata.drive();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>컴파일 에러가 발생한다. <code>genesis</code> 인스턴스에서는 <code>sonata</code>를 찾을 수 없기 때문이다.</p><p>두 객체의 관계는 다음과 같다.</p><p><img src="https://user-images.githubusercontent.com/33862991/105963265-25dc8e80-60c4-11eb-85db-1497aa1a914b.png"></p><p><code>Genesis</code> 객체를 통해서는 <code>g70</code>만 접근할 수 있지만, <code>Genesis</code>를 상속받는 <code>Hyundai</code>는 <code>sonata</code>, <code>tucson</code>, <code>g70</code> 모두 접근이 가능하다. 상속은 부모에서 자식에게 가능하지만, 자식에서 부모로는 불가능하다.</p><h2 id="다중상속"><a href="#다중상속" class="headerlink" title="다중상속"></a><a name="multiple-inheritance"></a>다중상속</h2><p><strong>자바에서는 다중상속을 불허</strong> 한다. 이유는 아래의 코드를 통해 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentA</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> String familyName = <span class="string">&quot;Beckham&quot;</span>;</span><br><span class="line">   <span class="keyword">protected</span> String givenName = <span class="string">&quot;David&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(givenName+<span class="string">&quot; &quot;</span>+familyName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentB</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> String familyName = <span class="string">&quot;Adams&quot;</span>;</span><br><span class="line">   <span class="keyword">protected</span> String givenName = <span class="string">&quot;Victoria&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(givenName+<span class="string">&quot; &quot;</span>+familyName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">ParentA</span>, <span class="title">ParentB</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> String givenName = <span class="string">&quot;Brooklyn&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(givenName+<span class="string">&quot; &quot;</span>+<span class="keyword">super</span>.familyName);;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 컴파일 에러가 발생한다. 이유는 <code>Son</code> 클래스에서 다중상속을 허용하지 않기 때문이다. 그렇다면, 자바는 왜 다중상속을 허용하지 않는걸까?</p><p>위 코드가 컴파일 에러가 발생하지 않는다고 가정해보자. <code>Son</code> 클래스의 <code>name()</code>에서 <code>super.familyName</code>은 무엇을 가져올 수 있을까?</p><p><u>자식 클래스에서 부모 클래스의 속성 또는 기능을 호출하려고 하는데, 위에서처럼 변수명은 같지만 할당된 리터럴이 다른 경우 JVM은 어느것을 호출해야할지 알 수 없게된다.</u></p><p>이런 경우를 <strong>다이아몬 문제(Diamond Problem)</strong> 이라고 한다. 따라서 자바에서는 다중상속을 지원하지 않는다. </p><p>그러나 인터페이스를 통해 다중상속을 비슷하게 구현할수 있긴 하다. </p><h2 id="상속관계에서-메서드-호출"><a href="#상속관계에서-메서드-호출" class="headerlink" title="상속관계에서 메서드 호출"></a><a name="call-method"></a>상속관계에서 메서드 호출</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;My name is A&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printClassName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;My name is B&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello from B&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello from C&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      C c = <span class="keyword">new</span> C();</span><br><span class="line">     </span><br><span class="line">      b.hello();</span><br><span class="line">      c.printClassName();</span><br><span class="line">      c.hello();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A -&gt; B -&gt; C 순서로 상속관계로 연결된 객체들이다. 상속관계에서 최하위 객체인 C 객체의 인스턴스를 생성해서 <code>printClassName()</code>와 <code>hello()</code> 를 호출해보았다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello from B</span><br><span class="line">My name is B</span><br><span class="line">Hello from C</span><br></pre></td></tr></table></figure><p><code>printClassName()</code> 은 B 객체에서 오버라이딩을, <code>hello()</code>는 C 객체에서 오버라이딩을 한 메서드들이다.</p><p>호출하면, <strong><u>상속관계에서 가장 가까운 객체의 메서드를 호출</u></strong> 하는 것을 알 수 있다.</p><h2 id="업캐스팅-다운캐스팅"><a href="#업캐스팅-다운캐스팅" class="headerlink" title="업캐스팅/다운캐스팅"></a><a name="casting"></a>업캐스팅/다운캐스팅</h2><p>상속관계에서는 부모 클래스와 자식 클래스 간에 형변환(Casting)이 가능하다.</p><ul><li><strong>업캐스팅</strong><ul><li>자식 클래스의 객체가 부모 클래스로 형변환</li></ul></li><li><strong>다운캐스팅</strong><ul><li>부모 클래스의 객체가 자식 클래스로 형변환</li></ul></li></ul><p>상속관계에서 업캐스팅과 다운캐스팅이 어떻게 진행되는지 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   String name = <span class="string">&quot;Sam&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> age = <span class="number">31</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritanceApp</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Student student = <span class="keyword">new</span> Student();</span><br><span class="line">      Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">      Student cast_student = (Student) person;   <span class="comment">// 다운 캐스팅</span></span><br><span class="line">      System.out.println(cast_student.name);  <span class="comment">// Sam</span></span><br><span class="line">      System.out.println(cast_student.age);   <span class="comment">// 31</span></span><br><span class="line">     </span><br><span class="line">      System.out.println(student.age);  <span class="comment">// 31</span></span><br><span class="line">      Person cast_person = student;   <span class="comment">// 업 캐스팅</span></span><br><span class="line">      System.out.println(cast_person.age);  <span class="comment">// copile error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Student -&gt; Person 의 상속관계이다. Person 타입의 인스턴스 객체 <code>person</code>을 자식 객체 타입인 Student 타입으로 다운 캐스팅하니까 모든 멤버 필드에 접근이 가능해졌다.</p><p>반면 자식 클래스 타입의 Student를 부모 객체 타입인 Person 타입으로 업 캐스팅하니까 기존엔 접근가능했던 자식 객체의 멤버 필드에 접근이 불가능해졌다. 형변환이 되었기 때문에 당연히 접근이 안되는 것이다.</p><br><h1 id="super-키워드"><a href="#super-키워드" class="headerlink" title="super 키워드"></a><a name="super"></a>super 키워드</h1><p><code>super</code>라는 키워드도 있는데, <code>super()</code> 라는 메서드도 존재한다. 각각의 차이는 다음과 같다.</p><ul><li><code>super</code> : 부모 클래스의 필드, 메서드 호출</li><li><code>super()</code> : 부모 클래스의 생성자를 호출하는 메서드</li></ul><p>코드를 통해 확인해보겠다. 생활코딩의 코드(<a href="https://www.youtube.com/watch?v=OStTXyl636k&list=PLuHgQVnccGMA1bRSk_SZrXMngx5iq03cc&index=5">출처</a>)를 가져왔다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v1, v2;</span><br><span class="line"></span><br><span class="line">   Cal(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)&#123;</span><br><span class="line">      <span class="keyword">this</span>.v1 = v1;</span><br><span class="line">      <span class="keyword">this</span>.v2 = v2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal3</span> <span class="keyword">extends</span> <span class="title">Cal</span> </span>&#123;</span><br><span class="line">   Cal3(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2) &#123;</span><br><span class="line">      <span class="keyword">super</span>(v1, v2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritanceApp</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Cal c = <span class="keyword">new</span> Cal(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">      Cal3 c3 = <span class="keyword">new</span> Cal3(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 사용한 <code>super()</code> 를 인텔리J에서 확인해보면 다음과 같이 출력된다.</p><p><img src="https://user-images.githubusercontent.com/33862991/107149188-96c05800-699a-11eb-9fc7-d20e6085de63.png"></p><p><code>Cal</code> 클래스를 상속받은 <code>Cal3</code> 클래스는 <strong><u>부모 클래스가 갖고있는 생성자를 반드시 호출</u></strong> 해야 한다.</p><p>이유는 부모 클래스인 <code>Cal</code> 클래스의 인스턴스를 생성하게 되면, 생성자가 우선적으로 호출되는데, <code>Cal</code> 클래스의 자식 클래스 역시 이 생성자를 호출해야지만 <code>Cal</code> 클래스를 온전히 계승한다고 볼 수 있기 때문이다.</p><p>이번엔 <code>super</code> 키워드를 사용하는 코드를 추가해봤다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v1, v2;</span><br><span class="line">   <span class="keyword">int</span> v3 = <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">   Cal(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)&#123;</span><br><span class="line">      <span class="keyword">this</span>.v1 = v1;</span><br><span class="line">      <span class="keyword">this</span>.v2 = v2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal3</span> <span class="keyword">extends</span> <span class="title">Cal</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> v3 = <span class="keyword">super</span>.v3+<span class="keyword">super</span>.v2;</span><br><span class="line">  </span><br><span class="line">   Cal3(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2) &#123;</span><br><span class="line">      <span class="keyword">super</span>(v1, v2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritanceApp</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Cal c = <span class="keyword">new</span> Cal(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">      Cal3 c3 = <span class="keyword">new</span> Cal3(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">     </span><br><span class="line">      System.out.println(c3.v3);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p><code>Cal3</code> 클래스에서 부모 클래스의 변수를 호출하는 변수를 선언했다. main 메서드에서 콘솔에 출력되는 수가 30인데, Cal3 클래스의 변수 <code>v3</code>이 부모 클래스의 <code>v3(10)</code>와 부모 클래스의 <code>v2</code>(생성자를 통해 들어온 20)의 합을 가져왔기 때문이다.</p><br><h1 id="메소드-오버라이딩"><a href="#메소드-오버라이딩" class="headerlink" title="메소드 오버라이딩"></a><a name="overriding"></a>메소드 오버라이딩</h1><p>오버라이딩은 부모 클래스의 메서드를 변형해서 사용하는 것을 의미한다. 부모로부터 상속받은 기능을 자신의 입맛대로 바꿔서 사용하는 것이다. </p><p>객체지향을 배울때 오버라이딩과 함께 배우는 개념으로 오버로딩이 있는데, 오버로딩은 부모 클래스의 메서드와 이름만 같을뿐 파라미터 갯수를 다르게 하여 다른 메서드로 사용하는걸 의미한다. 객체지향의 주요 개념중 하나인 <strong><u>다형성(Polymorphism)</u></strong> 이 사용된 개념이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String host, String guest)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, &quot;</span>+guest+<span class="string">&quot; from &quot;</span>+host);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String host, String guest1, String guest2)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello, &quot;</span>+guest1+<span class="string">&quot;, &quot;</span>+guest2+<span class="string">&quot; from &quot;</span>+host);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="오버라이딩과-오버로딩의-차이"><a href="#오버라이딩과-오버로딩의-차이" class="headerlink" title="오버라이딩과 오버로딩의 차이"></a><a name="differ-overriding-and-overloading"></a>오버라이딩과 오버로딩의 차이</h2><p>그럼 오버라이딩과 오버로딩의 차이는 무엇일까?<br><mark>오버로딩이 기능의 확장</mark>이라면, <mark>오버라이딩은 기능의 재정의</mark>이라고 할 수 있다.</p><p>아래의 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1+num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal2</span> <span class="keyword">extends</span> <span class="title">Cal1</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1-num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cal3</span> <span class="keyword">extends</span> <span class="title">Cal2</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> num3)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1+num2+num3;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minus</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1&gt;=num2 ? num1-num2 : num2-num1;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inheritance</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Cal2 cal2 = <span class="keyword">new</span> Cal2();</span><br><span class="line">      Cal3 cal3 = <span class="keyword">new</span> Cal3();</span><br><span class="line"></span><br><span class="line">      System.out.println(cal2.minus(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">      System.out.println(cal3.minus(<span class="number">10</span>,<span class="number">20</span>));</span><br><span class="line">      System.out.println(cal3.sum(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">      System.out.println(cal3.sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-10</span><br><span class="line">10</span><br><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>여기서 <strong>오버라이딩</strong> 을 시도한 코드는 <code>Cal3</code> 클래스의 <code>minus()</code>이다. 부모 클래스의 메서드를 가져와서 기능을 변형시켰다. </p><p><code>Inheritance</code> 클래스의 main 메서드에서 콘솔에 출력한 결과는 부모 클래스의 함수와 달랐다. 기능의 변경이 확인 된 것이다.</p><p><strong>오버로딩</strong> 을 시도한 코드는 <code>Cal3</code> 클래스의 <code>sum()</code>이다. 오버라이딩은 이름만 같을뿐 다른 기능이므로 오버로딩을 시도하면 기능이 하나 더 생긴다. 따라서 <code>Cal3</code> 클래스의 인스턴스로는 <code>sum()</code>이라는 이름의 메서드 2개를 호출할 수 있다.</p><p>오버라이딩은 상속관계에서만 사용되지만, 오버로딩은 같은 클래스내에서도 사용할 수 있다는 특징이 있다.</p><br><h1 id="다이나믹-메서드-디스패치-Dynamic-Method-Dispatch"><a href="#다이나믹-메서드-디스패치-Dynamic-Method-Dispatch" class="headerlink" title="다이나믹 메서드 디스패치 (Dynamic Method Dispatch)"></a><a name="dynamic-method-dispatch"></a>다이나믹 메서드 디스패치 (Dynamic Method Dispatch)</h1><p><strong>메서드 디스패치</strong> 란, 런타임 시점(실행 시점)이 아닌 <mark>컴파일 시점에 어떤 메서드가 호출될지를 결정할 수 있는지 여부</mark> 를 정의한다.</p><p>메서드 디스패치는 두가지로 분류된다.</p><ul><li><strong>정적 메서드 디스패치 (Static)</strong><ul><li><strong>컴파일</strong>시 결정되는 의존 관계</li><li>컴파일 시점에 어떤 메서드가 호출될지를 결정하는 코드</li></ul></li><li><strong>다이나믹 메서드 디스패치 (Dynamic)</strong><ul><li><strong>런타임</strong>시 결정되는 의존 관계</li><li>컴파일 시점에는 어떤 메서드가 호출될지 알지 못하나 런타임 시점에 메서드가 결정되는 코드</li></ul></li></ul><br><h1 id="추상-클래스"><a href="#추상-클래스" class="headerlink" title="추상 클래스"></a><a name="abstractclass"></a>추상 클래스</h1><p>클래스가 설계도라면, 추상 클래스는 미완성 설계도이다. 추상 메서드를 작성할 일이 있을때, 추상 메서드를 작성하는 클래스에 <code>abstract</code> 라는 키워드를 작성하면, 추상 클래스가 된다.</p><p>단독으로 사용될 수 없다. 인스턴스로 생성할 수 없기 때문에 추상 클래스는 반드시 상속으로 구현해서 자식 클래스에서 인스턴스화해서 사용해야한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1+num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> num3)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1+num2+num3;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      B b = <span class="keyword">new</span> B();</span><br><span class="line">      C c = <span class="keyword">new</span> C();</span><br><span class="line">      System.out.println(b.sum(<span class="number">5</span>,<span class="number">10</span>));</span><br><span class="line">      System.out.println(c.sum(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15</span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>추상 클래스 A를 상속받는 Class B, Class C를 통해서 <code>sum()</code>이라는 메서드를 서로 다르게 구현한 코드이다.</p><p><strong>추상 클래스는 인스턴스로 생성할 수 없다.</strong> 추상 클래스를 상속받은 자식 클래스를 통해서만 인스턴스화 할 수 있다. 같은 이유로 추상 클래스는 <a href="#final">final 키워드</a>로 선언할 수 없다.</p><p>그럼 추상 클래스는 언제 사용해야할까? 추상 메서드를 선언하려면 메서드를 선언하는 클래스가 추상 클래스여야 한다. 고로 추상 메서드가 필요할때가 추상 클래스가 필요한 시점이 된다.</p><p>그럼 추상 메서드는 언제 필요할까? <strong>추상 메서드란 선언부만 있고, 구현부는 없는 메서드</strong> 를 말한다. 인터페이스처럼 껍데기만 있는 것이다. 따라서 클래스간의 관계에서 공통 기능을 인터페이스 또는 추상클래스의 추상메서드로 분리할 수 있을 것이다.</p><p>여기까지 보면, 인터페이스와 다르지 않은것 같다. 인터페이스와 추상클래스는 어떤 차이가 있는걸까?</p><p>8주차 스터디를 하면서 인터페이스를 공부하면서 인터페이스와 추상클래스의 차이를 정리해보았다.<br><a href="https://youngjinmo.github.io/2021/02/livestudy-week-08/#differ-interface-abstractclass">인터페이스와 추상클래스의 차이</a></p><br><h1 id="final-키워드"><a href="#final-키워드" class="headerlink" title="final 키워드"></a><a name="final"></a>final 키워드</h1><p><code>final</code> 키워드는 객체의 모든 대상에 적용이 가능하며, 불가변적인 특징을 갖게된다.</p><p><strong>final 키워드 적용대상</strong></p><p><style>  table tr th {     text-align: center;  }  table tr td {     word-break: keep-all;  }  .fieldname {    text-align: center;    width: 15%;  }</style><table>  <tr>    <th>대상</th>    <th>의미</th>  </tr>  <tr>    <td class="fieldname">클래스</td>    <td>변경될 수 없는 클래스, 확장(상속)이 불가능해진다.</td>  </tr>  <tr>    <td class="fieldname" style="vertical-align: middle;">메서드</td>    <td>변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 할 수 없다.</td>  </tr>  <tr>    <td class="fieldname">멤버변수</td>    <td rowspan=2 style="vertical-align: middle;">변수 앞에 <code>final</code>이 붙으면, 값을 변경할 수 없는 상수가 된다.</td>  </tr>  <tr>    <td class="fieldname">지역변수</td>  </tr></table></p><p><strong>상수의 초기화</strong></p><p><code>final</code> 키워드를 사용해서 상수를 선언하더라도 생성자를 통해서 초기화를 할 수 있다. 만약 생성자를 통한 상수의 초기화가 불가능해지면, 이를 상속하는 모든 클래스에서 똑같은 상수 리터럴을 사용해야할 것이다.</p><p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001">남궁성의 Java의 정석</a></p><br><h1 id="Object-클래스"><a href="#Object-클래스" class="headerlink" title="Object 클래스"></a><a name="object"></a>Object 클래스</h1><p>java.lang 패키지의 대표적인 클래스 중 하나면서, Java에서 사용하는 모든 클래스의 조상이다. 따라서 Object 클래스의 메서드는 모든 클래스에서 바로 사용할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/33862991/107379706-8b9f3080-6b30-11eb-9286-1d1875747c0a.png"></p><p>예를 들면, String 클래스에서 <code>equals()</code>를 사용할 수 있는건, <code>equals()</code>가 Object 클래스의 메서드이고, Object 클래스를 String 클래스가 상속하기 때문에 가능하다.</p><h3 id="Object-클래스의-메서드"><a href="#Object-클래스의-메서드" class="headerlink" title="Object 클래스의 메서드"></a>Object 클래스의 메서드</h3><style>   #methods-object tr td {      vertical-align: center;   }   #methods-object th {      border : 1px solid black;   }</style><table id="methods-object">  <tr>      <th>Object 클래스의 메서드</th>    <th>설명</th>  </tr>  <tr>      <td>public final native Class<?> getClass()</td>    <td>객체 자신의 클래스 정보를 담는 Class 인스턴스를 반환한다.</td>  </tr>  <tr>      <td>public native int hashCode()</td>    <td>객체 자신의 해쉬코드를 반환한다.</td>  </tr>  <tr>      <td>public boolean equals(Object obj)</td>    <td>객체 자신과 객체 obj가 같은 객체인지 알려준다.</td>  </tr>  <tr>      <td>protected native Object clone() throws CloneNotSupportedException</td>    <td>객체 자신의 복사본을 반환한다.</td>  </tr>  <tr>      <td>public String toString()</td>    <td>객체 자신의 정보를 문자열로 반환한다.</td>  </tr>  <tr>      <td>public final native void notify()</td>    <td>객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.</td>  </tr>  <tr>      <td>public final native void notifyAll()</td>    <td>객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.</td>  </tr>  <tr>      <td>public final void wait() throws InterruptedException</td>    <td>다른 쓰레드가 notify() 또는 notifyAll()을 호출할때까지 현재 쓰레드를 잠시 대기하도록 한다.</td>  </tr>  <tr>      <td>public final native void wait(long timeoutMillis) throws InterruptedException</td>    <td>다른 쓰레드가 notify()나 notifyAll()을 호출할 때까지 현재 쓰레드를 무한히 또는 지정된 시간(timeout, nanos)동안 기다리게 한다.</td>  </tr></table><p>더 이상 참조하지 않는 객체를 GC에 의해 호출하도록 하는 <code>finalize()</code>는 deprecate되었다.<br>그동안 <code>finalize()</code>는 아래의 이유로 <strong><u>사용하지 않는 것이 권고</u></strong> 되었다는데 결국 deprecate되었다.</p><ul><li>객체가 이용할 수 없게된 시점부터 <code>finalize()</code>가 실행되는 시점까지 긴 시간이 소요될 수 있는데, 이 시간은 GC 알고리즘을 추종함.</li><li>반드시 실행된다는 보장이 없다.</li><li>예외가 발생하더라도 예외가 무시된다.</li><li>성능 저하가 발생한다.</li></ul><p>출처 : <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#wait()">Oracle Docs - Java11 Class Object</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
            <tag> whiteship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hackerrank - Java Datatype</title>
      <link href="2021/02/hackerrank-datatype/"/>
      <url>2021/02/hackerrank-datatype/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/106846791-e5e36000-66f0-11eb-83c3-562cd0c40b4f.png"></p><h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><p>Java has 8 primitive data types; <em>char, boolean, byte, short, int, long, float, and double</em>. For this exercise, we’ll work with the primitives used to hold integer values (<em>byte, short, int,</em> and <em>long</em>):</p><ul><li>A <em>byte</em> is an 8-bit signed integer.</li><li>A <em>short</em> is a 16-bit signed integer.</li><li>An <em>int</em> is a 32-bit signed integer.</li><li>A <em>long</em> is a 64-bit signed integer.</li></ul><p>Given an input integer, you must determine which primitive data types are capable of properly storing that input.</p><p>To get you started, a portion of the solution is provided for you in the editor.</p><p><strong>Reference:</strong> <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a></p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Sample Input</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">-150</span><br><span class="line">150000</span><br><span class="line">1500000000</span><br><span class="line">213333333333333333333333333333333333</span><br><span class="line">-100000000000000</span><br></pre></td></tr></table></figure><p>Sample Output</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-150 can be fitted in:</span><br><span class="line">* short</span><br><span class="line">* int</span><br><span class="line">* long</span><br><span class="line">150000 can be fitted in:</span><br><span class="line">* int</span><br><span class="line">* long</span><br><span class="line">1500000000 can be fitted in:</span><br><span class="line">* int</span><br><span class="line">* long</span><br><span class="line">213333333333333333333333333333333333 can&#39;t be fitted anywhere.</span><br><span class="line">-100000000000000 can be fitted in:</span><br><span class="line">* long</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []argh)</span> </span>&#123;</span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      <span class="keyword">int</span> t=sc.nextInt();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;t;i++) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> x=sc.nextLong();</span><br><span class="line">            System.out.println(x+<span class="string">&quot; can be fitted in:&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x&gt;=-<span class="number">128</span> &amp;&amp; x&lt;=<span class="number">127</span>)System.out.println(<span class="string">&quot;* byte&quot;</span>);</span><br><span class="line">            <span class="comment">//Complete the code</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x&gt;=Short.MIN_VALUE &amp;&amp; x&lt;=Short.MAX_VALUE) System.out.println(<span class="string">&quot;* short&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(x&gt;=Integer.MIN_VALUE &amp;&amp; x&lt;=Integer.MAX_VALUE) System.out.println(<span class="string">&quot;* int&quot;</span>);</span><br><span class="line">                </span><br><span class="line">            System.out.println(<span class="string">&quot;* long&quot;</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            System.out.println(sc.next()+<span class="string">&quot; can&#x27;t be fitted anywhere.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>입력받은 수의 데이터 크기에 따라 표현할 수 있는 자료형을 출력하는 간단한 퀴즈였다.</p><p>처음엔 각 자료형의 크기를 일일히 자료형으로 표현했는데, 나중에 다른 사람은 어떻게 풀었는지를 확인해보니 각 자료형 클래스의 <code>MIN_VALUE</code>, <code>MAX_VALUE</code> 라는 상수형 데이터를 활용한걸 알고 다시 풀어보았다.</p><p>백기선님 스터디를 통해 자바의 자료형을 다시 한 번 학습하고 나서 풀게된 문제여서 자료형 크기를 다시 정리할 수 있었던 문제였으며, 각 자료형 클래스마다 상수형으로 최소 수, 최대 수를 갖고있다는것도 알 수 있었다.</p><p><img src="https://user-images.githubusercontent.com/33862991/106847460-4a52ef00-66f2-11eb-992a-ce2d1c439d31.png"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Quiz </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Live Study 5주차 - 클래스</title>
      <link href="2021/01/livestudy-week-05/"/>
      <url>2021/01/livestudy-week-05/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/peEXNN-oob4/maxresdefault.jpg"></p><ul><li><a href="#class">클래스와 객체</a></li><li><a href="#definition">클래스 정의하는 방법</a><ul><li><a href="#access-modifier">접근제한자</a></li><li><a href="#constructor">생성자</a></li></ul></li><li><a href="#new">객체 만드는 방법 (new 키워드 이해하기)</a></li><li><a href="#function">메서드 정의하는 방법</a></li><li><a href="#constructor">생성자 정의하는 방법</a></li><li><a href="#this">this 키워드 이해하기</a></li></ul><h1 id="클래스와-객체"><a href="#클래스와-객체" class="headerlink" title="클래스와 객체"></a><a name="class"></a>클래스와 객체</h1><p>클래스에 앞서 <strong>객체</strong> 를 먼저 이해할 필요가 있다.</p><p>객체를 중심으로 프로그래밍을 하는 것을 객체지향 프로그래밍(Object Oriented Programming)이라 한다. 객체의 역할과 책임이 객체지향 프로그래밍의 중요한 부분이 된다.</p><p><img src="https://user-images.githubusercontent.com/33862991/105669387-8af87e80-5f22-11eb-96f4-bd5e95a93d11.png"></p><p>세탁기를 객체로 비유하면, 세탁기는 빨래감을 받고, 실행명령이 들어오면 세탁을 시작하면 된다. 어떤 옷이 들어올지는 알필요가 없고, 빨래가 들어왔고, 실행버튼이 눌려졌다면 세탁을하고 끝나면 알림만 전달하면 된다. 건조기는 세탁기에서 나온 빨랫감을 받아서 실행명령이 들어오면 건조를 시작하면 된다. 그리고 건조가 끝나면 끝났음을 알려주기만 하면 된다. 건조기와 세탁기는 서로가 하는 일을 알 필요가 없다. 그저 자신에게 주어진 빨랫감을 세탁 또는 건조를 하고 끝나면 알림을 하기만 하면된다. 이런 세탁 과정에서 세탁기와 건조기는 객체라 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      WashingMachine wash = <span class="keyword">new</span> WashingMachine();</span><br><span class="line">      wash.turnOn(clothes);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>클래스란 이런 객체를 생성하는 템플릿같은 개념이다. 클래스 <code>WashingMachine</code>을 사용하기위해서 인스턴스 <code>wash</code>를 생성했다.</p><p>객체를 정의하는 <a href="#new">방법</a>은 아래에서 정리했다.</p><h1 id="클래스-정의하는-방법"><a href="#클래스-정의하는-방법" class="headerlink" title="클래스 정의하는 방법"></a><a name="definition"></a>클래스 정의하는 방법</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> 클래스명 </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>클래스는 위의 구조로 생성되는데, 이 때 클래스에서 사용할 수 있는 접근제한자는 <code>public</code>과 <code>default</code>로만 사용가능하다. </p><h2 id="접근제한자"><a href="#접근제한자" class="headerlink" title="접근제한자"></a><a name="access-modifier"></a>접근제한자</h2><style>  #access-modifier {     border: 1px solid black;  }  #access-modifier tr th {    text-align: center;    border: 2px solid black;  }  #access-modifier tr td {    text-align: center;    border: 1px solid black;    word-break: keep-all;  }</style><table id="access-modifier">  <tr>      <th style="width: 20%;">접근 제한자</th>    <th style="width: 40%;">적용가능 대상</th>    <th style="width: 40%;">접근 가능 대상</th>  </tr>    <tr>        <td>public</td>        <td>클래스, 생성자, 메서드, 필드</td>        <td>모든 대상</td>    </tr>  <tr>        <td>protected</td>        <td>생성자, 메서드, 필드</td>        <td>같은 패키지 또는 상속받은 자식 클래스</td>    </tr>  <tr>        <td>default</td>        <td>클래스, 생성자, 메서드, 필드</td>        <td>같은 패키지에 소속된 클래스</td>    </tr>  <tr>        <td>private</td>        <td>생성자, 메서드, 필드</td>        <td>클래스 내부</td>    </tr></table><p>출처 : <a href="https://kephilab.tistory.com/53">Kephi Javatory - Java 접근제한자 public, protected, default, private</a></p><br><p>클래스명은 <code>.java</code> 파일명과 동일해야 컴파일 이후에 생성된 바이트코드를 JVM이 로딩할때 클래스를 찾을 수 있다.</p><p><a name="without-ide"></a>ide를 사용하지 않고 터미널에서 Vim 에디터를 이용하여 클래스를 직접 생성해보았다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim JavaTest.java</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac JavaTest.java</span><br></pre></td></tr></table></figure><p><code>javac</code> 는 자바 컴파일러이다. java 소스파일을 자바 컴파일러로 컴파일하라는 명령이기 때문에 이 명령어가 실행되면 디렉토리에 .class 파일이 생성된다. </p><p>클래스 이름은 파일이름과 반드시 같아야 한다. 그래야 JVM이 실행해야할 클래스를 찾을 수 있다. 그리고 클래스의 <code>main()</code>을 호출하게 된다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java JavaTest</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><code>java</code> 는 바이트코드를 JVM으로 실행하는 명령어이다. 이 명령어의 결과로 <code>JavaTest</code>가 실행되어 <code>main()</code>가 호출된 것이다. 실제로 JVM이 어떤 순서로 클래스를 실행하는지 아래의 코드로 살펴보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">      JavaTest test = <span class="keyword">new</span> JavaTest();</span><br><span class="line">  </span><br><span class="line">      System.out.println(test.add(num1, num2));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1+num2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac JavaTest.java &amp;&amp; java JavaTest</span><br><span class="line">30</span><br></pre></td></tr></table></figure><p><code>&amp;&amp;</code>은 복수의 쉘 명령을 순차적으로 할 수 있도록 하는 키워드이다.</p><p>위의 바이트코드를 <code>javap</code>로 뜯어보면, JVM에서 클래스와 메서드를 어떤 순서로 실행하는지 알 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">javap JavaTest</span><br><span class="line">compiled from &quot;JavaTest.java&quot;</span><br><span class="line">public class JavaTest &#123;</span><br><span class="line">   public JavaTest();</span><br><span class="line">   public static void main(java.lang.String[]);</span><br><span class="line">   public int add(int, int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>디폴트 생성자를 먼저 실행하고, 이후 <code>main()</code>을 실행, <code>int</code>형 인자 2개를 파라미터로 받는 <code>add()</code>가 호출된걸 알 수 있다.</p><h2 id="생성자"><a href="#생성자" class="headerlink" title="생성자"></a><a name="constructor"></a>생성자</h2><p>생성자는 파라미터가 없는 기본 생성자도 있을 수 있고, 파라미터가 있는 생성자도 만들수 있다. 다만 개발자가 직접 생성하지 않는다면 자바 컴파일러에서 파라미터가 없는 기본생성자를 자동으로 생성해준다.</p><p><mark>개발자가 임의로 생성자를 생성한다면, 자바 컴파일러는 기본 생성자를 생성하지 않는다.</mark></p><br><h1 id="객체-만드는-방법-new-키워드-이해하기"><a href="#객체-만드는-방법-new-키워드-이해하기" class="headerlink" title="객체 만드는 방법(new 키워드 이해하기)"></a><a name="new"></a>객체 만드는 방법(new 키워드 이해하기)</h1><p>클래스는 속성과 기능을 갖는다. 클래스를 바탕으로 객체를 생성하면 객체도 클래스의 속성과 기능을 갖게되는데, 이 때 객체가 갖는 속성과 기능을 멤버(member)라고 일컫는다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 클래스  인스턴스명 = new 생성자()</span></span><br><span class="line">StudyHalle study = <span class="keyword">new</span> StudyHalle();</span><br></pre></td></tr></table></figure><p>여기서 <code>StudyHalle</code>는 클래스이고, <code>study</code>가 이 클래스를 바탕으로 생성한 인스턴스 객체에 해당한다. </p><p>클래스는 템플릿이고, 이 템플릿을 바탕으로 실제 사용할 목적으로 생성한 객체가 인스턴스라고 한다. 따라서 하나의 클래스로 여러개의 독립된 인스턴스를 만드는것도 가능하다. 인스턴스를 통해서 해당 객체의 메서드나 필드에 접근이 가능해진다.</p><p>클래스는 참조형 타입이므로 인스턴스 생성시 <code>new</code> 키워드로 생성한다. <code>new</code> 키워드로 생성한다는건 곧 JVM의 Heap 영역에 메모리를 할당한다는 이야기이다. </p><p>객체는 null을 값으로서 가질수도 있는데, Heap에 있는 객체가 null을 가질경우, 더 이상 사용하지 않는다고 가정하고 가비지 컬렉터(GC)가 이 객체를 Heap에서 제거함으로써 메모리 누수를 방지해준다.</p><p><strong>정리하면,</strong> 위의 코드는 <code>StudyHalle</code> 라는 클래스로부터 <code>study</code> 라는 이름의 인스턴스 객체를 생성하며, 생성자 <code>StudyHalle()</code>로 변수를 초기화하는 작업을 거친 후 객체를 생성하는 코드이다.</p><p>아래 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMyName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Super.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello world.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMyName</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Sub.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Super a1 = <span class="keyword">new</span> Super();</span><br><span class="line">      Super a2 = <span class="keyword">new</span> Sub();</span><br><span class="line">     </span><br><span class="line">      Sub b1 = <span class="keyword">new</span> Super();  <span class="comment">// compile error</span></span><br><span class="line">      Sub b2 = <span class="keyword">new</span> Sub();  </span><br><span class="line">      </span><br><span class="line">      a1.printMyName();</span><br><span class="line">      a2.printMyName();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Super.</span><br><span class="line">Sub.</span><br></pre></td></tr></table></figure><p><code>Super</code>와 <code>Sub</code>는 Sub -&gt; Super의 상속관계이다. class Super로부터 인스턴스 객체 a1, a2를 생성해서 <code>print()</code>를 호출했는데 다른 결과가 출력되었다.</p><p>이유는 Class Super로부터 인스턴스 객체를 생성하면서 서로 다른 생성자를 사용했기 때문이다.  <code>a1</code>은 생성자 <code>Super()</code>를 초기화하면서 생성한 객체이고, <code>a2</code>는 생성자 <code>Sub()</code>를 초기화하면서 생성한 객체이다.</p><p>그렇다면 아래의 코드는 어떨까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Sub b1 = <span class="keyword">new</span> Super();  <span class="comment">// 컴파일 에러 발생</span></span><br><span class="line">      Sub b2 = <span class="keyword">new</span> Sub();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/33862991/107236719-51b72700-6a69-11eb-862e-d5dec9f5b2ee.png"></p><p>Class Sub에서 Super() 생성자를 호출하는건 불가능했다. 왜 그럴까? </p><p>상속관계(Sub-&gt;Super)를 다시 생각해볼 필요가 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sub b1 = <span class="keyword">new</span> Super();</span><br></pre></td></tr></table></figure><p><u>Class Sub 타입의 변수를 선언하면서 JVM의 heap에 Class Super 생성자로 초기화하여 대입하는 코드</u>이다. </p><p>컴파일 에러가 출력되는 이유는 부모클래스의 생성자를 자식 클래스 타입에 대입하는 것이 불가능하기 때문이다.</p><p>반대로 자식 클래스의 생성자는 부모/자식 클래스 타입에 모두 대입가능한데, 이유는 자식 클래스의 경우 <code>super()</code> 를 이용해서 부모 클래스에도 접근이 가능하기 때문일 것으로 추정된다(?) <em>혹시 잘못된 부분이 있다면, 댓글로 지적해주시면 감사하겠습니다.!!</em> </p><br><h1 id="메서드-정의하는-방법"><a href="#메서드-정의하는-방법" class="headerlink" title="메서드 정의하는 방법"></a><a name="function"></a>메서드 정의하는 방법</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[접근제한자] [반환타입] [메서드명]([파라미터]) &#123; &#125; </span><br></pre></td></tr></table></figure><p>메서드는 클래스 내부에서 선언할 수 있으며, 위의 문법으로 선언한다. </p><p>같은 클래스 또는 상속받은 객체에서만 접근가능하며, 파라미터를 받지않고 문자열 타입을 반환하는 메서드는 다음과 같이 생성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">studyHalle</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="생성자-정의하는-방법"><a href="#생성자-정의하는-방법" class="headerlink" title="생성자 정의하는 방법"></a><a name="constructor"></a>생성자 정의하는 방법</h1><p>클래스를 작성할때, 특별히 생성자를 생성하지 않더라도 디폴트로 생성자가 생성되지만, 직접 생성자를 정의할 수도 있다.</p><p> <a href="#without-ide">위에서</a> ide를 사용하지 않고 java를 생성해서 컴파일하면서 JVM이 클래스를 읽어들이면서 가장 먼저 생성자를 읽어들인걸 확인했다. 생성자는 JVM이 클래스를 읽어들일때 먼저 읽어들이므로 생성자를 통해서 하나의 클래스를 바탕으로 여러 인스턴스를 생성할 수 있다. 아래 예제 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevAndy</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> birthYear = <span class="number">1991</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DevAndy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      LocalDate date = LocalDate.now();</span><br><span class="line">      <span class="keyword">this</span>.age = date.getYear()-birthYear;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">DevAndy</span><span class="params">(String nation)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(nation.equals(<span class="string">&quot;Korea&quot;</span>))&#123;</span><br><span class="line">         LocalDate date = LocalDate.now();</span><br><span class="line">         <span class="keyword">this</span>.age = date.getYear()-birthYear+<span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         LocalDate date = LocalDate.now();</span><br><span class="line">         <span class="keyword">this</span>.age = date.getYear()-birthYear;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>생성자는 클래스와 동일한 이름을 가져야 하며, 파라미터 갯수와 인자 타입 등만 다르게 둘 수 있다. <strong>파라미터 갯수와 인자 타입을 다르게 하면, 생성자를 여러개로 생성</strong> 할 수도 있다. <a href="#this">this</a>에 대한 설명은 아래에서 정리했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> basic02;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> basic01.DevAndy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBasic02</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      DevAndy andy01 = <span class="keyword">new</span> DevAndy();</span><br><span class="line">      DevAndy andy02 = <span class="keyword">new</span> DevAndy(<span class="string">&quot;Korea&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(andy01.getName()+<span class="string">&quot;&#x27;s age is &quot;</span>+andy01.age);</span><br><span class="line">      System.out.println(andy02.getName()+<span class="string">&quot;&#x27;s age is &quot;</span>+andy02.age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DevAndy&#39;s age is 30</span><br><span class="line">DevAndy&#39;s age is 31</span><br></pre></td></tr></table></figure><p>인스턴스를 선언할때 파라미터를 넣으면 같은 클래스임에 필드값(<code>age</code>)이 다르게 가공되어 출력되는걸 알 수 있다.</p><br><h1 id="this-키워드-이해하기"><a href="#this-키워드-이해하기" class="headerlink" title="this 키워드 이해하기"></a><a name="this"></a>this 키워드 이해하기</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBasic03</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.num += num;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JavaBasic04</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      JavaBasic03 basic03 = <span class="keyword">new</span> JavaBasic03();</span><br><span class="line">      System.out.println(basic03.setNum(<span class="number">10</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><p>JavaBasic03 클래스에 대한 인스턴스를 생성해서 <code>setNum()</code>을 호출하고 반환된 값을 출력하는 코드이다. 여기서 주의깊게 봐야할 부분은 JavaBasic03의 <code>setNum()</code>이다.</p><p><code>setNum()</code>에서 다루는 변수는 <code>this.num</code>과 파라미터로 받는 <code>num</code>이다. 여기서 <code>this.num</code>은 클래스의 필드로 선언된 <code>num</code>이다. 리터럴로 20이 할당된 변수이다. 그냥 <code>num</code>은 파라미터로 들어온 변수로써 아직 리터럴을 알 수 없다.</p><p><code>this</code> 키워드를 사용하여 접근하는 변수는 <mark>로컬변수가 아닌 클래스 변수 또는 인스턴스 변수</mark>이다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
            <tag> whiteship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>디지털 개인정보</title>
      <link href="2021/01/digital-privacy/"/>
      <url>2021/01/digital-privacy/</url>
      
        <content type="html"><![CDATA[<p><img src="https://static.highsnobiety.com/thumbor/96U21JmcZFCuaDXfysBJYxZuBjs=/fit-in/800x480/smart/static.highsnobiety.com/wp-content/uploads/2019/03/15135749/apple-ad-privacy-00.jpg" alt="The Verge"></p><p>최근에 뉴욕타임즈 온라인 구독을 시작했다. 영어 실력이 부족하다보니 파파고를 이용해 번역하거나 iOS/MacOS에 내장된 사전기능(Lookup)을 이용한 검색이 많지만, 그래도 양질의 컨텐츠를 읽을 수 있다는 점이 상당히 매력적인것 같다. </p><p>뉴욕타임즈 칭찬하려고 쓰는 글은 아니고, 최근에 디지털 개인정보에 대해 관심이 커지게 된 계기가 여기서 읽게 된 몇개의 기사때문이다. </p><p>왓츠앱의 개인정보 정책을 비판하는 논조의 기사였다. 2014년 인스턴스 메세징 서비스 왓츠앱을 인수한 페이스북이 2016년 왓츠앱의 데이터를 페이스북과 공유하고 있다는 내용이었다. </p><p><em>관련기사</em></p><ul><li><a href="https://www.nytimes.com/2021/01/13/technology/whatsapp-data.html">NYT - The Truth About Your WhatsApp Data</a></li></ul><p><img src="https://static01.nyt.com/images/2021/01/13/business/13ontech/13ontech-jumbo.png?quality=90&auto=webp"></p><p>페이스북과 공유되는 데이터들은 이메일 정도가 아니라 사용자가 얼마나 자주 왓츠앱을 실행하는지, 앱을 실행하고 있는 위치 심지어는 디바이스 화면의 해상도까지 수집한다고 한다.</p><p>페이스북의 개인정보 관련 이슈는 어제 오늘일이 아니긴 하다. 2018년 떠들석했던 <a href="https://ko.wikipedia.org/wiki/%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%B6%81-%EC%BC%80%EC%9E%84%EB%B8%8C%EB%A6%AC%EC%A7%80_%EC%95%A0%EB%84%90%EB%A6%AC%ED%8B%B0%EC%B9%B4_%EC%A0%95%EB%B3%B4_%EC%9C%A0%EC%B6%9C_%EC%82%AC%EA%B1%B4">캠브리 애널리티카 정보 유출사건</a>부터 왓츠앱, 인스타그램, 오큘러스등 페이스북이 인수한 자회사들의 공동창업자들이 공교롭게도 2018년에 줄지어 퇴사하였다. 퇴사한 이들의 직책이 자회사 대표 또는 CTO로 높았음에도 불구하고 회사(페이스북)가 퇴사이유를 노코멘트로 하여 경영진간 갈등이 있지 않았냐하는 이야기가 많다.</p><p><em>관련기사</em></p><ul><li><a href="https://www.mk.co.kr/news/society/view/2018/05/277633/">매일경제 - ‘페북사태’에 와츠앱 공동창업자 퇴사</a></li><li><a href="https://news.joins.com/article/22998101">중앙일보 - 인스타그램 창업자들 회사 떠난다… 저커버그와 충돌 빚은듯</a></li></ul><p>2019년엔 마크 저커버그와 페이스북을 공동창업했던 Chris Hughes가 페이스북의 디지털 영향력과 회사내 CEO 마크 저커버그의 영향력에 대해 걱정하며 페이스북을 해체해야한다는 다소 과격한 오피니언이 뉴욕타임즈에 기고되기도 했다.</p><ul><li><a href="https://www.nytimes.com/2019/05/09/opinion/sunday/chris-hughes-facebook-zuckerberg.html?referrer=masthead">NYT - It’s Time to break Up Facebook</a> </li></ul><br><p>이런 이야기는 미국만의 이야기는 아니었다. 한국에선 최근 대화형 AI봇 “이루다”라는 서비스가 공개되고 2주간 뜨거운 감자였다. AI의 성차별 또는 혐오적인 발언으로 인해 큰 논란을 빚으며 2주만에 서비스가 중단되었다. </p><p><img src="https://external-content.duckduckgo.com/iu/?u=https://www.bloter.net/wp-content/uploads/2020/06/%25EC%2582%25AC%25EC%25A7%2584_%25EB%258C%2580%25ED%2599%2594%25ED%2598%2595AI-%25EC%259D%25B4%25EB%25A3%25A8%25EB%258B%25A4-%25EC%25B9%259C%25EA%25B5%25AC-%25EB%25AA%25A8%25EC%25A7%2591.jpg&f=1&nofb=1"></p><p>서비스가 중단되었음에도 이루다에 논란은 끝나지 않고 있다. AI가 어떻게 성차별, 혐오 발언을 할 수 있었느냐에서 시작되어 AI가 학습한 자료의 원천이 무엇이냐로 질문이 이어져 이루다가 사용자들의 카카오톡 대화내용을 통해 학습되었다는 사실이 공개되며 더 논란이 되었다.</p><p><em>관련기사</em></p><ul><li><a href="https://www.hankyung.com/it/article/2021011436101">한국경제 - 이루다 개발사 “데이터 전량폐기 안한다”</a></li><li><a href="https://www.bbc.com/korean/news-55659434">이루다: AI 시대에 우리의 사생활은 지켜질 수 있을까?</a></li></ul><p>이루다가 카카오라는 대기업의 서버에 무단으로 접근해서 데이터를 가져간건 아니고, <a href="https://play.google.com/store/apps/details?id=com.scatterlab.soljr&referrer=https://scienceoflove.co.kr/?btn=ad_3">“연애의 과학”</a>이라는 서비스를 통해 사용자들의 허가를 받고 데이터를 연동하여 학습한 것으로 추정된다.</p><p>그러나 비록 이 모든것이 합법이다 하더라도 걱정이 들었다. 우리가 메신저를 통해 대화하는 내용을 다른 회사에서 가져가서 머신러닝의 학습모델로 활용할 수 있다면, 우리의 대화내용을 기반으로 플랫폼사는 광고 판매에 활용할 수도 있었을 것이고 자사 플랫폼내 다른 서비스의 기획에도 활용되지는 않았을까 싶은 걱정으로 이어졌다.</p><p>이모든건 데이터가 안전하게 보관되지 않았기 때문에 발생한 일이라는 결론에 이르렀다. 만약 우리의 데이터가 암호화되어 관리되었더라면, 불필요한 데이터가 수집되지 않았더라면 페이스북이 이런 데이터를 가지고 캠브리지 애널리티카와 대선에 개입하지도 못했을 것이며, 이루다의 학습모델로 카카오톡 대화내용을 사용하지 못했을 것이다.</p><p><img src="https://justcreative.com/wp-content/uploads/2014/01/dont-be-evil.jpg" alt="Just Creative"></p><p>구글의 사명으로 알려진 “Don’t be evil”은 개인정보관점에서 <strong>“Can’t be evil”</strong> 로 바뀌어야한다. 이들이 데이터를 안전하게 보관하기를 바랄게 아니라 데이터를 더 이상 지금처럼 자유롭게 수집하지 못하도록 규제 해야할 시기가 왔다고 생각한다. </p><p>최근에 애플과 페이스북이 개인정보 이슈로 갈등을 빚고있다는 소식이 들려오고 있다. 앱스토어에 앱을 등록시 사용자와 관련된 어떤 데이터를 수집하는지를 명시해야하며 모든 수집에 있어 사용자에게 허가를 구하도록 하는 업데이트를 iOS 14에 릴리즈하면서 이로인한 가장 큰 피해를 입게된 페이스북이 구글에 항명을 하기도 했다고 한다.</p><p><em>관련뉴스</em></p><ul><li><a href="https://www.theverge.com/2020/12/16/22178068/facebook-apple-newspaper-ads-ios-privacy-changes">The Verge - Facebook criticizes Apple’s iOS privacy changes with full-page newspaper ads</a></li></ul><p>애플의 보다 강화된 개인정보 정책이 환영하긴 하나 이런 노력을 특정 기업에만 의존해서는 안된다고 생각한다. iOS 사용자만 개인정보에서 안전할게 아니라 모든 온라인 사용자들이 동일하게 권리를 보장받아야 한다고 생각한다.</p><p>따라서 각국의 정부가 함께 인터넷 개인정보 가이드라인을 준비해야 한다고 생각한다. 미국에서는 안되는데, 한국에선 되는(개인정보 관련) 서비스가 발생하면 안되고, 안드로이드에선 되는데 iOS에선 되는 일이 있어서는 안된다.</p><p>인터넷엔 국경이 없으므로 각국의 정부가 함께 규제를 만들어야 모든 사람들이 온라인에서 개인정보를 보호받을 수 있을 것이다. 지난해 시청한 넷플릭스 다큐멘터리 <a href="https://www.netflix.com/kr/title/81254224">&lt;소셜 딜레마&gt;</a>가 많은 걸 시사한다고 생각한다.</p><p><img src="https://user-images.githubusercontent.com/33862991/105502834-375f1880-5d09-11eb-9fe7-57cfc6d4c7e9.png" alt="다큐멘터리 소셜딜레마"></p><p>사용자들의 데이터가 돈이 되는한 플랫폼사들이 스스로 이윤을 포기하며 개인정보를 우선시할 이유는 없을 것이다. 따라서 이 시점에 거버넌스가 작동되어야 한다고 생각한다.</p><p><img src="https://cdn.dnaindia.com/sites/default/files/styles/full/public/2018/04/12/671097-facebook-ceo-mark-zuckerberg-reuters-image.jpg" alt="청문회에서 질의에 답하고 있는 Mark Zuckerberg"></p><p>무료로 서비스를 내어주고, 수집가능한 모든 데이터를 수집하며 광고로 이익을 내고있는 페이스북은 매년 200억불이 넘는 이익을 만들어내고 있다. 매출규모는 2019년 기준 700억불이 넘는다.</p><p>다음엔 내가 개인정보보호를 위해 하고 있는 행동 또는 이용하는 서비스들을 정리해봐야겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> privacy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live Study 4주차 - 제어문</title>
      <link href="2021/01/livestudy-week-04/"/>
      <url>2021/01/livestudy-week-04/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/peEXNN-oob4/maxresdefault.jpg"></p><ul><li><a href="#conditional">조건문</a><ul><li><a href="#if">if</a></li><li><a href="#ternary">삼항연산자</a></li><li><a href="#switch">switch</a></li></ul></li><li><a href="#loop">반복문</a><ul><li><a href="#for-i">for-i</a></li><li><a href="#for-each">for-each</a></li><li><a href="#while">while</a></li><li><a href="#do-while">do-while</a></li></ul></li><li><a href="#keywords">조건문과 반복문에서 쓰이는 키워드</a><ul><li><a href="#break">break</a></li><li><a href="#continue">continue</a></li></ul></li><li><a href="#dashboard">Live-Study 참석율 대시보드 생성하기</a></li></ul><h1 id="조건문"><a href="#조건문" class="headerlink" title="조건문"></a><a name="conditional"></a>조건문</h1><p>조건문은 if문과 switch문으로 구분된다.</p><ul><li><a href="#if">if</a></li><li><a href="#ternary">삼항연산자</a></li><li><a href="#switch">switch</a></li></ul><h2 id="if"><a href="#if" class="headerlink" title="if"></a><a name="if"></a>if</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> condition;</span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">   System.our.println(<span class="string">&quot;true&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if문은 조건이 <code>true</code>일 때 블럭 <code>&#123;&#125;</code> 안의 명령을 수행하도록 하는 조건식이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num&lt;<span class="number">0</span>)&#123;</span><br><span class="line">  System.our.println(<span class="string">&quot;0보다 작다.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(num&lt;<span class="number">10</span>)&#123;   <span class="comment">// 0 &lt;= num &lt; 10</span></span><br><span class="line">  System.our.println(<span class="string">&quot;10보다 작다.&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;             <span class="comment">// num &gt;= 10</span></span><br><span class="line">System.our.println(<span class="string">&quot;10보다 크다.&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="else-if-와-else"><a href="#else-if-와-else" class="headerlink" title="else-if 와 else"></a>else-if 와 else</h3><p>if문의 첫번째 조건이 충족(<code>true</code>)하지 않는 다른 조건의 경우는 <code>else if</code>문으로 조건 분기가 가능하다. <code>else</code> 는 위의 모든 조건을 제외한 경우를 의미한다.</p><p>if문 안의 조건엔 비교연산자와 논리연산자가 함께 쓰일수 있다.di</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(num&gt;=<span class="number">0</span> &amp;&amp; num&lt;<span class="number">10</span>)&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;한자릿수입니다.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="논리연산자-사용"><a href="#논리연산자-사용" class="headerlink" title="논리연산자 사용"></a>논리연산자 사용</h3><p>if문을 사용할때 boolean 타입의 변수를 사용하기보다 논리연산자를 사용하는 경우가 많다. 이 때 알아야 할 것이 있다. 바로 아래 예제 코드를 확인해보도록 하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle04</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">if</span>(num1++==<span class="number">15</span> &amp;&amp; num2++==<span class="number">20</span>)&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;failed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">      System.out.println(num1);</span><br><span class="line">      System.out.println(num2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 코드는 if문을 통해 success와 fail을 구분하는 코드지만, 필자가 이 코드를 통해 확인하고 싶은 부분은 if문 조건문 안에서 증감연산자를 적용한 <code>num1</code>과 <code>num2</code>가 값이 어떻게 바뀌는지 보고 싶었다.</p><p>위 코드의 결과는 아래와 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">failed</span><br><span class="line">11</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p>if문 안에서 똑같이 <code>num1</code>과 <code>num2</code>를 증감연산하였는데, 왜 <code>num1</code>만 증감연산 적용된걸까.</p><p>if 조건문안에서 사용한 논리연산자가 &amp;&amp; 였다. &amp;&amp; 는 두항 모두 <code>true</code>일 때 <code>true</code>를 반환하는 논리연산자이다. 위의 코드에서 num1++은 11인데 11은 15와 일치하지 않으므로 <code>false</code>를 반환하다. 그럼 우측 항이 <code>true</code>이든 <code>false</code>이든 상관없이 이미 <code>false</code>이므로 if문은 바로 break를 실행하고 빠져나오게 된다. 그래서 num2는 증감연산지 실행되지 않은것이다.</p><h3 id="중첩-if문"><a href="#중첩-if문" class="headerlink" title="중첩 if문"></a>중첩 if문</h3><p>if문안의 if문이 들어가는 중첩 if문도 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String name=<span class="string">&quot;David Beckham&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">7</span>;</span><br><span class="line">String club;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(number==<span class="number">7</span>)&#123;</span><br><span class="line">   <span class="keyword">if</span>(name.equals(<span class="string">&quot;David Beckham&quot;</span>))&#123;</span><br><span class="line">      club=<span class="string">&quot;Manchester United FC&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if문안의 중첩도를 3이상 만들수도 있지만, if문의 중첩도는 2 이하로 맞추는 것의 향후 코드 가독성을 위해서 좋다. 논리연산자를 사용하면 불필요한 중첩도를 낮출수 있다. 위의 코드를 리팩토링해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(number==<span class="number">7</span> &amp;&amp; name.equals(<span class="string">&quot;David Beckham&quot;</span>))&#123;</span><br><span class="line">   club=<span class="string">&quot;Manchester United FC&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>훨씬 가독성이 높아진다. 중첩도 2 수준만으로 대부분의 논리를 구현할 수 있으므로 중첩도가 3이상 넘어가지 않도록 주의하자.</p><h2 id="삼항연산자"><a href="#삼항연산자" class="headerlink" title="삼항연산자"></a><a name="ternary"></a>삼항연산자</h2><p>삼항연산자를 이용하면 if-else문을 간단히 한줄로 작성할수도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(조건식) ? [true] : [false]</span><br></pre></td></tr></table></figure><p><code>?</code> 기준으로 왼쪽이 조건식이 되며, <code>?</code> 오른쪽은 조건에 따라 수행될 함수 또는 대입될 리터럴을 작성한다.</p><p>조건식이 true이면 <code>:</code> 기준으로 왼쪽이 수행되고, false이면 <code>:</code> 기준으로 오른쪽이 수행된다. 아래 예제코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      LocalDateTime time = LocalDateTime.now();</span><br><span class="line">      String ampm = (time.getHour()&gt;=<span class="number">12</span>) ? <span class="string">&quot;오후&quot;</span> : <span class="string">&quot;오전&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;지금은 &quot;</span>+ampm+<span class="string">&quot;입니다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">지금은 오후입니다.</span><br></pre></td></tr></table></figure><p><code>LocalDateTime</code> 객체로 시간을 가져와서 그중 시간이 12시 이상이면, 문자열 변수 <code>ampm</code>에 오전/오후 리터럴을 대입하는 코드이다.</p><br><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a><a name="switch"></a>switch</h2><p>특정 조건으로 분기 처리할 수 있는 if문과 달리 switch문은 하나의 조건문으로만 명령이 수행되도록하는 특징이 있다. 이름 그대로 ‘스위치’ 같은 역할을 수행하는데, if문보다 <strong>간결</strong> 하다는 장점이 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">     System.out.println(<span class="string">&quot;입력받은 숫자는 0입니다.&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">     System.out.println(<span class="string">&quot;입력받은 숫자는 1입니다.&quot;</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">     System.out.println(<span class="string">&quot;입력받은 숫자는 2입니다.&quot;</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">     System.out.println(<span class="string">&quot;입력받은 숫자는 2보다 큰 정수입니다.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">입력받은 숫자는 2입니다.</span><br></pre></td></tr></table></figure><p>switch로 들어온 조건에 따라 다양하게 분기처리가 가능하다. <code>case</code> 는 <code>if</code> 또는 <code>else-if</code>와 같다. <code>default</code>는 <code>else</code>와 같다.</p><p>switch문에서 사용한 <code>break</code>는 아래 정리해두었다.</p><h3 id="switch의-제약조건"><a href="#switch의-제약조건" class="headerlink" title="switch의 제약조건"></a>switch의 제약조건</h3><ul><li>switch문의 조건식 결과는 정수 또는 문자열이어야 한다.</li><li>case문의 값은 정수, 상수만 가능하며, 중복되지 않아야 한다.</li></ul><p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001">남궁성 - Java의 정석</a></p><h3 id="중첩-switch문"><a href="#중첩-switch문" class="headerlink" title="중첩 switch문"></a>중첩 switch문</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">2</span>;</span><br><span class="line">String gender = <span class="string">&quot;male&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">switch</span>(gender) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;male&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;남자입니다.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;female&quot;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;여자입니다.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;1입니다.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;2입니다..&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    System.out.println(<span class="string">&quot;입력받은 숫자는 1보다 큰 정수입니다.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드처럼 switch 안의 switch가 중첩될수도 있으며, case 2개를 한번에 분기처리할수도 있다.</p><br><h1 id="반복문"><a href="#반복문" class="headerlink" title="반복문"></a><a name="loop"></a>반복문</h1><ul><li><a href="#for-i">for i</a></li><li><a href="#for-each">for each</a></li><li><a href="#while">while</a></li><li><a href="#do-while">do-while</a></li></ul><h2 id="for-i"><a href="#for-i" class="headerlink" title="for i"></a><a name="for-i"></a>for i</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(iterator 초기값; iterator 조건; 증감;) &#123; &#125;</span><br></pre></td></tr></table></figure><p>for문의 <code>()</code> 안에는 iterator의 초기값, 조건, 증감이 들어간다. iterator가 <code>true</code>일때까지 증감할때마다 블럭<code>&#123;&#125;</code> 안의 코드가 반복된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">  System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h2 id="for-each"><a href="#for-each" class="headerlink" title="for each"></a><a name="for-each"></a>for each</h2><p>for-each는 for-i와 달리 iterator를 쓰지 않는 for문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num:numbers)&#123;</span><br><span class="line">  System.out.print(num+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>iterator를 쓰지 않기 때문에 List 또는 배열등의 자료구조가 필요하다.</p><p>출처 : <a href="https://www.w3schools.com/java/java_for_loop.asp">w3schools - Java For Loop</a></p><h2 id="while"><a href="#while" class="headerlink" title="while"></a><a name="while"></a>while</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(condition) &#123; &#125;</span><br></pre></td></tr></table></figure><p>while문안의 조건문이 <code>true</code> 이면, 계속 반복하다가 조건문이 <code>false</code> 이면 반복문이 종료된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>)&#123;</span><br><span class="line">   System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4</span><br></pre></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a><a name="do-while"></a>do-while</h2><p>while문의 경우 블럭안의 내용이 실행되기 앞서 조건문을 먼저 실행한뒤에 조건이 <code>true</code>이면 블럭안의 코드가 실행되는데 반해, do-while문은 일단 블럭안의 코드를 실행한뒤에 더 반복할지 조건문을 실행하는 반복문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125; <span class="keyword">while</span>(i&lt;<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>주의해야할 점은 조건문을 마칠 때 <code>;</code>를 꼭 작성해야 한다!</p><p>출처 : <a href="https://www.w3schools.com/java/java_while_loop.asp">w3schools - Java While Loop</a></p><br><h1 id="조건문과-반복문에서-쓰이는-키워드"><a href="#조건문과-반복문에서-쓰이는-키워드" class="headerlink" title="조건문과 반복문에서 쓰이는 키워드"></a><a name="keywords"></a>조건문과 반복문에서 쓰이는 키워드</h1><p>조건문과 반복문에서 자주 쓰이는 키워들이다.</p><h2 id="break"><a href="#break" class="headerlink" title="break;"></a><a name="break"></a>break;</h2><p>switch는 조건에 따라 분기를 원할 경우, 각 case가 끝날때마다 <code>break</code>을 찍어줘야한다. 그렇지않으면 그 다음 case가 실행된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(num)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">     System.out.println(<span class="string">&quot;입력받은 숫자는 0입니다.&quot;</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">     System.out.println(<span class="string">&quot;입력받은 숫자는 1입니다.&quot;</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">     System.out.println(<span class="string">&quot;입력받은 숫자는 2입니다.&quot;</span>);</span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">     System.out.println(<span class="string">&quot;입력받은 숫자는 2보다 큰 정수입니다.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">입력받은 숫자는 0입니다.</span><br><span class="line">입력받은 숫자는 1입니다.</span><br></pre></td></tr></table></figure><p>첫번째 case에서 <code>break</code>되지 않고, 다음 case까지 실행되었기 때문이다. if문은 <code>&#123;&#125;</code>가 완벽하게 다른 조건과 독립되는것에 비해 switch가 갖는 특징이기도 하다.</p><h2 id="continue"><a href="#continue" class="headerlink" title="continue;"></a><a name="continue"></a>continue;</h2><p>반복하지 않고 바로 건너띄울때(<strong>skip</strong>) 사용하는 키워드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.print(i+<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>0부터 10까지 iterator를 돌리면서 iterator를 출력하는 반복문인데, 짝수(<code>i%2==0</code>)는 <code>continue</code> 되도록 하였다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 7 9</span><br></pre></td></tr></table></figure><br><h1 id="Live-Study-참석율-대시보드-생성하기"><a href="#Live-Study-참석율-대시보드-생성하기" class="headerlink" title="Live-Study 참석율 대시보드 생성하기"></a><a name="dashboard"></a>Live-Study 참석율 대시보드 생성하기</h1><p>Live-Study 대시보드는 Github에 소스코드와 문서를 정리하여 올려두었다.</p><p><a href="https://github.com/youngjinmo/WhiteShip-LiveStudy-Dashboard">https://github.com/youngjinmo/WhiteShip-LiveStudy-Dashboard</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> whiteship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>클래스변수와 인스턴스 변수 차이(생성시점)</title>
      <link href="2021/01/diff-static-variable-instance-variable/"/>
      <url>2021/01/diff-static-variable-instance-variable/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/105133010-3bcfd980-5b2f-11eb-87ef-626c9cf53575.png"></p><p>백기선님 라이브 스터디의 피드백 영상을 보면서 미처 모르고 코딩했던 부분을 알게되어 정리하게 되었다. 그냥 라이브 스터디 <a href="https://youngjinmo.github.io/2021/01/livestudy-week-02/">2주차 포스팅</a>에 업데이트 할 수 있었으나 꽤 중요한 부분이라는 생각이 들어서 따로 분리했다.</p><p>위의 스크린샷의 코드를 보면, <code>static</code> 메서드에서 인스턴스 변수를 참조하지 못하는 상황이다. 왜 그럴까?</p><p><code>static</code> 메서드는 클래스 생성 시점에 메모리에 올라가지만, 인스턴스 변수는 인스턴스 생성 시점에 생기기 때문에, <mark>static 메서드 관점에서 아직 메모리에 올라오지 않은 인스턴스 변수를 참조할 수 없기 때문이다.</mark></p><p>그럼 클래스가 생성되는 시점은 언제일까? 클래스가 생성되는 시점은 해당 클래스를 필요로해서 사용하는 시점이다. </p><p>위의 스크린샷에서는 메서드가 하나밖에 없기 때문에 예제 코드를 다시 만들어보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number1 = <span class="number">1_000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> number2 = <span class="number">2_000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">method02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalleTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String greeting = StudyHalle04.method02();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>StudyHalleTest</code> 클래스에서 문자열 변수를 담을때 <code>StudyHalle04</code> 클래스의 <code>method02()</code>를 반환받아서 대입했다. 이때 메모리에 <code>StudyHalle04</code> 클래스가 올라가고 이 시점에 <code>static</code> 키워드가 붙은 클래스 변수가 메모리에 함께 올라가게 된다. 하지만 인스턴스 변수는 사용되지 않았기 때문에 이 때엔 메모리에 올라가지 않게 된다. </p><p><img src="https://user-images.githubusercontent.com/33862991/105133017-3e323380-5b2f-11eb-835d-cf1436aa939b.png"></p><p>외부 클래스에서 접근할때 클래스 변수는 접근이 가능하지만, 이렇게 인스턴스 변수는 접근이 불가능한 이유다.</p><p><img src="https://user-images.githubusercontent.com/33862991/105133020-3ecaca00-5b2f-11eb-9243-756415bdd7f7.png"></p><p>인스턴스 변수를 사용하기 위해서는 위처럼 인스턴스를 생성해야한다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>결론은 클래스변수와 인스턴스변수의 생성시점이 다르기 때문에 메모리에 먼저 올라간 <code>static</code> 메서드가 아직 올라가지 않은 인스턴스변수를 참조하지 못한다는 것이다.</p><p>반대로 일반 메서드에서 클래스 변수를 참조할 수 있는 이유는 일반 메서드의 경우 인스턴스가 생성되는 시점에 호출되는데, 이 땐 이미 클래스가 메모리에 올라간 뒤기 때문에 클래스변수를 참조할 수 있다</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String 변수를 선언하는 2가지 방식</title>
      <link href="2021/01/two-ways-to-declare-string-variable/"/>
      <url>2021/01/two-ways-to-declare-string-variable/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/104871797-62570e80-598f-11eb-86a2-d2144e40e3f6.jpg"></p><p><code>String</code> 변수를 비교할 땐, 비교연산자 <code>==</code> 대신 String 클래스의 <code>equals()</code>를 사용해야한다. 왜 그럴까? 아래 코드를 통해 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">&quot;Hello World.&quot;</span>;</span><br><span class="line">String hi = <span class="keyword">new</span> String(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(greeting==hi);</span><br></pre></td></tr></table></figure><p>위에서 <code>greeting</code>과 <code>hi</code>는 서로 같은 문자열 리터럴을 갖고있으므로 비교연산자로 비교하면 같을것 같지만, <code>==</code> <strong><u>연산자는 객체를 비교하는 연산자</u></strong> 인데 두 변수는 두 서로 다른 객체이기 때문에, <code>false</code>를 반환한다.</p><p>따라서 문자열을 비교할땐, <code>==</code> 대신 <code>String</code> 클래스의 <code>equals()</code>를 이용해서 비교해야 한다. <code>equals()</code>는 객체가 다르더라도 문자열 값만 비교하므로 원하는 결과를 반환받을 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">&quot;Hello World.&quot;</span>;</span><br><span class="line">String hello    = <span class="string">&quot;Hello World.&quot;</span>;</span><br><span class="line">String hi = <span class="keyword">new</span> String(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;greeting==hi : &quot;</span>+greeting==hi);</span><br><span class="line">System.out.println(<span class="string">&quot;greeting.equals(hi) : &quot;</span>+greeting.equals(hi)+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;greeting 주소값 : &quot;</span>+System.identityHashCode(greeting));</span><br><span class="line">System.out.println(<span class="string">&quot;hello 주소값 : &quot;</span>+System.identityHashCode(hello));</span><br><span class="line">System.out.println(<span class="string">&quot;hi 주소값 : &quot;</span>+System.identityHashCode(hi));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">greeting&#x3D;&#x3D;hi : false</span><br><span class="line">greeting.equals(hi) : true</span><br><span class="line"></span><br><span class="line">greeting 주소값 : 640070680</span><br><span class="line">hello 주소값 : 640070680</span><br><span class="line">hi 주소값 : 1510467688</span><br></pre></td></tr></table></figure><p><code>System</code> 클래스의 <code>identityHashCode()</code>를 이용해서 주소값을 확인해보니 <code>greeting</code>과 <code>hi</code>는 다른 객체로 보여진다. 그래서 비교연산자를 통한 비교에서 <code>false</code>를 반환받은 것이다.</p><p>구글링해보니 일반적으로 객체는 <code>new</code> 키워드를 이용하여 생성자로 생성해야하나 <code>String</code> 변수에 한해 리터럴 대입을 허용한다고 한다. 그렇다면 문자열 리터럴을 대입하는것과 <code>new</code> 키워드로 <code>String </code>객체를 생성하는 것은 어떤 차이가 있을까.</p><p>문자열 리터럴을 대입하여 변수를 생성하면, 해당 변수는 JVM의 <strong>String Constant Pool</strong> 에 할당된다고 한다. 이름에서도 알 수 있듯이 상수로 사용되기 때문에 여기에 할당되면 가변성(immutable)이 허용되지 않는다. </p><p>반면 생성자를 통해 문자열 변수를 생성하면, Heap 메모리에 할당되어 값의 변경이 가능해진다고 한다. 정말 그런지 주소값을 통해 확인해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String constantStr01 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">String constantStr02 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;constantStr01 주소값 : &quot;</span>+System.identityHashCode(constantStr01));</span><br><span class="line">System.out.println(<span class="string">&quot;constantStr02 주소값 : &quot;</span>+System.identityHashCode(constantStr02));</span><br><span class="line"></span><br><span class="line">String heapStr01 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">String heapStr02 = <span class="keyword">new</span> String(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;heapStr01 주소값 : &quot;</span>+System.identityHashCode(heapStr01));</span><br><span class="line">System.out.println(<span class="string">&quot;heapStr02 주소값 : &quot;</span>+System.identityHashCode(heapStr02));</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constantStr01 주소값 : 225534817</span><br><span class="line">constantStr02 주소값 : 225534817</span><br><span class="line">heapStr01 주소값 : 640070680</span><br><span class="line">heapStr02 주소값 : 1510467688</span><br></pre></td></tr></table></figure><p>같은 값을 갖는 두개의 문자열 변수를 각각 리터럴 대입방식(<em>String Constant Pool에 할당</em>)과 생성자 생성방식(<i>Heap에 할당</i>)으로 선언하여 주소값을 비교한 결과이다.</p><p>리터럴 대입 방식을 통해서 선언한 문자열 변수들은 서로 같은 주소값을 갖고 있었다. String Constant Pool을 자세히 알지는 못하지만, 참조하는 값이 이미 할당된 변수가 있을 경우, 해당 변수가 바라보는 주소값을 참조하는것 같다.</p><p>반면 생성자를 통해 선언한 문자열 변수는 같은 값을 갖더라도 서로 다른 주소값을 갖는걸 알 수 있다. </p><p>결과적으로 문자열 변수 4개를 선언했지만, 주소값을 통해 확인된 객체는 3개이므로 메모리를 효율적으로 관리하기 위해서는 생성자를 통해서 문자열 변수를 선언하는것보단 리터럴을 대입하는 방식으로 선언하는게 더 나을것 같다.</p><p><strong>출처</strong></p><ul><li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001">남궁성 - Java의 정석</a></li><li><a href="https://youngjinmo.github.io/2020/04/java-object-instance/">DevAndy - 객체를 직접 호출하는 것과 인스턴스를 호출하는것의 차이 (메모리 주소값 비교)</a></li><li><a href="https://ict-nroo.tistory.com/18">Namjun Kim - String = “” vs new String(“”)의 차이</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live Study 3주차 - 연산자</title>
      <link href="2021/01/livestudy-week-03/"/>
      <url>2021/01/livestudy-week-03/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/peEXNN-oob4/maxresdefault.jpg"></p><ul><li><a href="#arithmetic">산술 연산자</a></li><li><a href="#shift">비트 연산자</a></li><li><a href="#relatioal">관계 연산자</a></li><li><a href="#logical">논리 연산자</a></li><li><a href="#instanceof">instanceof</a></li><li><a href="#assignment">assignment(=) operator</a></li><li><a href="#ternary">3항 연산자</a></li><li><a href="#priority">연산자 우선 순위</a></li><li><a href="#arrow">화살표(-&gt;) 연산자</a></li></ul><br><h1 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a><a name="arithmetic"></a>산술 연산자</h1><p>수학 연산을 처리하는 연산자이다.</p><ul><li><code>+</code> : 더하기 연산자</li><li><code>-</code> : 빼기 연산자</li><li><code>*</code> : 곱하기 연산자</li><li><code>/</code> : 나누기 연산자</li><li><code>%</code> : 나머지 연산자</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num1 = <span class="number">1</span>+<span class="number">1</span>;          <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">float</span> num2 = <span class="number">1.25f</span>-<span class="number">0.5f</span>; <span class="comment">// 0.75</span></span><br><span class="line">      <span class="keyword">int</span> num2 = <span class="number">11</span>*<span class="number">3</span>;         <span class="comment">// 33</span></span><br><span class="line">      <span class="keyword">float</span> num3 = <span class="number">0.1f</span>/<span class="number">0.2f</span>   <span class="comment">// 0.5</span></span><br><span class="line">      <span class="keyword">int</span> num4 = <span class="number">10</span>%<span class="number">3</span>;         <span class="comment">// 1</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이외에 증감 연산자(<code>++</code>, <code>--</code>)도 있다. 다만 <strong><u>연산자의 위치에 따라 증감이 이뤄지는 시기가 달라진다.</u></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle03</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      afterSensitization(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="comment">// beforeSensitization(1, 5);</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterSensitization</span><span class="params">(<span class="keyword">int</span> param, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">         System.out.println(i+<span class="string">&quot; 증감 : &quot;</span>+(param++));</span><br><span class="line">         System.out.println(i+<span class="string">&quot; 증감 후 : &quot;</span>+param+<span class="string">&quot;\n===============&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beforeSensitization</span><span class="params">(<span class="keyword">int</span> param, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">         System.out.println(i+<span class="string">&quot; 증감 : &quot;</span>+(++param));</span><br><span class="line">         System.out.println(i+<span class="string">&quot; 증감 후 : &quot;</span>+param+<span class="string">&quot;\n===============&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>초기값(<code>param</code>)과 반복 횟수(<code>count</code>)를 파라미터로 받는 메서드 2개를 만들었다. 둘다 for문을 통해 반복 횟수만큼 초기값을 증감하여 콘솔에 출력하는 메서드인데, 값을 증감하는 방식이 다르다.</p><ul><li><code>afterSensitization()</code> : param++;</li><li><code>beforeSensitization()</code> : ++param;</li></ul><p>먼저 <code>afterSensitization()</code>를 콘솔에 출력했을때의 결과이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1 증감 : 1</span><br><span class="line">1 증감 후 : 2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2 증감 : 2</span><br><span class="line">2 증감 후 : 3</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">3 증감 : 3</span><br><span class="line">3 증감 후 : 4</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">4 증감 : 4</span><br><span class="line">4 증감 후 : 5</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">5 증감 : 5</span><br><span class="line">5 증감 후 : 6</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>초기값이 1인데 증감연산자를 통해 증감(<code>param++</code>)을 실행하자마자 출력했을 때의 값도 1이었다. 이후에 다시 값을 출력했을때 비로소 증감이 이뤄진걸 알 수 있다.</p><p>이번엔 <code>beforeSensitization()</code>을 실행해보았다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0 증감 : 2</span><br><span class="line">0 증감 후 : 2</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">1 증감 : 3</span><br><span class="line">1 증감 후 : 3</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2 증감 : 4</span><br><span class="line">2 증감 후 : 4</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">3 증감 : 5</span><br><span class="line">3 증감 후 : 5</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">4 증감 : 6</span><br><span class="line">4 증감 후 : 6</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>아까와는 다른 결과이다. 초기값 1을 받아서 증감(<code>++param</code>)을 실행했을때, 곧바로 적용되어 출력되었다.</p><p>변수 또는 리터럴 뒤에 증감연산자가 올 경우는 해당 라인에서 즉시 값이 바뀌는게 아니라 그 다음 실행문부터 증감이 적용되며, 변수 또는 리터럴 앞에 증감연산자가 올 경우는 해당 라인에서 즉시 값이 바뀌는 것이다.</p><br><h1 id="비트-연산자"><a href="#비트-연산자" class="headerlink" title="비트 연산자"></a><a name="shift"></a>비트 연산자</h1><p>비트 연산은 개발할때 해본적이 없어서 좀 생소했다.</p><p>일단 비트는 0과 1만 표현할 수 있기 때문에 비트 연산 역시 0과 1로 이뤄진다.</p><h3 id="amp-AND-비트-논리곱"><a href="#amp-AND-비트-논리곱" class="headerlink" title="&amp; (AND : 비트 논리곱)"></a>&amp; (AND : 비트 논리곱)</h3><p><code>x &amp; y</code> : x,y 모두 1일 때에만 1을 반환</p><p><code>0101 &amp; 0111</code> 을 검토해보면, 각각의 자릿수를 비교해보면 두번째와 4번째 비트만 모두 1이므로 결과는 <code>0101</code>이 된다.</p><p>인텔리제이에서 실제로 비트 연산이 이뤄지는지 확인해보았다. IDE에서 바이너리 코드를 보고 싶다면, <code>Integer</code> 객체의 <code>toBinaryString()</code> 메서드를 이용하면 볼수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>;   <span class="comment">// 0101</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">7</span>;   <span class="comment">// 0111</span></span><br><span class="line">System.out.println(<span class="string">&quot;a &amp; b : &quot;</span>+(a&amp;b));  <span class="comment">// a &amp; b : 5</span></span><br></pre></td></tr></table></figure><h3 id="OR-비트-논리합"><a href="#OR-비트-논리합" class="headerlink" title="| (OR : 비트 논리합)"></a>| (OR : 비트 논리합)</h3><p><code>x | y</code> : x,y 중 하나라도 1이면 1을 반환</p><p><code>1010 | 0100</code> 을 검토해보면, 둘중 하나라도 1인 비트는 첫번째, 두번째, 세번째 비트이므로 결과는 <code>1110</code> 이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;  <span class="comment">// 1010</span></span><br><span class="line"><span class="keyword">int</span> d = <span class="number">4</span>;   <span class="comment">// 0100</span></span><br><span class="line">System.out.println(<span class="string">&quot;c | d : &quot;</span>+(c|d));  <span class="comment">// c | d : 14</span></span><br></pre></td></tr></table></figure><h3 id="XOR-비트-베타적-논리합"><a href="#XOR-비트-베타적-논리합" class="headerlink" title="^ (XOR : 비트 베타적 논리합)"></a>^ (XOR : 비트 베타적 논리합)</h3><p><code>x ^ y</code> : x, y가 서로다를때 1을 반환</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> e = <span class="number">10</span>;  <span class="comment">// 0000 1010</span></span><br><span class="line"><span class="keyword">int</span> f = <span class="number">20</span>;  <span class="comment">// 0001 0100</span></span><br><span class="line">System.out.println(<span class="string">&quot;e ^ f : &quot;</span>+(e^f));  <span class="comment">// e ^ f : 30</span></span><br></pre></td></tr></table></figure><h3 id="NOT-연산자"><a href="#NOT-연산자" class="headerlink" title="~ (NOT 연산자)"></a>~ (NOT 연산자)</h3><p><code>~</code> : 비트를 1이면 0, 0이면 1로 반환</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;  <span class="comment">// 0000 1010</span></span><br><span class="line"><span class="comment">// ~num : 1 0101</span></span><br><span class="line">System.out.println(<span class="string">&quot;~num : &quot;</span>+(~num)); <span class="comment">// ~num : -11</span></span><br></pre></td></tr></table></figure><h3 id="lt-lt-Left-shift-연산자"><a href="#lt-lt-Left-shift-연산자" class="headerlink" title="&lt;&lt; (Left shift 연산자)"></a>&lt;&lt; (Left shift 연산자)</h3><p><code>x &lt;&lt; y</code> : x의 비트를 왼쪽으로 y만큼 이동(빈자리는 0으로 채움)</p><p><code>0011 &lt;&lt; 0010</code> 을 검토해보면, <code>0011</code>을 왼쪽으로 <code>0010</code> 만큼 이동해야 한다. <code>0010</code> 은 십진수로 2이므로 <code>0011</code> 의 비트를 왼쪽으로 2만큼 이동하면, <code>1100</code>이 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> g = <span class="number">3</span>;  <span class="comment">// 0011</span></span><br><span class="line"><span class="keyword">int</span> h = <span class="number">2</span>;  <span class="comment">// 0010</span></span><br><span class="line"><span class="comment">// 0011 &lt;&lt; 0010 = 1100</span></span><br><span class="line">System.out.println(<span class="string">&quot;g &lt;&lt; h : &quot;</span>+(g&lt;&lt;h));  <span class="comment">// g &lt;&lt; h : 12</span></span><br></pre></td></tr></table></figure><h3 id="gt-gt-Right-shift-연산자"><a href="#gt-gt-Right-shift-연산자" class="headerlink" title="&gt;&gt; (Right shift 연산자)"></a>&gt;&gt; (Right shift 연산자)</h3><p><code>x &gt;&gt; y</code> : x의 비트를 y만큼 오른쪽으로 이동(빈자리는 a)</p><p><code>-8 &gt;&gt; 2</code> 를 검토해보자. 음의 십진수 -8의 비트는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">8</span>;</span><br><span class="line">System.out.println(i+<span class="string">&quot; : &quot;</span>+Integer.toBinaryString(i));</span><br><span class="line"><span class="comment">// -8 : 1 1000</span></span><br></pre></td></tr></table></figure><p>이 수를 오른쪽으로 비트를 2만큼 이동하면, <code>1 1110</code> 이므로 -2가 된다.</p><blockquote><p>비트로 십진수 음수를 표현하는 방법<br>출처 : <a href="https://m.blog.naver.com/PostView.nhn?blogId=mayu-story&logNo=220507028861&proxyReferer=https://www.google.com/">마유의 전자 이야기 - 음수 십진수를 음수 이진수로 표현 하는 방법</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">8</span>;  <span class="comment">// 1 1000</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;   <span class="comment">// 0010</span></span><br><span class="line"><span class="comment">// 오른쪽으로 2만큼 비트 이동하면 </span></span><br><span class="line"><span class="comment">// 1 1110</span></span><br><span class="line">System.out.println(<span class="string">&quot;i &gt;&gt; j : &quot;</span>+(i&gt;&gt;j));  <span class="comment">// i &gt;&gt; j : -2</span></span><br></pre></td></tr></table></figure><h3 id="gt-gt-gt-Unsigned-right-shift-연산자"><a href="#gt-gt-gt-Unsigned-right-shift-연산자" class="headerlink" title="&gt;&gt;&gt; (Unsigned right shift 연산자)"></a>&gt;&gt;&gt; (Unsigned right shift 연산자)</h3><ul><li><code>x &gt;&gt;&gt; y</code> : <code>&gt;&gt;</code> (Right shift 연산자)와 기본적으로 같지만, <strong>오른쪽으로 밀려나면서 생기는 비트 왼쪽의 공백은 최상위 부호 비트가 아니라 0으로 채워진다.</strong> 따라서 양수이건 음수이건 항상 양수로 반환된다.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = -<span class="number">8</span>;  <span class="comment">// 1 1000</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;   <span class="comment">// 0010</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsigned right shift는 항상 양수를 반환하므로</span></span><br><span class="line"><span class="comment">// 1073741822</span></span><br><span class="line">System.out.println(<span class="string">&quot;i &gt;&gt;&gt; j : &quot;</span>+(i&gt;&gt;&gt;j));  <span class="comment">// i &gt;&gt;&gt; j : 1073741822</span></span><br></pre></td></tr></table></figure><br><p>출처</p><ul><li><a href="https://coding-factory.tistory.com/521">코딩팩토리 [Java] 비트(Shift) 연산자 사용법 &amp; 예제</a></li><li><a href="https://www.geeksforgeeks.org/bitwise-operators-in-java/">Geeks for Geeks - Bitwise operators in Java</a></li></ul><br><h1 id="관계-연산자"><a href="#관계-연산자" class="headerlink" title="관계 연산자"></a><a name="relational"></a>관계 연산자</h1><ul><li><code>x &gt; y</code> : x가 y보다 크면 true, x가 y와 같거나 작으면 false 반환 </li><li><code>x &lt; y</code> : x가 y보다 작으면 true, x가 y와 같거나 크면 false 반환 </li><li><code>x &gt;= y</code> : x가 y보다 크거나 같으면 true, x가 y보다 작으면 false 반환 </li><li><code>x &lt;= y</code> : x가 y보다 작거나 같으면 true, x가 y보다 크면 false 반환 </li><li><code>x == y</code> : x와 y가 같으면 true, 다르면 false 반환</li><li><code>x != y</code> : x와 y가 다르면 true, 같으면 false 반환</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arithmetic</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> y = <span class="number">20</span>;</span><br><span class="line">      <span class="keyword">int</span> z = <span class="number">20</span>;</span><br><span class="line">     </span><br><span class="line">      System.out.println(<span class="string">&quot;x : &quot;</span>+x);</span><br><span class="line">      System.out.println(<span class="string">&quot;y : &quot;</span>+y);</span><br><span class="line">      System.out.println(<span class="string">&quot;z : &quot;</span>+z);</span><br><span class="line">      System.out.println(<span class="string">&quot;x&gt;y : &quot;</span>+(x&gt;y));</span><br><span class="line">      System.out.println(<span class="string">&quot;x&lt;y : &quot;</span>+(x&lt;y));</span><br><span class="line">      System.out.println(<span class="string">&quot;x&gt;=y : &quot;</span>+(x&gt;=y));</span><br><span class="line">      System.out.println(<span class="string">&quot;x&lt;=y : &quot;</span>+(x&lt;=y));</span><br><span class="line">      System.out.println(<span class="string">&quot;y==z : &quot;</span>+(y==z));</span><br><span class="line">      System.out.println(<span class="string">&quot;y!=z : &quot;</span>+(y!=z));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x : 10</span><br><span class="line">y : 20</span><br><span class="line">z : 20</span><br><span class="line">x&gt;y : false</span><br><span class="line">x&lt;y : true</span><br><span class="line">x&gt;&#x3D;y : false</span><br><span class="line">x&lt;&#x3D;y : true</span><br><span class="line">y&#x3D;&#x3D;z : true</span><br><span class="line">y!&#x3D;z : false</span><br></pre></td></tr></table></figure><p>여기서 하나 짚고넘어가야할 점이 있다. 비교연산자(<code>==</code>)를 이용하여 문자열 비교가 가능하지만, <code>new</code> 키워드로 생성자를 이용하여  <code>String</code> 객체를 생성한 경우라면, 원했던 비교가 이뤄지지 않을수 있다. 글이 길어져서 아래 링크로 대체한다.</p><ul><li><a href="https://youngjinmo.github.io/2021/01/two-ways-to-declare-string-variable/">DevAndy - String 변수를 선언하는 2가지 방식</a></li></ul><br><h1 id="논리-연산자"><a href="#논리-연산자" class="headerlink" title="논리 연산자"></a><a name="logical"></a>논리 연산자</h1><ul><li><code>&amp;&amp;</code> : 좌항 우항 모두 true일때만 true를 반환, 그렇지 않으면 false 반환.</li><li><code>||</code> : 좌항 우항 중 하나의 항이라도 true이면 true를 반환, 둘다 false 일때만 false를 반환.</li><li><code>!</code> : true면 false, false면 true를 반환.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arithmetic</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">boolean</span> ex01 = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">boolean</span> ex02 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;ex01 &amp;&amp; ex02 : &quot;</span>+(ex01&amp;&amp;ex02));</span><br><span class="line">      System.out.println(<span class="string">&quot;ex01 || ex02 : &quot;</span>+(ex01||ex02));</span><br><span class="line">      System.out.println(<span class="string">&quot;!ex02 : &quot;</span>+(!ex02));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ex01 &amp;&amp; ex02 : false</span><br><span class="line">ex01 || ex02 : true</span><br><span class="line">!ex02 : true</span><br></pre></td></tr></table></figure><br><h1 id="instance-of"><a href="#instance-of" class="headerlink" title="instance of"></a><a name="instanceof"></a>instance of</h1><p><code>instance of</code>는 런타임시에 객체의 타입을 검사하는 연산자이다.<br>아래의 예제코드를 확인해보자.</p><script src="https://gist.github.com/youngjinmo/15320152f54107007b03726162d34b06.js"></script><p><code>StudyHalle03</code> 클래스의 <code>main()</code>을 실행하면 다음과 같은 결과를 출력한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">true</span><br></pre></td></tr></table></figure><p>첫번째 출력문은 <code>Arithmetic</code> 클래스의 인스턴스 <code>arithmetic</code>의 객체 타입이 <code>Arithmetic</code>인지를 <code>instanceof</code> 연산자를 통해 검사한 결과이다. 당연히 <code>true</code>를 반환한다.</p><p>두번째 출력문은 <code>ex01</code> 의 인스턴스 변수 <code>num</code>의 객체 타입이 <code>Integer</code>인지 검사했다. <code>Example01.java</code>를 보면 당연히 <code>true</code>인걸 알 수 있다.</p><p>네번째 출력문에서는 <code>ex01.num</code>은 <code>Integer</code>이지만, <code>Integer</code>의 상위 객체가 <code>Object</code>이므로 이역시도 <code>true</code>를 반환한다.</p><p>다섯번째 출력문에서는 인스턴스 <code>ex02</code> 의 타입이 <code>Example01</code> 타입인지 검사했다. <code>ex02</code> 인스턴스의 객체 타입은 <code>Example02</code>이지만, <code>Example02</code> 클래스는 <code>Example01</code> 클래스를 상속받으므로 인스턴스 <code>ex02</code>의 객체 타입은 <code>Example01</code>이면서 동시에 <code>Example02</code> 이기도하다. 이 역시 <code>true</code>를 반환한다.</p><br><h1 id="assignment-operator"><a href="#assignment-operator" class="headerlink" title="assignment(=) operator"></a><a name="assignment"></a>assignment(=) operator</h1><ul><li><code>=</code> : 좌항에 변수가 오면 우항엔 리터럴, 좌항에 인스턴스가 오면 우항엔 객체가 오는 대입 연산자.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">Example ex = <span class="keyword">new</span> Example();</span><br></pre></td></tr></table></figure><ul><li><code>+=</code> : 좌항의 변수에 우항의 리터럴을 <code>+</code> 한후, 다시 좌항의 변수에 대입하는 연산자</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">num += <span class="number">20</span>;</span><br><span class="line">System.out.println(num);  <span class="comment">// 30</span></span><br></pre></td></tr></table></figure><ul><li><code>-=</code> : 좌항의 변수에 우항의 리터럴을 <code>-</code> 한후, 다시 좌항의 변수에 대입하는 연산자</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">num -= <span class="number">20</span>;</span><br><span class="line">System.out.println(num);  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><ul><li><code>*=</code> : 좌항의 변수에 우항의 리터럴을 <code>*</code> 한후, 다시 좌항의 변수에 대입하는 연산자</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">num *= <span class="number">3</span>;</span><br><span class="line">System.out.println(num);  <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><ul><li><code>/=</code> : 좌항의 변수에 우항의 리터럴을 <code>/</code> 한후, 다시 좌항의 변수에 대입하는 연산자</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">15</span>;</span><br><span class="line">num /= <span class="number">3</span>;</span><br><span class="line">System.out.println(num);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><ul><li><code>%=</code>: 좌항의 변수에 우항의 리터럴을 <code>%</code> 연산 후, 다시 좌항의 변수에 나머지 값을 대입하는 연산자</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">num %= <span class="number">6</span>;</span><br><span class="line">System.out.println(num);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><br><h1 id="3항-연산자"><a href="#3항-연산자" class="headerlink" title="3항 연산자"></a><a name="ternary"></a>3항 연산자</h1><p>변수를 선언 또는 리터럴을 대입할때 조건 분기처리할 수 있는 연산자이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="keyword">var</span> = (condition) ? (<span class="keyword">true</span>) : (<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><code>?</code> 을 기준으로 좌항에 조건식이 들어가며, 우항은 다시 <code>:</code>을 기준으로 나눈다. 조건식의 결과에 따라 <code>true</code>이면, <code>:</code> 의 좌항, <code>false</code>이면, <code>:</code> 우항으로 대입된다.</p><p>아래 예제 코드는 <code>Date</code> 클래스를 통해 불러온 현재 시간을 통해 <code>String</code>형 변수에 넣는 값을 분기처리하여 대입하는 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle03</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Date date = <span class="keyword">new</span> Date();</span><br><span class="line">      SimpleDateFormat time = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH시 mm분&quot;</span>);</span><br><span class="line">      SimpleDateFormat hour = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;HH&quot;</span>);</span><br><span class="line">      <span class="keyword">int</span> getHour = Integer.parseInt(hour.format(date));</span><br><span class="line"></span><br><span class="line">      String 오전일까_오후일까 = (getHour&gt;=<span class="number">12</span>) ? <span class="string">&quot;오후&quot;</span> : <span class="string">&quot;오후&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;현재 시각 : &quot;</span>+time.format(date));</span><br><span class="line">      System.out.println(오전일까_오후일까);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="연산자-우선-순위"><a href="#연산자-우선-순위" class="headerlink" title="연산자 우선 순위"></a><a name="priority"></a>연산자 우선 순위</h1><table><thead><tr><th>우선순위</th><th>연산자</th></tr></thead><tbody><tr><td>1</td><td>++, –, ~, !  (증감/부정 연산자)</td></tr><tr><td>2</td><td>*, /, %</td></tr><tr><td>3</td><td>+, -</td></tr><tr><td>4</td><td>&lt;&lt;, &gt;&gt;, &gt;&gt;&gt;  (비트 단위 시프트 연산자)</td></tr><tr><td>5</td><td>&lt;, &lt;=, &gt;, &gt;=</td></tr><tr><td>6</td><td>==, !=</td></tr><tr><td>7</td><td>&amp;  (비트 단위 논리 연산자)</td></tr><tr><td>8</td><td>^</td></tr><tr><td>9</td><td>|</td></tr><tr><td>10</td><td>&amp;&amp;</td></tr><tr><td>11</td><td>||</td></tr><tr><td>12</td><td>? :  (삼항 연산자)</td></tr><tr><td>13</td><td>==, +=, -=, *=, /=, %=, &lt;&lt;=, &gt;&gt;=, &amp;=, ^=, ~=  (대입 연산자)</td></tr></tbody></table><p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001">남궁성 - Java의 정석</a></p><br><h1 id="화살표-gt-연산자"><a href="#화살표-gt-연산자" class="headerlink" title="화살표(-&gt;) 연산자"></a><a name="arrow"></a>화살표(-&gt;) 연산자</h1><p>자바에서 화살표 연산자(<code>-&gt;</code>)는 람다식(Lambda Expression)을 의미한다. 람다는 JDK 1.8부터 도입되었는데, 자바라는 언어를 객체지향 언어인 동시에 함수형 언어로서도 동작하게 해준 개념이다.</p><p>람다는 메서드를 하나의 식으로 표현하는 표현식이다. 메서드이면서 이름도 없고, 반환값도 없다. 클래스에 종속되지도 않는다. 이상의 설명은 아래 포스팅으로 대체하고, 이 포스팅에선 사용법만 간단히 설명하겠다.<br><em><a href="https://youngjinmo.github.io/2020/06/java8-lambda-functional-interface/">DevAndy - [Java8] 람다와 함수형 인터페이스</a></em></p><p>람다식을 알아보기 위해 예제코드를 통해 들여다보자.</p><p>람다에선 타입을 명시하지 않아도 되는데, 컴파일러가 타입 추론이 가능케 하기 위해서는 <strong><u>함수형 인터페이스</u></strong> 를 사용해야 한다. 인터페이스는 반드시 메서드가 하나만 작성되어 있어야 하며, 인터페이스에 함수형 인터페이스임을 명시하는 <code>@FuntionalInterface</code>도 필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Question</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxNum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Answer</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">(Question param)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = param.maxNum(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;max num is &quot;</span>+num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle03</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Answer answer = <span class="keyword">new</span> Answer();</span><br><span class="line">      answer.calculate(<span class="keyword">new</span> Question() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxNum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (a&gt;b)?a:b;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드에서 프로그램 메인 메서드를 람다식으로 바꾸면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle03</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Answer answer = <span class="keyword">new</span> Answer();</span><br><span class="line">      answer.calculate((a,b)-&gt;&#123;</span><br><span class="line">         <span class="keyword">return</span> (a&gt;b)?a:b;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>변경사항을 확인해보자.</p><p><img src="https://user-images.githubusercontent.com/33862991/104614825-f2653180-56cb-11eb-8b37-8228647d5c4d.png"></p><p><code>maxNum()</code> 의 메서드명과 파라미터의 데이터 타입을 삭제했다. 함수형 인터페이스이기 때문에 메서드가 하나만 존재하여 컴파일러가 타입 추론이 가능하기 때문에 데이터 타입을 삭제했다.</p><p>메서드명 역시 함수형 인터페이스에선 메서드가 하나만 존재하기 때문에 굳이 이름을 명시하지 않아도 어떤 메서드를 사용하는지 컴파일러가 추론할 수 있다.</p><p>이처럼 함수형 인터페이스를 사용하여 메서드를 보다 간단하게 작성한걸 람다식이라고 한다.</p><p>출처</p><ul><li><a href="https://coding-factory.tistory.com/265">코딩팩토리 - [Java] 람다식(Lambda Expressions) -&gt; 사용법 &amp; 예제</a></li><li><a href="https://youngjinmo.github.io/2020/06/java8-lambda-functional-interface/">DevAndy - [Java8] 람다와 함수형 인터페이스</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lambda </tag>
            
            <tag> whiteship </tag>
            
            <tag> operator </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live Study 2주차 - 자바 데이터 타입, 변수 그리고 배열</title>
      <link href="2021/01/livestudy-week-02/"/>
      <url>2021/01/livestudy-week-02/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/peEXNN-oob4/maxresdefault.jpg"></p><ul><li><a href="#primitive">기본형(primitive) 타입 종류와 값의 범위, 기본 값</a></li><li><a href="#reference">기본형(primitive) 타입과 참조형(reference) 타입</a></li><li><a href="#literal">리터럴(literal)</a></li><li><a href="#declaration-variable">변수 선언 및 초기화하는 방법</a></li><li><a href="#scope">변수의 스코프와 라이프 타임</a><ul><li><a href="#instance-var">인스턴스 변수</a></li><li><a href="#class-var">클래스 변수</a></li><li><a href="#local-var">로컬 변수</a></li></ul></li><li><a href="#casting">타입 변환, 캐스팅 그리고 타입 프로모션</a></li><li><a href="#array">1차, 2차 배열 선언하기</a></li><li><a href="#var">타입 추론, var</a></li></ul><hr><h1 id="기본형-primitive-타입-종류와-값의-범위-기본값"><a href="#기본형-primitive-타입-종류와-값의-범위-기본값" class="headerlink" title="기본형(primitive) 타입 종류와 값의 범위, 기본값"></a><a name="primitive"></a>기본형(primitive) 타입 종류와 값의 범위, 기본값</h1><p>기본형 타입을 일반적으로 자료형이라고 표현하는데, 자료형을 알기 전 데이터 단위부터 정리하자.</p><p><img src="https://user-images.githubusercontent.com/33862991/103752066-8ee45f80-504c-11eb-9531-a574af6e2312.png"></p><p>데이터의 가장 작은 단위는 <strong>비트(bit, binary digit)</strong> 이다. 비트는 0과 1만을 표현한다. <strong>비트가 8개면 바이트(1byte = 8 bits)</strong> 가 되며, 표현할 수 있는 수는 2<sup>8</sup>이 된다.</p><p>비트와 바이트외에도 워드(word)라는 단위가 존재한다. 워드는 <strong>CPU가 한 번에 처리하는 데이터의 크기</strong> 를 의미한다고 한다. 워드는 CPU에 따라 단위가 달라지는 특성이 있는데, 32비트 CPU에서는 1워드는 4 바이트(32 bits)이고, 64비트 CPU에서 1워드는 8 바이트(64 bits)가 된다.</p><p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001&partner=googlek&BSCPN=ORM&BSPRG=ADWORDS&BSCCN1=89221&utm_source=ADWORDS&utm_medium=cpc&utm_term=JAVA%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD&gclid=CjwKCAiAudD_BRBXEiwAudakX6aXPXga64NqU9DBDJpL_GmPtN6M49zG5t4-FkiWselYCTZblwM1hRoCOFIQAvD_BwE">남궁성 - Java의 정석</a></p><p><a name="primitive-table"></a></p><style>  #data-size tr th {    width: 10%;     text-align: center;    border: 2px solid black;  }  #data-size tr td {    text-align: center;    border: 1px solid black;  }  .data-desc {      word-break: keep-all;  }</style><table id="data-size">  <tr>    <th style="width: 10%;">분류</th>    <th style="width: 10%;">타입</th>    <th style="width: 15%;">크기</th>    <th style="width: 20%;">값 범위</th>    <th style="width: 45%;">설명</th>  </tr>  <tr>    <td>논리형</td>    <td>boolean</td>    <td>1 byte</td>    <td>false, true</td>    <td class="data-desc" style="text-align: left;">true, false만을 표현하기 때문에 자료형중 가장 작은 크기를 가진다.</td>  </tr>  <tr>    <td>문자형</td>    <td>char</td>    <td>2 bytes</td>    <td>'\u0000' ~ '\uffff'</td>    <td class="data-desc" style="text-align: left;">문자를 저장하는데 사용되며, 하나의 문자만 변수(variable)에 저장이 가능하다.<br>자바에서 유니코드를 사용하므로 하나의 문자는 2 byte(8 bits)가 된다.</td>  </tr>  <tr>    <td rowspan="4">정수형</td>    <td>byte</td>    <td>1 byte</td>    <td>-2<sup>7</sup> ~ 2<sup>7</sup>-1</td>    <td rowspan="4" class="data-desc" style="text-align: left;">정수를 저장하는데 사용되며 주로 int가 사용된다. 이진데이터를 다루기 위해 byte를 사용하며, C언와의 호환을 위해 short이 추가되었다.<br>int(4 bytes)를 기준으로 int보다 작은 short(2 bytes), int보다 긴 long(64 bytes)으로 기억하면 좋다.</td>  </tr>  <tr style="text-align: center;">    <td>short</td>    <td>2 bytes</td>    <td>-2<sup>15</sup> ~ 2<sup>15</sup>-1</td>  </tr>  <tr style="text-align: center;">    <td>int</td>    <td>4 bytes</td>    <td>-2<sup>31</sup> ~ 2<sup>31</sup>-1</td>  </tr>  <tr>    <td>long</td>    <td>8 bytes</td>    <td>-2<sup>63</sup> ~ 2<sup>63</sup>-1</td>  </tr>  <tr>    <td rowspan="2">실수형</td>    <td>float</td>    <td>4 bytes</td>    <td>1.4x10<sup>-45</sup>~3.4x10<sup>38</sup></td>    <td rowspan="2" class="data-desc" style="text-align: left;">실수를 저장하는데 사용되며, float(4 bytes)보다 2배의 크기(8 bytes)를 갖는 double을 실수형 자료형으로 주로 사용한다.</td>  </tr>  <tr>    <td>double</td>    <td>8 bytes</td>    <td>4.9x10<sup>-324</sup>~1.8x10<sup>308</sup></td>  </tr></table><p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001&partner=googlek&BSCPN=ORM&BSPRG=ADWORDS&BSCCN1=89221&utm_source=ADWORDS&utm_medium=cpc&utm_term=JAVA%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD&gclid=CjwKCAiAudD_BRBXEiwAudakX6aXPXga64NqU9DBDJpL_GmPtN6M49zG5t4-FkiWselYCTZblwM1hRoCOFIQAvD_BwE">남궁성 - Java의 정석</a></p><p>실제 기본형 타입의 크기를 인텔리제이 디버거를 통해 확인해보았다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103749340-bdf8d200-5048-11eb-97ec-7f749f284ab3.png"></p><h3 id="타입-메모리-크기를-알아야-하는-이유"><a href="#타입-메모리-크기를-알아야-하는-이유" class="headerlink" title="타입 메모리 크기를 알아야 하는 이유"></a>타입 메모리 크기를 알아야 하는 이유</h3><p>타입의 메모리 크기를 알아둬야 하는 이유가 있다. 자료형 크기와 맞지않는 <a href="#literal">리터럴</a>을 대입하려고 하면 아래와 같은 케이스가 발생할 수 있다.</p><ul><li><strong>언더플로우</strong><ul><li>자료형 크기보다 작은 리터럴을 표현하려고 할 때 발생. </li><li>에러는 아님.</li></ul></li><li><strong>오버플로우</strong><ul><li>자료형 크기보다 큰 리터럴을 대입하려고 할 때 발생</li><li><strong><u>컴파일 에러</u></strong> 발생</li></ul></li></ul><p>아래의 예제코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">2_147_483_644</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">2_147_483_646</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid1 = (num1+num2)/<span class="number">2</span>;</span><br><span class="line">    System.out.println(mid1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>두 정수의 평균값을 구하는 코드이다. 결과는 어떨까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-3</span><br></pre></td></tr></table></figure><p>예상한 평균값과 다른 값이 나왔다. 왜 그럴까?</p><p>int형으로 표현할 수 있는 최대 크기의 정수가 <code>2_147_483_646</code>인데, <code>num1</code>과 <code>num2</code>를 더하면서 이미 int형의 표현범위를 벗어났기 때문이다.</p><p>따라서 위의 코드를 원하는 결과로 출력하려면 아래처럼 하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid2 = num1+(num2-num1)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>두 수중 더 큰 수에서 작은 수를 빼서 나오는 만큼의 마진과 작은수를 더하면 int형의 표현범위 내에서 연산이 발생하므로 원하는 값이 출력된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveType</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num1 = <span class="number">2_147_483_644</span>;</span><br><span class="line">    <span class="keyword">int</span> num2 = <span class="number">2_147_483_646</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid1 = (num1+num2)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> mid2 = num1+(num2-num1)/<span class="number">2</span>;</span><br><span class="line">    System.out.println(mid1);</span><br><span class="line">    System.out.println(mid2);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-3</span><br><span class="line">2_147_484_645</span><br></pre></td></tr></table></figure><br><h1 id="기본형-primitive-타입과-참조형-reference-타입"><a href="#기본형-primitive-타입과-참조형-reference-타입" class="headerlink" title="기본형(primitive) 타입과 참조형(reference) 타입"></a><a name="reference"></a>기본형(primitive) 타입과 참조형(reference) 타입</h1><ul><li>기본형 타입 : 실제 <strong>값</strong> 을 가지는 타입</li><li>참조형 타입 : 실제 값을 갖는 <strong>주소</strong> 를 가리키는 타입</li></ul><p>기본형 타입은 위에서 정리를 했다. 기본적으로 논리형, 문자형, 정수형, 실수형 4가지로 분류되는 8가지 자료형을 기본형 타입이라 하며, 그외 이런 기본형 타입을 참조하는 타입을 참조형 타입이라 한다.</p><p>기본형 타입과 달리 참조형 타입은 클래스의 이름을 변수의 타입으로 사용하기 때문에 클래스가 곧 참조변수의 타입이 된다. 따라서 새로운 클래스를 생성한다는 것은 새로운 참조형을 추가한다고 볼 수 있다.</p><h2 id="참조형-타입-String에서의-값-변경"><a href="#참조형-타입-String에서의-값-변경" class="headerlink" title="참조형 타입 String에서의 값 변경"></a>참조형 타입 String에서의 값 변경</h2><p>문자열은 기본형타입이 아닌 참조형 타입이다. 따라서 String은 불가변한 객체라 할 수 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;Andy&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;DevAndy&quot;</span>;</span><br></pre></td></tr></table></figure><p>위의 코드에서 문자열 변수 <code>name</code>은 값이 변경한게 아니라 가리키는 주소가 변경되었을뿐이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="keyword">new</span> String(<span class="string">&quot;Andy&quot;</span>);</span><br></pre></td></tr></table></figure><p>본래 참조형 타입은 <code>new</code> 키워드로 생성해야 하나 String은 JVM의 Heap 영역에 존재하는 String Constant Pool 덕분에 문자열 변수는 <code>new</code> 키워드 없이도 객체를 선언할 수 있다.</p><p>또 <code>new</code> 키워드로 객체를 생성하면, Heap에 새로운 객체가 생성되는데, String 변수를 직접 선언하면, String Constant Pool에 있는 주소값을 공유하면서 참조하기 때문에 참조하려는 주소가 String Constant Pool에 존재할 경우 Heap에 새로 생성하지 않고 주소값을 공유하여 참조할 수 있다.</p><p>이 때문에 문자열 변수는 <code>new</code> 키워드없이 사용하는게 메모리 관리에 더 효율적이다. 아래 예제 코드를 보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String seoulAir = <span class="string">&quot;Clean air&quot;</span>;</span><br><span class="line">String tokyoAir = <span class="string">&quot;Clean air&quot;</span>;</span><br><span class="line">String chinaAir = <span class="keyword">new</span> String(<span class="string">&quot;Clean air&quot;</span>);</span><br></pre></td></tr></table></figure><p>위의 코드에서 3개의 변수는 모두 같은 문자열 리터럴을 할당받고 있지만, <code>seoulAir</code>와 <code>tokyoAir</code>은 서로 같은 주소를 참조하고, <code>china Air</code>는 다른 주소를 갖게 된다.</p><p>비교연산자를 통해 비교해보면 확인이 된다. 그리고 실제 주소값을 출력해보면 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBasic</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String seoulAir = <span class="string">&quot;Clean air&quot;</span>;</span><br><span class="line">      String tokyoAir = <span class="string">&quot;Clean air&quot;</span>;</span><br><span class="line">      String chinaAir = <span class="keyword">new</span> String(<span class="string">&quot;Clean air&quot;</span>);</span><br><span class="line"></span><br><span class="line">      System.out.println(seoulAir==tokyoAir);</span><br><span class="line">      System.out.println(seoulAir==chinaAir);</span><br><span class="line"></span><br><span class="line">      System.out.println(System.identityHashCode(seoulAir));</span><br><span class="line">      System.out.println(System.identityHashCode(tokyoAir));</span><br><span class="line">      System.out.println(System.identityHashCode(chinaAir));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">209813603</span><br><span class="line">209813603</span><br><span class="line">1057941451</span><br></pre></td></tr></table></figure><p><code>seoulAir</code>와 <code>tokyoAir</code>의 주소는 서로 같은 주소를 갖고있는걸 알 수 있다. 따라서 <mark>String은 참조형 타입이지만 <code>new</code> 키워드로 객체를 생성하는 대신 리터럴을 직접 대입하는것처럼 생성해야 메모리를 효율적으로 관리</mark>할 수 있을것으로 판단된다.</p><p><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https://blog.kakaocdn.net/dn/CZS5V/btqFPrKJ713/7k48Gu8Hr6mdNmGO9wtTMK/img.png" alt="출처 : Random Access Memories 블로그"></p><p>출처 :</p><ul><li> <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001&partner=googlek&BSCPN=ORM&BSPRG=ADWORDS&BSCCN1=89221&utm_source=ADWORDS&utm_medium=cpc&utm_term=JAVA%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD&gclid=CjwKCAiAudD_BRBXEiwAudakX6aXPXga64NqU9DBDJpL_GmPtN6M49zG5t4-FkiWselYCTZblwM1hRoCOFIQAvD_BwE">남궁성 - Java의 정석</a></li><li> <a href="https://starkying.tistory.com/entry/what-is-java-string-pool">Random Access Memories - String Constant Pool이란?</a></li></ul><br><h1 id="리터럴-literal"><a href="#리터럴-literal" class="headerlink" title="리터럴(literal)"></a><a name="literal"></a>리터럴(literal)</h1><p>값을 저장하는 타입으로 변수(variable)와 상수(constant)가 존재한다. <u>변수는 가변성을 지니지만, 상수는 변수와 달리 불가변하다는 특징이 존재한다.</u></p><p><img src="https://user-images.githubusercontent.com/33862991/103751067-10d38900-504b-11eb-91a7-2874da86a4d8.png"></p><p>위의 코드를 보면, <code>num1</code>은 값의 변경이 가능하지만, <code>final</code> 키워드가 붙어서 상수로 선언된 <code>NUM2</code>는 연산이 되지않아 인텔리제이에서 에러를 발생시키는걸 알 수 있다.</p><blockquote><p>참고로 상수는 final 키워드와 함께 상수명을 대문자로 작성한다는 특징이 있다. 소문자로 작성해도 컴파일에 문제는 없지만, 상수는 대문자로 표현하는것이 약속과 같다.</p></blockquote><p><img src="https://user-images.githubusercontent.com/33862991/104688706-9094de00-5744-11eb-959b-078618e1569c.png"></p><p>변수와 상수에 들어가는 값, 이 값을 <strong>리터럴</strong> 이라고 한다.</p><p>위의 코드에서 <code>num1</code> 은 변수로, <code>num2</code> 는 상수로 선언되었는데 여기에 대입된 각각의 값 <code>30</code>, <code>1991</code>이 리터럴에 해당한다.</p><p>리터럴에도 자료형에 따라 타입이 존재한다. </p><p><a name="primitive-table"></a></p><table>  <tr>    <th style="width: 10%;">종류</th>    <th style="width: 30%;">리터럴</th>    <th>접미사</th>  </tr>  <tr>    <td>논리형</td>    <td>false, true</td>    <td>없음</td>  </tr>  <tr>    <td>정수형</td>    <td>123, 0b0101, 0xFF, 100L</td>    <td><code>int</code>형 리터럴에는 접미사가 없지만,<br><code>Long</code>형 리터럴에는 접미사 <code>L</code>을 붙힌다.</td>  </tr>  <tr>    <td>실수형</td>    <td>3.14m 3.0e8, 1.4f</td>    <td><code>float</code>형의 리터럴에는 <code>f</code>,<br><code>double</code>형의 리터럴에는 <code>d</code>를 붙힌다.</td>  </tr>  <tr>    <td>문자형</td>    <td>'A', '1', '\n'</td>    <td>없음</td>  </tr>  <tr>    <td>문자열</td>    <td>"ABC", "123", "A"</td>    <td>없음</td>  </tr></table><p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001&partner=googlek&BSCPN=ORM&BSPRG=ADWORDS&BSCCN1=89221&utm_source=ADWORDS&utm_medium=cpc&utm_term=JAVA%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD&gclid=CjwKCAiAudD_BRBXEiwAudakX6aXPXga64NqU9DBDJpL_GmPtN6M49zG5t4-FkiWselYCTZblwM1hRoCOFIQAvD_BwE">남궁성 - Java의 정석</a></p><p>접미사는 정수형, 실수형 자료형에만 필요한걸 알 수 있다. 위의 테이블을 요약하면, 정수형 실수형만 리터럴에 접미사가 요구되며, 접미사가 없으면 <code>int</code>형으로 인식하며, 접미사가 있을경우 해당 접미사에 따라 리터럴의 타입으로 인식된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 정수형 리터럴</span></span><br><span class="line"><span class="keyword">short</span>  num1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>    num2 = <span class="number">50000</span>;</span><br><span class="line"><span class="keyword">long</span>   num3 = <span class="number">5000_000L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 실수형 리터럴</span></span><br><span class="line"><span class="keyword">double</span> num5 = <span class="number">3.14592d</span>;</span><br><span class="line"><span class="keyword">float</span>  num4 = <span class="number">3.14592F</span>;</span><br></pre></td></tr></table></figure><p>리터럴을 사용할 때 유의할 것들이 몇 가지가 있다.</p><p>리터럴과 변수의 자료형 <strong>타입이 일치하지 않으면</strong> 컴파일 에러가 발생한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> num = <span class="number">100_000</span>;   <span class="comment">// 리터럴의 byte의 표현 범위를 벗어나므로 컴파일시 에러를 유발한다.</span></span><br></pre></td></tr></table></figure><h3 id="문자형과-문자열의-차이"><a href="#문자형과-문자열의-차이" class="headerlink" title="문자형과 문자열의 차이"></a>문자형과 문자열의 차이</h3><p>문자형(<code>char</code>)과 문자열(<code>String</code>)은 리터럴을 감싸는 표기를 어떻게 하느냐에 따라도 인식이 달라질 수 있다. 참고로 문자형(<code>char</code>)은 기본형 타입(primitive)에 해당하는 타입이지만, <strong>문자열은 참조형 타입(<code>String.class</code>)</strong> 에 속한다. (위 <a href="#primitive-table">자료형 테이블</a> 참고)</p><table><thead><tr><th>리터럴 타입</th><th>기호</th></tr></thead><tbody><tr><td>문자형(char)</td><td><code>&#39;&#39;</code></td></tr><tr><td>문자열(Strnig)</td><td><code>&quot;&quot;</code></td></tr></tbody></table><p><img src="https://user-images.githubusercontent.com/33862991/103857155-446cec80-50f9-11eb-8a8e-bc4ad40a4b89.png"></p><p>인텔리제이에서 따옴표만 다르게해서 변수를 선언하고 대입해보았지만, 쌍따옴표로 리터럴을 감싸니 리터럴을 문자형이 아닌 문자열로 인식을 하는걸 알 수 있다.</p><p>문자형(<code>char</code>)과 문자열(<code>String</code>)의 또 다른 차이중 하나는 <code>null</code>을 대입할 수 있느냐 없느냐의 차이가 있다. 문자열 변수엔 <code>null</code>을 대입할 수 있지만, 문자형 변수엔 <code>null</code> 대입이 불가능하다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103858687-248af800-50fc-11eb-9849-8414dc2f20b3.png"></p><p>뿐만 아니라 <strong>빈 값</strong> 을 대입하는 방법도 마찬가지다. 문자열(<code>String</code>)은 빈 값이 대입할 수 있지만, 문자형(<code>char</code>)은 빈 값을 대입할 수 없다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103858580-f7d6e080-50fb-11eb-8258-642ae0ef9dcc.png"></p><br><h1 id="변수-선언-및-초기화하는-방법"><a href="#변수-선언-및-초기화하는-방법" class="headerlink" title="변수 선언 및 초기화하는 방법"></a><a name="declaration-variable"></a>변수 선언 및 초기화하는 방법</h1><p>자바에서 변수를 선언하는 방법은 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>자료형을 먼저쓰고, 변수명을 쓰면 변수를 선언할 수 있다. 그리고 변수 선언과 동시에 값을 대입하면, 이 값이 변수의 초기값이 된다.</p><p>초기값의 경우 <strong>기본값(default value)</strong> 이라는게 존재한다. 변수 선언할 때 개발자가 따로 대입하지 않아도 변수로 선언되는 동시에 갖는 기본값이다. </p><table><thead><tr><th>자료형</th><th>기본값</th></tr></thead><tbody><tr><td>boolean</td><td>false</td></tr><tr><td>char</td><td>‘\u0000’</td></tr><tr><td>byte, short, int</td><td>0</td></tr><tr><td>long</td><td>0</td></tr><tr><td>float</td><td>0.0f</td></tr><tr><td>double</td><td>0.0d or 0.0</td></tr></tbody></table><p>기본형 타입(primive)외에 <strong>참조형 타입(reference)은 객체이므로 <code>null</code>을 기본값</strong> 으로 갖는다.</p><p>출처 : <a href="https://doublesprogramming.tistory.com/73">더블에스_devlog - 자바 변수의 초기화</a></p><p>기본값이 이렇게 있음에도 초기화를 해야하는 이유가 뭘까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHale</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  String b;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">boolean</span> d;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    String b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">boolean</span> d;</span><br><span class="line"></span><br><span class="line">    StudyHale study = <span class="keyword">new</span> StudyHale();</span><br><span class="line">    System.out.println(study.a);   <span class="comment">// 0</span></span><br><span class="line">    System.out.println(study.b);   <span class="comment">// null</span></span><br><span class="line">    System.out.println(study.c);   <span class="comment">// []</span></span><br><span class="line">    System.out.println(study.d);   <span class="comment">// false</span></span><br><span class="line">    System.out.println(<span class="string">&quot;======&quot;</span>);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    System.out.println(c);</span><br><span class="line">    System.out.println(d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 <code>StudyHale</code> 클래스는 타입이 각각 다른 4개의 변수를 각각 클래스와 메인 메서드안에 초기화하지 않고 선언한 클래스이다. 클래스에 선언한 변수는 인스턴스 변수, 메ㅓ드 내부에 선언한 변수는 로컬 변수라한다.<br>초기화하지 않고 선언했을때, 각각 기본값이 어떻게 적용하기 위해 컴파일하면 어떤 일이 발생할까?</p><p><img src="https://user-images.githubusercontent.com/33862991/103863053-7c792d00-5103-11eb-961c-79f3f0790666.png"></p><p>인스턴스 변수들까지는 문제가 없고, 로컬 변수들이 문제였다. 인텔리제이 경고창을 통해 변수들이 초기화해야한다고 경고를 하고 있다.</p><p>같은 이름의 변수임에도 불구하고, <strong>스코프(scope)</strong> 에 따라 기본값 적용여부가 달라자는 것이다. 변수의 스코프가 클래스 일 때에만 기본값이 대입되고, <strong><u>메서드 안에서 선언된 변수의 경우 기본값이 적용되지 않기 때문에 반드시 초기화</u></strong> 해주어야 한다.</p><br><h1 id="변수의-스코프와-라이프-타임"><a href="#변수의-스코프와-라이프-타임" class="headerlink" title="변수의 스코프와 라이프 타임"></a><a name="scope"></a>변수의 스코프와 라이프 타임</h1><p>위에서 스코프라는 단어를 사용했는데, <strong>스코프란, 변수를 사용가능한 범위</strong> 를 표현한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHale</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">int</span> num1 = <span class="number">20</span>;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">12</span>;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">      printNum();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">13</span>;</span><br><span class="line">      System.out.println(num);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 클래스에서 변수 <code>num</code>은 같은 이름으로 3번 선언되었는데, 모두 선언된 위치가 다르다. 하나는 클래스 내부이면서 메서드 외부에, 다른 하나는 <code>main()</code>에, 나머지 하나는 <code>printNum()</code>에 선언되었다.</p><p>메인 메서드를 실행하면, 다음과 같은 결과를 출력한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">13</span><br></pre></td></tr></table></figure><p><code>main()</code> 에서 출력한 <code>num</code>은 <code>main()</code> 내부에서 선언한 변수를 출력했고,  <code>printNum()</code>을 통해 출력된 <code>num</code> 은 <code>printNum()</code> 내부에서 선언된 <code>num</code>을 출력한 것이다.</p><p>변수를 사용할땐 이처럼 이름이 같더라도 스코프에 따라 구별됨을 알 수 있다.</p><p>스코프에 따른 변수는 크게 3가지로 분류된다.</p><h2 id="인스턴스-변수-Instance-Variable"><a href="#인스턴스-변수-Instance-Variable" class="headerlink" title="인스턴스 변수(Instance Variable)"></a><a name="instance-var"></a>인스턴스 변수(Instance Variable)</h2><p><img src="https://user-images.githubusercontent.com/33862991/104193435-72d52980-5463-11eb-850b-64ea3887fd81.png"></p><p><strong>정의</strong></p><p>인스턴스 변수는 <u>클래스 내부에 선언되었으면서 메서드 외부에 선언된 변수</u>를 정의한다.</p><p><strong>스코프</strong></p><p><u><code>static</code> 메서드를 제외한</u> 클래스 어디서나 접근 가능하다.</p><p><strong>라이프 타임</strong></p><p>라이프 타임이란, <strong><u>객체가 생성되어 GC에 의해 제거될때까지</u></strong> 를 의미한다. </p><p>인스턴스 변수의 라이프 타임은 인스턴스 객체가 생성되는 시점부터 객체의 사용이 다해서 GC에 의해 제거될 때까지이다.</p><br><h2 id="클래스-변수-Class-Variable"><a href="#클래스-변수-Class-Variable" class="headerlink" title="클래스 변수 (Class Variable)"></a><a name="class-var"></a>클래스 변수 (Class Variable)</h2><p><img src="https://user-images.githubusercontent.com/33862991/104193424-7072cf80-5463-11eb-9755-82c726b45868.png"></p><p><strong>정의</strong></p><p>인스턴스 변수처럼 <u>클래스 내부와 메서드 외부에 선언된 변수</u>이지만, <code>static</code> 키워드가 붙는다는 점에서 다르다. </p><p><strong>스코프</strong></p><p>클래스 어디서나 접근가능하다. (<code>static</code> 메서드에서 접근불가능한 인스턴스 변수보다 스코프가 넓다.)</p><p><strong>라이프 타임</strong></p><p>클래스가 호출되는 시점에 메모리에 할당된다. 클래스가 호출되는 시점이란, 말그대로 해당 클래스가 호출되는 시점에 클래스 변수가 메모리에 올라간다. </p><p>클래스 변수의 생성시점과 인스턴스 변수와의 차이에 대해 다음 포스팅(<a href="https://youngjinmo.github.io/2021/01/diff-static-variable-instance-variable/">클래스변수와 인스턴스 변수 차이(생성시점)</a>)에서 정리해두었다.</p><p>출처 </p><ul><li><a href="https://youngjinmo.github.io/2021/01/livestudy-week-01/#method-area">DevAndy - JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가</a></li><li><a href="https://youngjinmo.github.io/2021/01/diff-static-variable-instance-variable/">클래스변수와 인스턴스 변수 차이(생성시점)</a></li></ul><br><h2 id="로컬-변수-Local-Variable"><a href="#로컬-변수-Local-Variable" class="headerlink" title="로컬 변수(Local Variable)"></a><a name="local-var"></a>로컬 변수(Local Variable)</h2><p><img src="https://user-images.githubusercontent.com/33862991/104193438-749eed00-5463-11eb-8335-57483b4a7cae.png"></p><p><strong>정의</strong></p><p>메서드 내에서 선언된 변수이다.</p><p><strong>스코프</strong></p><p>메서드 내부에서만 사용할 수 있다.</p><p><strong>라이프 타임</strong></p><p>로컬 변수가 선언된 메서드가 호출될 때 메모리에 할당되어 메서드가 사용을 마치면, GC에 의해 제거된다.</p><p>출처</p><ul><li><a href="https://league-cat.tistory.com/411">리그캣 - [Java] 변수의 스코프와 라이프타임</a></li><li><a href="https://itmining.tistory.com/20">IT마이닝 - [Java] 자바의 변수(클래스 변수, 인스턴스 변수, 지역 변수)</a></li></ul><br><h1 id="타입-변환-캐스팅-그리고-타입-프로모션"><a href="#타입-변환-캐스팅-그리고-타입-프로모션" class="headerlink" title="타입 변환, 캐스팅 그리고 타입 프로모션"></a><a name="casting"></a>타입 변환, 캐스팅 그리고 타입 프로모션</h1><p>타입 변환과 타입 캐스팅을 동일한 개념으로 오해하고 있었는데, 이번 라이브 스터디를 하며 제대로 알게 된 개념들이다.</p><h2 id="타입-변환"><a href="#타입-변환" class="headerlink" title="타입 변환"></a>타입 변환</h2><p>타입 변환이란, 리터럴의 데이터 타입을 다른 데이터 타입으로 변환하는걸 의미한다. 예를들면 다음과 같은 코드가 타입 변환에 해당한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = ch;   <span class="comment">// 65로 리터럴이 변환돰</span></span><br></pre></td></tr></table></figure><p><code>char</code>형 변수 <code>ch</code>를 <code>int</code> 형으로 타입을 변환했다. char형을 int형으로 형변환하면 <a href="https://ko.wikipedia.org/wiki/ASCII">아스키코드</a>값으로 변환된다.</p><p>여기까지는 뭐 단어의 의미만으로 다 알수있는 내용이다. 이 타입 변환은 자료형의 표현범위에 따라, 변수의 메모리 크기에 따라 타입 캐스팅과 타입 프로모션으로 구분될 수 있다.</p><ul><li><strong>타입 프로모션</strong><ul><li>크기가 더 큰 자료형으로 리터럴을 대입할 때 <mark>자동으로 타입이 변환</mark>되는 것.</li></ul></li><li><strong>타입 캐스팅</strong><ul><li>크기가 더 작은 자료형으로 리터럴을 명시하여 <mark>강제로 타입 변환</mark> 하는 것.</li></ul></li></ul><p>출처 : <a href="https://m.blog.naver.com/PostView.nhn?blogId=haejoon90&logNo=220781157092&proxyReferer=https://www.google.com/">이해준 - 자바에서 프로모션과 캐스팅이란?</a></p><h2 id="타입-프로모션"><a href="#타입-프로모션" class="headerlink" title="타입 프로모션"></a>타입 프로모션</h2><p><img src="https://user-images.githubusercontent.com/33862991/104193443-7668b080-5463-11eb-8ed2-46a3e88d417b.png"></p><p>리터럴을 더 메모리 크기가 큰 자료형에 대입하는 경우를 프로모션이라고 한다. 개발자가 명시적으로 타입 변환하지 않아도, 자동으로 타입이 변환된다.</p><p>그러나 인텔리 제이에서 보는것처럼 해당 자료형이 필요보다 크다는 alert를 띄워준다. 메모리 누수를 걱정하는 alert이다.</p><br><h2 id="타입-캐스팅"><a href="#타입-캐스팅" class="headerlink" title="타입 캐스팅"></a>타입 캐스팅</h2><p>위에서 정리했던 <a href="#primitive-table">자료형 테이블</a>을 보면, <code>char</code>형이 16 bits, <code>int</code>형이 32 bits의 표현 범위를 갖기 때문에 <code>char</code>형 리터럴은 개발자가 명시하지 않아도 <code>int</code>형으로 프로모션될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">int</span> num = ch;</span><br></pre></td></tr></table></figure><p>그럼 반대로 하면 어떨까?</p><p><img src="https://user-images.githubusercontent.com/33862991/104198975-3bb64680-546a-11eb-9270-cdeafeb50ad2.png"></p><p>자동 타입 변환이 이뤄지지 않는다.</p><p>원래의 자료형보다 더 표현 범위가 작은 자료형으로 타입 변환을 시도하기 때문에 자동 타입 변환이 되지 않는 것이다.</p><p>이 때 개발자가 변환할 타입을 리터럴에 명시함으로써 강제로 타입을 변환하는 것을 타입 캐스팅이라고 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">65</span>;</span><br><span class="line"><span class="keyword">char</span> ch = (<span class="keyword">char</span>)num;</span><br><span class="line">System.out.println(ch);   <span class="comment">// A</span></span><br></pre></td></tr></table></figure><p>65의 아스키 코드값 A로 값이 타입 캐스팅된 것을 확인할 수 있다.</p><br><h1 id="1차-2차-배열-선언하기"><a href="#1차-2차-배열-선언하기" class="headerlink" title="1차, 2차 배열 선언하기"></a><a name="array"></a>1차, 2차 배열 선언하기</h1><p>배열은 복수의 리터럴을 저장할 수 있는 객체이다. 배열의 리터럴로 기본 자료형이 들어오든, 참조형 자료형이 들어오든 배열 자체가 객체이다. 따라서 <code>new</code> 키워드를 사용하여 배열을 선언한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = <span class="keyword">new</span> String[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>배열을 선언시 크기를 지정해야 하는 특징때문에 배열의 크기를 변경할 수 없다는 특징이 있다.</p><p>1차원 배열은 다음과 같이 선언한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHale</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">      <span class="keyword">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>배열은 크기가 고정되기 때문에 <code>new</code> 키워드로 크기만 지정해서 바로 선언할 수 있다. </p><p>또는 배열 안에 들어갈 요소(element)를 <code>&#123;&#125;</code>에 담아서 선언할 수 있다. 이 때 요소의 갯수가 곧 배열의 크기에 해당해서 이 크기로 먼저 메모리에 배열의 크기만큼 할당하고, 요소를 하나씩 할당한다.</p><p>2차원 배열 선언은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHale</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">int</span>[][] arr2 = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1차원 배열과 마찬가지로 두가지 방법으로 선언할 수 있다. </p><p>1차원 배열과 다른 특징이 있다면, 1차원 배열은 <code>.length</code>를 통해 배열의 길이를 반환받을 수 있지만, 2차원 배열부터는 행과 열의 길이를 각각 구해야 한다. </p><p><code>.length</code>는 배열의 행 길이만 반환해준다. 열의 길이를 반환하기 위해서는 for문을 사용하여 행마다 열의 길이를 반환해주어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">   System.out.println(arr[i].length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>또 1차원 배열과 다른 점은 1차원 배열은 <code>Arrays.toString()</code>으로 배열을 문자열로 출력할 수 있었다면, 2차원 배열은 for문을 결합해서 출력해야 한다는 특징이있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">   System.out.println(Arrays.toString(arr[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;==========&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">      System.out.print(arr[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0, 0]</span><br><span class="line">[0, 0]</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">0 0  </span><br><span class="line">0 0 </span><br></pre></td></tr></table></figure><p>스터디 과제를 준비하며 다른 사람이 제출한 과제를 통해 알게된 것이 있다. 배열이 메모리에 어떻게 할당하는지를 보여주는 그림이다.</p><p>1차원 배열은 다음과 같이 할당된다.</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F674c2d06-6323-4894-a5e1-03bfa25991bf%2FUntitled.png?table=block&id=665336d3-a109-4d7e-9a54-2c4fb0427cdb&width=1340&userId=&cache=v2" alt="1차원 배열의 메모리 할당"></p><p>메모리 영역의 스택에 배열이 호출되면, 배열의 각 요소는 배열의 크기만큼 할당된 Heap 영역의 주소를 가리킨다.</p><p>2차원 배열은 다음과 같이 할당된다.</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fac44fd4f-af77-4127-a878-26fd5becb061%2FUntitled.png?table=block&id=5fccd8f4-0b93-4154-8767-c44be93c4821&width=1340&userId=&cache=v2" alt="2차원 배열의 메모리 할당"></p><p>2차원 배열은 배열의 배열로 선언하기 때문이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>위의 2차원 배열 <code>arr</code>은 아래와 같이 선언할수도 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[ ][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>2차원 배열부터는 배열의 배열이기 때문이다. </p><p>각각의 행에 <code>new</code> 키워드를 사용하여 배열을 선언할 경우 행마다 다른 길이의 열을 갖는 배열을 선언할수 있는데, 이를 <strong>가변 배열</strong> 이라 한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[ ][] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>][];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">      System.out.print(arr[i][j]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0</span><br><span class="line">0 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>출처 - <a href="https://www.notion.so/2-38b5d67c7f5a48238529bb8f1617ea0d">damho1104님 Notion</a></p><br><h1 id="타입-추론-var"><a href="#타입-추론-var" class="headerlink" title="타입 추론, var"></a><a name="var"></a>타입 추론, var</h1><p>타입 추론이란, 말그대로 변수의 타입을 추론하는 것인데 개발자가 직접 추론하는게 아니라 바이트코드로 컴파일 하는 단계에서 컴파일러가 타입을 추론하는걸 의미한다.</p><p>아래의 예제 코드를 보자.</p><script src="https://gist.github.com/youngjinmo/78581da7fe7027012de7e9d23934428c.js"></script><p>객체의 클래스 이름을 가져오는 함수로 <code>getClass().getSimpleName()</code> 을 사용했다.</p><p><code>StudyHaleEx01</code> 클래스의 메인 메서드를 실행하면 다음과 같이 출력된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String</span><br><span class="line">int[]</span><br><span class="line">StudyHale02</span><br><span class="line">String</span><br></pre></td></tr></table></figure><p>콘솔에 출력한 변수는 모두 <code>var</code> 로 타입추론한 변수들이다. 즉 개발자가 컴파일러에게 객체의 타입을 명시하지 않았음에도 컴파일러가 타입을 추론한걸 확인할 수 있다.</p><p>이 타입 추론은 기본 자료형에는 적용되지 않는다. 오직 객체의 타입 추론에만 사용가능하다. 따라서 <code>int</code> 형 변수의 타입 추론은 안되지만, <code>Integer</code> 의 타입추론은 가능하다.</p><p><img src="https://user-images.githubusercontent.com/33862991/104276598-90000b80-54e8-11eb-921a-09ed878da7be.png"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> casting </tag>
            
            <tag> whiteship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot + MyBatis + Oracle(with Docker) CRUD 구현해보기</title>
      <link href="2021/01/springboot-mybatis-oracle2/"/>
      <url>2021/01/springboot-mybatis-oracle2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/97108403-a8922e00-1710-11eb-9e42-b093ed1857d8.png"></p><p><a href="https://youngjinmo.github.io/2020/10/springboot-mybatis-oracle/">지난 포스팅</a>에서 스프링부트로 만든 API로 오라클RDBMS에 데이터를 요청하는 간단한 실습을 구현해보았다. 당시 오라클 DB의 테이블을 단순 조회하는 것까지 해보았는데, 이번엔 간단한 CRUD를 구현한 API를 만들어보려고 한다.</p><p>마찬가지로 도커를 이용하여 오라클 DB(Oracle 11g)를 띄워두었고, 스프링부트로 웹서버를 개발하고, MyBatis를 이용하여 DB를 매핑하였다.</p><p>조회(Read)하는건 했으니 이번 포스팅에선 C(Create), U(update), D(delete)를 구현하면 될 것 같다.</p><p>2달만에 다시 하려고 하니 테이블을 다시 만들어야 하는 과정에서 필드 하나를 누락했다. 만약 첫번째 포스팅을 보고 이어서 실습을 하는 분이 계시다면 아래의 테이블 변경부터 하고 튜토리얼을 진행하겠다.</p><p>원래 <code>Members</code> 라는 테이블에 <code>loc</code> 라는 필드가 있었는데, 이를 삭제했다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> MEMBERS</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> loc;</span><br></pre></td></tr></table></figure><ul><li>VO 약간의 리팩토링하기</li><li>컨트롤러 리팩토링 및 추가하기</li><li>서비스 생성하기</li><li>DAO 생성하기</li><li>Mapper 쿼리 작성하기</li><li>포스트맨으로 API 조회하여 테스트</li></ul><br><h2 id="VO-리팩토링"><a href="#VO-리팩토링" class="headerlink" title="VO 리팩토링"></a>VO 리팩토링</h2><p>지난 포스팅때 VO를 만들면서 Lombok 어노테이션의 <code>@Data</code> 를 사용했는데, 이렇게 하면 어떤 어노테이션을 사용중인지 직관적이지 않다는 생각이 들어서 이를 <code>@Getter</code>, <code>@Setter</code> 어노테이션으로 분리했다.</p><p>그리고 <code>@JsonProperty</code> 어노테이션에 value값을 넣어서 JSON 객체를 주고받을 때, 필드명을 좀 더 분명히 했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberVO</span> </span>&#123;</span><br><span class="line">   <span class="meta">@JsonProperty(value=&quot;id&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@JsonProperty(value=&quot;name&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@JsonProperty(value=&quot;job&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> String job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="컨트롤러-리팩토링-및-추가하기"><a href="#컨트롤러-리팩토링-및-추가하기" class="headerlink" title="컨트롤러 리팩토링 및 추가하기"></a>컨트롤러 리팩토링 및 추가하기</h2><p>지난 포스팅때는 <code>@Controller</code> 를 생성해서 각 컨트롤러마다 <code>@ResponseBody</code> 어노테이션을 사용했는데, 화면과 통신하는게 아니라 그저 JSON만 주고받는 컨트롤러이기 때문에 리팩토링을 해보았다.</p><p><code>@RestController</code> 로 생성해서 <code>@ResponseBody</code> 어노테이션을 쓰지않아도 되도록 리팩토링 하였다.</p><h3 id="회원-등록-컨트롤러"><a href="#회원-등록-컨트롤러" class="headerlink" title="회원 등록 컨트롤러"></a>회원 등록 컨트롤러</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping(&quot;/member/new&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MemberVO&gt; <span class="title">insertMember</span><span class="params">(<span class="meta">@RequestBody</span> MemberVO member)</span></span>&#123;</span><br><span class="line">   memberService.insertMember(member);</span><br><span class="line">   <span class="keyword">return</span> memberService.selectAllMembers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTTP body로 들어오는 JSON을 가져오기 위해서 컨트롤러의 파라미터 영역에서 <code>@RequestBody</code> 어노테이션을 사용했다.</p><p>서비스단에서 비즈니스 로직을 구현할 예정이므로 아직 생성하지 않은 서비스의 <code>insertMember()</code> 를 호출했다.</p><p>마지막으로 포스트맨에서 API 요청을 하면, 실제로 회원이 성공적으로 추가되었는지를 확인하기 위해 전체 회원을 반환할수있도록 <code>List&lt;&gt;</code> 타입으로 반환타입을 지정하였다.</p><p><code>List&lt;MemberVO&gt;</code> 는 리스트인데, 이 리스트에 들어올 수 있는 타입으로 <code>MemberVO</code> 클래스로만 고정하는 제너릭 타입이다.</p><h3 id="회원-수정-컨트롤러"><a href="#회원-수정-컨트롤러" class="headerlink" title="회원 수정 컨트롤러"></a>회원 수정 컨트롤러</h3><p>어떤 멤버를 수정할지를 URL에 id값을 받아서 해당 회원정보를 HTTP body에 들어온 JSON 데이터로 변경하는 컨트롤러를 생성했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PutMapping(&quot;/member/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MemberVO&gt; <span class="title">updateMember</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> id, <span class="meta">@RequestBody</span> MemberVO member)</span></span>&#123;</span><br><span class="line">   memberService.updateMember(id, member);</span><br><span class="line">   <span class="keyword">return</span> memberService.selectAllMembers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RESTful한 API를 위해 회원 수정 API는 HTTP PUT 메서드를 받도록(<code>@PutMapping</code>) 개발했다.</p><p>쿼리스트링이 아닌 REST 방식으로 URL을 설계하였으며, 이를 위해 컨트롤러의 파라미터에 <code>@PathVariable</code> 어노테이션을 사용하여 URL로 들어오는 <code>id</code> 값을 매핑처리하였다.</p><p>서비스에 <code>id</code>값과 <code>MemberVO</code> 를 인자로 받는 <code>updateMember()</code>를 호출하도록 하였다. 향후 이 서비스에서 <code>id</code>값으로 회원을 찾아서 해당 회원에 대한 정보를 인자로 들어온 <code>member</code> 변수로 변경할 것이다.</p><h3 id="회원-삭제-컨트롤러"><a href="#회원-삭제-컨트롤러" class="headerlink" title="회원 삭제 컨트롤러"></a>회원 삭제 컨트롤러</h3><p>마찬가지로 RESTful한 API 설계를 위해 HTTP DELETE 메서드를 받도록 처리하였다. (<code>@DeleteMapping()</code>)</p><p>회원 삭제 컨트롤러도 회원 수정 컨트롤러와 마찬가지로 URL로 들어오는 id값을 인자로 가져와서 해당 멤버를 조회후 삭제하는 로직을 태웠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeleteMapping(&quot;/member/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MemberVO&gt; <span class="title">deleteMember</span><span class="params">(<span class="meta">@PathVariable</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">  memberService.deleteMember(id);</span><br><span class="line">  <span class="keyword">return</span> memberService.selectAllMembers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>Github에 소스코드를 공개해두었다.</p><p><a href="https://github.com/youngjinmo/MyBatisOraclePractice/blob/26ec2f4e89/src/main/java/com/devandy/web/controller/MemberController.java">MemberController.java</a></p><br><h2 id="서비스-생성하기"><a href="#서비스-생성하기" class="headerlink" title="서비스 생성하기"></a>서비스 생성하기</h2><p>인터페이스를 먼저 생성해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.devandy.web.vo.MemberVO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;MemberVO&gt; <span class="title">selectAllMembers</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertMember</span><span class="params">(MemberVO member)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateMember</span><span class="params">(<span class="keyword">int</span> id, MemberVO member)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteMember</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이제 인터페이스의 구현체를 생성해보자.</p><h3 id="회원-등록-서비스"><a href="#회원-등록-서비스" class="headerlink" title="회원 등록 서비스"></a>회원 등록 서비스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertMember</span><span class="params">(MemberVO member)</span> </span>&#123;</span><br><span class="line">   memberDao.insert(member);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DB에 회원 생성 쿼리를 날려야 하므로 DAO의 메서드에 <code>member</code> 객체를 파라미터로 담아서 호출만 하면 된다.</p><h3 id="회원-수정-서비스"><a href="#회원-수정-서비스" class="headerlink" title="회원 수정 서비스"></a>회원 수정 서비스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateMember</span><span class="params">(<span class="keyword">int</span> id, MemberVO updateMember)</span> </span>&#123;</span><br><span class="line">  MemberVO member = memberDao.selectById(id);</span><br><span class="line">  <span class="keyword">if</span>(member!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    member.setName(updateMember.getName());</span><br><span class="line">    member.setJob(updateMember.getJob());</span><br><span class="line">    memberDao.update(member);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;회원이 존재하지 않습니다.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>회원 수정을 하기 위해서 파라미터로 받은게 두가지가 있다. 하나는 수정할 대상 회원의 id와 변경할 부분의 JSON 값.</p><p>먼저 수정 대상인 회원이 존재하는지 여부를 확인(<code>memberDao.selectById(id)!=null</code>)하고, 그렇지 않으면 <code>IllegalStateException()</code> 에 메세지를 작성하여 콘솔에 출력하도록 하였다. 이 예외처리가 발생하면 클라이언트는 500 HTTP 상태 코드를 전달 받을 것이다.</p><p>DAO에서 id값으로 회원을 조회한 결과가 <code>null</code>이 아니라면, 회원이 존재하므로 회원 객체에 JSON으로 넘어온 값에서 <code>name</code> 과 <code>job</code> 을 set해주고, 수정 쿼리를 날려주는 DAO의 <code>update(member)</code> 를 호출한다.</p><h3 id="회원-삭제-서비스"><a href="#회원-삭제-서비스" class="headerlink" title="회원 삭제 서비스"></a>회원 삭제 서비스</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteMember</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(memberDao.selectById(id)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      memberDao.delete(id);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;회원이 존재하지 않습니다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>회원 삭제 서비스도 수정과 마찬가지로 회원이 존재하는지를 확인하고, 없으면 500 상태코드와 함께 콘솔에 메세지를 출력하고, DAO의 삭제 쿼리를 호출한다.</p><br><p>Github에 소스코드를 공개해두었다.</p><p><a href="https://github.com/youngjinmo/MyBatisOraclePractice/blob/26ec2f4e89/src/main/java/com/devandy/web/service/MemberServiceImpl.java">MemberServiceImpl.java</a></p><br><h2 id="DAO-생성하기"><a href="#DAO-생성하기" class="headerlink" title="DAO 생성하기"></a>DAO 생성하기</h2><p>DAO는 인터페이스이므로 DB 제어가 필요한 메서드만 만들어두었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.devandy.web.vo.MemberVO;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberDao</span> </span>&#123;</span><br><span class="line">   <span class="function">List&lt;MemberVO&gt; <span class="title">selectAll</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">MemberVO <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(MemberVO member)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(MemberVO member)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Service와-DAO-차이"><a href="#Service와-DAO-차이" class="headerlink" title="Service와 DAO 차이"></a>Service와 DAO 차이</h3><p>간단한 실습 튜토리얼이다 보니 서비스와 DAO가 비슷해보이는 측면이 있다. 그러나 서비스와 DAO는 엄연히 다른 개념이다.</p><p>서비스가 DAO를 포함한 비즈니스 로직을 의미한다면, DAO는 실제로 쿼리를 이용하여 DB와 통신이 필요한 로직에만 해당한다.</p><p><strong>함께 읽으면 좋을 글</strong></p><ul><li><a href="https://okky.kr/article/179628">OKKY - DAO랑 Service랑 차이가 없던데 무슨차이죠?</a></li></ul><br><h2 id="Mapper-쿼리-작성하기"><a href="#Mapper-쿼리-작성하기" class="headerlink" title="Mapper 쿼리 작성하기"></a>Mapper 쿼리 작성하기</h2><p>DAO에 의하여 실제로 DB와 통신할 쿼리가 작성될 곳이다.</p><p>Mapper 쿼리에서 사용하는 id값은 DAO에서 작성한 메서드명과 매핑된다.</p><h3 id="ID값으로-회원조회하는-Mapper-쿼리"><a href="#ID값으로-회원조회하는-Mapper-쿼리" class="headerlink" title="ID값으로 회원조회하는 Mapper 쿼리"></a>ID값으로 회원조회하는 Mapper 쿼리</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;MemberVO&quot;</span>&gt;</span></span><br><span class="line">   SELECT *</span><br><span class="line">   FROM MEMBERS</span><br><span class="line">   WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>조회하는 쿼리이므로 <code>&lt;select&gt;</code> 태그를 사용하였으며, 파라미터 타입으로 id의 타입인 <code>int</code>, 반환 타입은 SELECT 결과에 따른 멤버 객체를 지정하였다.</p><p>Mapper 쿼리에서 사용하는 id값은 DAO에서 작성한 메서드명과 매핑된다.</p><h3 id="회원-등록-Mapper-쿼리"><a href="#회원-등록-Mapper-쿼리" class="headerlink" title="회원 등록 Mapper 쿼리"></a>회원 등록 Mapper 쿼리</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;MemberVO&quot;</span>&gt;</span></span><br><span class="line">   INSERT INTO MEMBERS(id, name, job)</span><br><span class="line">   VALUES(id_seq.nextval, #&#123;name&#125;, #&#123;job&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JSON으로 가져온 멤버 객체를 파라미터로 받아서 각 필드에 INSERT 했다. 여기서 id는 시퀀스로 생성했기 때문에 임의로 입력하는 대신 오라클 시퀀스에 의해 자동으로 값을 생성해서 INSERT하도록 하였다.</p><h3 id="회원-수정-Mapper-쿼리"><a href="#회원-수정-Mapper-쿼리" class="headerlink" title="회원 수정 Mapper 쿼리"></a>회원 수정 Mapper 쿼리</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;MemberVO&quot;</span>&gt;</span></span><br><span class="line">   UPDATE MEMBERS</span><br><span class="line">   SET name = #&#123;name&#125;,</span><br><span class="line">       job = #&#123;job&#125;</span><br><span class="line">   WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="회원-삭제-Mapper-쿼리"><a href="#회원-삭제-Mapper-쿼리" class="headerlink" title="회원 삭제 Mapper 쿼리"></a>회원 삭제 Mapper 쿼리</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">   DELETE MEMBERS</span><br><span class="line">   WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure><br><p>Github에 소스코드를 공개해두었다.</p><p><a href="https://github.com/youngjinmo/MyBatisOraclePractice/blob/26ec2f4e89/src/main/resources/mappers/MemberDaoImpl.xml">MemberDaoImpl.xml</a></p><br><h2 id="포스트맨으로-API-조회하여-테스트"><a href="#포스트맨으로-API-조회하여-테스트" class="headerlink" title="포스트맨으로 API 조회하여 테스트"></a>포스트맨으로 API 조회하여 테스트</h2><h3 id="회원-등록-API-테스트"><a href="#회원-등록-API-테스트" class="headerlink" title="회원 등록 API 테스트"></a>회원 등록 API 테스트</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">POST  &#x2F;member&#x2F;new</span><br></pre></td></tr></table></figure><p>포스트맨에서 요청할 때 Body에 JSON 객체를 담아야 하므로 아래의 이미지처럼 JSON 형태로 작성해서 API를 요청했다.</p><p><img src="https://user-images.githubusercontent.com/33862991/104151219-c7ef4c00-541f-11eb-97dd-c4c699a37e52.png"></p><p>Body에 담은 JSON 객체가 성공적으로 회원 목록에 포함된걸 확인했다. <code>id</code>가 6이 아니라 8로 입력된 이유는 이 스크린샷을 찍기 전에 테스트를 하느라 시퀀스를 소비(?)했기 때문이다.</p><h3 id="회원-수정-API-테스트"><a href="#회원-수정-API-테스트" class="headerlink" title="회원 수정 API 테스트"></a>회원 수정 API 테스트</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT  &#x2F;member&#x2F;&#123;id&#125;</span><br></pre></td></tr></table></figure><p>이번엔 아까 등록해둔 Zidane이라는 회원의 <code>job</code>을 변경하는 수정 API를 요청해보았다.</p><p><img src="https://user-images.githubusercontent.com/33862991/104151225-ca51a600-541f-11eb-96d9-ebb2c87e013f.png"></p><p>반환받은 회원목록에서 Zidane 회원의 <code>job</code>이 Coach에서 Legend로 성공적으로 바뀐것을 확인하였다.</p><h3 id="회원-삭제-API-테스트"><a href="#회원-삭제-API-테스트" class="headerlink" title="회원 삭제 API 테스트"></a>회원 삭제 API 테스트</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE  &#x2F;member&#x2F;&#123;id&#125;</span><br></pre></td></tr></table></figure><p>이번엔 Zidane 회원을 삭제하는 API를 요청해보았다.</p><p><img src="https://user-images.githubusercontent.com/33862991/104151229-ccb40000-541f-11eb-8a5a-d552c3b7c132.png"></p><p>성공했다!</p><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> tutorial </tag>
            
            <tag> docker </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring에서 URL로 파라미터를 받는 방법 2가지</title>
      <link href="2021/01/spring-request-parameter/"/>
      <url>2021/01/spring-request-parameter/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/104125838-b1ec7780-539c-11eb-8e7c-26ac78f2978b.jpeg"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;youngjinmo.github.io&#x2F;member?id&#x3D;2  &#x2F;&#x2F; type 1</span><br><span class="line">GET http:&#x2F;&#x2F;youngjinmo.github.io&#x2F;member&#x2F;2     &#x2F;&#x2F; type 2</span><br></pre></td></tr></table></figure><p>URL에 파라미터를 전송하는 두가지 방식으로 두가지 방식이 있다. type 1의 방식이 쿼리 스트링을 적용한 방식이고, type 2가 REST하게 이용하는 방식이다.</p><h2 id="쿼리스트링"><a href="#쿼리스트링" class="headerlink" title="쿼리스트링"></a>쿼리스트링</h2><p>쿼리스트링으로 파라미터를 URL로 전송할 때엔 컨트롤러에서 파라미터를 받을때 <code>@RequestParam</code> 을 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   MemberService memberService;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@GetMapping(&quot;/member&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;MemberVO&gt; <span class="title">getMemberById</span><span class="params">(<span class="meta">@RequestParam</span> Long id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> memberService.selectMemberById(id);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실습 예제를 만들면서 포스트맨으로 간단히 API 조회를 할 수 있도록 Http Body에 결과를 담아 반환하는 컨트롤러를 만들었다. 이를 위해 <code>@Controller</code> 대신 <code>@RestController</code> 를 사용했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;localhost:8080&#x2F;member?id&#x3D;2</span><br></pre></td></tr></table></figure><p><code>@RequestParam</code> 어노테이션을 컨트롤러 파라미터에 작성하면 쿼리 스트링으로 들어오는 영역에서 <code>id</code> 값을 매핑해서 가져올 수 있다.</p><br><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h2><p>RESTful하게 파라미터를 받기 위해서 컨트롤러에서 <code>@PathVariable</code> 어노테이션을 사용했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   MemberService memberService;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@GetMapping(&quot;/member/&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;MemberVO&gt; <span class="title">getMemberById</span><span class="params">(<span class="meta">@RequestParam</span> Long id)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> memberService.selectMemberById(id);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이외에 <code>@GetMapping()</code> 어노테이션에 <code>@RequestParam</code> 어노테이션으로 가져올 파라미터를 <code>&#123;&#125;</code> 형태로 작성해줘야 파라미터로 매핑이 이뤄진다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;localhost:8080&#x2F;member&#x2F;2</span><br></pre></td></tr></table></figure><p>쿼리스트링은 URL에 입력하는 파라미터 순서가 중요하지 않으나 REST 방식으로 URL에 파라미터를 담아서 전송할 경우, 파라미터의 위치가 중요해진다. 이 떄문에 <code>@RequestMapping</code> 또는 <code>@GetMapping</code> 어노테이션에서 파라미터명을 매핑해줘야한다.</p><hr><p><strong>Reference</strong></p><ul><li><a href="https://elfinlas.github.io/2018/02/18/spring-parameter/">MHLab Blog - Spring에서 @RequestParam과 @PathVariable</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Live Study 1주차 - JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가</title>
      <link href="2021/01/livestudy-week-01/"/>
      <url>2021/01/livestudy-week-01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/peEXNN-oob4/maxresdefault.jpg"></p><ul><li><a href="#jvm-definition">JVM이란 무엇인가</a></li><li><a href="#how-to-compile">컴파일 및 실행하는 방법</a></li><li><a href="#bytecode">바이트코드란 무엇인가</a></li><li><a href="#components-of-jvm">JVM 구성요소</a></li><li><a href="#jit">JIT 컴파일러란 무엇이며 어떻게 동작하는지</a></li><li><a href="#jdk-jre">JDK와 JRE차이</a></li></ul><br><h1 id="JVM이란-무엇인가"><a href="#JVM이란-무엇인가" class="headerlink" title="JVM이란 무엇인가"></a><a name="jvm-definition"></a>JVM이란 무엇인가</h1><p>자바를 두 문장으로 설명하는 말이 있다.</p><blockquote><p>Write once,<br>Run anywhere.</p></blockquote><p>자바 언어로 개발된 프로그램은 , 운영체제가 리눅스이건, 윈도우이건, 맥OS이건 모두 실행가능한 특징을 비유하는 말이다. 이를 가능케하는 존재가 <strong>JVM(Java Virtual Machine)</strong> 이다.</p><p>컴퓨터에서 프로그램이 실행되려면, 컴퓨터가 읽을 수 있는 언어로 변환이 필요하다. 이렇게 변환된 언어를 기계어라고 한다. 자바에서는 기계어로 번역하는 역할을 JVM이라는 가상 머신에서 한다. </p><p>자바 프로그램을 실행하는 환경이 어떤 운영체제이든 JVM만 설치되어 있다면, 이 JVM에서 컴퓨터에 맞는 기계어로 번역하기 때문에 JDK가 설치된 환경이라면, 어디서나 자바 프로그램을 실행할 수 있게된다. </p><p><img src="https://user-images.githubusercontent.com/33862991/103503907-299c3d00-4e99-11eb-88fc-a0647a074cc6.png"></p><p>출처 : <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001">남궁성 - Java의 정석</a></p><p>단, JVM은 java 코드를 직접 읽지 못하기 때문에 JVM이 읽을 수 있는 형태인 바이트코드로 컴파일해주어야 한다. 이 역할을 하는걸 자바 컴파일러라고 한다.</p><br><h1 id="컴파일-및-실행하는-방법"><a href="#컴파일-및-실행하는-방법" class="headerlink" title="컴파일 및 실행하는 방법"></a><a name="how-to-compile"></a>컴파일 및 실행하는 방법</h1><p>개발자가 Java로 작성한 소스 코드가 컴퓨터에 의해 읽어들이기까지의 과정은 다음과 같다.</p><ol><li>Java 코드 작성하기</li><li>자바 컴파일러로 java 파일 컴파일하기 (= 바이트코드 생성)</li><li>바이트코드를 JVM에서 OS(운영체제)에 맞는 기계어(binary)로 변환하기</li><li>자바 애플리케이션 실행하기</li></ol><h3 id="Java-코드-작성하기"><a href="#Java-코드-작성하기" class="headerlink" title="Java 코드 작성하기"></a>Java 코드 작성하기</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim StudyHale.java</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHale</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="컴파일하기-bytecode-생성"><a href="#컴파일하기-bytecode-생성" class="headerlink" title="컴파일하기 (bytecode 생성)"></a>컴파일하기 (bytecode 생성)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac StudyHale.java</span><br></pre></td></tr></table></figure><h3 id="Java-프로그램-실행"><a href="#Java-프로그램-실행" class="headerlink" title="Java 프로그램 실행"></a>Java 프로그램 실행</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java StudyHale</span><br><span class="line">Hello World.</span><br></pre></td></tr></table></figure><br><h1 id="바이트코드란-무엇인가"><a href="#바이트코드란-무엇인가" class="headerlink" title="바이트코드란 무엇인가"></a><a name="bytecode"></a>바이트코드란 무엇인가</h1><p><img src="https://user-images.githubusercontent.com/33862991/103438486-cfbc2d00-4c76-11eb-9e71-c4478a07b98c.png" alt="컴파일 과정"></p><p>JVM이 실행하는 명령어 형태이다. 컴퓨터에 의해 실행되려면 기계어로 번역되어야 하는데, JVM은 자바 코드를 읽지 못한다. 따라서 자바 컴파일러를 이용하여 JVM이 읽을 수 있는 형태인 바이트코드로 컴파일 해주어야한다.</p><p>자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1 byte라서 이를 바이트코드라한다.</p><p>그리고 JVM에서 이 바이트코드를 읽어들여 최종적으로 컴퓨터가 실행할 수 있는 기계어로 번역한다. </p><p><code>javap</code> 명령어를 이용하면 바이트코드를 볼 수 있다. 아래 예제코드를 통해 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudyHalle01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        StudyHalle01 study = <span class="keyword">new</span> StudyHalle01();</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; lotto = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">            lotto.add(study.randomNumber());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(getDate()+<span class="string">&quot; 로또 번호는 입니다&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">randomNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> number = random.nextInt(<span class="number">45</span>);</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Date time = <span class="keyword">new</span> Date();</span><br><span class="line">        SimpleDateFormat date = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy년 MM월 dd일&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> date.format(time);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드를 컴파일하고, <code>javap</code> 명령어로 컴파일하여 생성된 바이트코드를 확인해보겠다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac StudyHalle01.java</span><br><span class="line">javap -c StudyHalle01</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/33862991/104706473-7c5dda80-575e-11eb-8a3a-b1f6b4b5a90b.png"></p><p><code>javap</code>의 <code>-c</code> 옵션 명령어를 사용하면 위에서 보듯 역어셈블된 코드를 출력하는데, 이 때 보이는 한 줄 한 줄 명령어(Code)의 크기가 1 byte이다. 그래서 바이트코드라하는 것이다.</p><p>출처 : <a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EB%B0%94_%EB%B0%94%EC%9D%B4%ED%8A%B8%EC%BD%94%EB%93%9C">위키백과 - 자바 바이트코드</a></p><p>인텔리제이에서 바이트코드를 확인할 수 있다. <strong>[View]</strong> - <strong>[Show Bytecode]</strong> 를 클릭하면, 바이트코드를 보여준다. 단, 프로그램이 빌드한 이력이 있어야 한다. 개발자가 코딩한 직후엔 아직 바이트코드를 생성하지 않았기 때문에 이 땐 바이트코드를 보여줄 수 없다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103438315-6687ea00-4c75-11eb-8942-e282780b277f.png"></p><p>위에서 작성한 클래스의 바이트코드.</p><p><img src="https://user-images.githubusercontent.com/33862991/103438317-6982da80-4c75-11eb-8c55-274df3f446ef.png"></p><p>출처 : <a href="https://withhamit.tistory.com/502">햄과함께IT - java bytecode 확인</a></p><br><h1 id="JVM-구성요소"><a href="#JVM-구성요소" class="headerlink" title="JVM 구성요소"></a><a name="components-of-jvm"></a>JVM 구성요소</h1><p><img src="https://miro.medium.com/max/1286/0*GMXQBZCEpGQMBjy-" alt="JVM"></p><p>출처 : <a href="https://medium.com/platform-engineer/understanding-jvm-architecture-22c0ddf09722">platformengineer.com - Understanding JVM Architecture</a></p><p>JVM은 크게 아래의 모듈들로 구성되어 있다.</p><ul><li><a href="#classloader">클래스 로더(Class Loader)</a></li><li><a href="#runtime-data-area">런타임 데이터 에어리어(Runtime Data Area)</a></li><li><a href="#execution-engine">실행 엔진(Execution Engine)</a><ul><li><a href="#gc">가비지 콜렉터 (Garbage Collector, GC)</a></li></ul></li><li><a href="#jni">자바 네이티브 인터페이스(Java Native Interface, JNI)</a></li></ul><h2 id="클래스-로더-Class-Loader"><a href="#클래스-로더-Class-Loader" class="headerlink" title="클래스 로더 (Class Loader)"></a><a name="classloader"></a>클래스 로더 (Class Loader)</h2><p>자바 컴파일러에 의해 컴파일된 자바 바이트코드(<code>.class</code>)들이 JVM에 의해 읽어들여지면, 클래스로더가 이 바이트코드를 운영체제(OS)로부터 적재받은 메모리 영역인 런타임 데이터 에어리어로 <strong>적재(Loading)</strong> 하는 일을 한다. </p><p>여기서 말하는 운영체제로부터 적재받은 메모리란, <strong>RAM</strong> 을 이야기한다. 이 RAM에 클래스 파일들이 올라가야만(Loading), 프로세스로서 실행될 수 있다.</p><p>또 하나, 런타임이란 실행시점을 의미한다. 이와 비슷하지만 다른 시점이 컴파일 시점이 있다.</p><ul><li>컴파일 타임<ul><li>자바 컴파일러에 의해 바이트코드가 생성되는 시점</li></ul></li><li>런타임<ul><li>자바 애플리케이션(기계어)을 실행하는 시점</li></ul></li></ul><p>에러가 없다면 좋겠지만, 에러를 확인해야 한다면 에러는 런타임이 아니라 컴파일 타임에서 확인되는게 가장 좋다. 에러를 누가 확인하는지를 생각하면 이해할 수 있다. 컴파일 타임은 개발자가 확인하지만, 런타임은 사용자도 볼 수 있기 때문이다. 따라서 배포되기 전에 개발자에게 발견되려면 아예 컴파일 시점에 발견되어 컴파일에 실패하는게 좋다.</p><p>Loading 단계에서는 클래스 파일의 <code>main()</code> 부터 메모리에 적재되는데, <code>main()</code> 이 실행되면서 필요한 객체들을 동적으로 로딩하게 된다.</p><p>자바 바이트코드는 JVM에서 기계어(바이너리 코드)로 변환된다고 하였는데, 이 때 코드가 통째로 기계어로 번역되는게 아니라 <u>애플리케이션에 필요한 객체들이 먼저 JIT에 의해서 번역(Interpretion)된다.</u><br>이를 <strong>동적인 클래스 로딩(Java’s dynamic class loading)</strong> 이라고 한다.</p><p>클래스 로더에서는 메모리 영역에 객체 정보를 적재하는 역할 외에 적재된 클래스 파일의 에러를 검증하고 레퍼런스들을 연결하는 <strong>Linking</strong> 이라는 작업을 거친다.</p><p>마지막으로 초기화(<strong>Initialization</strong>)를 거침으로 클래스 로더의 역할이 끝이난다.</p><p>출처 : <a href="https://yeon-kr.tistory.com/112">당근케잌 - [Java] JVM Architecture란?</a></p><br><h2 id="메모리-영역-Runtime-Data-Area"><a href="#메모리-영역-Runtime-Data-Area" class="headerlink" title="메모리 영역 (Runtime Data Area)"></a><a name="runtime-data-area"></a>메모리 영역 (Runtime Data Area)</h2><p>JVM이 운영체제(OS)로부터 적재받은 메모리 영역이다. 이곳에 클래스가 적재되어야지 자바 애플리케이션이 프로세스로써 컴퓨터에서 실행될 수 있다. 지금부터는 그냥 ‘메모리’라고 표현하겠다.</p><p>JVM의 메모리 영역은 다음으로 구성된다.</p><ul><li><a href="#method-area">Method Area</a></li><li><a href="#heap">Heap Area</a></li><li><a href="#stack">Stack Area</a></li><li><a href="#program-counter">PC Register</a></li><li><a href="#native-method-stack">Native Method Stack</a></li></ul><h3 id="메서드-영역-Method-Area"><a href="#메서드-영역-Method-Area" class="headerlink" title="메서드 영역(Method Area)"></a><a name="method-area"></a>메서드 영역(Method Area)</h3><p>JVM 내 하나만 존재하는 <strong>공유자원</strong> 이며, 메모리에 항상 상주하는 영역이기 때문에 JVM 내 스레드들이 메서드 영역의 자원을 공유하여 사용한다.</p><p>클래스에서 필요한 패키지 클래스, 런타임 상수풀, 인터페이스, 상수, <code>static</code> 변수, <code>final</code> 변수, 필드 데이터, 생성자 등의 모든 메서드 정보가 한 번 적재되면, 메모리 영역에서 항상 상주하게 된다.</p><p><a href="#jit">JIT 컴파일러</a>가 프로그램의 실제 실행시점에 실행에 필요한 바이트코드를 기계어로 번역하며, 다른 클래스에서 사용되는 클래스 정보를 메서드 영역에 적재해두고 공유하는 것이다.</p><p>메서드 영역에 Constant Pool이라는 영역이 존재하는데, 이곳에 상수값을 저장한다. 자바 애플리케이션 런타임시에 필요한 모든 종류의 숫자, 문자열, 식별자 이름, 클래스 파일, 메서드 정보들이 Constant Pool에 저장되는 데이터들이다.</p><p>출처 : <a href="https://honbabzone.com/java/java-jvm/">김석진 - JVM(Java Virtual Machine)이란</a></p><br><h3 id="힙-영역-Heap-Area"><a href="#힙-영역-Heap-Area" class="headerlink" title="힙 영역(Heap Area)"></a><a name="heap"></a>힙 영역(Heap Area)</h3><p>메서드 영역과 마찬가지로 힙 영역도 JVM 내에 하나만 존재하는 공유자원이다. <code>new</code> 키워드로 생성된 객체의 데이터가 힙 영역에 적재된다. </p><p>메모리 영역(Method Area)에도 <code>new</code> 키워드로 생성한 클래스의 정보가 저장되는데, 힙 영역과 차이점이 있다면, <strong>메모리 영역은 클래스 정보가 저장되는 곳이라면, 힙 영역은 실제 데이터가 저장</strong> 되는 곳이다.</p><p><a href="#execution-engine">실행 엔진(Execution Engine)</a>에서 다시 설명하겠지만, 자바는 <a href="#gc">가비지 콜렉터(GC)</a>가 존재하기 때문에 더 이상 사용되지 않는 인스턴스는 GC에 의해 제거되어 자동으로 메모리 관리가 이뤄지는데, 이 힙 영역에서 더 이상 참조되지 않는 메모리를 GC가 찾아서 제거해준다.</p><p>메모리 영역과 힙 영역은 다중 스레드에 의해 공유되는 자원이기 때문에 여기에 적재된 데이터들은 동기화 문제를 유발할 수 있다. 즉 Thread-safe 하지 않게된다는 이야기이다.</p><p>동기화 문제를 해결하려면, 임계구역을 만들어서 한 번에 한 스레드만 진입하도록 해야한다고 한다. 한 스레드가 자원을 사용하면, 다른 스레드들이 접근하지 못하도록 Lock을 걸고, 사용하던 스레드가 더 이상 사용하지 않으면 Lock을 해제하는 원리라고 한다.</p><p>출처</p><ul><li><p><a href="https://yeon-kr.tistory.com/112">당근케잌 - [Java] JVM Architecture란?</a></p></li><li><p><a href="https://jeong-pro.tistory.com/148">정아마추어 코딩블로그 - JVM구조와 자바 런타임 메모리구조</a></p></li></ul><br><h3 id="스택-영역-Stack-Area"><a href="#스택-영역-Stack-Area" class="headerlink" title="스택 영역(Stack Area)"></a><a name="stack"></a>스택 영역(Stack Area)</h3><p>스레드가 할당되는 영역이며, 스레드가 시작될때 스택 영역에 적재된다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackArea</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      hello();</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같은 코드의 애플리케이션을 실행한다고 하면, <code>main()</code> 이 먼저 실행되며, <code>hello()</code> 가 실행될 것이다. 그럼 스택 영역에 <code>main()</code> 스레드가 할당되고, <code>main()</code> 위로 <code>hello()</code> 가 할당되게 된다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103510309-5277fe80-4ea8-11eb-85e5-5d2aae2c10a4.png"></p><p>메서드 호출이 종료되면, 스택 영역에서 제거된다.</p><br><h3 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a><a name="program-counter"></a>PC Register</h3><p>Program Counter의 약자이다. </p><p>스레드당 하나의 PC 레지스터가 존재하며, 스레드가 생성될때마다 생성되는 영역이다.</p><p>스레드가 실행되면, 현재 스레드가 실행되는 부분의 주소와 명령을 저장하고, 이 명령이 끝나면 다음 실행될 명령의 주소를 가리킨다. 이 덕분에 여러 스레드들이 명령의 흐름을 잃지않고 순차적으로 실행 될 수 있다.</p><p>출처 : <a href="https://honbabzone.com/java/java-jvm/">김석진 - JVM(Java Virtual Machine)이란</a></p><h3 id="Native-Method-Stack"><a href="#Native-Method-Stack" class="headerlink" title="Native Method Stack"></a><a name="native-method-stack"></a>Native Method Stack</h3><p>자바 외에 다른 언어로 작성된 메서드 정보가 저장되는 영역이다.</p><p>출처 : <a href="https://honbabzone.com/java/java-jvm/">김석진 - JVM(Java Virtual Machine)이란</a></p><br><h3 id="실행-엔진-Execution-Engine"><a href="#실행-엔진-Execution-Engine" class="headerlink" title="실행 엔진 (Execution Engine)"></a><a name="execution-engine"></a>실행 엔진 (Execution Engine)</h3><p>컴파일러가 변환한 바이트코드가 실제로 실행되는 영역이다.  실행 엔진은 다음으로 구성되어 있다.</p><ul><li>인터프리터</li><li>JIT 컴파일러</li><li>가비지 콜렉터(GC)</li></ul><p>인터프리터는 바이트코드를 한 줄씩 읽고 실행하는 역할을 수행한다.</p><p>자바는 바이트코드로 컴파일 후, 다시 기계어로 변환하는 작업을 거치기 때문에 네이티브 언어(C언어)보다 느리다고 평가받았다. 이를 극복하기 위해 등장한 것이 JIT인데, JIT는 <a href="#jit">아래</a>에서 더 자세하게 설명하겠다.</p><p><a name="gc"></a> <strong>가비지 콜렉터</strong> 는 메모리를 자동으로 관리해주는 영역이다. 힙 영역에 적재된 객체들 중 더 이상 참조되지 않는 객체들을 탐색 후 제거해주는 역할을 수행한다. 주로 힙 영역에 적재된 객체들이 GC의 타겟이 되지만, 메서드 영역과 스택 영역도 GC의 타겟이 된다.</p><p>사용되지 않으면서 메모리만 사용하고있던 불필요한 자원을 프로그래머 대신 가비지 콜렉터가 자동으로 해주는 것이다.</p><p>출처</p><ul><li><a href="https://yeon-kr.tistory.com/112">당근케잌 - [Java] JVM Architecture란?</a></li><li><a href="https://yeon-kr.tistory.com/114">당근케잌 - Java Memory Model(자바 메모리 모델)</a></li><li><a href="https://jeong-pro.tistory.com/148">정아마추어 코딩블로그 - JVM구조와 자바 런타임 메모리구조</a></li></ul><br><h2 id="자바-네이티브-인터페이스-Java-Native-Interface-JNI"><a href="#자바-네이티브-인터페이스-Java-Native-Interface-JNI" class="headerlink" title="자바 네이티브 인터페이스 (Java Native Interface, JNI)"></a><a name="jni"></a>자바 네이티브 인터페이스 (Java Native Interface, JNI)</h2><p>네이티브 코드(C, C++)로 작성된 라이브러리를 제공하는 Native Method Libraries와 상호작용하기 위해 존재하는 영역이다. </p><p>이 영역은 아직 이해가 잘 안되는 부분이다. 더 공부가 필요할것 같다…</p><br><p>출처 : <a href="https://yeon-kr.tistory.com/112">당근케잌 - [Java] JVM Architecture란?</a></p><h1 id="JIT-컴파일러란-무엇이며-어떻게-동작하는지"><a href="#JIT-컴파일러란-무엇이며-어떻게-동작하는지" class="headerlink" title="JIT 컴파일러란 무엇이며 어떻게 동작하는지"></a><a name="jit"></a>JIT 컴파일러란 무엇이며 어떻게 동작하는지</h1><p>JIT 컴파일러란, Just In Time 컴파일러를 정의한다. <strong>프로그램을 실행하는 시점에 전체 바이트코드가 아닌 필요한 함수만 기계어로 번역하여 실행</strong> 하는 컴파일러를 가리킨다.</p><p>JIT 컴파일러를 설명하기 앞서 프로그래밍 언어를 실행하는 방식에 대해 먼저 짚고넘어가자. 프로그래밍 언어를 실행하는 방식은 크게 두가지가 있다. 인터프리터와 컴파일러 방식.</p><p>인터프리터는 말 코드를 한 줄 씩 번역하여 실행을 하며, 컴파일은 실행하기 전에 프로그램 코드 전체를 기계어로 번역해서 번역된 기계어를 한 번에 실행한다.</p><p>이런 특징 때문에 인터프리터는 컴파일러 대비 생산속도는 빠르지만, 실행 속도는 느리다는 특징으로 정리될 수 있다.</p><p>반면 컴파일러는 코드 전체를 기계어로 번역후, 번역된 기계어를 실행한다. 이 때문에 컴파일 과정에서 에러를 발견할 수 있어서 실행할 때의 오류를 미리 알 수 있다는 특징도 있다.</p><p>컴파일러는 인터프리터 대비 생산 속도는 느리지만, 실행 속도는 빠르다고 할 수 있다.</p><p>JIT 컴파일러는 자바라는 언어가 인터프리터와 컴파일러의 특징 모두를 가질 수 있게한 컴파일러이다.<br>자바 컴파일러로 변환한 바이트코드를 한 번에 기계어로 번역하는게 아니라 실행 시점에 필요한 함수(메서드)만 기계어로 변환하기 때문에 기존보다 속도에서 더 향상 되었다고 할 수 있다.</p><p>출처 : <a href="https://yeon-kr.tistory.com/112">당근케잌 - [Java] JVM Architecture란?</a></p><br><h1 id="JDK와-JRE차이"><a href="#JDK와-JRE차이" class="headerlink" title="JDK와 JRE차이"></a><a name="jdk-jre"></a>JDK와 JRE차이</h1><h3 id="JRE-Java-Runtime-Environment"><a href="#JRE-Java-Runtime-Environment" class="headerlink" title="JRE (Java Runtime Environment)"></a>JRE (Java Runtime Environment)</h3><p>자바 애플리케이션을 <u>실행</u>하기 위한 최소한의 배포 단위이다. JVM과 라이브러리가 포함된다. 개발이 아닌 실행만을 위한 도구이다.</p><h3 id="JDK-Java-Development-Kit"><a href="#JDK-Java-Development-Kit" class="headerlink" title="JDK (Java Development Kit)"></a>JDK (Java Development Kit)</h3><p>자바 애플리케이션 개발에 필요한 도구가 모두 포함된다. 원래 JDK를 설치하면 JRE까지 함께 설치되었으나 Oracle JDK11부터는 JRE가 기본으로 제공되지 않는다고 한다. </p><p>이유는 JRE의 구성요소가 JDK에 이미 포함되기 때문에 굳이 JRE를 따로 배포할 필요가 없어졌기 때문이라고 한다. 따라서 JRE를 따로 설치안하더라도 JDK만 설치하면 자바 애플리케이션을 실행할 수 있다.</p><p>출처 : <a href="https://www.oracle.com/java/technologies/javase/jdk-11-relnote.html">Oracle - JDK 11 Release Notes</a></p><br><hr><p><strong>더 읽어볼 글</strong></p><ul><li><a href="https://d2.naver.com/helloworld/1230">Naver D2 - JVM Internal</a></li><li><a href="https://d2.naver.com/helloworld/1329">Naver D2 - Java Garbage Collection</a></li><li><a href="https://d2.naver.com/helloworld/329631">Naver D2 - Java Reference와 GC</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> whiteship </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>인텔리제이에서 Livereload 적용하기</title>
      <link href="2020/12/enable-livereload/"/>
      <url>2020/12/enable-livereload/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/8vxDyBa3NmxhsWZ0QpNWfBJPFKVGz24cNI0oixDqyZpAMQriDLAe9f6Wk9xfWWsDVzka_ugUnTRNpAk7YAkCkzRidA=w640-h400-e365-rj-sc0x00ffffff"></p><p>인텔리제이에서 스프링부트 프로젝트를 하면서 화면(View)에 변화를 주면, 자동으로 리빌드하고 브라우저에서 리로드하는 Livereload를 적용하면서 매번 구글링하면서 적용하는것 같아서 아예 내 블로그에도 정리해보았다.</p><p>출처 : <a href="https://m.blog.naver.com/spring1a/221757269099">호노루 - [Springboot] Developer Tools - Live Reload 설치 삽질기</a></p><p>Livereload를 적용하는 방법은 아래의 4가지 순서대로 정리했다.</p><ol><li>DevTools 의존성 주입</li><li>인텔리제이 Registry 활성화</li><li>컴파일러 빌드 자동화 활성화</li><li>크롬에서 LiveReload 설치</li></ol><br><h2 id="1-DevTools-의존성-주입"><a href="#1-DevTools-의존성-주입" class="headerlink" title="1. DevTools 의존성 주입"></a>1. DevTools 의존성 주입</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-인텔리제이-Registry-활성화"><a href="#2-인텔리제이-Registry-활성화" class="headerlink" title="2. 인텔리제이 Registry 활성화"></a>2. 인텔리제이 Registry 활성화</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.automake.allow.when.app.running</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/33862991/103331287-8d44f580-4aa8-11eb-93ec-3811f28b6ff5.png"></p><h2 id="3-컴파일러-빌드-자동화-활성화"><a href="#3-컴파일러-빌드-자동화-활성화" class="headerlink" title="3. 컴파일러 빌드 자동화 활성화"></a>3. 컴파일러 빌드 자동화 활성화</h2><p>인텔리제이의 설정에서 <strong>[Build] - [Compiler] - [Build project automatically]</strong> 활성화</p><p><img src="https://user-images.githubusercontent.com/33862991/103331291-8fa74f80-4aa8-11eb-962c-e924e8ec671f.png"></p><h2 id="4-크롬에서-LiveReload-설치"><a href="#4-크롬에서-LiveReload-설치" class="headerlink" title="4. 크롬에서 LiveReload 설치"></a>4. 크롬에서 LiveReload 설치</h2><p>마지막으로 크롬 또는 파이어폭스에서 LiveReload 익스텐션을 설치하고, 활성화하면 마무리된다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103331293-9209a980-4aa8-11eb-9c67-5a1a7dadc61d.png"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> intellij </tag>
            
            <tag> livereload </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>인텔리J에서 스프링부트 프로젝트 JDK 버전 변경하기</title>
      <link href="2020/12/change-jdk-intellij/"/>
      <url>2020/12/change-jdk-intellij/</url>
      
        <content type="html"><![CDATA[<p>인텔리J에서 스프링부트 프로젝트 JDK 버전을 변경하는 방법에 대한 글이다.</p><h2 id="인텔리J-프로젝트-환경-구성"><a href="#인텔리J-프로젝트-환경-구성" class="headerlink" title="인텔리J 프로젝트 환경 구성"></a>인텔리J 프로젝트 환경 구성</h2><p>인텔리J의 상단 메뉴탭에서 <strong>[File] - [Project Structure]</strong> 에 들어간다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103204019-bd21bb00-4939-11eb-9f4c-1d4695bae57b.png"></p><p>그리고 <strong>[Project]</strong> 에 접속하면 Project의 JDK를 변경할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103204024-bf841500-4939-11eb-8ba9-5de9e9589a63.png"></p><p>마지막으로 Maven 기준으로 pom.xml에서 Java version도 변경해주고, 다시 Maven을 빌드해준다.</p><h2 id="프로젝트-빌드툴-JDK-버전-변경"><a href="#프로젝트-빌드툴-JDK-버전-변경" class="headerlink" title="프로젝트 빌드툴 JDK 버전 변경"></a>프로젝트 빌드툴 JDK 버전 변경</h2><p><img src="https://user-images.githubusercontent.com/33862991/103204444-bb0c2c00-493a-11eb-8a2e-6d2908805089.png"></p><p>여기까지 하면, 인텔리제이에서 스프링부트 프로젝트이 JDK 버전 변경이 끝난다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> ide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDE에서 assertEquals 못불러올 때</title>
      <link href="2020/12/import-assertequals/"/>
      <url>2020/12/import-assertequals/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/103162552-6468fa00-4835-11eb-8b90-dbd036499078.png"></p><p>JUnit으로 단위테스트를 해보려다가 <code>assertEquals()</code>를 개발환경에서 불러오지 못하는 현상이 발생했다.</p><p>현재 단위테스트를 위한 클래스에서 사용하고있는 패키지는 다음과 같다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103162553-66cb5400-4835-11eb-8417-9637dc8bb082.png"></p><br><p>여기까지의 상황을 추론해보면, <code>assertEquals()</code> 가 현재 클래스에서 사용중인 <code>Jupiter.api</code> 패키지에 없다는 사실을 알 수 있다. </p><p>그래서 <code>assertEquals()</code>의 패키지 경로를 수동으로 추가해주었다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103162655-975fbd80-4836-11eb-9837-42a44ecb775b.png"></p><p>수동으로 추가해줬음에도 불구하고, 인텔리제이에서 해당 패키지의 라이브러리를 사용하고 있지 않다고 알려주고 있다. 아직 인텔리제이는 <code>assertEquals()</code>를 찾지 못한것으로 보여진다. 여기서 한 가지 더 추론해본다면, 인텔리제이에서 <code>assertEquals()</code>를 아직 JUnit의 패키지 경로(<code>org.junit.jupiter.api.*</code>)에서 찾고있음을 알 수 있다. </p><p><strong>Assert가 정적 메서드이기 때문이다.</strong></p><p><code>Assert</code> 패키지 경로를 <code>static</code> 으로 선언하면, <code>Assert</code> 와 같은 정적 메서드를 정상적으로 인텔리제이에서 불러올 수 있다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103163273-6afc6f00-483f-11eb-8ae2-e7dbfe6d105e.png"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> intellij </tag>
            
            <tag> error </tag>
            
            <tag> junit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java I/O - 파일 복사하기</title>
      <link href="2020/12/java-io-fileclone/"/>
      <url>2020/12/java-io-fileclone/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1503694978374-8a2fa686963a?ixlib=rb-1.2.1&ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&auto=format&fit=crop&w=1650&q=80"></p><p><code>BufferedReader</code>와 <code>BufferedWriter</code>를 이용하여 파일을 복사하는 과정을 정리해보았다.</p><ol><li>애국가가 작성된 파일을 인텔리제이 프로젝트 디렉토리에 넣어둔다.</li><li>이 파일을 복사하는 메서드를 생성한다.</li><li>이렇게 복사한 파일을 새로운 파일로 생성하는 메서드를 생성한다.</li><li>실행하여 파일이 복사되는지 확인한다. 만약 파일이 이미 존재한다면, Exception을 발생시킨다.</li></ol><br><h2 id="파일을-복사하는-메서드-개발"><a href="#파일을-복사하는-메서드-개발" class="headerlink" title="파일을 복사하는 메서드 개발"></a>파일을 복사하는 메서드 개발</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  파일 읽어들이는 메서드</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filename</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">inputWord</span><span class="params">(String filename, <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  File file = <span class="keyword">new</span> File(filename);  <span class="comment">// 파일존재유무 파악을 위한 File 객체 생성</span></span><br><span class="line">  String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span>(file.exists())&#123;      <span class="comment">// 파일이 존재하는지 확인</span></span><br><span class="line">    <span class="keyword">try</span>(BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename)))&#123;      <span class="comment">// try-with-resource 사용</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        String temp = reader.readLine();   <span class="comment">// 한줄씩 Buffer에 read</span></span><br><span class="line">        <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          str += <span class="string">&quot;\n&quot;</span>+temp;      <span class="comment">// 한줄씩 끊어서 String형 변수에 저장</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;      <span class="comment">// 더이상 읽을 문자열이 없으면 종료</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;파일이 없는데요?&quot;</span>);  <span class="comment">// 파일이 존재하면 Exception 발생</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>먼저 복사하려는 대상 파일이 존재하는지 확인부터 했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(filename);</span><br><span class="line"><span class="keyword">if</span>(file.exists()) &#123; &#125;</span><br></pre></td></tr></table></figure><p><code>File</code> 클래스엔 <code>.exists()</code> 라는 함수가 있는데, 이걸로 파일이 존재하는지 여부를 <code>boolean</code> 타입으로 반환받을 수 있다. 복사대상 파일이므로, 복사대상이 존재하지 않으면 조건절 분기처리로 <code>IOException</code>을 발생시켰다.</p><p>파일이 존재하지 않는다면, <code>try-resource-with</code> 를 작동시킨다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader())) &#123; &#125;</span><br></pre></td></tr></table></figure><p>일반적으로 IO와 관련한 클래스는 사용한 직후에 <code>.close()</code> 를 사용해야 하는데, <code>try-resource-with</code> 를 사용하면 <code>.close()</code> 를 개발자가 닫을 필요없이 알아서 닫힌다. 자바8에서 추가된 기능이다.</p><p>파일을 읽어들이는 클래스인 <code>FileReader</code>를 파라미터로 받는 <code>BufferedReader</code> 객체를 생성했다.</p><p>이제 문자열 변수에 <code>BufferedReader</code> 클래스의 <code>readLine()</code>을 이용하여 한줄씩 읽어들인다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">   String temp = reader.readLine();   <span class="comment">// 한줄씩 Buffer에 read</span></span><br><span class="line">   <span class="keyword">if</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">      str += <span class="string">&quot;\n&quot;</span>+temp;               <span class="comment">// 한줄씩 끊어서 String형 변수에 저장</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;                           <span class="comment">// 더이상 읽을 문자열이 없으면 종료</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이 때 문자열 변수를 2개(<code>str</code>, <code>temp</code>)를 생성했는데, <code>temp</code>는 실제 <code>readLine()</code> 을 이용하여 버퍼에 읽어들인 데이터를 임시저장하는 변수이고, <code>str</code>은 <code>temp</code>에 데이터가 있을경우, 즉 데이터가 읽어들여졌을경우 이어붙여서 저장하고 최종적으로 메서드의 반환타입으로 반환될 변수이다.  </p><p>만약 버퍼에 읽어들인 데이터가 없을 경우는 for 문을 종료하도록 했다.</p><br><br><h2 id="파일을-생성하는-메서드-개발"><a href="#파일을-생성하는-메서드-개발" class="headerlink" title="파일을 생성하는 메서드 개발"></a>파일을 생성하는 메서드 개발</h2><p>파일을 읽어들이는 메서드를 생성했으므로 이제 복사하는 기능은 개발되었다. 이렇게 복사한 데이터를 새로 생성한 파일에 작성(Writer)하여 최종적으로 복사본을 생성하는 메서드를 개발할 차례이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  파일 생성(출력)하는 메서드</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> filename</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createCloneFile</span><span class="params">(String filename, String target, <span class="keyword">int</span> size)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   File file = <span class="keyword">new</span> File(filename);   <span class="comment">// 파일존재유무 파악을 위한 File 객체 생성</span></span><br><span class="line">   <span class="keyword">if</span>(file.exists())&#123;             <span class="comment">// 파일이 존재하는지 확인</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;같은 이름의 파일이 이미 존재합니다.&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span>(BufferedWriter newFile = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(filename)))&#123;</span><br><span class="line">         newFile.write(inputWord(target, size));   <span class="comment">// inputWord()로 파일을 읽어들이고, 새 파일로 복제</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번에도 파일 존재유무를 확인하고, 파일이 존재하면, <code>IOException</code> 을 발생시켰다. 이번엔 위와 다르게 했는데 이유는 새로운 파일을 생성해야하는데, 파일이 이미 존재하면 파일을 덮어씌워지는 의도하지 않은 상황이 발생할 수 있으므로 <code>.exists()</code> 에서 <code>true</code>를 반환할경우 <code>IOException</code>을 발생시켰다.</p><p>그리고 이번에도 <code>try-resource-with</code> 로 <code>BufferedWriter</code> 객체를 생성했다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>(BufferedWriter newFile = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(filename))) &#123; &#125;</span><br></pre></td></tr></table></figure><p>이렇게 생성한 <code>BufferedWriter</code> 객체에 작성할 데이터는 위에서 만들어놓은 <code>inputWord()</code>를 이용하여 데이터를 입혔다. 이제 파일을 복사하고 복사본 파일을 생성하는것까지 구현하였다.</p><br><h2 id="메인-메서드-개발"><a href="#메인-메서드-개발" class="headerlink" title="메인 메서드 개발"></a>메인 메서드 개발</h2><p>이제 위에서 만든 메서드를 실행하는 메인 메서드를 개발할 차례이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">   String target = <span class="string">&quot;korean.txt&quot;</span>;</span><br><span class="line">   String cloneFile = <span class="string">&quot;clone.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 타겟 대상 파일 읽어들여서 콘솔에 출력하기</span></span><br><span class="line">   String fileread = inputWord(target, <span class="number">1000</span>);</span><br><span class="line">   System.out.println(fileread);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 파일 읽어들여서 다른이름의 파일 생성하기</span></span><br><span class="line">   createCloneFile(cloneFile, target, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&quot;korean.txt&quot;</code> 라는 이름의 파일을 복사할 것이고, 이렇게 복사해서 새로 생성될 파일 이름은 <code>&quot;clone.txt&quot;</code> 이다.</p><p>사실 콘솔에서 확인하기 위하여 몇 줄 더 작성하긴 했지만, 메인 메서드에서 중요한 코드는 마지막 한 줄이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createCloneFile(cloneFile, target, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p><code>target</code> 파일을 1000줄까지 읽어들이고, <code>cloneFile</code>을 생성하라는 코드이다.</p><br><h2 id="파일-복제-테스트"><a href="#파일-복제-테스트" class="headerlink" title="파일 복제 테스트"></a>파일 복제 테스트</h2><p>정상적으로 복사본이 생성되었다면 아래와 같은 화면을 볼 수 있을 것이다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103134487-ccfc8d80-46f4-11eb-8f7b-53d647513de7.png"></p><p>만약 이미 같은 이름의 파일이 존재한다면 아래와 같이 <code>IOException</code>이 발생한걸 확인할 수 있다.</p><p><img src="https://user-images.githubusercontent.com/33862991/103134494-d1c14180-46f4-11eb-9abf-381da7a13a3c.png"></p><p>이 코드 내용은 Github Gist에 <a href="https://gist.github.com/youngjinmo/3a30b98558d7281a798aace72af1dc6e">공개</a>해두었다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> IO </tag>
            
            <tag> BufferedReader </tag>
            
            <tag> BufferedWriter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot로 Hello World 화면에 출력해보기(With Mustache)</title>
      <link href="2020/12/springboot-helloworld/"/>
      <url>2020/12/springboot-helloworld/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/104319420-2dc4fc00-5524-11eb-8802-5e7cd62e72ae.jpeg"></p><p>간단한 튜토리얼인데, 최근에 간단한 Spring MVC 개발할 일이 있었는데, 지금까지 모르면서 간과하며 개발했던걸 알게되어 정리하고자 남기는 포스팅이다.<br>어떤걸 모르면서 개발했는지는 포스팅에서 자세히 설명하도록 하겠다.</p><h2 id="프로젝트-생성하기"><a href="#프로젝트-생성하기" class="headerlink" title="프로젝트 생성하기"></a>프로젝트 생성하기</h2><p>본 튜토리얼은 <a href="https://spring.io/tools">Spring Tool Suite 4.4.9(STS)</a>으로 진행했다.</p><p><img src="https://user-images.githubusercontent.com/33862991/102748400-7403c100-43a5-11eb-82f4-fd21884dd968.PNG"></p><p>STS를 실행하고 <strong>[FILE]</strong> 에서 <strong>[Spring Start Project]</strong> 를 실행한다.</p><p><img src="https://user-images.githubusercontent.com/33862991/102748412-7e25bf80-43a5-11eb-9a34-0f236ab9d415.PNG"></p><p>프로젝트명은 <strong>HelloSpringBootApp</strong> 으로 생성했다.</p><p><img src="https://user-images.githubusercontent.com/33862991/102748408-79610b80-43a5-11eb-8a5e-19ef09d19dbc.PNG"></p><p>간단한 Hello World를 출력하는 스프링부트앱을 만들기 위해서는 Spring Web과 Mustache를 의존성으로 불러와야한다. Mustache는 화면에서 HTML 파일을 반환하기 위한 ViewResolver를 위해 필요한 의존성이다. Mustache가 아니어도 Thymeleaf 의존성을 불러와도 무방하다.</p><p><a href="https://mustache.github.io/">Mustache</a>는 Thymeleaf와 달리 백엔드 개발자가 화면에서 로직을 구현할 수 없는 logicless 템플릿엔진이다.</p><br><h2 id="HTML-페이지-생성하기"><a href="#HTML-페이지-생성하기" class="headerlink" title="HTML 페이지 생성하기"></a>HTML 페이지 생성하기</h2><p>스프링부트 프로젝트에서는 <code>src/main/resources</code>에서 HTML 파일을 관리한다. 해당 디렉토리 하위에는 static과 templates 디렉토리가 있는데, static은 말그대로 정적인 자원을 반환할때 사용하는 디렉토리이고, templates는 스프링 컨테이너에 의해 동적으로 반환될 자원을 사용하는 디렉토리이다.</p><p>본 튜토리얼에서는 둘 다 사용하며 어떤 차이가 있는지 확인하려고 한다.</p><p>똑같이 hello.html 파일을 각각 src와 template 디렉토리에 생성한다.</p><p><img src="https://user-images.githubusercontent.com/33862991/102749429-5afc0f80-43a7-11eb-8725-7e0062980962.PNG"></p><p>그러나 파일내부는 서로 다른 코드를 작성해서 브라우저에서 어떻게 반환되는지를 구별하려고 한다.</p><p><strong>static/hello.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 한글 utf-8 설정 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>SpringMVC - static<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello Spring Boot!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">이것은 static 페이지입니다.</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>templates/hello.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 한글 utf-8 설정 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>SpringMVC - templates<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello SpringBoot!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">이것은 컨트롤러에 의해 동적으로 반환되는 템플릿 html입니다.</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이 파일이 스프링 컨테이너에서 찾을수 있도록 하기 위해서는 resources 디렉토리에 있는 application.properties에서 설정을 한 줄 추가한다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.mustache.suffix</span>: <span class="string">.html</span></span><br></pre></td></tr></table></figure><p>이 설정을 넣어야 Mustache가 화면으로 읽어들일 자원의 포맷으로 html을 읽어들이게 된다.</p><p>이제 static 디렉토리와 templates 디렉토리에 이름만 같고 코드는 다른 hello.html을 생성하는 작업이 끝났다.</p><h2 id="컨트롤러-생성하기"><a href="#컨트롤러-생성하기" class="headerlink" title="컨트롤러 생성하기"></a>컨트롤러 생성하기</h2><p>위에서 생성한 html 파일을 반환하도록 요청하는 컨트롤러를 생성하는 작업이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">HelloController</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/hello)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 주의해야할 점이 있다. 컨트롤러를 생성하는 패키지 경로는 <code>SpringApplication.run()</code>이 있는 <span style="color: red;">스프링부트 애플리케이션 클래스와 같은 경로</span>에 있어야 한다.</p><p>내가 그동안 아무생각없이 Spring MVC 개발을 하다가 당황스러웠던 경험도 이 때문이었다. 스프링부트 애플리케이션과 다른 경로에 패키지를 설정하면 컨트롤러가 제대로 작동되지 않는다.<br>아래 이미지를 참고하자.</p><p><img src="https://user-images.githubusercontent.com/33862991/102851220-9b6a9480-445e-11eb-8914-75e92a616e78.png"></p><h2 id="API-요청하기"><a href="#API-요청하기" class="headerlink" title="API 요청하기"></a>API 요청하기</h2><p>이제 스프링부트웹앱을 브라우저에서 실행해서 위에서 만든 html 파일들을 어떻게 반환받을 수 있는지 알아보자.</p><p>첫번째로는 static 디렉토리에 있는 정적인 파일을 반환받으려고 한다. 브라우저 주소창에 <code>localhost:8080/hello.html</code> 이라고 입력하면 아래와 같이 정상적으로 화면이 출력된다.</p><p><img src="https://user-images.githubusercontent.com/33862991/102761451-4117f800-43ba-11eb-81bf-46003af2c546.PNG"></p><p>이번에는 templates 디렉토리에 있는 동적인 파일을 반환받으려고 한다. 브라우저 주소창에 <code>localhost:8080/hello</code> 라고만 입력하면 아래처럼 화면을 출력받을 것이다.</p><p><img src="https://user-images.githubusercontent.com/33862991/102761453-42492500-43ba-11eb-83b8-0cc93bcc14c0.PNG"></p><p>여기까지는 사실 파일의 확장자를 붙이느냐, 안붙이느냐 정도의 차이만 구별되는데, 동적으로 파일을 반환할 수 있는 templates 자원의 경우 API를 요청할때 들어오는 인자값에 따라 화면에 인자값을 출력하거나 값을 가공하여 동적으로 반환할 수도 있다.</p><p>이를위해 templates 디렉토리에 있는 파일과 컨트롤러를 수정해보겠다.</p><p><strong>templates/hello.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 한글 utf-8 설정 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>SpringMVC - templates<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello SpringBoot!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">Welcome, &#123;&#123;name&#125;&#125;.</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>HelloController.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">HelloController</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/hello)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name, Model model)</span></span>&#123;</span><br><span class="line">      model.addAttribute(<span class="string">&quot;name&quot;</span>, name);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello()의 파라미터로 2가지를 주입했다. String형 <code>name</code>은 클라이언트로부터 입력받는 값을 <code>name</code>이라는 변수에 담기 위함이며, Model 객체는 화면에 뿌려주기 위해 필요한 객체이다.<br>Model 객체의 <code>addAttribute()</code>를 이용하면, Model 객체에 값을 저장하여 화면에 뿌려준다.</p><p>이 때, <code>addAttribute(&quot;name&quot;, name)</code>의 첫번째 파라미터가 화면에서 받을 property 이름이며, 두번째 파라미터가 이 model 객체로 넣을 파라미터 객체이다.</p><p>그럼 이제 브라우저에 아까와 다른 URL를 요청해보자.</p><p><code>localhost:8080/hello?name=devandy</code></p><p><img src="https://user-images.githubusercontent.com/33862991/102761133-d666bc80-43b9-11eb-835b-13efb9990212.PNG"></p><p>다른 이름을 대입하면 그 이름이 화면에 출력될 것이다. 이것이 API 컨트롤러와 templates 경로내 자원으로 할 수 있는 일이다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> mustache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello, Vue.js</title>
      <link href="2020/12/hello-vue/"/>
      <url>2020/12/hello-vue/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.ytimg.com/vi/DsuTwV0jwaY/maxresdefault.jpg"></p><h2 id="What-is-Vue"><a href="#What-is-Vue" class="headerlink" title="What is Vue"></a>What is Vue</h2><p>공식문서를 보면, 사용자 UI를 위한 Progressive Framework라고 소개한다. View layer에 맞추어 다른 프로젝트와의 통합이 쉬운 편이라고 하며, View를 강조하기 위해 이와 비슷하게 들리는 Vue로 이름을 지었다고 한다.</p><p>데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공한다고 한다.</p><p>처음 회사에 들어왔을 때 배운 웹스퀘어처럼 비동기적으로 데이터를 바인딩하는 UI 프레임워크인것으로 보인다.</p><br><h2 id="Vue-Instance"><a href="#Vue-Instance" class="headerlink" title="Vue Instance"></a>Vue Instance</h2><p>모든 Vue 앱은 Vue 함수로 새 Vue 인스턴스를 만드는것부터 시작한다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// Vue.js</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue 앱은 <code>new Vue</code> 를 통해 만들어진 루트 Vue 인스턴스로 구성된다고 한다. 재사용 가능한 컴포넌트 트리로 구성할 수 있으며, Todo 앱을 구현한다고 하면, 앱의 컴포넌트 트리는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Root Instance</span><br><span class="line">└─ TodoList</span><br><span class="line">   └─ TodoItem</span><br><span class="line">   |  └─ DeleteTodoButton</span><br><span class="line">   |  └─ EditTodoButton</span><br><span class="line">   └─ TodoListFooter</span><br><span class="line">      └─ ClearTodosButton</span><br><span class="line">      └─ TodoListStatistics</span><br></pre></td></tr></table></figure><p>출처 : <a href="https://kr.vuejs.org/v2/guide/instance.html">https://kr.vuejs.org/v2/guide/instance.html</a></p><br><h2 id="Model-view-viewmodel"><a href="#Model-view-viewmodel" class="headerlink" title="Model-view-viewmodel"></a>Model-view-viewmodel</h2><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/MVVMPattern.png/500px-MVVMPattern.png"></p><br><h2 id="Instance-Lifecycle-Hook"><a href="#Instance-Lifecycle-Hook" class="headerlink" title="Instance Lifecycle Hook"></a>Instance Lifecycle Hook</h2><p>Vue의 각 인스턴스는 생성될 때 일련의 초기화 단계를 거치며, 템플릿을 컴파일 하는 경우, 인스턴스를 DOM에 마운트하는 경우, 그리고 데이터가 변경되어 DOM을 업데이트하는 경우가 발생한다.</p><p>그 과정에서 사용자 정의 로직을 실행할 수 있는 라이프사이클 훅도 호출된다.</p><br><h2 id="Lifecycle-Diagram"><a href="#Lifecycle-Diagram" class="headerlink" title="Lifecycle Diagram"></a>Lifecycle Diagram</h2><img src="https://kr.vuejs.org/images/lifecycle.png" style="zoom:50%;" /><br><h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><h3 id="install-node"><a href="#install-node" class="headerlink" title="install node"></a>install node</h3><p><a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><h3 id="install-vue"><a href="#install-vue" class="headerlink" title="install vue"></a>install vue</h3><p><a href="https://vuejs.org/v2/guide/installation.html">https://vuejs.org/v2/guide/installation.html</a></p><br><h2 id="Hello-Vue"><a href="#Hello-Vue" class="headerlink" title="Hello Vue"></a>Hello Vue</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue.js Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue-app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">                el: <span class="string">&#x27;#vue-app&#x27;</span>,</span></span><br><span class="line">                data: &#123;</span><br><span class="line"><span class="javascript">                    message: <span class="string">&#x27;Hello World&#x27;</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>script 코드로 Vue 객체를 생성한다. 단 이 때 Vue를 cdn으로 가져와야 페이지에서 Vue가 동작한다.</p><p><code>el</code> 은 DOM에서 셀렉트 영역을 선택하는 속성이다. id가 <code>vue-app</code> 을 선택해야지만 해당 영역을 선택하고, Vue를 동작시킨다.</p><p><code>data</code> 는 비동기적으로 화면에 전달되는 데이터를 의미한다. 화면에서 <code>&#123;&#123; name &#125;&#125;</code> 이라고 입력하면, Vue의 data 속성중 <code>message</code> 라는 이름의 값이 출력된다.</p><br><h2 id="v-if-gt-조건문"><a href="#v-if-gt-조건문" class="headerlink" title="v-if -&gt; 조건문"></a>v-if -&gt; 조건문</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue.js Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue-app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;brazil&quot;</span>&gt;</span>Brazil won the worldcup champion in 2002.<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&quot;france&quot;</span>&gt;</span>France won the Worldcup champion in 1998.<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app =<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#vue-app&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        brazil: <span class="literal">true</span>,</span><br><span class="line">        france: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p> <code>v-if</code> 를 사용하면, 조건에 따라 화면에 출력여부를 결정할 수 있다.</p><br><h2 id="v-for-gt-반복문"><a href="#v-for-gt-반복문" class="headerlink" title="v-for -&gt; 반복문"></a>v-for -&gt; 반복문</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue.js Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue-app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-for</span>=<span class="string">&quot;player in players&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; player.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">&#x27;#vue-app&#x27;</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">      players: [</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Minkyun Kim&#x27;</span> &#125;,</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Leandro&#x27;</span> &#125;,</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Sangmin Lee&#x27;</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>v-for</code> 태그를 사용하여 for-loop를 구현한다. 처음 할 때 조금 신기하다고 생각했던건 그냥 문자열같은 <code>v-for</code>의 값도 <code>elements in list</code> 구조로 파싱하여 elements를 추출한다는점이었다.</p><p>위의 코드는 <code>players</code> 라는 Vue 객체의 요소를 <code>player</code> 라는 이름으로 바인딩해서 화면에서 <code>&lt;li&gt;</code> 태그로 출력한다.  </p><p>리스트에 새로운 이름을 추가(Push) 할 수도 있다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">&#x27;#vue-app&#x27;</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">      players: [</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Minkyun Kim&#x27;</span> &#125;,</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Leandro&#x27;</span> &#125;,</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Sangmin Lee&#x27;</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.players.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;New player!&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><br><h2 id="v-on-click-gt-이벤트-처리"><a href="#v-on-click-gt-이벤트-처리" class="headerlink" title="v-on:click -&gt; 이벤트 처리"></a>v-on:click -&gt; 이벤트 처리</h2><p>버튼을 생성해서 버튼을 클릭하면 텍스트를 변경하는 함수를 추가했다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue.js Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue-app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; club &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;changeclub&quot;</span>&gt;</span>Change Club<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-for</span>=<span class="string">&quot;player in players&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123; player.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">&#x27;#vue-app&#x27;</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">      players: [</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Minkyun Kim&#x27;</span> &#125;,</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Leandro&#x27;</span> &#125;,</span><br><span class="line">         &#123; <span class="attr">name</span>: <span class="string">&#x27;Sangmin Lee&#x27;</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      club: <span class="string">&#x27;Seoul Eland FC&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   methods: &#123;</span><br><span class="line">      changeclub = <span class="string">&#x27;Seoul City FC&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.players.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;New player!&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p><code>v-on:click=&quot;changeclub&quot;</code> 속성을 <code>&lt;button&gt;</code> 에 추가해서 버튼을 클릭하면, <code>changeclud</code> 함수를 실행하도록 구현했다.</p><br><h2 id="v-model-gt-양방향-바인딩"><a href="#v-model-gt-양방향-바인딩" class="headerlink" title="v-model -&gt; 양방향 바인딩"></a>v-model -&gt; 양방향 바인딩</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue.js Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue-app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; club &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">&#x27;#vue-app&#x27;</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">       message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>&lt;input&gt;</code> 태그로 들어오는 값을 바인딩하여 화면에 값을 동적으로 변경하는 코드이다.</p><br><h2 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h2><p>HTML Element를 확장하여 재사용 가능한 코드를 캡슐화하는 Vue의 기능이다. </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>Vue.js Sample<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;index.css&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;vue-app&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">todo-item</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">todo-item</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="line">   template: <span class="string">&#x27;&lt;li&gt;This is Vue.js Component&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">&#x27;#vue-app&#x27;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/33862991/100982465-6bc91a80-358b-11eb-8123-64856c506cad.JPG"></p><p>Vue 객체를 생성해서 <code>component()</code>안에 이름을 지정하고 <code>&#123; template : &#125;</code> 안에 입력한 HTML Element를 화면에 뿌린다.</p><p>HTML에서는 <code>Vue.Component()</code>에서 지정한 컴포넌트 이름으로 태그를 만들면 <code>Vue.component()</code>로 생성한 Element를 화면에서 출력한다.</p><p>출처 : <a href="https://kr.vuejs.org/v2/guide/components.html">https://kr.vuejs.org/v2/guide/components.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>신입개발자가 생각하는 개발 문서</title>
      <link href="2020/11/how-to-write-readme/"/>
      <url>2020/11/how-to-write-readme/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1461773518188-b3e86f98242f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80"></p><p>주말에 진행하고 있는 사이드 프로젝트에서 본격적인 프로젝트 개발 전에 개발 문서를 작성하며 시작하자는 이야기가 나왔다. 현재 파견나와 있는 프로젝트에서 하는 것처럼 전통적인 메뉴얼 느낌의 문서가 아닌 개발자들을 위한 개발 문서를 이야기하는 것이다. 이 문서에서는 코딩 컨벤션이나 변수명 규칙 등 사소하지만 개발할 때 고민하는 시간을 줄여주거나 충돌을 피하게 해주는 꽤 중요한 부분들이라고 생각한다.</p><p>그런데 회사에서도 개발 문서를 작성하자는 이야기가 나왔다. 향후 확장성을 고려해서 마크업 언어로 문서를 작성하자고 이야기가 나와서 한 번 정리하면 좋겠다는 생각이 들어 정리를 하게 되었다.</p><blockquote><p>본문에 앞서 이 글은 6개월차 신입 개발자가 작성했음을 알려드립니다.<br>부족한 내용이 있을수 있고, 심지어는 잘못 이해하여 오해하고 있는 부분이 있을 수 있습니다. 이런 부분에 대해서는 가감없이 댓글로 지적해주시면 감사하겠습니다.</p></blockquote><br><h2 id="왜-개발-문서를-쓰는가"><a href="#왜-개발-문서를-쓰는가" class="headerlink" title="왜 개발 문서를 쓰는가"></a>왜 개발 문서를 쓰는가</h2><p>난 항상 <span style="color: red;">Why</span>가 가장 중요하다고 생각한다. Why가 중요하다고 느낀 한 가지 사례를 이야기해보겠다.<br>최근에 테스트 코드를 작성하는 법을 배웠는데, 이 테스트를 통해서 개발자가 의도한대로 서비스 플로우가 정상 작동하는지 파악하는 과정이다. 그리고 이런 테스트가 중심이 되는 개발방식을 TDD(Test Driven Development)라고 한다. <span style="color: red;">TDD에선 테스트 코드를 먼저 작성</span>하며 개발을 한다고 한다.</p><p>사이드 프로젝트에선 테스트 코드까지 작성하는게 하나의 사이클이다보니 여전히 테스트 코드에 대한 이해도는 부족하나 조금씩 익숙해져 가고 있다.</p><p>테스트 코드를 작성하면서 느낀건, 테스트 코드를 통해 확인하는건 단지 이 코드가 정상 작동하는지를 파악할 뿐 아니라 개발자가 <span style="color: red;">어떤 코드를 필요한지</span> 정리하는 과정같다는 생각이 들었다. 테스트 코드를 통해 입력받는 값은 무엇인지 <em>(given)</em>, 이 코드가 서비스 플로우에서 언제 처리되며 <em>(when)</em>, 그래서 어떤 값을 반환하는지 <em>(then)</em>. </p><blockquote><p><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=241936778">Refactoring</a> 의 저자 Martin Fowler는 테스트 코드를 작성할 때 위와같이 given, when, then의 방식으로 테스트 코드를 작성하라고 말한다.<br>출처 : <a href="https://martinfowler.com/bliki/GivenWhenThen.html">GivenWhenThen - martinfowler.com</a></p></blockquote><p>테스트 코드를 작성하며 정리를 한 다음, 실제 코드를 작성하게 됨으로써 불필요한 코드를 작성할 일을 사전에 방지할 수 있는 효과도 기대할 수 있다고 생각한다.</p><p>이런걸 이해하니까 테스트 코드가 왜 필요한지를 더 분명하게 이해할 수 있었다. 이같은 Why는 어떠한 행동을 이끌어내는데 가장 강력한 <strong>motivation</strong> 이라고 생각한다.</p><h3 id="그래서-왜-왜-왜-개발문서를-써야하는가"><a href="#그래서-왜-왜-왜-개발문서를-써야하는가" class="headerlink" title="그래서 왜 왜 왜 개발문서를 써야하는가?"></a>그래서 왜 왜 왜 개발문서를 써야하는가?</h3><p><img src="https://media.giphy.com/media/s142Kq18w5DCo/giphy.gif" alt="출처 : Giphy"></p><p>이 글을 읽는 개발자라면, 당신도 어딘가에서 어떠한 프로젝트를 수행중일 것이다. 프로젝트의 수명이 아직 끝나지 않은 상황에서 현 프로젝트의 개발자들이 어느날 갑자기 이직을 선언한다면 어떨것 같은가?<br>혹은 이 프로젝트의 A to Z를 다 알고있는 개발자가 갑자기 아침 출근길에 교통사고를 당해서 2주간 출근할 수 없게 된다면?</p><p>이런 끔찍한 상황을 제외하더라도 프로젝트 단위로 계약을 맺는 프리랜서 개발자들이 아니라면, 프로젝트의 수명과 개발자는 항상 운명을 같이 할 수 없다. 아니 이를 보장할 수 없다.</p><p>개발중인 프로젝트에 신규 개발자가 투입되는 일은 이처럼 특별한 일이 아니다. 이미 몇년간 개발과 유지보수를 이어온 프로젝트라면, 중간에 합류한 개발자에게 해당 프로젝트의 아키텍처는 복잡하게 느껴질 것이며, 봐야할 소스코드의 양도 상당할 것이다. 그런데 이를 가이드할 사람이 없다면 어떻게 해야할까?</p><p>결국 문서다. 우리가 새로운 유형의 전자제품을 구입했을때 메뉴얼을 보고 설치/사용법을 익히듯 프로젝트에 대한 개발 문서는 너무나 당연히 필요한 존재이다. 신규 개발자가 프로젝트에 투입되어서 프로젝트를 파악하는 시간을 줄일 수 있는 가장 효율적인 방법이 개발 문서인 것이다.</p><p><img src="https://media.giphy.com/media/8dYmJ6Buo3lYY/giphy.gif" alt="출처 : Giphy"></p><br><h2 id="그래서-개발-문서는-어떻게-쓰는가"><a href="#그래서-개발-문서는-어떻게-쓰는가" class="headerlink" title="그래서 개발 문서는 어떻게 쓰는가?"></a>그래서 개발 문서는 어떻게 쓰는가?</h2><h3 id="1-친절한-설명은-비용을-낮춘다"><a href="#1-친절한-설명은-비용을-낮춘다" class="headerlink" title="1. 친절한 설명은 비용을 낮춘다"></a>1. 친절한 설명은 비용을 낮춘다</h3><p>Github에 있는 오픈소스 프로젝트들을 보면, 모든 프로젝트가 첫 페이지에 README를 보여주고 있다. 이 README를 통해 이 프로젝트가 어떤 프로젝트이며, 이 프로젝트를 사용하기 위해서 어떤 절차가 필요한지를 쉽게 이해할 수 있다.</p><p>Github에서 본 README 문서중 잘 정리가 된듯한 README 문서 몇가지를 예시로 사용하려고 한다. 그리고 이 문서들의 목록(<a href="https://ko.wikipedia.org/wiki/TOC">ToC</a>)을 정리해보았다.</p><ul><li><a href="https://github.com/cli/cli">Github CLI</a><ul><li>Short description with images.</li><li>Documentation(사용법)</li><li>Contributing (프로젝트 기여하는 법)</li><li>Installation</li></ul></li><li><a href="https://github.com/jhy/jsoup">Jsoup</a><ul><li>Short description</li><li>Example</li><li>Open Source (License)</li><li>Getting Started</li><li>Development and Support (Contact)</li><li>Status (배포 상태)</li></ul></li><li><a href="https://github.com/kakao/kakao.github.io">Tech Kakao (Archived)</a><ul><li>설치</li><li>사용법</li><li>라이센스</li><li>주의할 점</li></ul></li></ul><p>위 3개의 문서에서 발견한 공통적인 목록은 프로젝트를 소개하는 <span style="color: red;">짧은 설명</span>과 <span style="color: red;">사용법</span>을 정리했다는 점이 공통적이다. </p><p>마지막으로 프로젝트의 라이센스를 표기함으로써 문서가 마무리된다. </p><p>중요한건 사용법이라는 생각이 든다. 얼마나 친절하게 쓰여있는지에 따라 프로젝트에 참여/실행하는 비용이 낮아진다. 문서가 불친절할수록 해당 프로젝트에 대한 접근성이 떨어지며, 이는 곧 비용의 상승으로 이어진다.</p><p>가독성 높은 README 를 작성하는 방법을 정리하는 글을 인용한다.</p><ul><li><a href="https://blog.bitsrc.io/how-to-write-beautiful-and-meaningful-readme-md-for-your-next-project-897045e3f991">How to Write Beautiful and Meaningful README.md</a></li></ul><p>이 글에서 인상깊은 부분은 설명을 위한 이미지를 첨부하라는 것. 사실 텍스트보다 훨씬 가독성 높은건 이미지이다. 프로젝트를 실행/동작하는 스크린샷을 첨부한다면 보다 쉽게 이해할 수 있을 것이다.</p><p>프로젝트를 실행/동작시키는 방법도 GIF 포맷으로 만든다면 금상첨화일 것 같다. </p><h3 id="2-Markdown으로-작성하기"><a href="#2-Markdown으로-작성하기" class="headerlink" title="2. Markdown으로 작성하기"></a>2. Markdown으로 작성하기</h3><p>README 문서는 Markdown 기반으로 작성된다. 여기서도 Why를 물어보자. 왜 Markdown으로 작성하는가.</p><p>먼저 마크업 언어로 문서를 작성하는 이유부터 알아보자. 개인적인 추론이라는 점을 서두에 밝힌다.</p><p>HTML 문서는 PDF로 export하기도 쉽고, 그 자체를 웹에 배포할 수도 있다. 따라서 확장성이 높다고 할 수 있다. 그런데 HTML 문서를 작성하는건 모두에게 쉬운 일은 아니다. 일일히 태그를 열고 닫아야 하며, CSS 까지 신경써야 한다.</p><p>여기서부터는 마크업 문서를 만들기 위해 Markdown을 사용해야하는 이유를 알아보자.</p><table><thead><tr><th>Column A</th><th>Column B</th></tr></thead><tbody><tr><td>A-value1</td><td>B-value1</td></tr><tr><td>A-value2</td><td>B-value2</td></tr></tbody></table><p>한 예로 위와 같은 테이블을 생성한다고 하면 HTML로 작성한다고 하면 아래처럼 길게 늘어뜨려야 한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Column A<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>column B<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>A-value1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>B-value1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>A-value2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>B-value2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>고작 컬럼 2개, 로우 2개를 갖는 테이블을 생성하기 위해 이렇게 태그를 열고 닫기를 반복해야 한다면, 문서 작성을 포기하더라도 이해가 된다.</p><p>그런데 Markdown을 이용하면, 보다 쉽게 마크업 페이지를 만들어낼 수 있다. 위에서 만든 똑같은 테이블을 Markdown으로 작성해보았다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|Column A|Column B|</span><br><span class="line">|A-value1|B-value1|</span><br><span class="line">|A-value2|B-value2|</span><br></pre></td></tr></table></figure><p>이게 Markdown을 사용해야 하는 이유이다.</p><br><p><img src="https://user-images.githubusercontent.com/33862991/99767382-4b8a6c00-2b46-11eb-9172-436dfc7ca69a.JPG" alt="출처 : Markdown Guide"></p><p>Markdown 문법은 <a href="https://www.markdownguide.org/cheat-sheet">Markdown Cheat Sheet</a>를 보며 문서를 하나 직접 작성해보면 금방 익힐 수 있다. 이 글에선 문법을 나열하지는 않겠다.</p><p>Markdown 에디터는 여러가지가 있지만, Typora를 추천한다. Typora를 사용하면 Preview 화면(<a href="https://www.makeareadme.com/#rendered-1">Rendered</a>)으로 보면서 작성할 수 있기 때문에 효율적으로 문서를 작성할 수 있다.</p><p><img src="https://support.typora.io/media/files/Screen%20Shot%202019-01-06%20at%2022.18.56.png" alt="출처 : Typora"></p><br><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>정리되지 않은 생각을 쓰면서 정리하다보니 글이 장황해졌지만, 결론은 <strong>친절한 개발 문서를 작성하는 습관을 들이자.</strong> </p><p>개발 문서는 프로젝트의 시작과 끝이 되어야 한다고 생각한다. 내가 작성한 코드가, 우리가 만든 프로젝트가 나에게만 또는 우리에게만 이해하기 쉬운 코드일지 모른다. 그러니 신규 개발자가 이 개발문서를 보고 빠르게 프로젝트를 이해할 수 있도록 친절한 개발 문서를 작성하도록 노력해야겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> documentation </tag>
            
            <tag> readme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lombok 라이브러리</title>
      <link href="2020/11/lombok/"/>
      <url>2020/11/lombok/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/98791938-1a74b200-2449-11eb-8112-f06b4b5feb31.jpg"></p><h2 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h2><ul><li><a href="#why">Why Lombok</a></li><li><a href="#change">How can be change</a></li><li><a href="#annotations">Lombok Annotations</a></li><li><a href="#install">How to use</a></li></ul><h2 id="Why-Lombok"><a href="#Why-Lombok" class="headerlink" title="Why Lombok?"></a><a name="why"></a>Why Lombok?</h2><p>VO를 작성할 때면, 거의 생각하지 않고 반복적으로 작성하는 코드가 있다. <code>getter()</code>, <code>Setter()</code>, <code>ToString()</code> 그리고 생성자이다. </p><p>VO에 정의된 필드가 많을수록 코드에 대한 가독성이 떨어질수밖에 없다. 필드 개수의 2배수만큼의 메서드 (Getter/Setter)를 생성하기 때문에 다른 메서드가 있는지 확인하려면 스크롤해서 내려가야 한다.</p><p>그러나 <a href="https://projectlombok.org/">Lombok</a> 라이브러리를 사용하면, Getter, Setter 메서드로 코드를 어지럽게 작성할 필요도, 생성자를 작성할 필요도 없다. 딱 필드만 남게되므로 오히려 코드의 가독성이 높아진다.<br><br></p><h2 id="How-can-be-change"><a href="#How-can-be-change" class="headerlink" title="How can be change?"></a><a name="change"></a>How can be change?</h2><p>Lombok을 적용하기 전과 Lombok을 적용한 이후 어떻게 달라지는지 확인해보자.</p><h3 id="Before-Lombok"><a href="#Before-Lombok" class="headerlink" title="Before Lombok"></a>Before Lombok</h3><p>임의로 만들어본 VO 객체이다. 게시판을 만든다고 생각하고 게시판에 필요한 6개의 필드를 작성했으며, 이 필드를 사용하는 <code>Getter()</code>, <code>Setter()</code>, <code>toString()</code>, 생성자를 만들었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.domain.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Domain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String author;</span><br><span class="line">  <span class="keyword">private</span> String createdDate;</span><br><span class="line">  <span class="keyword">private</span> String updatedDate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hit;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> no;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.no = no;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getCreatedDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createdDate;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreatedDate</span><span class="params">(String createdDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.createdDate = createdDate;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getUpdatedDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> updatedDate;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUpdatedDate</span><span class="params">(String updatedDate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.updatedDate = updatedDate;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hit;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHit</span><span class="params">(<span class="keyword">int</span> hit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hit = hit;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Domain [no=&quot;</span> + no + <span class="string">&quot;, title=&quot;</span> + title + </span><br><span class="line">      <span class="string">&quot;, author=&quot;</span> + author + <span class="string">&quot;, createdDate=&quot;</span> + createdDate + </span><br><span class="line">      <span class="string">&quot;, updatedDate=&quot;</span> + updatedDate + <span class="string">&quot;, hit=&quot;</span> + hit + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Domain</span><span class="params">(<span class="keyword">int</span> no, String title, </span></span></span><br><span class="line"><span class="function"><span class="params">                String author, String createdDate, </span></span></span><br><span class="line"><span class="function"><span class="params">                String updatedDate, <span class="keyword">int</span> hit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.no = no;</span><br><span class="line">    <span class="keyword">this</span>.title = title;</span><br><span class="line">    <span class="keyword">this</span>.author = author;</span><br><span class="line">    <span class="keyword">this</span>.createdDate = createdDate;</span><br><span class="line">    <span class="keyword">this</span>.updatedDate = updatedDate;</span><br><span class="line">    <span class="keyword">this</span>.hit = hit;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4가지 기능(Getter, Setter, toString, 생성자)을 추가했을 뿐인데, 코드가 엄~청 길어졌다..<br>이제 Lombok을 적용해보자.</p><h3 id="After-Lombok"><a href="#After-Lombok" class="headerlink" title="After Lombok"></a>After Lombok</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.domain.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Getter</span> <span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Domain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">  <span class="keyword">private</span> String title;</span><br><span class="line">  <span class="keyword">private</span> String author;</span><br><span class="line">  <span class="keyword">private</span> String createdDate;</span><br><span class="line">  <span class="keyword">private</span> String updatedDate;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>코드가 획기적으로 줄어들었다! 무엇보다 좋은건 이 VO 객체가 하는 행동(?)을 직관적으로 명확하게 이해할 수 있다는 점이다.</p><p>이 Domain 이라는 VO 객체는 <code>toString()</code> 과 <code>getter()</code>, <code>setter()</code> 를 가지고 있으며, 인자값이 없는 기본생성자와 모든 필드를 인자값으로 갖는 생성자를 각각 갖는 VO라는 사실을 <strong><u>어노테이션</u></strong> 만으로 알 수 있다.<br>Lombok에서 사용하는 어노테이션에 대한 설명은 <a href="#annotations">아래</a>에 정리해두었다.</p><p>Lombok을 사용하기 전보다 Lombok을 사용한 이후에 VO 객체가 더 직관적으로 바뀌었으므로 왠만하면 Lombok을 사용해야 할 것 같다.</p><br><h2 id="Lombok-Annotations"><a href="#Lombok-Annotations" class="headerlink" title="Lombok Annotations"></a><a name="annotations"></a>Lombok Annotations</h2><h3 id="ToString"><a href="#ToString" class="headerlink" title="@ToString"></a><a href="https://projectlombok.org/features/ToString">@ToString</a></h3><p>자동으로 <code>ToString()</code> 를 사용할 수 있는 어노테이션이다.</p><h3 id="Getter-and-Setter"><a href="#Getter-and-Setter" class="headerlink" title="@Getter and @Setter"></a><a href="https://projectlombok.org/features/GetterSetter">@Getter and @Setter</a></h3><p>자동으로 <code>getter()</code>, <code>setter()</code> 를 사용할 수 있는 어노테이션이다.</p><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a><a href="https://projectlombok.org/features/constructor">@NoArgsConstructor</a></h3><p>인자값이 없는 기본 생성자를 사용할 수 있는 어노테이션이다.</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a><a href="https://projectlombok.org/features/constructor">@AllArgsConstructor</a></h3><p>VO 객체에 있는 모든 필드를 인자로 받는 생성자를 사용할 수 있는 어노테이션이다.</p><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a><a href="https://projectlombok.org/features/Data">@Data</a></h3><p><code>@ToString</code>, <code>@EqualsAndHashCode</code>, <code>@Getter</code>, <code>@Setter</code>, <code>@RequiredArgsConstructor</code> 를 모두 자동으로 사용할 수 있는 어노테이션이다.</p><br><h2 id="How-to-use"><a href="#How-to-use" class="headerlink" title="How to use?"></a><a name="install"></a>How to use?</h2><p>메이븐 프로젝트의 경우, pom.xml에 dependency를 추가하면 Lombok을 사용할 수 있다. </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그러나 VO 객체에서 Lombok 어노테이션을 추가했음에도 불구하고, DAO나 다른 곳에서 VO 데이터를 사용하지 못하기도 하다. </p><blockquote><p> <code>getNo()</code>, <code>getTitle()</code> 등의 메서드를 VO 외부에서 사용했을때 불러오지 못하는 경우를 말한다.</p></blockquote><p>이 땐 운영체제에 lombok.jar를 직접 설치해서 컴파일하고, Lombok을 사용중인 프로젝트의 IDE 환경에서도 lombok을 설치해주어야 한다.</p><p>이 방법은 <a href="https://projectlombok.org/setup/eclipse">Lombok 공식 홈페이지</a>에서 각각의 환경에서 어떻게 Lombok을 설치하는지 확인할 수 있다.</p><p>아래는 STS(Spring Suite Tools 4.4.8)에 맞춰서 설명을 해보았다.</p><ol><li><p>Lombok 홈페이지에서 lombok.jar 를 설치한다.</p></li><li><p>다운받은 디렉토리에서 터미널을 실행하여 lombok.jar를 실행한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar lombok.jar</span><br></pre></td></tr></table></figure></li><li><p>STS의 검색창에서 [Install New Software..]를 실행한다.<br><img src="https://user-images.githubusercontent.com/33862991/98795903-23b44d80-244e-11eb-9e31-bf9ecb5cdef8.JPG"></p></li><li><p>Work with 라고 적힌 blank에 설치할 라이브러리의 저장소 주소를 입력한다. Lombok은 <code>https://projectlombok.org/p2</code> 를입력하면된다.<br><img src="https://user-images.githubusercontent.com/33862991/98795908-244ce400-244e-11eb-82aa-daf05a7a9be6.JPG"></p></li><li><p>위의 이미지처럼 주소를 정상적으로 입력했다면, 아래에 Lombok 라이브러리가 검색되는걸 확인할 수 있다. 체크박스를 체크하고 install 한다.</p></li><li><p>STS를 종료하고 다시 실행하면, Lombok 어노테이션이 작동된다! </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot + MyBatis + Oracle(with Docker) 초간단실습</title>
      <link href="2020/10/springboot-mybatis-oracle/"/>
      <url>2020/10/springboot-mybatis-oracle/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/97108403-a8922e00-1710-11eb-9e42-b093ed1857d8.png"></p><p>JPA를 공부하기 전에 먼저 MyBatis로 서버를 셋팅하는걸 해보고 싶었다. 지난해 학원에서 교육받을때는 실력있는 팀원이 해주셔서 내가 직접 해본 경험이 없었다. </p><p>이 실습의 목적은 스프링부트로 만든 서버에서 MyBatis로 오라클에 쿼리를 던져서 조회하는 실습을 해볼 것이다.</p><p>DB는 <strong>도커(Docker)</strong> 로 <strong>오라클</strong> 컨테이너를 생성해서 이용할 것이며, 커맨드라인에서 <strong>SQL PLUS</strong> 을 통해 테이블을 생성하고, 데이터를 삽입한다.</p><p>서버는 <strong>스프링부트(Spring Boot)</strong> 로 생성하며, MVC 패턴으로 생성한다.</p><ul><li><a href="#docker-oracle">DB 생성하기</a></li><li><a href="#springboot">Spring Boot 서버 생성하기</a></li><li><a href="#postman">Postman으로 API 호출하기</a></li><li><a href="https://github.com/youngjinmo/MyBatisOraclePractice">소스코드 @Github</a></li></ul><br><h2 id="DB-생성하기"><a href="#DB-생성하기" class="headerlink" title="DB 생성하기"></a><a name="docker-oracle"></a>DB 생성하기</h2><p>도커 컨테이너 접속해서 SQL PLUS 실행하기</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker start oralce11g</span><br><span class="line">$ docker <span class="built_in">exec</span> -it oracle11g bash</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@a0ddd3dd3495: /<span class="comment"># sqlplus</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/33862991/97108778-03c52000-1713-11eb-8b4f-b5be6409780f.png"></p><h3 id="테이블-생성하기"><a href="#테이블-생성하기" class="headerlink" title="테이블 생성하기"></a>테이블 생성하기</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> members(</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">number</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">   <span class="keyword">name</span> <span class="built_in">varchar2</span>(<span class="number">20</span>),</span><br><span class="line">   job<span class="built_in">varchar2</span>(<span class="number">20</span>),</span><br><span class="line">   loc<span class="built_in">varchar2</span>(<span class="number">30</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>id값에 <code>INSERT</code>할 때 사용하기 위한 <code>SEQUENCE</code> 생성하기</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> id_seq<span class="comment">-- 시퀀스 이름</span></span><br><span class="line"><span class="keyword">INCREMENT</span> <span class="keyword">BY</span> <span class="number">1</span><span class="comment">-- 시퀀스 증감 숫자</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span><span class="comment">-- 시퀀스 시작 숫자</span></span><br><span class="line"><span class="keyword">MINVALUE</span> <span class="number">1</span><span class="comment">-- 최솟값</span></span><br><span class="line">MAXVALUE <span class="number">100</span><span class="comment">-- 최댓값</span></span><br><span class="line"><span class="keyword">NOCYCLE</span>;<span class="comment">-- 순환하지 않음</span></span><br></pre></td></tr></table></figure><p>테이블에 값 추가하기</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> members(<span class="keyword">id</span>, <span class="keyword">name</span>, jon, loc)</span><br><span class="line"><span class="keyword">VALUES</span> (id_seq.nextval, <span class="string">&#x27;Sam&#x27;</span>, <span class="string">&#x27;Athelete&#x27;</span>, <span class="string">&#x27;Seoul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> members(<span class="keyword">id</span>, <span class="keyword">name</span>, jon, loc)</span><br><span class="line"><span class="keyword">VALUES</span>(id_seq.nextval, <span class="string">&#x27;Andy&#x27;</span>, <span class="string">&#x27;Programmer&#x27;</span>, <span class="string">&#x27;Kyonggi&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> members(<span class="keyword">id</span>, <span class="keyword">name</span>, jon, loc)</span><br><span class="line"><span class="keyword">VALUES</span>(id_seq.nextval, <span class="string">&#x27;Nani&#x27;</span>, <span class="string">&#x27;Mechanical Engineer&#x27;</span>, <span class="string">&#x27;Seoul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> members(<span class="keyword">id</span>, <span class="keyword">name</span>, jon, loc)</span><br><span class="line"><span class="keyword">VALUES</span>(id_seq.nextval, <span class="string">&#x27;Gil&#x27;</span>, <span class="string">&#x27;Fashion MD&#x27;</span>, <span class="string">&#x27;Seoul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> members(<span class="keyword">id</span>, <span class="keyword">name</span>, jon, loc)</span><br><span class="line"><span class="keyword">VALUES</span>(id_seq.nextval, <span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Reporter&#x27;</span>, <span class="string">&#x27;Seoul&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><br><h2 id="Spring-Boot-서버-생성하기"><a href="#Spring-Boot-서버-생성하기" class="headerlink" title="Spring Boot 서버 생성하기"></a><a name="springboot"></a>Spring Boot 서버 생성하기</h2><ul><li><a href="#create-project">프로젝트 생성하기</a></li><li><a href="#application-properties">application.properties에 Datasource 설정 추가하기</a></li><li><a href="#vo">VO 생성하기</a></li><li><a href="#dao">DAO 생성하기</a></li><li><a href="#xml">Mapper 생성하기 (Oracle 쿼리)</a></li><li><a href="#service">Service 생성하기</a></li><li><a href="#controller">Controller 생성하기</a></li></ul><h3 id="프로젝트-생성하기"><a href="#프로젝트-생성하기" class="headerlink" title=" 프로젝트 생성하기"></a><a name="create-project"></a> 프로젝트 생성하기</h3><p><strong>[Spring Start Project]</strong> 로 생성하고, Dependency로 <strong>Spring Web</strong>, <strong>Lombok</strong>, <strong>MyBatis Framework</strong>, <strong>Oracle Driver</strong> 을 주입한다.</p><p><img src="https://user-images.githubusercontent.com/33862991/97098624-38f55200-16c2-11eb-9ba4-66c6e97a7d83.png"></p><p>프로젝트의 패키지 구조는 다음과 같다.</p><p><img src="https://user-images.githubusercontent.com/33862991/97098575-a2c12c00-16c1-11eb-974a-16efd0e66d60.png"></p><br><h3 id="application-properties에-Datasource-설정-추가하기"><a href="#application-properties에-Datasource-설정-추가하기" class="headerlink" title="application.properties에 Datasource 설정 추가하기"></a><a name="application-properties"></a>application.properties에 Datasource 설정 추가하기</h3><p>먼저 MyBatis Mapper와 DBMS에 대한 Datasource 설정을 application.properties에서 한다. 본 파일은 <code>/src/main/resources</code>에 위치해있다.</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Setting for Oracle</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">oracle.jdbc.driver.OracleDriver</span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:oracle:thin:@localhost:1521/xe</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">[db-user-name]</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">[db-user-password]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VO location</span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.devandy.web.vo   </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># XML location</span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mappers/**/*.xml</span></span><br></pre></td></tr></table></figure><p>VO와 XML 위치를 지정하는 설정을 미리 등록해두었다.</p><br><h3 id="VO-생성하기"><a href="#VO-생성하기" class="headerlink" title="VO 생성하기"></a><a name="vo"></a>VO 생성하기</h3><p>데이터를 오브젝트 형태로 담아놓을 VO를 생성한다.</p><p>경로 : <code>/src/main/java/com/devandy/web/vo</code><br>파일명 : MemberVO.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.vo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberVO</span> </span>&#123;</span><br><span class="line">   <span class="meta">@JsonProperty</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@JsonProperty</span></span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@JsonProperty</span></span><br><span class="line">   <span class="keyword">private</span> String job;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@JsonProperty</span></span><br><span class="line">   <span class="keyword">private</span> String home;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Getter/Setter</code> 메서드를 자동으로 생성해주는 Lombok 라이브러리의 <code>@Data</code> 어노테이션을 클래스 위에 작성한다.</p><p>그리고 Postman으로 Json 형식으로 데이터를 호출할것이므로 VO 각 필드위에 <code>@JsonProperty</code> 라는 어노테이션도 추가해준다. 이 어노테이션을 붙이지 않으면, API를 호출하는 과정에서 <b><span style="color: red;">Serializable(직렬화)</span></b> 에러가 발생한다.</p><br><h3 id="DAO-생성하기"><a href="#DAO-생성하기" class="headerlink" title="DAO 생성하기"></a><a name="dao"></a>DAO 생성하기</h3><p>DB에 쿼리를 던지는 MyBatis Mapper 클래스를 생성하는 단계이다. DAO 안에 실제 쿼리까지 포함시킬수 있으나 인터페이스와 Mapper를 분리했다.</p><p>경로 : <code>src/main/java/com/devandy/web/dao</code><br>파일명 : <strong>MemberDAO.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> com.devandy.web.vo.MemberVO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberDAO</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;MemberVO&gt; <span class="title">selectAllMembers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Mapper-작성하기-Oracle-쿼리"><a href="#Mapper-작성하기-Oracle-쿼리" class="headerlink" title=" Mapper 작성하기 (Oracle 쿼리)"></a><a name="xml"></a> Mapper 작성하기 (Oracle 쿼리)</h3><p>DAO를 구현하는 xml이다. 실제로 던지는 쿼리를 작성한다.</p><p>경로 : <code>/src/main/resources/mappers/member</code><br>파일명 : <strong>SelectSQL.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.devandy.web.dao.MemberDAO&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectAllMembers&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">resultType</span>=<span class="string">&quot;MemberVO&quot;</span>&gt;</span></span><br><span class="line">      SELECT ID, NAME, JOB, LOC</span><br><span class="line">      FROMMEMBERS</span><br><span class="line">   <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Mapper 태그안의 <code>namespace</code> 를 통해 MyBatis가 맵핑할 이 쿼리가 어떤 DAO에서 호출될 것인지 명시한다.</p><p>Mapper 태그 내부에는 쿼리의 타입으로 <code>SELECT</code> 인지, <code>INSERT</code> 인지를 명시하고, <code>id</code>는 DAO에서 해당 쿼리를 implement하는 메서드명을 작성해준다. <code>resultType</code> 은 DAO 메서드를 통해 반환받을 타입을 작성한다. </p><p>위의 쿼리를 단순히 MEMBERS라는 테이블을 조회하는 쿼리이므로, 반환받을 데이터는 VO 객체에 해당한다. 따라서 <code>resultType</code> 으로 VO 명을 작성한다.</p><p>정리하면, 위의 쿼리는 <code>MemberDAO.class</code> 의 <code>selectAllMembers()</code> 를 구현하는 쿼리이며, 쿼리의 결과로 VO를 반환받는 객체이다.</p><br><h3 id="Service-생성하기"><a href="#Service-생성하기" class="headerlink" title="Service 생성하기"></a><a name=""></a>Service 생성하기</h3><p>Service 클래스는 MVC 패턴에서 Controller에의해 호출되며, 앞서 생성한 DAO를 호출하는 클래스이다.</p><p>경로 : <code>src/main/java/com/devandy/web/service</code><br>파일명 : <strong>MemberService.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.devandy.web.dao.MemberDAO;</span><br><span class="line"><span class="keyword">import</span> com.devandy.web.vo.MemberVO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Autowired</span></span><br><span class="line">      MemberDAO memberDao;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> List&lt;MemberVO&gt; <span class="title">selectAllMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memberDao.selectAllMembers();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="Controller-생성하기"><a href="#Controller-생성하기" class="headerlink" title="Controller 생성하기"></a><a name="controller"></a>Controller 생성하기</h3><p>드디어 API를 호출하는 컨트롤러를 생성한다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.web.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.devandy.web.service.MemberService;</span><br><span class="line"><span class="keyword">import</span> com.devandy.web.vo.MemberVO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIcontroller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   MemberService memberService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@GetMapping(&quot;/members&quot;)</span></span><br><span class="line">   <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">List&lt;MemberVO&gt; <span class="title">selectListMembers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      List&lt;MemberVO&gt; allMembers = memberService.selectAllMembers();</span><br><span class="line">      <span class="keyword">return</span> allMembers;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/members</code>라는 API를 호출하는 <code>selectListMembers()</code>라는 메서드를 생성했다. 웹페이지를 반환하는게 아니라 Json 형식으로 데이터를 반환받을 것이므로 메서드의 리턴타입은 <code>@ResponseBody</code> 로 한다.</p><p>그리고 제네릭타입으로 <code>MemberVO</code> 를 갖는 List를 생성해서 List에 <code>memberService</code> 의 <code>selectAllMembers()</code> 호출 결과를 담는다.</p><p>메서드의 리턴타입으로 이 List를 받으면, Postman을 통해 Json으로 데이터를 받을 수 있을 것이다.</p><br><h2 id="Postman으로-API-호출하기"><a href="#Postman으로-API-호출하기" class="headerlink" title="Postman으로 API 호출하기"></a><a name="postman"></a>Postman으로 API 호출하기</h2><p>Postman은 API를 테스트할 수 있는 애플리케이션이다. Postman을 사용하면, 파라미터(param)나 인증(Authorization), Header 등을 변경해서 간편하게 API를 호출하는 테스트를 해볼수 있다.</p><p><img src="https://user-images.githubusercontent.com/33862991/97108789-09226a80-1713-11eb-8ed3-056f0b787abf.png"></p><p>GET 메서드로 <code>http://localhost:8080/members</code> 로 API를 호출해보니 오라클에서 작성한 테이블의 데이터가 정상적으로 JSON형식으로 반환받는 것을 확인할 수 있다.</p><p>이번엔 SQL Plus로 생성해놓은 테이블을 스프링부트로 생성한 웹 서버에 API를 요청해서 반환하는 것만 실습해보았다. 다음 포스팅에선 CRUD를 구현하는 실습을 해보겠다.</p><ul><li><a href="https://youngjinmo.github.io/springboot-mybatis-oracle2">SpringBoot + MyBatis + Oracle(with Docker) CRUD 구현해보기</a></li><li><a href="https://github.com/youngjinmo/MyBatisOraclePractice">Github 소스코드</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> tutorial </tag>
            
            <tag> docker </tag>
            
            <tag> springboot </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github 디폴트 브랜치, Main으로 전환하기</title>
      <link href="2020/10/github-branch-to-main/"/>
      <url>2020/10/github-branch-to-main/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/33862991/96870083-56040800-14ab-11eb-94f3-c4330d1014f8.jpg"></p><p>인종차별 이슈가 불거지며 테크 업계에서도 자성의 목소리가 나기 시작했다.아래의 권고사항을 통해 인종차별적인 용어를 사용하지 않기위해 노력해야겠다. </p><table><thead><tr><th>Before</th><th>After</th></tr></thead><tbody><tr><td>Master</td><td>Leader, Primary</td></tr><tr><td>Slave</td><td>Follower, Replica</td></tr><tr><td>Whitelist</td><td>Allowlist</td></tr><tr><td>Blacklist</td><td>Denylist</td></tr></tbody></table><p>기술 용어중 인종차별적인 용어들이 일부 있었는데, Github에서 가장 먼저 이를 바꾸는 움직임을 보였다.</p><p>Github의 디폴트 브랜치는 지금까지 Master라고 했었으나 10월부터는 디폴트 브랜치명이 Main으로 바뀐다. 본 포스트는 10월 전까지 생성한 레포지토리에 대한 디폴트 브랜치를 Main으로 바꾸는 법을 정리해보았다.</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Breonna Taylor, George Floyd, Ahmaud Arbery, Tony McDade, and countless others deserve justice. We extend our support to Black Hubbers and Black developers. GitHub stands with the Black community in the fight against racism and injustice, and will continue to take action.</p>&mdash; GitHub (@github) <a href="https://twitter.com/github/status/1269664807977771008?ref_src=twsrc%5Etfw">June 7, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>지금까지는 사용하던 저장소의 디폴트 브랜치이름을 <code>master</code>라고 불렀는데, 이 디폴트 브랜치이름을 더 직관적이면서 인종차별적인 의미를 제거하는 차원에서 <code>main</code> 으로 바꾸기로 결정되었다.</p><p>그럼 이제 디폴트 브랜치를 <code>main</code> 으로 바꾸는법을 알아보겠다.</p><h2 id="Github-원격-저장소-디폴트-브랜치-변경하기"><a href="#Github-원격-저장소-디폴트-브랜치-변경하기" class="headerlink" title="Github 원격 저장소 디폴트 브랜치 변경하기"></a>Github 원격 저장소 디폴트 브랜치 변경하기</h2><p>Github의 레포지토리 설정에서 디폴트 브랜치를 바꿀수 있다.<br>[Settings] - [Branches] 를 들어가면 아래와 같은 화면에서 바꿀수 있다.</p><p><img src="https://user-images.githubusercontent.com/33862991/96867648-f1937980-14a7-11eb-8b3d-3e802ae42236.png"></p><img src="https://user-images.githubusercontent.com/33862991/96867996-6666b380-14a8-11eb-89e2-6090911789bf.png" style="zoom:50%;" /><p>여기에서 <code>Master</code> 를 <code>main</code> 으로 바꾸고 Update 버튼을 클릭하면 레포지토리의 디폴트 브랜치명이 변경된다.</p><br><h2 id="로컬-저장소-디폴트-브랜치-변경하기"><a href="#로컬-저장소-디폴트-브랜치-변경하기" class="headerlink" title="로컬 저장소 디폴트 브랜치 변경하기"></a>로컬 저장소 디폴트 브랜치 변경하기</h2><p>로컬 환경에서는 어떻게 브랜치명을 바꿀수 있을까</p><p><a href="https://github.blog/2020-07-27-highlights-from-git-2-28/">Git 2.28</a> 부터 브랜치를 디폴트 브랜치를 main으로 바꿀수 있게 되었다. 따라서 우선 git부터 2.28 버전으로 업데이트를 하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew upgrade git</span><br></pre></td></tr></table></figure><p>git config에서 디폴트 브랜치를 main으로 바꾸는 명령어가 필요하다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure><p>이후부터 <code>git init</code> 으로 로컬에서 레포지토리를 생성하면 디폴트 브랜치가 <code>main</code> 브랜치로 생성될 것이다.</p><br><h2 id="이미-생성한-프로젝트의-디폴트-브랜치-변경하기"><a href="#이미-생성한-프로젝트의-디폴트-브랜치-변경하기" class="headerlink" title="이미 생성한 프로젝트의 디폴트 브랜치 변경하기"></a>이미 생성한 프로젝트의 디폴트 브랜치 변경하기</h2><p>기존에 디폴트 브랜치로 <code>master</code> 를 쓰고 있는 프로젝트도 <code>main</code> 으로 변경할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -B main</span><br><span class="line">$ git push -u origin main</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/33862991/96870074-53091780-14ab-11eb-98fd-52447e547539.png"></p><p>따로 생성하지 않아도 <code>checkou</code> 으로 <code>main</code> 브랜치 이동이 가능하다. 이 상태에서 원격 저장소에 <code>push</code> 하면 원격저장소에서 <code>main</code>브랜치가 올라간걸 확인할 수 있다.</p><img src="https://user-images.githubusercontent.com/33862991/96870290-a4b1a200-14ab-11eb-9517-ec9b150ceed8.png" style="zoom:33%;" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blacklivesmatter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>뉴욕타임즈에 투자하다</title>
      <link href="2020/09/why-i-invested-nyt/"/>
      <url>2020/09/why-i-invested-nyt/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i0.wp.com/digiday.com/wp-content/uploads/2014/04/Nytimes_hq.jpg?fit=1600,1064&ssl=1"></p><p>어젯밤 오랜만에 주식을 좀 샀다. 국내증시는 너무 올랐고, 미국증시도 만만찮게 올랐는데 평소에 관심있게 보던 회사의 기사가 자꾸 생각나서 소액 투자해보았다.</p><h2 id="새로운-시대가-요구하는-미디어"><a href="#새로운-시대가-요구하는-미디어" class="headerlink" title="새로운 시대가 요구하는 미디어"></a>새로운 시대가 요구하는 미디어</h2><p>지난 달에 이런 기사를 읽었다.<br><a href="https://biz.chosun.com/site/data/html_dir/2020/08/06/2020080600562.html">조선비즈 - 美 유료구독 1위 뉴욕타임스, 디지털 매출이 종이신문 추월</a></p><p>뉴욕타임즈가 이번 2분기 실적에서 최초로 디지털 부문 매출이 종이신문 매출을 추월했다고 한다. 2010년 이후에 재개한 유료 서비스에서 발생한 매출이 100년이 넘는 시간동안 판매한 종이신문 매출을 추월한데에는 구독 서비스에 익숙한 밀레니얼 세대의 문화와 더불어 최근 발생한 팬데믹이라는 이벤트가 기인한 것으로 보여진다. </p><p>뉴욕타임즈는 미국에서 디지털 전환을 가장 빨리 한 회사이기도 하다. 2011년쯤 유료 서비스를 론칭하였으며, 지난해에는 전체 유료구독자 490만명중 온라인으로 400만명을 유치했다고도 한다.(<a href="https://www.yna.co.kr/view/AKR20191108004600072">출처</a>)</p><h2 id="그래서-난-왜-미디어에-투자했나"><a href="#그래서-난-왜-미디어에-투자했나" class="headerlink" title="그래서 난 왜 미디어에 투자했나"></a>그래서 난 왜 미디어에 투자했나</h2><p>전대 미문의 팬데믹에서 사람들은 모두 혼란스러워했고, 가짜 뉴스가 트위터, 유튜브 등을 통해 빠르게 퍼져나가기 시작했다. 뭐가 진짜이고, 뭐가 가짜인지 분별하기 힘든 시대이다. 이럴 때일수록 정보의 출처, 신뢰할만한 정보에 대한 수요가 커질거라고 생각한다. </p><p>이제 누구나 손 안의 휴대폰으로 언제 어디서나 원하는 정보를 찾을 수 있는 세상이 되었다. 이젠 정보의 양이 아닌, 정보의 질이 더 중요한 시대이다. 어떤 정보를 갖고있는지보다 얼마나 신뢰도 높은 정보를 갖고있는지가 훨씬 더 중요해지고 있다. </p><p><img src="http://img.hani.co.kr/imgdb/resize/2018/0927/00503442_20180927.JPG"><br>우리의 취향을 파악해서 큐레이션하는 알고리즘은 확증 편향성을 부각시켜, 가짜뉴스에 파묻혀있는 사람은 계속 알고리즘에 의해 가짜뉴스에만 갇히고있다.</p><p>최근에 내가 어떻게 정보를 소비중인지 생각해보니 다양한 분야의 정보를 소셜미디어 플랫폼으로 접하기보다 각각의 전문 미디어 스타트업을 통해 구독중인데, 이유는 믿을만한 정보의 출처, 즉 <strong>‘신뢰’</strong> 때문이다. 믿을 수 있는 정보를 소비할 수 있다는 측면에서 이들 서비스가 유료화를 한다하더라도 구독을 유지할 생각이다.</p><h2 id="신뢰받는-미디어만이-할-수-있는-도전"><a href="#신뢰받는-미디어만이-할-수-있는-도전" class="headerlink" title="신뢰받는 미디어만이 할 수 있는 도전"></a>신뢰받는 미디어만이 할 수 있는 도전</h2><p>뉴욕타임즈의 디지털 전환 성공은 단순히 시대가 부합하는 모델을 잘 적용해서 성공한 것으로 볼 수만은 없다. 모든 미디어가 뉴욕타임즈처럼 성공하길 원할 수 있지만, 독자들로부터의 신뢰를 얻지못하면 이같은 디지털 전환은 불가능하다.<br>포털에 올려서 그저 클릭을 유발하는 기사를 생산하는 매체들은 감히 시도할 수 없는 도전이다. </p><p><img src="https://search.pstatic.net/common/?src=http://blogfiles.naver.net/MjAyMDA2MDdfMjE3/MDAxNTkxNTA5MDA3NDU3.qIEiFFNX9DJ-9S7O2Gx_E3pgqSQWn_xNbUFS69o4WaQg.Kj80Ba3kqChzRK9evLu8PUZQd1PdP_a4RgfOHcNwTrsg.PNG.sence255/image.png&type=sc960_832"><br>국내에서도 뉴욕 타임즈처럼 광고가 아닌 컨텐츠로 수익화를 시도하는 시도가 이뤄지고 있다. 이런 도전은 기성 매체가 아닌 오히려 <a href="http://newneek.co/" target="_blank">뉴닉</a>, <a href="https://livesmarter.joins.com/" target="_blank">듣똑라</a>같은 스타트업들이 주도하고 있다. 이들이 밀레니얼 세대에게 선택받은 이유는 단지 힙해서 또는 ‘모바일 프렌들리’ 하기 때문은 아닐 것이다. </p><p>나는 미국의 뉴욕타임즈, 한국에선 듣똑라처럼 컨텐츠로 돈을 버는 새로운 미디어들의 도전을 환영한다. 항상 관심있게 지켜보고 있으며, 소액이지만 뉴욕타임즈의 주주가 된만큼 앞으로도 미디어 산업이 어떻게 바뀌는지 계속 지켜볼 예정이다.</p><p>아래 기사는 뉴욕타임즈의 최근 실적에 대한 아티클이다.(출처 : NYT)<br><a href="https://www.nytimes.com/2020/08/05/business/media/nyt-earnings-q2.html">NYT - Digital Revenue Exceeds Print for 1st Time for New York Times Company</a></p><p>2분기에 신규가입자 증가폭이 역대 최다였고, 이에 힘입어 디지털 매출이 늘어나며 종이신문 매출을 처음으로 추월했다고.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> investment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>첫 오픈소스 기여</title>
      <link href="2020/09/github-contribution/"/>
      <url>2020/09/github-contribution/</url>
      
        <content type="html"><![CDATA[<p><img src="https://opensource.guide/assets/images/cards/contribute.png"></p><p>뭐 엄청 작은부분이지만, 그래도 첫 오픈소스 기여를 기념하여 그 과정을 기록한다.</p><p>오픈소스를 기여하는 방법은 4가지 정도로 생각할 수 있다.</p><ol><li>오픈소스 프로젝트 후원하기</li><li>문서 번역하기</li><li>버그 수정해서 PR하기</li><li>새로운 기능 제안하기</li></ol><p>난 이 중 2번인 문서 번역을 선택했다. 막연히 오픈소스에 기여해보고 싶던차에 1년 넘게 잘 사용하고 있는 깃헙 블로그 테마인 <a href="https://github.com/ppoffice/hexo-theme-hueman">Hueman 프로젝트</a>를 살펴봤다. 아직까지 사용하며 버그를 발견하지는 못했고, 새로운 기능을 제안하기 앞서 먼저 문서를 살펴봤다. 여러가지 언어를 지원하는데, 한글 컨텐츠 중에 일부가 번역이 되있지 않은걸 확인했다. 그래서 이 부분을 번역해서 PR하기로 했다.</p><p>그럼 이제부터 오픈소스에 참여하는 절차를 정리해보자.</p><ol><li>저장소 fork하기</li><li>로컬에 프로젝트 clone</li><li>개발 하기</li><li>Commit &amp; Push</li><li>Pull Request</li><li>Merge</li></ol><h2 id="1-저장소-fork하기"><a href="#1-저장소-fork하기" class="headerlink" title="1. 저장소 fork하기"></a>1. 저장소 fork하기</h2><p>참여하고 싶은 오픈소스 저장소를 내 github 저장소로 fork를 한다. 우측 상단에 보면 fork버튼이 있다. 이걸 클릭하면 내 저장소로 저장소를 그대로 복제한다.</p><p><img src="https://user-images.githubusercontent.com/33862991/93561912-fbfdb780-f9bf-11ea-8bb5-c6e54899b4de.PNG"></p><p> <a href="https://cli.github.com/">Github CLI</a> 명령어는 다음과 같다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gh repo fork [repository][flags]</span><br></pre></td></tr></table></figure><p>fork한 이후 생긴 저장소이다.</p><p><img src="https://user-images.githubusercontent.com/33862991/93561916-fd2ee480-f9bf-11ea-8b42-bb202644127c.PNG"></p><h2 id="2-로컬에-프로젝트-clone"><a href="#2-로컬에-프로젝트-clone" class="headerlink" title="2. 로컬에 프로젝트 clone"></a>2. 로컬에 프로젝트 clone</h2><p>이제 저장소를 로컬환경으로 clone한다.</p><p><img src="https://user-images.githubusercontent.com/33862991/93562197-880fdf00-f9c0-11ea-8dcf-639447471161.PNG"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gh repo <span class="built_in">clone</span> &lt;repository&gt; [&lt;directory&gt;] [-- &lt;gitflags&gt;...]</span><br></pre></td></tr></table></figure><h2 id="3-개발하기"><a href="#3-개발하기" class="headerlink" title="3. 개발하기"></a>3. 개발하기</h2><p>내가 한 작업은 개발이 아닌 번역 수준이지만, 어쨋든 코드를 작성한다.</p><h2 id="4-Commit-amp-Push"><a href="#4-Commit-amp-Push" class="headerlink" title="4. Commit &amp; Push"></a>4. Commit &amp; Push</h2><p>혼자만 볼게 아니라 나중에 프로젝트 관리자가 리뷰를 할 것이므로 가급적이면 커밋도 작게 나누도록 하자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -am <span class="string">&quot;commit-message&quot;</span> &amp;&amp; git push -u origin [branch-name]</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3c9Oa4DWRkARjB_zHlZ0Tn-TNkRxzbvj3vgpf0U0qnbwam5bgUgCDKNPK4Dfw47vYGI2mp7vJa35HCRe16gTUaKZ5bkP11MA7GUOB1oYCo2vahTi-v-ebG6jplcZsCpy04J8TqJP3b_hclesPWLU7jAmA=w1379-h782-no?authuser=2"></p><h2 id="5-Pull-Request"><a href="#5-Pull-Request" class="headerlink" title="5. Pull Request"></a>5. Pull Request</h2><p>push한 저장소로 웹에 접속하면, 아래의 이미지처럼 오리지널 저장소와 비교하고 Pull Request할 수 있는 버튼이 활성화된걸 볼 수 있다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eZXCNTftk68g0JLGt5VCiiRWXdnQVk5gwoHujn_-1IlO3-ceXAS_y58J-VEHMdJJOWQh3ambi7w_iDKNWa0rEQpQjoKq-dpUqnTzGOtzBZCXXkR4E_0824okPSIauZuEez8LX9SAKiM5Gehe7UxQ7vAg=w1226-h334-no?authuser=1"></p><p>개발자분이 쉽게 이해하실수 있도록 신경써서 PR 메세지를 작성하도록 하자.<br><img src="https://lh3.googleusercontent.com/pw/ACtC-3fGHQB2k8ntWqnrljws_K-tmhQz5STtIsH2dSSa8OrpoHlyWhcgIt-JIptCDs22tUwrPLhaHM1mWw3TCGGr-iM4jvv3ctgci-6vSxMagwAfLiEMdjHl5qJtrLfAbqJYGhgCAF9h3N6sdfhK3kzA5ZVTdA=w1226-h695-no?authuser=1"></p><p>당연히 Github CLI로도 PR을 할 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gh pr create [flags]</span><br></pre></td></tr></table></figure><p>오픈소스 저장소 Pull Request에 들어가면 방금 올린 PR을 확인할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cjXe5IkCuZu9x_HIOi3OUia_ry8hbSFuukgUjj3y8XaBkndpb0qb9AOTNA2bEwJO8cBROTo3oc5yIUPMhKGMx_P5mGk5yJbbxXPCgI6TVFA2AhLthF0PNfYK4vj6fNqkRBr_WZCxW06npsR5rSlzax9g=w1226-h699-no?authuser=1"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gh pr list</span><br></pre></td></tr></table></figure><p>이제 커밋이 Merge되거나 거절당할때까지 기다리면 된다.</p><h2 id="6-Merge"><a href="#6-Merge" class="headerlink" title="6. Merge"></a>6. Merge</h2><p>Merge되면 아래처럼 PR 라벨이 Open에서 Merged로 변경된다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3dJKqdcFxLoyjQVqDsLQkWVB0UvmH2Niy1rE7sGB__oFIk3BjKkC6yAYTLIdSOkm0TsA9tPwJTSgn9aeaD3wDI7KlC0qOtAjRlrqbW7iKzkNt3ea-BAXGtgYNrfVlcZe6gudoslhPizHhiXoh95yFeeEQ=w1226-h632-no?authuser=1"></p><p>이렇게 저장소의 Contributor에 이름도 추가되었다!</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eVWevUuwACMvMmiYLEcO9HJhRCnemfCnhBKZKKc_8vom-kadqQ_PcKbtQ8d1jsS1vdhzZOTDKt2DHALQ24ZkYc-dHk9WwAd_Ab2LeKWZOnW23wHkKvU3aGYVd-_JR0n3nzdRTi_hg3LgQSPBA_amgJtA=w853-h528-no?authuser=1"></p><br><p>비록 번역 몇 단어한 것에 불과하지만 첫 오픈소스 기여여서 기념차 작성한 포스팅이다. 나중엔 버그를 잡아보거나 새로운 기능을 제안하는 PR도 해보고 싶다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> contribution </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML, JSON 그리고 XMLHttpRequest</title>
      <link href="2020/09/xml-json-xmlhttprequest/"/>
      <url>2020/09/xml-json-xmlhttprequest/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/pw/ACtC-3f3uUiEllt7yZ2cz-TBQE53mDoXAvAbilDnTHnb0gUIYnX86czSpvvAGNC1uwJN3Mm543ae8FVwBXvYPyOcYzNVH-5fg0VXSmiORlQSYChhlqdO1jLRs_XhVOQYcySp_K_S3JbhAK4jHpeyRpXmh45Gqg=w640-h405-no?authuser=2"></p><p>웹에서 API로 통신을 할 때 데이터를 전달받는 형식이 있다. XML과 JSON이 그 형식들이다. Ajax나 API로 요청하고 데이터를 받을때, JSON으로 데이터가 넘어오고 하는데, 한 번 정리하고 넘어가고 싶어서 정리한 글이다.</p><p>JSON과 XML은 데이터 통신을 위해 고안된 형식이라고 한다. 그래서 자바, 파이썬 같은 프로그래밍 언어에 의해 파싱될 수 있으며, 계층적 구조(Hierarchical Structure)를 갖고 있다.</p><br><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>HTML과 유사한 마크업 언어이다. 데이터를 저장하고, 전달할 목적으로 고안되었다.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dog</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>식빵<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">family</span>&gt;</span>웰시코기<span class="tag">&lt;<span class="name">family</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">age</span>&gt;</span>1<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">weight</span>&gt;</span>2.14<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dog</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>dog</strong> 라는 객체의 <strong>name</strong> 속성으로 <code>식빵</code>, <strong>family</strong> 속성으로 <code>웰시코기</code>, <strong>age</strong> 속성으로 <code>1</code>, <strong>weight</strong> 속성으로 <code>2.14</code>를 반환하는 데이터이다.</p><br><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>XML과 마찬가지로 데이터 저장과 전달을 목적으로 고안되었으며, 자바 스크립트 기반으로 작성되었다.</p><p>XML의 대안으로서 고안되었으며, XML 대비 더 직관적이며, 작성하기 편리하다는 특징이 있다. 또 배열을 파싱할 수 없는 XML과 달리 JSON은 배열을 사용할 수 있다.</p><p>JSON은 key와 value가 한 쌍을 이루는 구조의 객체로 구성되어 있다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;식빵&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;family&quot;</span>: <span class="string">&quot;웰시코기&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;age&quot;</span>: <span class="number">1</span>,</span><br><span class="line">   <span class="attr">&quot;weight&quot;</span>: <span class="number">2.14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 XML로 전달받은 동일한 객체를 JSON으로 전달받았을때 볼 수 있는 코드이다. <strong>name</strong>, <strong>family</strong>, <strong>age</strong>, <strong>weight</strong> 가 key가 되며, 각각의 key에 해당하는 value가 <code>식빵</code>, <code>웰시코기</code>, <code>1</code>, <code>2.14</code>에 해당한다.</p><p>XML이 <a href="http://www.tcpschool.com/xml/xml_dom_xmlParser">XML Parser</a>로 파싱을 한다면, JSON은 자바스크립트 표준함수인 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/eval">eval()</a>로 파싱한다고 한다.</p><h3 id="함께-읽어보면-좋은-문서"><a href="#함께-읽어보면-좋은-문서" class="headerlink" title="함께 읽어보면 좋은 문서"></a>함께 읽어보면 좋은 문서</h3><ul><li><a href="http://www.json.org/json-ko.html">JSON 개요</a></li></ul><br><p>XML이든 JSON이든 결국 <code>XMLHttpRequest</code> 객체를 사용해서 동작한다. <code>XMLHttpRequest</code>에 대해서도 알아보도록 하자.</p><h2 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h2><p><code>XMLHttpRequest</code>는 서버와 상호작용(동기/비동기)하기 위하여 사용하는 객체이다. WebAPI의 인터페이스중 하나이다. 페이지의 Reload없이도 웹서버로부터 데이터를 가져올 수 있기 때문에 Ajax에서 주로 사용된다고 한다.</p><p>XML과 JSON 모두 <code>XMLHttpRequest</code> 객체를 이용하여 서버에서 데이터를 전송받는다.</p><p>주요 속성과 메서드는 <a href="https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest">MDN 공식문서</a>를 통해 확인가능하다.</p><p><code>XMLHttpRequest</code>를 이용한 데이터 전송을 하는 예제 코드이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadDoc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// XMLHttpRequest 객체를 생성</span></span><br><span class="line">    <span class="keyword">var</span> xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="comment">// onreadystatechange 이벤트 핸들러 생성</span></span><br><span class="line">    xmlHttp.onreadyStatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 서버에 문서가 존재하고, 요청한 데이터의 처리가 완료되어 응답 준비가 완료되었을때</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.status == <span class="number">200</span> &amp;&amp; <span class="built_in">this</span>.readyState == <span class="built_in">this</span>.DONE)&#123;</span><br><span class="line">            <span class="comment">// 요청한 데이터를 문자열로 반환</span></span><br><span class="line">            <span class="built_in">document</span>.getElementById(<span class="string">&quot;parseText&quot;</span>) = xmlHttp.responseText;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 요청 초기화</span></span><br><span class="line">    xmlHttp.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;/data.txt&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 요청을 실행. 기본값은 비동기(Asynchronous) 요청 직후 즉시 반환.</span></span><br><span class="line">    xmlHttp.send();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위에서 사용한 XMLHttpRequest의 속성은 다음과 같다.</p><ul><li><code>XMLHttpRequest.onreadystatechange</code><ul><li>readyState 속성(attribute)이 변경될때마다 호출되는 <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Event_handlers">이벤트핸들러</a></li></ul></li><li><code>XMLHttpRequest.status</code><ul><li>요청의 응답 상태를 갖는 unsigned short를 반환</li></ul></li><li><code>XMLHttpRequest.readyState</code><ul><li>요청의 상태를 unsigned short로 반환</li></ul></li><li><code>XMLHttpRequest.responseText</code><ul><li>요청에 대한 응답을 텍스트로 갖는 DOMString을 반환.</li><li>요청에 실패할 경우 null 반환</li></ul></li><li><code>XMLHttpRequest.open()</code><ul><li>요청을 초기화하는 메서드.</li></ul></li><li><code>XMLHttpRequest.send()</code><ul><li>요청을 보낸다.</li><li>요청이 비동기(default)일 경우, 요청 직후 즉시 반환하는 메서드.</li></ul></li></ul><p>출처 : <a href="https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest">MDN - XMLHttpRequest</a></p><br><h2 id="왜-JSON을-사용해야-하는가"><a href="#왜-JSON을-사용해야-하는가" class="headerlink" title="왜 JSON을 사용해야 하는가?"></a>왜 JSON을 사용해야 하는가?</h2><p>XMLHttpRequest를 사용해서 데이터를 통신할 경우 배열 객체를 전달받고 사용하는 일이 까다로워질 수 밖에 없다.</p><p><code>XMLHttpRequest.responseText</code>는 문자열을 반환하므로 이를 사용하기 위해서는 <code>,</code> 를 중심으로 문자열을 나눠야한다. 그러나 JSON을 사용하면 배열 자체를 사용할 수 있기 때문에 번거로운 파싱작업을 할 필요가 없어진다.</p><p>또 XML 대신 최근에 JSON만을 사용하는 이유로는 JSON은 XML처럼 엔드 태그가 존재하지 자바스크립트로 간단히 작성할 수 있으며, 더 가볍기 때문이다. 또한 XML로는 배열을 표현하는데 한계가 있지만, JSON은 그렇지 않다는 특징도 있다.</p><br><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="http://tcpschool.com/json/json_intro_xml">TCPSchool - JSON과 XML:</a></li><li><a href="http://tcpschool.com/xml/xml_dom_xmlHttpRequest">TCPSchool - XMLHttpRequest</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest">MDN - XMLHttpRequest</a></li><li><a href="https://developer.mozilla.org/ko/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest">MDN - Using XMLHttpRequest</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> xml </tag>
            
            <tag> json </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - Sequence 생성하고 테이블에 삽입하기</title>
      <link href="2020/08/create-table-sequence/"/>
      <url>2020/08/create-table-sequence/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/pw/ACtC-3dnKjQpuvDEmVxFsIrKfVbq9RCZMjbbZPOtAWR0Etr5EfTkx58EYPQjjgLEiO8XYLsVu_1TWyNmpySsDRxXvCplY6aMPhIMQgNCaH0TBpVv0vxyI_-b6pK9x8qhVSSptzKgeu-dbMHYIt-eS1MUDQnkiw=w640-h427-no?authuser=0"></p><p>시퀀스를 생성하고, 이 시퀀스를 적용한 데이터 필드를 테이블에 삽입하는 쿼리이다.</p><h2 id="시퀀스-생성"><a href="#시퀀스-생성" class="headerlink" title="시퀀스 생성"></a>시퀀스 생성</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> seq</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INCREMENT</span> <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">NOMAXVALUE</span></span><br><span class="line"><span class="keyword">NOMINVALUE</span>;</span><br></pre></td></tr></table></figure><br><h2 id="생성한-시퀀스-확인하기"><a href="#생성한-시퀀스-확인하기" class="headerlink" title="생성한 시퀀스 확인하기"></a>생성한 시퀀스 확인하기</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> USER_SEQUENCES;</span><br></pre></td></tr></table></figure><br><h2 id="테이블-생성하기"><a href="#테이블-생성하기" class="headerlink" title="테이블 생성하기"></a>테이블 생성하기</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">User</span> (</span><br><span class="line">seq <span class="keyword">id</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar2</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><h2 id="데이터-삽입하기"><a href="#데이터-삽입하기" class="headerlink" title="데이터 삽입하기"></a>데이터 삽입하기</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">User</span>(<span class="keyword">id</span>, <span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(seq.NEXTVAL, <span class="string">&#x27;devandy&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">User</span>(<span class="keyword">id</span>, <span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(seq.NEXTVAL, <span class="string">&#x27;devjoyce&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">User</span>(<span class="keyword">id</span>, <span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(seq.NEXTVAL, <span class="string">&#x27;devkami&#x27;</span>);</span><br></pre></td></tr></table></figure><br><h2 id="테이블-조회하기"><a href="#테이블-조회하기" class="headerlink" title="테이블 조회하기"></a>테이블 조회하기</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">User</span>;</span><br></pre></td></tr></table></figure><br><h2 id="테이블에서-현재-시퀀스-조회하기"><a href="#테이블에서-현재-시퀀스-조회하기" class="headerlink" title="테이블에서 현재 시퀀스 조회하기"></a>테이블에서 현재 시퀀스 조회하기</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> seq.CURVAL</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">User</span>;</span><br></pre></td></tr></table></figure><br><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://hellogk.tistory.com/33">https://hellogk.tistory.com/33</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet - Redirect와 Forward</title>
      <link href="2020/08/servlet-redirect-forward/"/>
      <url>2020/08/servlet-redirect-forward/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cK_j9D5XupS1mIeAAwsE1cOAdZ05jfS290XghGTAfDNVmf1VDdldnidSEQpbEAPRe_aTchGC7U00h7lU9JKtTV3ltDyqUcofn0Xu4p0pm_ROewKfcnOG3UO4Yo4EgVG6ZeQfoemWHklC1hGMn-1DXYfQ=w640-h427-no?authuser=0"></p><h2 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h2><p><img src="https://cphinf.pstatic.net/mooc/20180127_5/1517046342330PRbSX_PNG/2_4_1_redirect__.PNG?type=w760" alt="출처 : edwith"></p><p>위의 이미지를 설명하면, 리다이렉트는 클라이언트가 redirect01.jsp를 요청했더니 웹서버로부터 반환된 내용에 리다이렉트 내용이 있어서 웹서버로 다시 요청, 웹서버에서 최종적으로 redirect02.jsp를 반환하는 과정이다.</p><p>리다이렉트를 현실에서 비유를 들자면, 휴대폰 관련 상담을 위해 고객상담센터에 연락을 했다고 가정해보자.<br>휴대폰 보험 관련 문의를 위해 고객상담센터에 전화했더니 센터에서는 해결을 못하니 보험 회사로 직접 연락하라며 번호를 알려주었다. 이 번호로 다시 연락해서 보험 상담원과 연결이 되었다.</p><p>이렇게 클라이언트가 처음 요청과 다른 요청을 해서 2번의 요청을 통해 연결되는 상황을 리다이렉트라고 할 수 있다.</p><p>결과적으로 브라우저를 통해 페이지 로드가 한 번 되는것처럼 보이지만, 사실은 <strong>클라이언트와 웹서버간 통신이 각각 2번씩 이뤄진다는 점</strong> 이다. 클라이언트가 웹서버에 2번의 요청을 하는 것이다.</p><blockquote><p>클라이언트 &gt;&gt; 웹서버(redirect) &gt;&gt; 클라이언트(redirect) &gt;&gt; 웹서버 &gt;&gt; 클라이언트</p></blockquote><h3 id="예제코드"><a href="#예제코드" class="headerlink" title="예제코드"></a>예제코드</h3><p><strong>RedirectFirst.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class redirect01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/redirect-first&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedirectFirst</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">redirectFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line">out.println(<span class="string">&quot;Hello Servlet 01&quot;</span>);</span><br><span class="line">response.sendRedirect(<span class="string">&quot;/redirect-second&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>RedirectSecond.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class redirect01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/redirect-second&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedirectSecond</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">redirectSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line">out.println(<span class="string">&quot;Hello Servlet 02&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>서블릿 클래스를 생성한 예제 코드이다. <code>/redirect-first</code> 라는 API로 요청이 들어오면,  <code>HttpServletResponse</code>의 <code>sendRedirect()</code>를 이용하여  <code>/redirect-second</code> API로 요청을 리다이렉트하는 코드이다. 결국 화면에 Hello Servlet 02가 출력된다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3d_jA03TM66pDeTJsdPeWUWrgTOryS3cf3TvkEVdEV2R5HyhAnYdDyjMM2OG8F1vYxETjGGCACM5Z69tWHoF0CaaTmK3LV5JgJkfxB0C7QnX3lifARtCK2nBkoMK6nNlVxYanFEXEwv8FZI8UkHWAWeUg=w640-h360-no?authuser=0"></p><p><code>HttpServletResponse</code>의 <code>sendRedirect()</code>에 대해 더 알아보자.</p><p>아래 포워드에서 비교해서 알 수 있겠지만, 리다이렉트는 <code>sendRedirect()</code> 함수가 호출되는 시점에 페이지를 바로 이동하는게 아니라 서블릿 클래스 내에 코드가 모두 실행되고 반환될 때, 웹서버의 서블릿 클래스가 클라이언트의 요청을 바꿔서 다시 요청받는거다. </p><p>HTTP Header의 Status Code를 301(Permanently) 또는 302(Temporarily)로 바꿔서 반환한다. 그래서 바뀐 Header값으로 클라이언트가 웹서버에 재요청하여 다른 페이지를 반환받는 것이다. 이게 리다이렉트 과정이다.</p><br><h2 id="Forward"><a href="#Forward" class="headerlink" title="Forward"></a>Forward</h2><p><img src="https://cphinf.pstatic.net/mooc/20180129_279/1517202070933x0x42_PNG/2_4_2_forward.png?type=w760" alt="출처 : edwith"></p><p>포워드는 클라이언트가 웹서버에 forward01.jsp를 요청했더니 forward01.jsp에서 작성된 코드에의해 포워딩되어 forward02.jsp를 반환하는걸 의미한다. 결과적으로 위에서 설명한 리다이렉트와 비슷하지만, <strong>클라이언트와 서버간 통신이 각각 1번씩이라는 점</strong>에서 다르다. </p><p>이번에도 현실에서 비유를 들어보겠다.<br>고객상담센터에 전화를 걸어서 요금 관련 문의를 했더니, 잠시만 기다려달라고 하더니 저절로 요금 관련 상담원으로 전화연결이 바뀌었다. 전화를 끊고 다시 한것도 아닌데 고객상담센터에서 내 전화를 요금 관련 상담원으로 연결해준 것이다. </p><p>이처럼 클라이언트는 한 번의 요청을 했지만, 서버에서 페이지를 바꿔서 반환하는 것을 포워딩이라고 한다.</p><p>포워드는 다른 서버와는 할 수 없고, 클라이언트가 처음 요청한 서버내에서 다른 클래스를 전달할 수 있다. 또한 포워딩하는 과정에서 처음 요청받은 서블릿 클래스의 request와 response도 함께 포워딩할 수 있다는 특징이 있다.</p><p><code>클라이언트 &gt;&gt; 웹서버(forward) &gt;&gt; 웹서버(forwared) &gt;&gt; 클라이언트</code></p><h3 id="예제코드-1"><a href="#예제코드-1" class="headerlink" title="예제코드"></a>예제코드</h3><p><strong>FrontServlet.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.RequestDispatcher;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class FrontServlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/front&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FrontServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FrontServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> randNum = (<span class="keyword">int</span>)(Math.random() * <span class="number">6</span>) +<span class="number">1</span>;</span><br><span class="line">    req.setAttribute(<span class="string">&quot;rand&quot;</span>, randNum);</span><br><span class="line">    </span><br><span class="line">    RequestDispatcher requestDispatcher = req.getRequestDispatcher(<span class="string">&quot;/forward&quot;</span>);</span><br><span class="line">    requestDispatcher.forward(req, resp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BackServlet.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet implementation class BackServlet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/forward&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BackServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">    response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">    out.println(<span class="string">&quot;&lt;head&gt;&lt;title&gt;form&lt;/title&gt;&lt;/head&gt;&quot;</span>);</span><br><span class="line">    out.println(<span class="string">&quot;&lt;body&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rand = (<span class="keyword">int</span>)request.getAttribute(<span class="string">&quot;rand&quot;</span>);</span><br><span class="line">    out.println(<span class="string">&quot;랜덤 수 : &quot;</span>+rand);</span><br><span class="line"></span><br><span class="line">    out.println(<span class="string">&quot;&lt;/body&gt;&quot;</span>);</span><br><span class="line">    out.println(<span class="string">&quot;&lt;/html&gt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/front</code> 로 요청이 들어오면, FrontServlet.class 에서 랜덤 숫자를 생성했다. 이렇게 생성한 숫자를 포워딩할 클래스에 보내려면, <code>HttpServletRequest</code>의 <code>setAttribute()</code>와 <code>RequestDispatcher</code>의 <code>forward()</code>를 사용해야한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> randNum = (<span class="keyword">int</span>)(Math.random() * <span class="number">6</span>) +<span class="number">1</span>;</span><br><span class="line">req.setAttribute(<span class="string">&quot;rand&quot;</span>, randNum);</span><br></pre></td></tr></table></figure><p>생성된 랜덤 숫자를 “rand”라는 이름으로 attribute에 넣는다. 이렇게 저장된 attribute를 포워딩하는 서블릿 클래스로 보낼때 사용하는 객체가 RequestDispatcher이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RequestDispatcher requestDispatcher = req.getRequestDispatcher(<span class="string">&quot;/forward&quot;</span>);</span><br><span class="line">requestDispatcher.forward(req, resp);</span><br></pre></td></tr></table></figure><p><code>/forward</code> 로 요청을 포워딩하는 <code>RequestDispatcher</code>를 생성하고, <code>RequestDispatcher</code>의 <code>forward()</code> 파라미터에 request와 response를 넣으면, 포워딩되는 클래스에 request와 response를 함께 보내준다. 이 request 객체에 attribute가 있기 때문에 <code>RequestDispatcher.forward()</code> 파라미터에 request와 response를 주입하는 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">response.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> rand = (<span class="keyword">int</span>)request.getAttribute(<span class="string">&quot;rand&quot;</span>);</span><br><span class="line">out.println(<span class="string">&quot;랜덤 수 : &quot;</span>+rand);</span><br></pre></td></tr></table></figure><p>그럼 포워딩되는 서블릿 클래스에서 API 요청을 받아서 랜덤숫자가 저장된 attribute를 화면에 출력하는 코드이다.</p><p><code>RequestDispatcher</code> 객체는 <code>HttpServletRequest</code>에서 제공하는 객체며, <code>forward()</code>와 <code>include()</code> 2개의 메서드를 가지고 있다.</p><p>출처 : <a href="https://opentutorials.org/module/3569/21214">생활코딩 - JSP/서블릿 훑어보기</a></p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cSU5XYQWxkx5yaBl09zqrELzA4X-pEjzfqp2BhfSRc26UmwnJSN5QYaxJ17LerFC5wwHLfECjoZoLbrEF5l9YCbOjhEKhcc8Ss9TZWAAgYqP9sQSEhWQqJFWm4t5wqKI6x-0Lis-UN_-9rrZbIK5ZQ0Q=w640-h360-no?authuser=0"></p><br><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.edwith.org/boostcourse-web/lecture/16705/">edwith - 웹 프로그래밍</a></li><li><a href="https://blog.outsider.ne.kr/188">Outsider’s Dev Story - response.sendRedirect()에 대해서…</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode - Twosum</title>
      <link href="2020/08/leetcode-twosum/"/>
      <url>2020/08/leetcode-twosum/</url>
      
        <content type="html"><![CDATA[<p><img src="https://assets.leetcode.com/static_assets/public/images/LeetCode_Sharing.png"></p><h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p><table>  <tr>      <td>        Given an array of integers, return <b>indices</b> of the two numbers such that they add up to a specific target.<br>You may assume that each input would have <b>exactly</b> one solution, and you may not use the *same* element twice.    </td>  </tr></table></p><p>주어진 int형 배열에서 2개의 수를 더했을때 특정값(target)이 되는 배열의 인덱스를 반환하는 문제이다.</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">int</span>[] returnValue = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;nums.length; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j &amp;&amp; nums[i]+nums[j]==target)&#123;</span><br><span class="line">               returnValue[<span class="number">0</span>] = i;</span><br><span class="line">               returnValue[<span class="number">1</span>] = j;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>오랜만에 알고리즘 문제를 풀어봤다. 올초만 하더라도 1일1백준을 했었는데, 취업 준비를 하며 알고리즘 문제를 전혀 안풀어봤었다. 그러다 이렇게 아예 손놓으면 나중에 더 힘들어지겠다 싶어서 점심시간에 잠시 짬내서 leetcode 문제를 풀어보았다.</p><p>간단한 문제였다. int형 배열을 반복문으로 더해보며 target에 해당하는 연산결과가 나오면 해당 인덱스들을 새로운 int형 배열에 담아서 반환하면 되는 문제였다.</p><p>문제 풀이 결과 코드는 맞췄지만, Runtime 성능이 133ms로 하위 5% 대로 나왔다. 퇴근하면서 유튜브로 다른 사람의 해설을 참고해봐야겠다. </p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Quiz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker로 MySQL 실행하기</title>
      <link href="2020/08/run-mysql-with-docker/"/>
      <url>2020/08/run-mysql-with-docker/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/pw/ACtC-3fdpC3xu5q4xnJRLLhSaWCrARbnQ1qdp_DpF0Z7BITrtrr6gZWGExKC4PcMlVo3AxVhVbYiFgDhNObWmtv3hGwoEtF_4zFb_1fQsdL6d1K3UNA0LRkczuC_nNvcEHERB8EIB3uvWOIps7j1iraX6DGLbQ=w720-h480-no?authuser=0" width="650px" /><!-- myssql password : andy@mysql --><!-- other user (devandy) : dev@mysql --><p>먼저 도커를 실행한다.</p><p>이후 도커에서 <a href="https://hub.docker.com/_/mysql">MySQL 이미지</a>를 조회하고, 내려받는다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search mysql</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull mysql</span></span><br></pre></td></tr></table></figure><p>도커 이미지가 내려받아지면, 이제 이미지 기반으로 컨테이너를 생성한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=1q2w3e4r mysql</span></span><br></pre></td></tr></table></figure><p>각 옵션을 설명하면 다음과 같다.</p><ul><li><code>run</code> : 컨테이너를 생성(create)하자마자 실행(start)한다.</li><li><code>-d</code> : detach, 백그라운드에서 컨테이너를 실행한다는 명령어이다.</li><li><code>-p</code> : port, 컨테이너의 포트를 도커가 실행되고 있는 호스트 PC의 포트와 맵핑할 때 사용하는 옵션이다. 위의 명령어는 컨테이너의 3306번 포트와 호스트 PC의 3306번 포트를 맵핑하는 명령이다.</li><li><code>--name</code> : 컨테이너의 이름을 지정하는 옵션이다.<ul><li>이미지 이름과 같은 이름을 컨테이너에 지정하다보니 위의 명령어가 헷갈릴수 있는데, 명령어 마지막에 붙은 mysql은 이미지 이름을 의미한다.</li></ul></li><li><code>-e</code> : 환경변수를 설정하는 옵션이다. 위의 명령어에선 mysql의 ROOT 비밀번호를 지정하는 명령으로 사용했다.</li></ul><p>이제 도커가 실행되면, 컨테이너 내부로 진입을 해야한다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it mysql bash</span></span><br></pre></td></tr></table></figure><p>bash 모드로 컨테이너를 진입하겠다는 명령이다.</p><p>도커 컨테이너에 진입했다면, mysql을 실행할 차례이다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -u root -p</span></span><br></pre></td></tr></table></figure><p>그리고 아까 환경변수에 입력했던 비밀번호를 입력하면 mysql이 실행될 것이다.</p><br><p>이제 막 mysql 컨테이너를 생성했기 때문에 컨테이너 내부 데이터베이스엔 기본 데이터베이스만 있을 것이다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eyl0L0Zvh4Tzenx698wJ1YQJMIS7KhjY4SxlKvp6vFsUs8vv9jqVZDyT-5SQU27lH-jLb1_HyGKJk1cOk67TtVa_1qTgIWL4rhsPktvS5kbT2vrADA0X0wUcPLuPyz7MPaF2Y9K4ZEtjs3fOQCU4bQYA=w730-h423-no?authuser=0"></p><p>이제 데이터베이스를 생성해보자. connectdb 라는 이름의 데이터베이스를 생성해보겠다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE connectdb;</span><br></pre></td></tr></table></figure><p>데이터베이스를 사용할때 이용할 사용자 계정을 생성하겠다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER devandy@&#39;%&#39; identified by &#39;1q2w3e4r&#39;;</span><br><span class="line">mysql&gt; CREATE USER devandy@&#39;localhost&#39; identified by &#39;1q2w3e4r&#39;;</span><br></pre></td></tr></table></figure><p>데이터 베이스에 사용할 수 있는 권한으로 방금 생성한 사용자를 등록해보겠다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON connectdb.* TO devandy @ &#39;%&#39; identified BY &#39;1q2w3e4r&#39;;</span><br><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON connectdb.* TO devandy @ &#39;localhost&#39; identified BY &#39;1q2w3e4r&#39;;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p> 마지막에 <code>flush</code> 명령어를 입력해주어야만 <code>privileges</code> 설정이 MySQL에 반영된다.</p><p>방금 생성한 사용자 계정으로 데이터베이스를 실행해보겠다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mysql -h127.0.0.1 -udevandy -p connectdb;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>-h</code> 옵션은 host를 의미한다. 데이터베이스를 실행하는 환경이 어디인지를 지정하는 것이다. 로컬에서 작업하므로 127.0.0.1을 입력하였다.</p></li><li><p><code>-u</code>옵션은 사용자를 지정하는 옵션 명령어이다.</p></li></ul><p>프롬프트창에서 비밀번호를 입력하면, 위에서 생성한 계정으로 접속했음을 알 수 있다.</p><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> docker </tag>
            
            <tag> mysql </tag>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - Generics</title>
      <link href="2020/08/java-generics/"/>
      <url>2020/08/java-generics/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fn4AUZCP7DphMah-Ogllwhz_L06lNtzs3GoJWLDwpu-Vub96QgCRxQzRapGka1rL8juttdvUSHa3_GaAOo74OBU9xOrM9mS84zWgiU3Q4aY0BusSSwDdQRBzKekr_dx10JzOyLbSC3UACtRhG6PxEYyw=w720-h478-no?authuser=0"></p><ul><li><h2 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h2><ul><li><a href="#generic">제네릭이란?</a><ul><li><a href="#type-variable">타입 매개변수</a></li><li><a href="#type-safety">제네릭의 효용 - 타입 안정성</a></li><li><a href="#features">제네릭의 특징</a></li></ul></li><li><a href="#generic-method">제네릭 메서드</a><ul><li><a href="#why-generic-method">왜 제네릭 메서드가 필요한가?</a></li><li><a href="#limited-parameter">제네릭 메서드에서 타입 매개변수를 제한하고 싶을때</a></li></ul></li><li><a href="#type-inference">컴파일러의 제네릭 타입 추론</a></li><li><a href="#limited-generic">제한된 제네릭</a></li><li><a href="#wildcard">와일드 카드</a><ul><li><a href="#types-of-generics">와일드카드 종류</a></li><li><a href="#difference-between-limitedgeneric-and-wildcard">제한된 제네릭과 와일드 카드의 차이?</a></li></ul></li></ul><br><h1 id="제네릭-Generic"><a href="#제네릭-Generic" class="headerlink" title="제네릭(Generic)"></a><a name="generic"></a>제네릭(Generic)</h1><p>제네릭은 클래스 내부에서 사용하는 데이터 타입을 외부에서 지정하는 기법이다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cjPbh-GitRFWPeHgyuGu-0f4G8W8vIrDmg4nbSFu-umvUXae4UsczpCAVAZ6Gsho2KaY3u6ptn2YP6fhobdhdfH4xpyi26upLVQQnFKfJuWybbOgQtao7Jugs0RveD2Ia4fchc3GrPoOknTWGXDV_vXw=w676-h246-no?authuser=0"></p><p>오픈튜토리얼스에서 이고잉님이 설명하신 제네릭 이미지를 인용한다.<br>제네릭 클래스 Person을 사용하여 인스턴스를 만들때 타입 매개변수로 <code>String</code>을 주입했다. 이렇게 하면, 인스턴스 <code>p1</code>은 <code>String</code>형 Person 객체에 대한 인스턴스로 생성된다. 마찬가지로 인스턴스 <code>p2</code>는 <code>StringBuilder</code>형 Person 객체에 대한 인스턴스로 생성된다.</p><p>하나의 객체의 인스턴스를 생성하며 다양한 타입의 인스턴스로 생성할 수 있는 것이다.</p><p>다른 예제 코드도 함께 첨부한다.</p><p><strong>Person.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> T id;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> id;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">setId</span><span class="params">(T id)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.id = id;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PersonExam.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Person&lt;String&gt; t1 = <span class="keyword">new</span> Person&lt;String&gt;();</span><br><span class="line">      t1.setId(<span class="string">&quot;DevAndy&quot;</span>);</span><br><span class="line">      System.out.println( t1.getId() );</span><br><span class="line">     </span><br><span class="line">      Person&lt;Integer&gt; t2 = <span class="keyword">new</span> Person&lt;Integer&gt;();</span><br><span class="line">      t2.setId(<span class="number">123456789</span>);</span><br><span class="line">      System.out.println( t2.getId() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력결과</span><br><span class="line">DevAndy</span><br><span class="line">123456789</span><br></pre></td></tr></table></figure><p>Person 클래스의 멤버필드 <code>id</code>는 따로 데이터타입을 지정하지 않았다. 그냥 <code>T</code> 라는 기호를 붙여뒀을뿐인데, 이 <code>T</code>는 **타입 매개변수(Type variable)**이라 하며, 클래스에서 파라미터를 통해 가져오는 데이터 타입이다. </p><p>외부에서 Person 클래스를 사용할때 데이터 타입을 지정하면 이 때 지정한 데이터 타입이 파라미터를 통해 멤버필드의 타입으로 주입되는 것이다.</p><br><h2 id="타입-매개변수"><a href="#타입-매개변수" class="headerlink" title="타입 매개변수"></a><a name="type-variable"></a>타입 매개변수</h2><p>위에서 타입 매개변수라고 했는데, 일반적으로 타입 매개변수로 <code>T</code>를 많이 사용하긴 하나 왜 <code>T</code>를 사용하는지 몰랐다. 그러나 이 타입 매개변수를 작성하는데에도 관례가 존재했다.</p><p>원칙이나 표준은 아니기에 타입 매개변수는 조직 내에서 약속된 범위내에서 자유롭게 쓸수 있을거라고 생각한다.</p><table><thead><tr><th>Type Variable</th><th>Definition</th></tr></thead><tbody><tr><td>T</td><td>Type</td></tr><tr><td>S, U, V</td><td>2nd, 3rd, 4th..</td></tr><tr><td>E</td><td>Element</td></tr><tr><td>K</td><td>Key</td></tr><tr><td>V</td><td>Value</td></tr><tr><td>N</td><td>Number</td></tr></tbody></table><br><h2 id="제네릭의-효용-타입-안정성"><a href="#제네릭의-효용-타입-안정성" class="headerlink" title="제네릭의 효용 - 타입 안정성"></a><a name="type-safety"></a>제네릭의 효용 - 타입 안정성</h2><p>자, 근데 그래서 이걸 왜 쓰는걸까..? 아니 그냥 선언할때 데이터 타입 지정하면 외부에서 가져다 쓸때도 편하지 않을까? 굳이 데이터 타입 명시하는 일을 외부에 넘기는 이유가 뭘까?</p><p>Java에서 <code>List</code>를 사용하면 IDE에서 자동으로 제네릭을 사용하는걸 경험해봤을 것이다. 자료구조 특징상 같은 데이터 타입의 데이터를 저장할 것이기에 제네릭으로 데이터 타입을 고정하여 <strong>타입 안정성</strong>을 높힌 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">stringList.add(<span class="number">1</span>)    <span class="comment">// compile error</span></span><br><span class="line">stringList.add(<span class="string">&quot;2&quot;</span>)  <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li></ul><p>  아래의 예제 코드를 통해 타입 안정성이 무슨 말인지 알아보자.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">itemBox</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      List items = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">      items.add(<span class="string">&quot;ABC&quot;</span>);  <span class="comment">// unchecked</span></span><br><span class="line">      items.add(<span class="number">123</span>);    <span class="comment">// unchecked</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(Object obj : items)&#123;</span><br><span class="line">         System.out.println(obj);</span><br><span class="line">      &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <code>List</code>를 선언하면서 제네릭을 사용하지 않았다. 이때에 <code>List</code>는 기본적으로 <code>Object</code> 타입이므로 모든 객체 타입을 받아들일 수 있다. 즉 <code>String</code> 형 데이터도 add 할 수 있고, <code>int</code> 형 데이터도 add 할 수 있는 것이다.</p><p>  이런 경우가 타입 안정성이 검증되지 않았다고 이야기할 수 있다. 어떤 타입의 데이터가 <code>List</code>에 add될지 알 수 없으므로 개발자가 의도하지 않은 에러가 런타임시에 발생할 수도 있는 불확실성이 존재한다. </p><p>  <code>List</code>는 자바에서 자료구조 인터페이스에 해당한다. 따라서 다른 타입의 데이터가 같은 리스트에 묶이기 보다는 서로 같은 타입의 데이터가 묶여야 한다.</p><p>  그러나 위 코드에서 제네릭을 적용한다면,</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemBox</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      List&lt;String&gt; items = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">      items.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      items.add(<span class="string">&quot;generic!&quot;</span>);</span><br><span class="line">      <span class="comment">// items.add(123);    // compile error</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(String str : items)&#123;</span><br><span class="line">         System.out.println(str);</span><br><span class="line">      &#125;   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력 결과</span><br><span class="line">hello</span><br><span class="line">generic!</span><br></pre></td></tr></table></figure><p>  <code>String</code> 형만 add 할 수 있으므로 다른 데이터 타입을 <code>List</code>에 add 하려고 하면, 컴파일 에러를 유발하게 된다. 이렇게 제네릭을 사용하면 개발자가 의도하지 않은 데이터 타입이 <code>List</code>에 추가될시 컴파일 단계에서 이 문제를 인지할 수 있게된다.</p><p>  제네릭의 이런 특징을 <strong>타입 안정성을 보장</strong> 한다고 표현한다. 런타임시에 발생할 수 있는 에러를 컴파일 시에 발생하도록 유도하여 안정적인 개발을 돕는 것이다.</p>  <br><h2 id="제네릭의-특징"><a href="#제네릭의-특징" class="headerlink" title="제네릭의 특징"></a><a name="features"></a>제네릭의 특징</h2><h3 id="기본형-타입은-타입-매개변수에서-불가능"><a href="#기본형-타입은-타입-매개변수에서-불가능" class="headerlink" title="기본형 타입은 타입 매개변수에서 불가능"></a>기본형 타입은 타입 매개변수에서 불가능</h3><p>  제네릭에서 타입 매개변수에 들어올 수 있는 데이터 타입으로 기본형 타입은 쓸 수 없다.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> T num;</span><br><span class="line">   <span class="keyword">public</span> S name;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(T num, S name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.num = num;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="comment">// Person&lt;int, String&gt; p1 = new Person&lt;int, String&gt;(10, &quot;devandy&quot;);</span></span><br><span class="line">      <span class="comment">// compile error</span></span><br><span class="line">     </span><br><span class="line">     System.out.println(p1.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  위의 코드처럼 제네릭 클래스를 사용하는 외부 클래스에서 타입으로 <a href="https://github.com/devyoungjin/Wiki/blob/master/languages/java.md#java-type">기본형 타입</a>을 사용할 수 없다는 이야기이다. 기본형 타입을 사용하고자 한다면, 직접 사용할 순 없고 기본형 데이터 타입을 객체화하는 <a href="https://github.com/devyoungjin/Wiki/blob/master/languages/java.md#wrapper-class">Wrapper 클래스</a>를 사용해야 한다.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&lt;<span class="title">T</span>, <span class="title">S</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> T num;</span><br><span class="line">   <span class="keyword">public</span> S name;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(T num, S name)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.num = num;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Person&lt;Integer, String&gt; p1 = <span class="keyword">new</span> Person&lt;Integer, String&gt;(<span class="number">10</span>, <span class="string">&quot;devandy&quot;</span>);</span><br><span class="line">      System.out.println(p1.name);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력 결과</span><br><span class="line">devandy</span><br></pre></td></tr></table></figure>  <br><h1 id="제네릭-메서드"><a href="#제네릭-메서드" class="headerlink" title="제네릭 메서드"></a><a name="generic-method"></a>제네릭 메서드</h1><p>  제네릭은 클래스뿐만 아니라 메서드에서도 사용가능하다.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;T&gt; list)</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>&lt;T&gt;</code> : 타입 매개변수</p></li><li><p><code>void</code> : 리턴 타입</p></li><li><p><code>foo</code> : 메서드 명</p></li><li><p><code>List&lt;T&gt; list</code> :  매개변수</p><p>메서드를 제네릭 메서드로 선언하기 위해서는 접근제한자와 리턴타입 사이에 타입 매개변수를 작성해야 컴파일러에서 이 메서드를 제네릭 메서드로 인식하여 컴파일시 파라미터로 들어오는 타입 매개변수를통해 타입 추론을 할 수 있다.<br>이 내용은 <a href="#type-inference">아래</a>에서 더 정리를 했다!</p><br><h2 id="왜-제네릭-메서드가-필요한가"><a href="#왜-제네릭-메서드가-필요한가" class="headerlink" title="왜 제네릭 메서드가 필요한가?"></a><a name="why-generic-method"></a>왜 제네릭 메서드가 필요한가?</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">add</span><span class="params">(List&lt;String&gt; list, String element)</span></span>&#123;</span><br><span class="line">   list.add(element);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add()</code>는 <code>String</code>형 <code>List</code>에만 대응할 수 있는 메서드이다. 그런데 만약 <code>String</code>형뿐만 아니라 <code>Integer</code> 등 다른 타입의 <code>List</code>도 대응하고 싶다면, 위의 메서드에서 <code>List</code>의 타입을 제네릭으로 바꿔야한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">add</span><span class="params">(List&lt;T&gt; list, T element)</span></span>&#123;</span><br><span class="line">   list.add(element);</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>이렇게 하면, 다양한 데이터 타입의 <code>List</code>에 대응할 수 있는 <code>add()</code>로 변경된다.</p><p>예제 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodEx</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 일반 메서드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">add</span><span class="params">(List&lt;String&gt; list, String element)</span></span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 제네릭 메서드</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">add</span><span class="params">(List&lt;T&gt; list, T element)</span></span>&#123;</span><br><span class="line">        list.add(element);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericMethodEx ex = <span class="keyword">new</span> GenericMethodEx();</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        strList.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        strList.add(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; intList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        intList.add(<span class="number">123</span>);</span><br><span class="line">        intList.add(<span class="number">456</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(ex.add(strList, <span class="string">&quot;!&quot;</span>));</span><br><span class="line">        System.out.println(ex.add(intList, <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력 결과</span><br><span class="line">[hello, world, !]</span><br><span class="line">[123, 456, 1000]</span><br></pre></td></tr></table></figure><br><h2 id="제네릭-메서드에서-타입-매개변수를-제한하고-싶을때"><a href="#제네릭-메서드에서-타입-매개변수를-제한하고-싶을때" class="headerlink" title="제네릭 메서드에서 타입 매개변수를 제한하고 싶을때"></a><a name="limited-parameter"></a>제네릭 메서드에서 타입 매개변수를 제한하고 싶을때</h2><p>메서드로 전달되는 타입 매개변수의 범위를 제한하고자 한다면 아래처럼 입력할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Fruit&gt; <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">   <span class="comment">// success </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그러나 아래처럼 메서드의 파라미터 안에서 <code>extends</code> 키워드를 사용한다면 이는 컴파일 에러가 발생한다. 파라미터가 아니라 메서드 리턴 타입에서 제한을 시켜야만 제네릭을 인자로 불러올 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;T extends Fruit&gt; list)</span></span>&#123;</span><br><span class="line">   <span class="comment">// compile error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h1 id="컴파일러의-제네릭-타입-추론"><a href="#컴파일러의-제네릭-타입-추론" class="headerlink" title="컴파일러의 제네릭 타입 추론"></a><a name="type-inference"></a>컴파일러의 제네릭 타입 추론</h1><p>Java를 처음 공부할때엔 접근제한자, 리턴 타입, 메서드명, 파라미터 순으로 메서드에 대한 정의가 제대로 이루어져야만 컴파일이 된다고 배웠다. 당연히 그도 그럴 것이, 컴파일러가 해당 메서드가 호출되는 시점에 메모리에 올리려면 정확한 객체 정보가 필요하기 때문이다.</p><p>그런데 제네릭을 사용하면, 대체 컴파일러는 어떻게 타입을 추론하는걸까?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericEx01</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericSample</span><span class="params">(T param)</span></span>&#123;</span><br><span class="line">      System.out.println(param);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      genericEx01&lt;String&gt; ex = <span class="keyword">new</span> genericEx01&lt;String&gt;();</span><br><span class="line">       </span><br><span class="line">      ex.genericSample(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력결과</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>위의 코드는 제네릭 클래스 GenericEx의 인스턴스를 생성해서 <code>genericSample()</code>을 호출하는 코드이다.</p><p><code>genericSample()</code>은 제네릭 타입의 파라미터를 받고 있는데, <code>main()</code>에서 인스턴스를 생성하면서 데이터 타입을 String으로 전달했기 때문에 컴파일러가 데이터 타입을 추론할 수 있었다.</p><p>이제 여기서 변화를 줘보겠다. GenericEx를 제네릭 클래스에서 일반 클래스로 바꿔보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericEx02</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericSample</span><span class="params">(T param)</span></span>&#123;</span><br><span class="line">      System.out.println(param);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      genericEx02 ex = <span class="keyword">new</span> genericEx02();</span><br><span class="line">       </span><br><span class="line">      ex.genericSample(<span class="string">&quot;hello&quot;</span>);  <span class="comment">// compile error</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력결과</span><br><span class="line">Error: Unable to initialize main class genericExDevAndy.genericEx02</span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: T</span><br></pre></td></tr></table></figure><p><code>T</code>라는 클래스를 찾을수 없다는 메세지와 함께 컴파일 에러가 발생했다.</p><p>왜 컴파일러는 타입 추론을 하지 못한걸까?</p><p>위의 코드를 다시 훑어보면, <code>genericSample()</code>의 파라미터로 들어오는 <code>T</code>라는 타입을 컴파일러 입장에서 추론할 수 있는 방법이 없다. 인스턴스를 통해 전달된 데이터 타입이 없기 때문에 컴파일러가 타입 매개변수 <code>T</code>가 어떤 타입인지 추론하지 못하는 것이다.</p><p>그래서 컴파일러에게 이 <code>T</code> 가 제네릭 타입 매개변수임을 알려주기 위해 <code>genericSample()</code>이 있는 클래스를 제네릭 클래스로 바꾸던, 메서드 자체를 제네릭 메서드로 바꾸던 해주어야 한다. 그럼 컴파일러는 <code>T</code>를 제네릭 타입 매개변수로 인지하고 이 객체를 사용하는쪽에서 주입하는 데이터 타입으로 맞춰서 호출해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEx03</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericSample</span><span class="params">(T param)</span> </span>&#123;</span><br><span class="line">      System.out.println(param);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      GenericEx03 ex = <span class="keyword">new</span> GenericEx03();</span><br><span class="line">      ex.genericSample(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 출력결과</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericEx04</span>&lt;제네릭&gt; </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericSample</span><span class="params">(제네릭 param)</span> </span>&#123;</span><br><span class="line">System.out.println(param);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">GenericEx04&lt;String&gt; ex = <span class="keyword">new</span> GenericEx04&lt;String&gt;();</span><br><span class="line">ex.genericSample(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 출력결과</span></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><br><p>지금까지는 일반 메서드 예제코드를 다뤄봤다. 그렇다면 <code>static</code> 메서드에서는 어떨까. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericEx05</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">genericSample</span><span class="params">(T param)</span></span>&#123;</span><br><span class="line">      <span class="comment">// compile error. 타입 추론 불가.</span></span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>static</code> 키워드를 사용함으로써 런타임시 heap 메모리에 바로 객체를 올려두어야 하는데, 런타임시에는 이 파라미터의 데이터 타입을 알 수 없으므로 heap 메모리에 객체를 올릴수가 없게된다. </p><p>따라서 이 경우엔 <code>static</code> 메서드를 <a href="#generic-method">제네릭 메서드</a>로 바꿔주어야만 컴파일이 가능해진다. 그냥 리턴 타입 앞에 제네릭 타입 변수를 명시해주면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericEx06</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericSample</span><span class="params">(T param)</span></span>&#123;</span><br><span class="line">      <span class="comment">// ok. 타입 추론 가능.</span></span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 제네릭 메서드로 바꾸면, 컴파일러에서 타입 추론이 가능해진다. </p><p>컴파일러는 <code>genericSample()</code> 가 타입 매개변수 <code>T</code>를 사용하는 제네릭 메서드라는걸 알고 있고, 제네릭 메서드 타입 매개변수와 같은 타입 매개변수가 파라미터로 들어왔기 때문에 컴파일러가 이 타입을 추론할 수 있는 것이다.</p><p>만약 아래의 코드처럼 파라미터의 타입 매개변수와 제네릭 메서드의 타입 매개변수가 다르면, 컴파일러에서 타입 추론이불가능해지기 때문에 이 역시 컴파일 에러를 유발한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericEx07</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericSample</span><span class="params">(S param)</span></span>&#123;</span><br><span class="line">      <span class="comment">// compile error.</span></span><br><span class="line">      <span class="comment">// T cannot be resolved to a type</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>타입 매개변수 <code>T</code>를 기대했지만, 파라미터로 들어온 타입 매개변수는 <code>S</code>이기 때문이다.</p><br><h1 id="제한된-제네릭"><a href="#제한된-제네릭" class="headerlink" title="제한된 제네릭"></a><a name="limited-generic"></a>제한된 제네릭</h1><p>제네릭 클래스는 이를 인스턴스로 생성해서 사용하는 쪽에서 타입 변수로 아무런 데이터 타입을 넣어서 사용할 수 있다. 그러나 이 타입변수에 <code>extends</code> 키워드를 사용하면, 특정 클래스를 상속받는 클래스로만 타입 변수를 제한할 수 있다. 이를 제한된 제네릭이라고 한다.</p><p>예제 코드를 살펴보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span>&gt; </span>&#123;</span><br><span class="line">   List&lt;T&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">      items.add(item);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드처럼 타입 매개변수 뒤에 <code>extends</code> 키워드를 사용하면, 이 제네릭 클래스는 특정 클래스를 상속받는 타입 변수만 허용된다는 제한 조건이 성립된다. 따라서 타입변수 <code>T</code> 에 아무 데이터 타입이 들어올 수 없게 된 것이다.</p><br><h2 id="제한된-제네릭의-특징"><a href="#제한된-제네릭의-특징" class="headerlink" title="제한된 제네릭의 특징"></a>제한된 제네릭의 특징</h2><p>제한된 제네릭에선 타입 매개변수의 제한조건으로 <code>extends</code> 키워드만 사용할 수 있다. 설사 인터페이스를 구현하는 제약을 추가하려고 해도 <code>implement</code>대신 반드시 <code>extends</code> 만 사용해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sample</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Eatable</span>&gt; </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>추가로 클래스 Fruit의 자식이면서 인터페이스 Eatable도 구현해야한다면 <code>&amp;</code> 기호를 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitBox</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span> &amp; <span class="title">Eatable</span>&gt;</span>&#123; &#125;</span><br></pre></td></tr></table></figure><br><p>제한된 제네릭 사용예제 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> <span class="keyword">implements</span> <span class="title">Eatable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Fruit&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Apple&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grape</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Grape&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;Toy&quot;</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   List&lt;T&gt; list = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T item)</span> </span>&#123; list.add(item); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">T <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="keyword">return</span> list.get(i); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list.size(); &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> list.toString(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitBox</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Fruit</span> &amp; <span class="title">Eatable</span>&gt; <span class="keyword">extends</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitBoxEx</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      FruitBox&lt;Fruit&gt; fruitBox = <span class="keyword">new</span> FruitBox&lt;Fruit&gt;();</span><br><span class="line">      FruitBox&lt;Apple&gt; appleBox = <span class="keyword">new</span> FruitBox&lt;Apple&gt;();</span><br><span class="line">      FruitBox&lt;Grape&gt; grapeBox = <span class="keyword">new</span> FruitBox&lt;Grape&gt;();  </span><br><span class="line"></span><br><span class="line">      <span class="comment">// FruitBox&lt;Grape&gt; grapeBox2 = new FruitBox&lt;Apple&gt;();  // compile error. 타입 불일치.</span></span><br><span class="line">      <span class="comment">// FruitBox&lt;Grape&gt; grapeBox2 = new FruitBox&lt;Fruit&gt;();  // compile error. 타입 불일치.</span></span><br><span class="line">      <span class="comment">// FruitBox&lt;Toy&gt; toyBox = new FruitBox&lt;Toy&gt;();   // compile error. FruitBox의 제한조건에 부합하지 않으므로.</span></span><br><span class="line"></span><br><span class="line">      fruitBox.add(<span class="keyword">new</span> Fruit());   </span><br><span class="line">      fruitBox.add(<span class="keyword">new</span> Apple());   <span class="comment">// appleBox의 타입 Apple이 FruitBox의 타입인 Fruit의 자식 객체이므로 Ok.</span></span><br><span class="line">      fruitBox.add(<span class="keyword">new</span> Grape());   <span class="comment">// Grape가 FruitBox의 타입인 Fruit의 자식 객체이므로 Ok.</span></span><br><span class="line">      appleBox.add(<span class="keyword">new</span> Apple());   </span><br><span class="line">      <span class="comment">// applpeBox.add(new Grape());  // appleBox의 타입 Apple과 Grape는 서로 상속관계가 아님. 타입 불일치.</span></span><br><span class="line">      grapeBox.add(<span class="keyword">new</span> Grape());   </span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">&quot;fruitbox : &quot;</span>+fruitBox);</span><br><span class="line">      System.out.println(<span class="string">&quot;appleBox : &quot;</span>+appleBox);</span><br><span class="line">      System.out.println(<span class="string">&quot;grapeBox : &quot;</span>+grapeBox);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력 결과</span><br><span class="line">fruitbox : [Fruit, Apple, Grape]</span><br><span class="line">appleBox : [Apple]</span><br><span class="line">grapeBox : [Grape]</span><br></pre></td></tr></table></figure><p><a href="https://repl.it/@youngjinmo/genericsSample">Repl에서 실행해보기</a></p><br><h1 id="와일드-카드"><a href="#와일드-카드" class="headerlink" title="와일드 카드"></a><a name="wildcard"></a>와일드 카드</h1><p>와일드 카드란 제네릭 타입을 파라미터나 리턴 타입으로 사용할 때 구체적인 타입 대신 사용하는 문법이다.</p><p>예제 코드를 따라가보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericsWildCards</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intSum</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(Numer num : list)&#123;</span><br><span class="line">          sum += num.doubleValue();</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">return</span> sum;</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      GenericsWildCards generic = <span class="keyword">new</span> GenericsWildCards();</span><br><span class="line">       </span><br><span class="line">      List&lt;Integer&gt; intNums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">      List&lt;String&gt; stringWords = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">       </span><br><span class="line">      intNums.add(<span class="number">3</span>);</span><br><span class="line">      intNums.add(<span class="number">5</span>);</span><br><span class="line">      intNums.add(<span class="number">10</span>);</span><br><span class="line">       </span><br><span class="line">      <span class="keyword">int</span> sum1 = generic.intSum(intNums);</span><br><span class="line">      <span class="keyword">int</span> sum2 = generic.intSum(stringWords); <span class="comment">// compile error. 와일드카드 조건에 불일치.</span></span><br><span class="line">       </span><br><span class="line">      System.out.println(<span class="string">&quot;sum of integers : &quot;</span>+sum1);</span><br><span class="line">      System.out.println(<span class="string">&quot;Sum of doubles : &quot;</span>+sum2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드를 보면, <code>sum2</code>를 선언하는 코드에서 컴파일 에러가 발생한다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3deMKzWikqhQOlYx02oYhd5DdfqSqf-oiLK9a1woQaOIa4MbkQ05phOhpyGlHGM-HbPwvtwmAu4lzpEp9TR6HfB10T1DcKPrc3wfqoPMSmq1qlvilz_-kW9LJquHhH6ERP-x6Luy3EFAP9uoizQ9t9qWA=w768-h132-no?authuser=0"></p><p>원인은 <code>sum2</code>를 선언하는 과정에서사용한 <code>intSum()</code> 의 파라미터로 들어간 타입이  <code>generic</code> 인스턴스 객체의 와일드카드  조건에 부합하지 않은 인자(argument)로 들어왔다는 경고 문구이다.</p><p><code>intSum()</code>을 보면 다음과 같이 와일드 카드를 사용하고 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intSum</span><span class="params">(List&lt;? extends Number&gt; list)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p><code>intSum()</code> 파라미터로 List형을 받을 수 있는데, List의 타입은 <code>Number</code>를 상속하는 자식객체 타입으로 사용을 제한하는 와일드카드가 선언되어 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GenericsWildCards generic = <span class="keyword">new</span> GenericsWildCards();</span><br><span class="line">List&lt;String&gt; stringWords = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">int</span> sum2 = generic.intSum(stringWords);</span><br></pre></td></tr></table></figure><p>그런데 <code>intSum()</code>의 파라미터로 <code>String</code>형 List를 인자로 사용하니 컴파일 에러가 발생한 거였다.</p><br><h2 id="와일드카드-종류"><a href="#와일드카드-종류" class="headerlink" title="와일드카드 종류"></a><a name="types-of-generics"></a>와일드카드 종류</h2><p>제네릭에서 와일드 카드는 크게 3가지로 분류할 수 있다.</p><h3 id="와일드-카드-Unbounded-Wildcards"><a href="#와일드-카드-Unbounded-Wildcards" class="headerlink" title="와일드 카드 (Unbounded Wildcards)"></a>와일드 카드 (Unbounded Wildcards)</h3></li><li><p><code>&lt;?&gt;</code></p></li><li><p>제한이 없기때문에 모든 클래스나 인터페이스 타입이 올 수 있다.</p></li><li><p>사실상 <code>&lt;? extends Object&gt;</code>와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intSum</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="와일드-카드의-하위-클래스-제한-Upper-Bounded-Wildcards"><a href="#와일드-카드의-하위-클래스-제한-Upper-Bounded-Wildcards" class="headerlink" title="와일드 카드의 하위 클래스 제한(Upper Bounded Wildcards)"></a>와일드 카드의 하위 클래스 제한(Upper Bounded Wildcards)</h3></li><li><p><code>&lt;? extends T&gt;</code></p></li><li><p>타입 매개변수 <code>T</code>와 그 자식 객체들을 구현한 매개변수만 가능</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intSum</span><span class="params">(List&lt;? extends T&gt; list)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="와일드-카드의-상위-클래스-제한-Lower-Bounded-Wildcards"><a href="#와일드-카드의-상위-클래스-제한-Lower-Bounded-Wildcards" class="headerlink" title="와일드 카드의 상위 클래스 제한 (Lower Bounded Wildcards)"></a>와일드 카드의 상위 클래스 제한 (Lower Bounded Wildcards)</h3></li><li><p><code>&lt;? super T&gt;</code></p></li><li><p>타입 매개변수 <code>T</code>와 그 부모 객체들을 구현한 매개변수만 가능</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intSum</span><span class="params">(List&lt;? <span class="keyword">super</span> T&gt; list)</span> </span>&#123; &#125;    </span><br></pre></td></tr></table></figure><p>와일드카드 예제 코드</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericWildcards</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 와일드카드 unbounded wildcard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printData</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Object obj : list)&#123;</span><br><span class="line">            System.out.println(obj+<span class="string">&quot; ::&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 와일드카드 상위클래스 제한 lower bounded wildcard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInteger</span><span class="params">(List&lt;? <span class="keyword">super</span> Integer&gt; list)</span></span>&#123;</span><br><span class="line">        list.add(<span class="number">120</span>);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 와일드카드 하위클래스 제한 upper bounded wildcard</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sum</span><span class="params">(List&lt;? extends Number&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Number n : list)&#123;</span><br><span class="line">            sum += n.doubleValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; intNums = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;String&gt; stringWords = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        </span><br><span class="line">        intNums.add(<span class="number">3</span>);</span><br><span class="line">        intNums.add(<span class="number">10</span>);</span><br><span class="line">        intNums.add(<span class="number">200</span>);</span><br><span class="line">        </span><br><span class="line">        stringWords.add(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        stringWords.add(<span class="string">&quot;generic&quot;</span>);</span><br><span class="line">        stringWords.add(<span class="string">&quot;widlcard&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        printData(stringWords);</span><br><span class="line">        addInteger(intNums);</span><br><span class="line">        System.out.println(sum(intNums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;   출력 결과</span><br><span class="line">hello ::</span><br><span class="line">generic ::</span><br><span class="line">wildcard ::</span><br><span class="line">[3, 10, 200, 120]</span><br><span class="line">333.0</span><br></pre></td></tr></table></figure><p><a href="https://repl.it/@youngjinmo/java-generic-wildcard-sample-codes">Repl에서 실행하기</a></p><br><h2 id="제한된-제네릭과-와일드-카드의-차이"><a href="#제한된-제네릭과-와일드-카드의-차이" class="headerlink" title="제한된 제네릭과 와일드 카드의 차이?"></a><a name="difference-between-limitedgeneric-and-wildcard"></a>제한된 제네릭과 와일드 카드의 차이?</h2><p>제네릭을 공부하다보니 제한된 제네릭과 와일드카드가 헷갈렸다. 아래의 글을 읽고 관점을 구분해서 바라보니 그 차이를 조금씩 이해할 수 있었다.</p><table>  <tr>      <th style="width:10%; text-align: center;"></th>      <th style="width:40%; text-align: center;">제한된 제네릭</th>      <th style="width:50%; text-align: center;">와일드카드</th>  </tr>  <tr>      <td style="text-align: center;">관점</td>      <td>제네릭 클래스를 선언하는 개발자</td>      <td>메서드를 만드는 개발자</td>  </tr>  <tr>      <td style="text-align: center;">목적</td>      <td>객체 생성시 사용될 객체를 제한</td>      <td>메서드에 사용될 매개변수가 제네릭 클래스를 구현한 객체일때 그 제네릭 클래스의 타입 매개변수를 제한</td>  </tr></table></li></ul><p>  이제 코드 작성시 제한된 제네릭과 와일드카드의 차이를 살펴보겠다.</p><p>  제네릭 메서드는 파라미터에서 제한된 제네릭을 사용할 수 없었다.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethodEx01</span><span class="params">(List&lt;T extends Fruit&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// compile error.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Fruit&gt; <span class="function"><span class="keyword">void</span> <span class="title">genericMethodEx02</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ok.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  반면, 와일드카드는 파라미터에서 제한된 제네릭을 사용하는게 가능하다.</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">genericMethodEx03</span><span class="params">(List&lt;? extends Fruit&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ok.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <br><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://opentutorials.org/course/2518/6237">생활코딩 - 제네릭</a></li><li><a href="https://www.youtube.com/watch?v=n28M8iryFPw">10분 테코톡 - 💫두강의 Generics</a></li><li><a href="https://www.youtube.com/watch?v=SjlnP1N0R4o">한빛미디어 - 이것이 자바다 13.1 왜 제네릭을 사용해야 하는가</a></li><li><a href="https://yaboong.github.io/java/2019/01/19/java-generics-1/">YABOONG - 자바 제네릭 이해하기</a></li><li><a href="https://siyoon210.tistory.com/16">Siyoon210 - 제네릭스(Generics) 와일드카드&lt;?&gt;</a></li><li><a href="https://link.coupang.com/re/CSHARESDP?lptag=CFM65897625&pageKey=57799011&itemId=200423111&vendorItemId=71077819740">Java의 정석</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java5 </tag>
            
            <tag> generics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github Two-Factor 적용이후 Authenticatin Fail 발생할때</title>
      <link href="2020/07/git-access-token/"/>
      <url>2020/07/git-access-token/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/pw/ACtC-3c0HSofpqq_UtrJXXwrAYhUV-EvsnA_Wk8SIDLiLtS_nlfVMjtTtXUHXTwn1bepE5e0IoOi6LJ3drWR0gnFogQXpV1ZVlsSHCnZ9DkUMA7nXvMRAODKmqmIkAzUWTNBUChJwuGm2NQfTJVwgiDR_ax9Ng=w720-h480-no?authuser=0"/><p>Github에서 <a href="https://jojoldu.tistory.com/449">Two-factor 인증</a>을 적용하고 나니 CLI에서 push할 때 계속 Authentication failed 에러가 발생했다. </p><p>원격 서버(Github)에서 인증 정보가 바뀌었는데 로컬에 적용된 인증 정보와 일치하지 않으면서 발생한 현상이다.</p><p>로컬의 인증정보를 업데이트하려면, <strong>1)</strong> <u>Github에서 토큰을 발급</u>받아서 <strong>2)</strong> 로컬에서 <u>authentication을 등록</u>해두어야 한다. 그럼 일단 토큰을 업데이트 해야한다.</p><p><a href="https://github.com/settings/tokens">Github 설정</a>에 들어가서 새로운 토큰을 발급받자. Generate 버튼을 클릭해서 신규 Personal access 토큰을 발급한다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eu0Ljcu-TpqKcwSPx9XWYUR6X8qu9o80GPT-5tyy8_tPCccHHRmHD1YZZYDx3T7zyXEIY6lvXw3KwwhmmhjxVdmBlTxIA01Sz52dNze2OrFrQQs0iFSExNyEN7u3ttY27znjREmHoyRS7ctqt49GbA-w=w2016-h596-no?authuser=0"></p><p>발급을 시도하면, 토큰의 권한을 설정할 수 있다. 필요한 권한만큼 체크해서 넘어가면 된다. 그럼 아래의 이미지처럼 토큰 주소가 발급된다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3ewISsb7wsh0RTYzi-fYnXSSP94g3DT0Ii3QT0Eu_Gsqars8vYqMj78UJrtLGbL-wBbWa4FckYQv1Jkal4CDC8P4goM6_PMbVl4o4bT13gc2Fs_Ti3XVMGtlAAGMdoMj9km1zoXQt_7s51z6g_8FmHjVw=w1872-h1478-no?authuser=0"></p><p>이 토큰 주소를 로컬에서 authentication할 때 패스워드로 등록하면 된다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3f5wL4eorW_E1nKq8t0-5LDhUmYBo_dIj1fH8MVBIUCe9VA40sYajqG-SYdoi5QJQMdJCquPuWFLX6G0ORk2Uk0aTZi8cV40CYh1-s13Nj4A_Sgb1BB2WFrcEFbMtk87YNfNJpjKOwPI7LNkbbQTzYtSQ=w1109-h344-no?authuser=0"></p><p>Username에는 Github에서 사용하는 이메일을 입력하고, 패스워드는 토큰을 발급받으면서 받은 주소를 입력하면 된다. 이후부터는 다시 CLI에서 원격서버와 통신(push, pull)이 가능해진다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fSU08a0KYMwP1gs457YnuTVRSYd1Ke7jXPIkqYhJvDNYRvMVCPuFxY9OWCfYaALjieIFCCAsV472UB9VqDLCnJD8xanUjd4XsYMazsrTahpcoR0Ik5tNyWLiMsLyXyPOmxQGL3mZgczxhfCfe3VCwu8w=w1752-h704-no?authuser=0"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> git </tag>
            
            <tag> error </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - JVM</title>
      <link href="2020/07/java-jvm/"/>
      <url>2020/07/java-jvm/</url>
      
        <content type="html"><![CDATA[<div align="center">  <img src="https://lh3.googleusercontent.com/pw/ACtC-3e1wABVIxe20MsC2iZ5sxyWZP3UMB3BV5dP9qZVWb-F-rmC9TmXhvkDSYNodvT9Ysfg1QvAt6WgJa6tdkg5heBGQZSCs8OM2dkPqdaMn0d3obmoc1oehFLVquGR5H1sXupM5F4hCqhgvt1-oTyvA215AA=w720-h480-no?authuser=0"/></div><p>자바 소스코드를 class 파일로 컴파일해주고 실행하는 **JVM(Java Virtual Machine)**의 메모리 구조에 대한 이야기이다.</p><h2 id="왜-JVM이-필요한가"><a href="#왜-JVM이-필요한가" class="headerlink" title="왜 JVM이 필요한가?"></a>왜 JVM이 필요한가?</h2><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eves8TGpNW27YOqU0U5C9CFzFrkP6JUEzhMXbFhYt9SfrYQKh3ZkjNXRIGkPTnqIYeyitKzKQRR1kJUbbQv9dv1uP6meWH9-ZPVq6Hz6py3i8t8EiH4QlzMNS3fUrncNtFj9oFxLNuYJFvn9PJRcsdmg=w995-h274-no?authuser=0"></p><p>자바로 프로그래밍된 파일을 실행하려면 JVM이 필수적이다. 자바 소스코드는 그 자체로 OS에서 즉시 실행할 수 없고 자바 런타임환경에서 실행될 수 있는데, 그러려면 JVM이 운영체제에 맞게 바이트 코드로부터 기계어로 컴파일 해주어야 한다.</p><h3 id="자바-애플리케이션-실행과정"><a href="#자바-애플리케이션-실행과정" class="headerlink" title="자바 애플리케이션 실행과정"></a>자바 애플리케이션 실행과정</h3><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fp4NDDdjAj7GndOA-Pr9PNm0l_cpTYBf3EyciNqe5PqVTqfKWw8UxVCmxNofj9_wNehW1yRnezeidg2prGrTUAtY_B65mS7nMzOf6h2JaHZ9SPMZY1ok8SnXfiV083ZBEUvsiINkq8wBaXw-cMB-lslA=w773-h502-no?authuser=0"></p><p>운영체제에서 자바 프로그램을 실행하기 위한 과정은 다음과 같다. </p><ol><li>프로그래머가 작성한 소스코드(.java)를 JDK에 내장된 자바 컴파일러(javac)로 컴파일한다. 컴파일 결과로 바이트 코드(.class)가 생성된다. 컴파일 하는 목적은 JVM을 위함이다. JVM은 바이트 코드만 읽을 수 있기 때문이다.<br><em>(웹 개발시 Maven이나 Gradle로 빌드하면서 생성되는 jar파일은 이런 class 파일들의 집합이다.)</em></li><li>자바 컴파일러(javac)로 컴파일한 class 파일은 JVM 에서 구동할 수 있다. 그럼 JVM은 바이트 코드로부터 실행환경(운영체제)에 맞는 기계어(binary)로 컴파일 한다.</li><li>이렇게 컴파일된 기계어는 자바 런타임 환경(JRE)에서 애플리케이션(프로세스)으로 실행된다. </li></ol><p>OS에서 바로 실행하는 것이 아닌 JVM이라는 가상머신을 통해 구동하기 때문에 Java는 <a href="https://devyoungjin.github.io/2019/02/java-intro/#os-independent" target="_blank">플랫폼 독립적</a>이라는 특징을 가질 수 있는 것이다.</p><p>JVM은 바이트 코드를 읽어서 프로세스로 동작시키는 것 외에도 가비지 컬렉터(GC)를 내장하고 있어서 GC가 메모리 관리를 해준다. 메모리 관리란, 이미 쓰임을 다한 메모리 주소를 반납하는 것을 의미하는데, C 계열의 언어에서는 프로그래머가 수동으로 해야하는 일이지만, 자바는 그럴 필요가 없다.</p><p>JVM과 함께 언급되는 키워드로 JDK, JRE가 있는데, JDK와 JRE는 서로 다른 환경에서 필요하다. JDK는 자바 애플리케이션을 개발하는 환경에서 필요하며, JRE는 자바 애플리케이션을 실행하는 환경에서 필요한 자원이다.</p><h3 id="Java와-C의-차이"><a href="#Java와-C의-차이" class="headerlink" title="Java와 C의 차이"></a>Java와 C의 차이</h3><p>자바는 소스 코드(.java)로부터 바이트 코드(.class)로 컴파일 하고, 다시 바이트 코드로부터 기계어로 컴파일하는 과정을 거치지만, C에서는 바이트 코드 변환과정없이 소스코드에서 곧바로 기계어로 번역된다. 그래서 C가 자바보다 실행 속도가 더 빠르다고 이야기되곤 한다. 그렇다면 자바는 왜 C처럼 소스 코드를 기계어로 바로 컴파일하지 않고, 바이트 코드로 컴파일하는 과정을 거치는 걸까?</p><p>이유는 이미 위에 작성해두었다! ㅎㅎ</p><br><h2 id="JVM-구동-원리"><a href="#JVM-구동-원리" class="headerlink" title="JVM 구동 원리"></a>JVM 구동 원리</h2><p>위에서 자바 애플리케이션의 구동원리를 크게 두번의 과정으로 설명했는데, 위의 과정에서 2번을 좀 더 상세히 정리해보려고 한다. 즉, <strong>JVM에서 어떻게 프로세스로 변환되는지에 대한 과정</strong>이다.</p><ol><li>자바 애플리케이션이 실행되면, JVM은 이 애플리케이션의 실행에 필요한 메모리를 운영체제로부터 할당받는다. 이렇게 할당된 메모리는 용도에 따라 여러 영역으로 나누어 관리된다.</li><li>그리고 JVM의 클래스 로더에 의해 class 파일(바이트 코드)들이 JVM으로 로딩된다.</li><li>로딩된 class 파일은 Execution Engine을 통해 해석된다.</li><li>해석된 바이트 코드들이 Runtime Data Areas로 배치되어 프로세스로써 실질적인 수행이 이루어진다.</li></ol><br><h2 id="JVM의-구성"><a href="#JVM의-구성" class="headerlink" title="JVM의 구성"></a>JVM의 구성</h2><p><img src="https://static.wixstatic.com/media/b9ec8c_3b784efced29431bbb856c12d0ac1ee3~mv2.png"></p><ol><li><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><ul><li>Runtime 시에 동적으로 클래스 파일들을 JVM으로 로딩하는데 사용하는 서브 시스템이다. </li><li>클래스 로더에서 발생하는 행위는 아래 3가지로 구분할 수 있다.<ul><li>Loading - JVM으로 로딩한다.</li><li>Linking - 필요한 영역으로 배치하는 역할을 수행.</li><li>Initialization</li></ul></li></ul></li><li><h3 id="Method-Area"><a href="#Method-Area" class="headerlink" title="Method Area"></a>Method Area</h3><ul><li>클래스 정보를 메모리 공간에 처음 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간이다.</li><li>올라가게 되는 메서드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드이다. 거의 모든 바이트 코드가 Method Area에 할당된다고 생각하면 된다.</li><li>클래스 데이터를 위한 공간이라고 이해하면 좋다.</li><li>Method Area는 Constant runtime pool이라는 관리 영역도 존재하는데, 이곳에서 상수형 자료형을 저장하고 참조하여 중복을 막는 역할을 수행한다.</li></ul></li><li><h3 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h3><ul><li>인스턴스 변수들과 배열 등 모든 변수가 Heap 에 저장된다.</li><li>new 키워드로 생성된 인스턴스 변수들이 할당되는 곳이라고 이해하면 된다.</li><li>Method Area가 클래스 데이터를 위한 공간이라면, Heap은 객체를 위한 공간이다.</li></ul></li><li><h3 id="JVM-Language-Stacks"><a href="#JVM-Language-Stacks" class="headerlink" title="JVM Language Stacks"></a>JVM Language Stacks</h3><ul><li>메서드 안에서 사용되는 변수(local variable)들을 저장하는 영역이다.</li><li>자바 애플리케이션 실행 과정에서 임시로 할당되었다가 메서드를 빠져나가며 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다.</li><li>메서드 호출시마다 각각의 스택 프레임(해당 메서드만을 위한 공간)이 생성된다.</li><li>메서드 수행이 끝나면 스택 프레임 별로 삭제를 한다.</li></ul></li><li><h3 id="PC-Register"><a href="#PC-Register" class="headerlink" title="PC Register"></a>PC Register</h3><ul><li>현재 실행중인 JVM의 주소를 저장한다.</li><li>쓰레드가 시작될 때 생성되는 공간으로 쓰레드마다 PC 레지스터를 각각 갖는다.</li><li>쓰레드가 어떤 명령에 의해 어떤 부분을 실행해야하는지를 기록하는 영역이다.</li></ul></li><li><h3 id="Native-Method-Stacks"><a href="#Native-Method-Stacks" class="headerlink" title="Native Method Stacks"></a>Native Method Stacks</h3><ul><li>자바 애플리케이션이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어(바이너리)로 작성된 프로그램을 실행시키는 영역이다.</li></ul></li><li><h3 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h3><ul><li>클래스를 실행시키는 역할을 수행한다.</li><li>클래스 로더가 JVM 내의 Runtime Data Area에 바이트 코드를 배치시키면, 이것이 실행 엔진에 의해 실행된다.</li><li>실행 엔진은 바이트 코드를 JVM에서 실제로 기계가 실행할 수 있는 형태인 바이너리로 변경한다.</li></ul></li><li><h3 id="Native-Method-Interface"><a href="#Native-Method-Interface" class="headerlink" title="Native Method Interface"></a>Native Method Interface</h3><ul><li>JVM 에서 실행중인 자바 코드가 라이브러리와 네이티브 애플리케이션들에 의해 호출되도록 허용하는 역할을 수행한다.</li></ul></li><li><h3 id="Native-Method-Libraries"><a href="#Native-Method-Libraries" class="headerlink" title="Native Method Libraries"></a>Native Method Libraries</h3><ul><li>실행 엔진에 필요한 네이티브 라이브러리들의 모음(컬렉션)이다.</li></ul></li><li><h3 id="Run-Time-Area"><a href="#Run-Time-Area" class="headerlink" title="Run Time Area"></a>Run Time Area</h3><ul><li>자바 애플리케이션을 실행하기 위해 운영체제에서 할당받은 메모리 영역이다.</li></ul></li></ol><br><p><strong>함께 읽으면 훠얼씬 좋은 글</strong></p><ul><li><a href="https://yeon-kr.tistory.com/112">페페로니피자 - [Java]JVM Architecture란?</a></li><li><a href="https://asfirstalways.tistory.com/158">Jbee - JVM이란 무엇인가?</a></li><li><a href="https://asfirstalways.tistory.com/159">Jbee - GC/JVM 구동원리에 이어서</a></li></ul><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Enumeration 인터페이스와 Iterator 인터페이스</title>
      <link href="2020/07/enumeration-iterator/"/>
      <url>2020/07/enumeration-iterator/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/pw/ACtC-3dIdR_1TGmDO2nU1B5bqSUsZSkjU3QsbPC_MmORxvTMnbD4hMtBW9mvOEQKBLsCzCVAIUZJEN8zZHOUGwyvJB4qk6WvryU-g2Z15V15o857kAHBkeULBVpL6DNul4F0eEVcwj_LXMRyzEv_w51ugsaGLQ=w720-h467-no?authuser=0" /><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html">Enumeration 인터페이스</a>와 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html">Iterator 인터페이스</a> 모두 하는 역할은 비슷하다. 배열의 원소(Element)들을 한 순간에 하나씩 처리할 수 있는 메서드를 제공하는 컬렉션들이다. 일반적으로 배열문과 함께 사용되며, 다음에 처리할 수 있는 원소가 있는지 없는지 등의 여부(boolean)와 다음 원소를 반환할 수 있다.</p><p>Enumeration 인터페이스와 Iterator 인터페이스의 메서드를 알아보며 어떤 차이가 있는지 알아보자.</p><h2 id="Enumeration-인터페이스"><a href="#Enumeration-인터페이스" class="headerlink" title="Enumeration 인터페이스"></a><a name="enumeration"></a>Enumeration 인터페이스</h2><p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html">Enumeration</a> 인터페이스는 Java 8에서 Iterator 인터페이스가 추가되기 전까지 사용하던 컬렉션이다. </p><h3 id="Enumeration의-주요-메서드"><a href="#Enumeration의-주요-메서드" class="headerlink" title="Enumeration의 주요 메서드"></a>Enumeration의 주요 메서드</h3><ul><li><strong>hasMoreElements()</strong> : boolean<ul><li>element가 더 남아있는지 boolean 값을 반환한다.</li></ul></li><li><strong>nextElement()</strong> : E<ul><li>다음 element를 열거형(E)으로 반환한다.</li></ul></li></ul><br><h2 id="Iterator-인터페이스"><a href="#Iterator-인터페이스" class="headerlink" title=" Iterator 인터페이스"></a><a name="iterator"></a> Iterator 인터페이스</h2><p><a href="#enumeration">Enumeration</a> 인터페이스와 비슷하지만, <strong>원소를 삭제할 수 있는 메서드가 존재</strong>한다는 점에서 Enumeration가 다르다.</p><h3 id="Iterator의-주요-메서드"><a href="#Iterator의-주요-메서드" class="headerlink" title="Iterator의 주요 메서드"></a>Iterator의 주요 메서드</h3><ul><li><strong>hasNext()</strong> : boolean<ul><li>다음에 처리할 element가 남아있는 boolean 값을 반환한다.</li></ul></li><li><strong>next()</strong> : E<ul><li>다음 element를 열거형(E)로 반환한다.</li></ul></li><li><strong>remove()</strong> : void<ul><li>element를 삭제한다.</li></ul></li></ul><p>Iterator 인터페이스는 Java 1.2부터 추가되었는데, <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html">오라클 공식문서</a>에서는 아래와 같은 이유로 Enumeration 인터페이스 대신 Iterator 인터페이스를 쓰라고 권하고 있다.</p><blockquote><p>NOTE : The functionality of this interface is duplicated byu the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementatinos should consider using iterator in preference to Enumeration.</p></blockquote><p>삭제할 수 있는 메서드가 생겼고, 메서드의 이름이 더 짧아졌기 때문에 새로 구현하는 객체에서는 Enumeration 대신에 Iterator를 사용하라는 문구이다.</p><br><p><strong>참고문서</strong></p><ul><li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Enumeration.html">Oracle - Enumeration</a></li><li><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html">Oracle - Iterator</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> enumeration </tag>
            
            <tag> iterator </tag>
            
            <tag> interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet - 서블릿 생명주기와 HttpServletRequest, HttpServletResponse</title>
      <link href="2020/07/servlet-lifecycle/"/>
      <url>2020/07/servlet-lifecycle/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/pw/ACtC-3dHdIhZeAndZXjmSKQyLmv8763DlAt354TUXj6aL3b_JyMcbLnjnuBIIIhDCVdOxWBsLTUQxBLKVF-pSVMBew4QWGkLMmtdefu7PBTzYEnuY47c9YzyTAYcqel9TZ48xsn28YgLPq7hG2Z2OMHMnre2GA=w720-h480-no?authuser=0"/><p>앞서 서블릿을 이용해 화면에 Hello world를 찍어보는 <a href="https://devyoungjin.github.io/2020/07/servlet-01/">간단한 실습</a>을 해보았다. 이번엔 이 때 사용했던 개념들에 대해 조금 더 알아보는 시간을 가지려고 한다.</p><br><p>우선 서블릿이 어떻게 호출되고, 실행되는지부터 알아보자.</p><h2 id="Servlet-작동원리"><a href="#Servlet-작동원리" class="headerlink" title="Servlet 작동원리"></a><a name="servlet-op"></a>Servlet 작동원리</h2><p>웹서버에 HTTP 프로토콜로 요청이 들어오면, 웹서버는 해당 요청을 파악하고, 요청에 맞는 리소스를 다시 HTTP 프로토콜로 반환한다. 간단하지만 이게 웹의 기본이자 핵심이다.</p><p>웹의 동작을 천천히 따라가보자.</p><img src="https://lh3.googleusercontent.com/pw/ACtC-3daSpkLqxeY1X7d7GEuFdPlFNkZfXKpLDD7J8MA_74LiuqTCIT3cv2-iFJ09eaaEiJnlC9n5q_AFo6c5TBen4z2dkf8y8u0NWchJ_tfYncV794V6jndbxWGw9araOdXP5xpIBxwZhWQ8heeF-jZ68Ln5A=w680-h215-no?authuser=0" /><p>브라우저 주소창에서 URL을 입력하면, 브라우저는 요청메세지를 만들어서 HTTP 프로토콜을 이용하여 DNS에 보낸다.</p><img src="https://lh3.googleusercontent.com/pw/ACtC-3d3Ut37ZpheziNho-gqiKu8iLlLfXTL858qYJuqVpamUOCVKAgqOKBKims0jaPbTZ89n-SjRxxkz4g8bK6Ez8iieAhgHabfazUunLTjHZ-7dGtNX4xnp6nVLMXbpCgU-yB6s2XWDkDnm3cqpg4Geh_jrw=w720-h310-no?authuser=0" alt="요청메세지를 통해 웹서버가 알수있는 정보들"/><p>그럼 DNS에서는 해당 URL 주소를 갖는 IP주소를 찾아서 IP주소가 가리키는 웹서버로 아까 클라이언트로부터 받은 요청 메세지를 던진다. 위의 이미지는 웹서버를 띄워서 요청메세지(<code>HttpServletRequest</code>)를 통해 어떤 정보를 웹서버가 알 수 있는지를 보여주는 코드를 작성해보았다.</p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fOIMcjoFK6VB49jxnbBGqNzmaM6-bmIIbziUbnKBEbWFsFgKRgkRPT-7IIY1HtlcogRk1OwFDEHm5Y-Tdh1mYGZdep8IK02U5p7qyn00FMOzACkcrcWxwsamVwmrHLAeyBZFH1HFsMYWj3TD-U8IgC9A=w680-h251-no?authuser=0"/><p>그럼 웹서버는 이 요청에 맞는 리소스를 찾아서 응답 메세지로 만들어 다시 HTTP 프로토콜을 이용하여 요청메세지의 클라이언트에 반환한다.</p><p>이 과정에서 서블릿에서 일어나는 일들을 정리해보면,</p><p>웹 서버가 실행되고, 서블릿의 초기화 메서드(<code>init()</code>)가 호출된다. 이후 웹 서버에 요청이 들어오면, 서비스(<code>service()</code>)가 호출되면서 요청을 파악하게 된다.</p><p>서비스에서 요청을 파악하여 HTTP 메서드가 GET이면 <code>doGet()</code>을, POST이면 <code>doPost()</code>을 호출한다.</p><p>Apache의 <a href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServlet.html">HttpServlet 클래스 문서</a>를 보면, <code>HttpServlet</code>의 메서드들 대부분이 HTTP 메서드와 연관된 메서드(GET/POST/PUT/DELETE..)들임을 확인할 수 있다.</p><p> 그리고 이 <code>HttpServlet</code> 클래스에서 사용하는 파라미터는 <code>HttpServletRequest</code>와 <code>HttpServletResponse</code> 인터페이스 객체이다.</p><br><h2 id="Servlet-생명주기"><a href="#Servlet-생명주기" class="headerlink" title="Servlet 생명주기"></a><a name="lifecycle"></a>Servlet 생명주기</h2><p>서블릿에 여러가지 메서드가 중요하지만, 서블릿의 시작과 끝 등을 다루는 주요 메서드로는 아래 3가지가 있다. </p><ul><li><code>.init()</code></li><li><code>.service(request, response)</code></li><li><code>.destroy()</code></li></ul><p>위 메서드들은 <a href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServlet.html">HttpServlet</a>의 메서드를 오버라이딩해서 사용할 수 있다. 서블릿을 생성해서 위 3가지 HttpServlet 메서드를 오버라이딩해서 사용해보자.</p><p>생성자와 HttpServlet 3가지 메서드를 포함하여 4가지 메서드가 생성된다. Sysout으로 콘솔에서 식별할 수 있는 문구를 작성해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/lifecycle&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifecycleServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">LifeCycleServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;LifeCycleServler 생성!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;init 호출!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Service 호출!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;destory 호출!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; console result</span><br><span class="line">LifeCycleServler 생성!!</span><br><span class="line">init 호출!!</span><br><span class="line">Service 호출!!</span><br></pre></td></tr></table></figure><p>서버 실행 후, URL로 호출하면, 콘솔결과에 출력되는걸 확인할 수 있다. </p><ul><li>생성자 : 서블릿이 <strong>생성</strong>될때 호출된다.</li><li>init : 서블릿이 <strong>초기화</strong>될때 호출된다.</li><li>service : 서블릿이 <strong>호출</strong>될때 호출된다.</li></ul><p>서버를 실행하고, 브라우저에서 URL을 호출하면, WAS는 서블릿 요청을 받아서 해당 서블릿이 메모리에 있는지 여부를 확인한다. 있으면 바로 <code>service()</code>를 호출하고, 없으면 생성자부터 <code>init()</code>을 호출하게 된다.</p><p>처음 웹서버를 실행하고 서블릿을 호출하면, </p><ol><li>생성자 호출</li><li><code>init()</code> 호출</li><li><code>service()</code> 호출</li></ol><p>순으로 호출된다.</p><p>브라우저에서 다시 URL을 호출하거나, 현재창에서 refresh하면, 1) 생성자, 2) <code>init()</code> 을 skip하고 <code>service()</code>만 호출한다. WAS가 서블릿 요청을 받아서 해당 서블릿이 메모리에 있는지 확인했는데 이미 존재하기 때문에 서블릿을 생성하지 않고 곧바로 <code>service()</code>를 호출한 것이다.</p><p>여기서 하나 알아둬야할 점은 JSP 처럼 서블릿을 이용하여 화면에 뿌리는 메서드는 <code>service()</code> 뿐이다. <code>service()</code>에서만 반환객체 <code>HttpServletResponse</code> 를 파라미터로 받고있기 때문이다.<br>(JSP 엔진에서 사용하는 서비스 메서드명은 <code>_jspService()</code>이다.)</p><p>그럼 <code>destory()</code>는 언제 실행되는걸까?</p><p>서블릿 클래스를 수정하면, eclipse가 자동으로 수정된 클래스를 바탕으로 재 빌드를 하면서 콘솔화면에 <code>destroy()</code>가 실행된걸 알 수 있다.</p><p>즉, <code>destroy()</code>가 호출되는 경우는 WAS가 죽는 경우, 즉 웹 애플리케이션이 종료되는 시점이다.</p><br><h2 id="Servlet-2-x대와-3-x대의-차이"><a href="#Servlet-2-x대와-3-x대의-차이" class="headerlink" title="Servlet 2.x대와 3.x대의 차이"></a><a name="comparison-2-with-3"></a>Servlet 2.x대와 3.x대의 차이</h2><p>서블릿 버전 2.0과 3.0의 작성법이 다르다고 한다. 3.0에선 <code>HttpServlet</code>을 상속받고, 어노테이션 <code>@WebServlet()</code>을 작성함으로써 간단하게 작성이 가능하지만, 2.0에선 XML 기반으로 작성해야했다.</p><p><strong>Servlet 2.xx</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span><span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>myServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>edwith.myServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span><span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/helloservlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Servlet 3.xx</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/helloservlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">helloservlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="Servlet의-요청과-응답"><a href="#Servlet의-요청과-응답" class="headerlink" title="Servlet의 요청과 응답"></a><a name="httpservlet"></a>Servlet의 요청과 응답</h2><p>요청할 때엔 갖고있는 정보를 <code>HttpServletRequest</code>에 저장한다.</p><p>응답을 보낼때는 <code>HttpServletResponse</code> 객체를 생성해서 <code>HttpServletResponse</code>를 통해 응답한다.</p><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><ul><li><p>ServletRequest를 상속받는 클래스이다.</p></li><li><p>http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용한다.</p></li><li><p>헤더 정보, 파라미터, 쿠키, URI, URL 등의 정보를 읽어 들이는 메서드를 가진다.</p></li><li><p>body의 stream을 읽어들이는 메서드가 존재한다.</p></li></ul><h3 id="HttpServletRequest-클래스의-주요-메서드"><a href="#HttpServletRequest-클래스의-주요-메서드" class="headerlink" title="HttpServletRequest 클래스의 주요 메서드"></a>HttpServletRequest 클래스의 주요 메서드</h3><ul><li><b>getParameterNames()</b> : E<ul><li>현재 요청에 포함된 매개변수를 반환한다. 열거(Enumeration)로 가져온다. 파라미터가 없으면 빈 열거를 반환한다.</li></ul></li><li><strong>getParameter(name)</strong> : String<ul><li>문자열 name과 같은 이름을 가진 매개변수 값을 요청으로부터 가져온다.</li></ul></li><li><strong>getParameterValues(name)</strong> : String[]<ul><li>문자열 name과 같은 이름을 가진 매개변수 값을 문자열 배열 형태로 가져온다.<br>( 주로 checkbox, mutilple list 등에 사용 )</li></ul></li><li><strong>getCookies()</strong> : Cookie[]<ul><li>모든 쿠키값을 javax.servlet.http.Cookie의 배열 형태로 가져온다.</li></ul></li><li><strong>getMethod()</strong> : String<ul><li>현재 요청이 GET인지 POST인지 HTTP Method를 반환한다.</li></ul></li><li><b>getSession()</b> : HttpSession<ul><li>현재 세션 객체를 가져온다.</li></ul></li><li><b>getRemoteAddr()</b> : String<ul><li>현재 클라이언트의 IP 주소를 가져온다.</li></ul></li><li><b>getProtocol()</b> : String<ul><li>현재 서버의 프로토콜을 문자열 형태로 가져온다.</li></ul></li><li><b>setCharacterEncoding()</b> : void<ul><li>웹서버로 전달되는 내용을 인코딩한다.</li></ul></li><li><b>getAttribute(name)</b> : Object<ul><li>문자열 name과 같은 이름을 갖는 매개변수 값을 Object 타입으로 가져온다.</li></ul></li><li><b>setAttibute(name, value)</b> : void<ul><li>문자열 name과 같은 이름을 가진 매개변수의 값을 value로 수정한다.</li></ul></li></ul><p><strong>HttpServletRequest의 메서드를 활용한 예제 코드.</strong></p><p>header로 저장되는 정보 브라우저 화면에서 출력하는 법</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;String&gt; headerNames = request.getHeaderNames();</span><br><span class="line"><span class="keyword">while</span>( headerNames.hasMoreElements() ) &#123;</span><br><span class="line">  String headernames = headerNames.nextElement();</span><br><span class="line">  String headerValue = request.getHeader(headernames);</span><br><span class="line">  out.println(headerNames+<span class="string">&quot; : &quot;</span>+headerValue+<span class="string">&quot;&lt;br&gt;&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="HttpServletResponse"><a href="#HttpServletResponse" class="headerlink" title="HttpServletResponse"></a>HttpServletResponse</h2><p>​    • WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 <code>HttpServlerResponse</code> 객체를 생성하여 서블릿에게 전달한다.</p><p>​    • 서블릿은 해당 객체를 이용하여 content-type, 응답 메세지 등을 <code>HttpServlerResponse</code> 에 담아서 전송한다.</p><h3 id="HttpServletResponse-클래스의-주요-메서드"><a href="#HttpServletResponse-클래스의-주요-메서드" class="headerlink" title="HttpServletResponse 클래스의 주요 메서드"></a>HttpServletResponse 클래스의 주요 메서드</h3><ul><li><b>setContentType()</b> : void<ul><li>문자열 형태의 type에 지정된 MIME Type으로 Content Type으로 지정한다.</li></ul></li><li><b>setHeader(name, value)</b> : void<ul><li>문자열 name의 이름으로 value 값을 헤더로 설정한다.</li></ul></li><li><b>setDateHeader(name, date)</b> : void<ul><li>문자열 name의 이름으로 date에 설정된 ms시간 값을 헤더에 설정한다.</li></ul></li><li><b>sendRedirect(url)</b> : void<ul><li>클라이언트 요청을 다른페이지로 보낸다.</li></ul></li></ul><br><p><strong>참고 문서</strong></p><ul><li><a href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServlet.html">Apache - Class HttpServlet</a></li><li><a href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServletRequest.html">Apache - Interface HttpServletRequest</a></li><li><a href="https://tomcat.apache.org/tomcat-5.5-doc/servletapi/javax/servlet/http/HttpServletResponse.html">Apache - Interface HttpServletResponse</a></li><li><a href="https://woojong92.tistory.com/entry/Servlet%EA%B5%AC%EC%A1%B0%EC%99%80-HttpServlet-%ED%81%B4%EB%9E%98%EC%8A%A4">woojong92 - JAVA Servlet구조와 HtppServlet 클래스</a></li><li><a href="https://devbox.tistory.com/entry/Servlet-%EC%84%9C%EB%B8%94%EB%A6%BF-%ED%95%84%ED%84%B0%EC%99%80-%EC%9D%B4%EB%B2%A4%ED%8A%B8">devbox - [Servlet] 서블릿 기초</a></li></ul><p>서블릿으로 Hello World 찍어보는 실습 구경하러 가기<br>-&gt; <a href="https://youngjinmo.github.io/2020/07/servlet-tutorial/">Servlet 실습하며 알아보기</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Servlet - 서블릿 튜토리얼</title>
      <link href="2020/07/servlet-tutorial/"/>
      <url>2020/07/servlet-tutorial/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/pw/ACtC-3cdgEabesS1rs-zetUO966emZ6pab2BifVkCVUqOfrED9ahd2kwxk6B-qv48z7cc1-aRHRIXvyPcj8NcEe3vVlPxm0SYdUOktLpceAoShJ7BwZxOx2LgNUO4IDRzOK3stfi9QIuGEJqq-anZvlHOM5FjQ=w720-h480-no?authuser=0"/><p>스프링을 공부하다가 모호한 부분이 많아서 시작하게된 공부이다. </p><p>스프링 기반기술이 서블릿인데 사실 자바 언어를 사용하며 웹 애플리케이션을 개발하기 위해서는 반드시 서블릿을 사용할 수 밖에 없다. 웹 애플리케이션을 개발하기 위해서는 Http로 통신하는 애플리케이션을 개발해야하는데 서블릿은 <code>HttpServlet</code> 클래스를 상속받아서 Http 프로토콜로 요청과 응답을 구현하는, WAS에서 동작하는 클래스이기 때문이다.</p><p>요즘은 개발자가 직접 서블릿을 생성할 필요가 없는데 스프링 프레임워크와 스프링부트처럼 간단하게 웹 개발할 수 있는 프레임워크가 존재하기 때문이다. 그러나 개발자가 직접 생성하지 않을뿐이지 결국 이런 자바 기반의 웹 개발 프레임워크 모두 서블릿 기반의 프레임워크라는 사실을 잊어서는 안된다.</p><p>서블릿은 WAS에서 동작하는 자바 클래스이다.</p><br><h2 id="Servlet-만들어보기"><a href="#Servlet-만들어보기" class="headerlink" title="Servlet 만들어보기"></a><a name="tutorial"></a>Servlet 만들어보기</h2><p><strong>프로젝트(Dynamic Web Project) 생성하기</strong></p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3e_WfwceYdP5cuuZ95jeXvaHFqdZ8k2LOpFJ4l2HvbJmbDTlgfmhKFL1CmmXiDKsdmMNoomt7nS0vY6SxdVx21TpAG4i_PoZfV8vMC52z3uNQMT4KcoZKbRPRlmHohpYFxPNtHw5zOw8h9pxnQPwjzKFg=w1442-h401-no?authuser=0"></p><p>서블릿은 정적 웹(Static Web)이 아닌 동적인 웹(Dynamic Web)을 위해 탄생한 기술이다. 따라서 이클립스에서 <strong>[File] - [New] - [Other]</strong> 를 클릭하고, <strong>[Dynamic Web Project]</strong> 선택한다.</p><p>앞서 서블릿은 WAS에서 작동하는 자바 클래스라고 했다. 따라서 설정할때 어디서 실행될지(Terget runtime)를 정해야한다. 필자는 Apache Tomcat 9.0을 WAS로 지정했다. 이렇게 WAS를 지정하고, Next로 넘어간다.</p><br><p><strong>서블릿 클래스 생성하기</strong></p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3d7U5AOmeMcSWTnBMQk0-S2cDNLYNYeMa74m4yWO1v4TwSuKAdgBXWgusWOWlBAJrPt2ow6yjvY6VVDAo5cvrnp3yzlECxyCegqVGXT5qnvQ03SwsTcPqtVWCslGwuwUNroepVnWpse4c0mFEWrJ-fXrg=w1442-h731-no?authuser=0"></p><p> 프로젝트가 생성되었으니 이제 프로젝트에서 서블릿 클래스를 생성할 차례이다. src 디렉토리 하위에 패키지를 하나 생성하고(생성하지 않아도 상관은 없다. default package가 생성될 것이다.) 생성된 패키지 하위에 <strong>[New] - [Web] - [Servlet]</strong> 을 선택해서 서블릿 클래스를 생성한다. </p><br><p><strong>서블릿 클래스 작성하기</strong></p><p>서블릿 클래스를 생성하면, 자동으로 <code>doGet()</code>, <code>doPost()</code> 가 완성된 클래스 파일이 생성된다. 현 상태로도 브라우저에서 화면을 출력할 수 있지만, 상징적인 의미로 Hello World를 찍어보겠다.</p><p>서블릿의 동작원리는 다음과 같다. </p><ol><li><p>java 코드를 작성하고, Run on Server를 실행하면, </p></li><li><p>IDE(Eclipse)에서 java코드를 class코드로 컴파일. </p></li><li><p>컴파일한 코드를 톰캣(서블릿 컨테이너)에서 서블릿 규칙에 따라 코드를 실행하고 결과를 서버에 전달.</p></li><li><p>전달받은 서버는 클라이언트로부터 정해진 요청(HttpServletRequest)이 들어올 경우, 해당 요청에 맞는 응답(HttpServletResponse)을 HTTP 프로토콜을 통해 브라우저로 전송한다.</p></li></ol><p>따라서 <code>doGet()</code> 에 코드를 작성해보겠다.</p><p><a href="https://gist.github.com/youngjinmo/8e0c24b10bf70e9c2ba87d8ac2a5a3a1">전체 코드 보기</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    PrintWriter out = response.getWriter();</span><br><span class="line">    out.println(<span class="string">&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    out.println(<span class="string">&quot;My &lt;span style=\&quot;color: red;\&quot;&gt;First&lt;/span&gt; Servlet!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    response.getWriter().append(<span class="string">&quot;Served at: &quot;</span>).append(request.getContextPath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 서버를 실행하면, 브라우저가 자동으로 실행되며 다음과 같은 화면을 뿌려줄 것이다. 서버를 실행할 때 어떤 서버에서 실행할지 실행환경을, 즉 WAS를 물어보는데 이 때 서버를 선택하고 Next로 넘어가면 된다. 아래 Always user thie server 라는 체크박스를 체크하면, 다음부터 서블릿을 실행하면 자동으로 해당 WAS로 서블릿을 실행하게 된다. </p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fyvjOK-IiC_a3kqWJ8ExHTcV4hP0Y-vttBTsg7tIgiv2me8cqnk96tQzmODde_v23teU-3Rnx9FRy4DkGAffzOzTphHO6Pf2ZMo673j2WxFXMUtx7fbTtyGgMUUgcyG0lJsoTZdtWx2nMZjPpUHtZAkw=w1442-h828-no?authuser=0"></p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fEx_pDV-1cFUA1J_XXS9YnExDOLt3Yr1t3MHskvgWuEA8QefNIMn7tCstFTavm7qTNhP6olILbOg1tmViYNwUXVJpI9J6Z4znlu7OACzw8Qu_otPDWxcqsvxf5maishI7QmH8voZ0RjE8es9DjE3q9lw=w936-h566-no?authuser=0"></p><p>만약 브라우저가 안열린다면 이클립스의 Preference에서 browser 설정을 다음처럼 바꿔준다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eEN70TZdzfsc7LO4DMRseiIvGvZp5ngHHtcd-h1wpbhe1wKPOiRLRwvBws74VN4GeRDZrIivawyiIkebUnQTLs9S67YwLWj_pkot-i8qc8Ds9-_b-0Tu3_N0T7iL5Z9KpMM5fTkVwcUoB3gfT9WSV4aw=w1442-h1105-no?authuser=0"></p><p>클라이언트로부터 요청을 받아야 서버가 응답을 한다고 했는데, 어떤 요청을 했길래 웹 서버가 자동으로 결과를 뿌려준걸까? 여기서 사용자가 한 요청은 웹 브라우저 주소창에 있는 URL이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;&#123;server-name&#125;&#x2F;&#123;annotation&#125;</span><br></pre></td></tr></table></figure><p>로컬 환경에서 작업중이기 때문에 localhost:8080까지는 알겠는데, server-name은 어디서 알 수 있는걸까?</p><p>이클립스의 Servers 탭에서 서버를 더블클릭한다. (이미지에서 표기한 Servers탭 말고 해당 탭에 있는 로컬서버를 클릭하셔야한다.)</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3exwOtqdnQ5csGQUNSB10kqNonLSXYuMrTA97j3xJVhiHuyoHYFBUC9rtxt8Ggf7gqtk0NN58_Z8ilTbylxeJz1t9uGM2AWO9qiHni8MxElilgNN3ubbQemLy3dW0ZxDv0cu3VlEcQl_SjJqBSsyKzK7A=w480-h218-no?authuser=0"></p><p>그리고 서버 환경설정 화면이 나오면, 하단 메뉴에서 Modules를 클릭한다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eTJN6_o9tSvEvBY_JThIgeN6RkGLBgWwQK7JsSYi0t9-RA6dlIrNnVRCSYpx6-s65c0RZOM08y3Iijh68tvatblyNjI2I2ZZTyjvhNZvmyXMssqg3KQnSDDx-dCcDaBfwO8yJMqskYtYpzxAsW52M73A=w720-h201-no?authuser=0"></p><p>그럼 위와 같이 Web Modules에서 현재 서버의 Path를 볼 수 있다. 이 Path가 우리가 서블릿으로 만든 웹서버에 접속할 수 있는 요청을 할 URL에 포함시켜야할 주소이다.</p><p>간단하게 서블릿 작업만 하고 싶다면, 위의 Path를 그냥 <code>/</code> 로 바꾸는게 편할 수 있다.</p><p>위의 주소로 입력하면, 내장 톰캣 서버가 해당 요청에 맞는 응답을 클라이언트로 response하는 건데, 이 과정은 다음과 같다.</p><p>서블릿 클래스에서<code>@WebServlet(&quot;/HelloServlet&quot;)</code> 이라는 어노테이션을 작성하면, 어노테이션의 파라미터로 들어간 URI(“/HelloServlet”)로 접속을 하면, 서블릿 클래스에 작성된 로직이 실행되는 것이다. 그리고 이 서블릿 클래스 중에서도 <code>doGet()</code>에 작성된 로직이 웹 서버에 요청되면서 아까 <code>PrinterWriter</code> 객체로 작성한 html 코드가 브라우저로 반환된 것이다.</p><br><h2 id="파라미터-담아서-요청하기"><a href="#파라미터-담아서-요청하기" class="headerlink" title="파라미터 담아서 요청하기"></a><a name="request-with-parameters"></a>파라미터 담아서 요청하기</h2><p>URL에 파라미터를 붙여서 요청할 수도 있다. 요청할 URL에 <code>?</code>를 붙이고 파라미터 이름과 파라미터 값을 추가하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;&#123;server-name&#125;&#x2F;&#123;annotation&#125;?&#123;parameter1&#125;&#x3D;&#123;value1&#125;&amp;&#123;parameter2&#125;&#x3D;&#123;value2&#125;</span><br></pre></td></tr></table></figure><p>이렇게 브라우저 주소창에 입력한 파라미터를 웹서버에서 요청받고, 응답하려면 서블릿 클래스에도 파라미터를 받아줄 코드를 작성해주어야 한다.</p><p><code>doGet()</code>에서 <strong>HttpServletRequest</strong> 객체의 <code>getParameter()</code>를 이용하면 URI로 넘어오는 인자값을 서버에서 받아서 처리할 수 있게 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">out.printWriter(<span class="string">&quot;Hello, &quot;</span>+name);</span><br></pre></td></tr></table></figure><p>그럼 이렇게 요청받은 인자값을 서버에서 받아서 다시 화면에 출력한 걸 확인할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3c2y7yWuFE2xynmetTmsFmQc3KGwF1YIWbpIbpZwEVS6MDrb_DUR1SaPDG0DYkACXKCve2UpCF2QEJBiBGWIASe8HyjjyxjOYbH6xpE0uONEKhv_naItNbUPTX1ophkwFwhamZ4QzPRfq4hL6X3XgQYug=w1120-h348-no?authuser=0"></p><br><p>다음 포스트에서는 이 간단한 실습때 사용했던 서블릿의 개념들에 대해 조금 더 알아보자.<br><a href="https://youngjinmo.github.io/2020/07/servlet-lifecycle/">다음 포스트 읽으러 가기</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8 - 람다와 함수형 인터페이스</title>
      <link href="2020/06/java8-lambda-functional-interface/"/>
      <url>2020/06/java8-lambda-functional-interface/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/pw/ACtC-3d1WLMhptAFRFFS_tjcR0WDysxudFi4CvTDO2mBdtPh201_ZGnF7c_tk2lAlK4bwa-ykbUtERCJcDowTZUs_I5rD2D1f5eD3sT5kct4e_QfOaQOLcHoSLG_QrbcvOY1YWHK3sbB0m-QfrDN-3U0pWuIiA=w600-h338-no?authuser=0" width="650px" /><p>자바 8에 람다(Lambda)가 도입되면서 자바는 객체지향언어인 동시에 함수형 언어가 될 수 있었다. </p><p>람다식을 간단히 표현하면, 메서드를 하나의 식(expression)으로 표현한 <strong>익명 함수(Anonymous function)</strong> 이다. 여기서 알아두어야 할 점은 람다가 메서드가 아니라 함수라는 점이다. </p><p>람다를 알기 전까지는 메서드와 함수를 같은 의미로 해석했지만, 람다를 이해하기 위해서는 이 둘을 분리해서 생각해야 한다. 메서드 역시 함수와 같은 기능을 하지만, <strong>메서드는 클래스에 반드시 속해야 한다는 제약조건이 존재</strong> 한다. 그러나 람다에서 함수는 어떤 클래스에도 종속될 필요가 없다. 그냥 사용하면 된다.<br><em><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001">Java의 정석 3판</a> 795페이지 참고</em></p><p>자바 8 이전의 자바에서는 메서드를 파라미터로 전달할 수 있는 방식이 없었다. 오직 인스턴스를 생성해서 객체를 통해서만 전달할 수 있었는데, 람다가 도입되면서, <strong>인스턴스 없이도 파라미터안에 메서드를 정의</strong> 할 수 있게되었다. </p><p>이렇게 함수형 프로그래밍을 하게 될 경우, 객체지향에서처럼 메서드를 객체로 만들어서 파라미터에 넣어 사용하는대신 람다식은 함수 내에서 곧바로 사용할 수 있다는 특징이 있다. 이러한 프로그래밍을 함수형 프로그래밍이라 한다.</p><br><h2 id="함수형-프로그래밍"><a href="#함수형-프로그래밍" class="headerlink" title="함수형 프로그래밍"></a>함수형 프로그래밍</h2><p><strong>객체지향 : “Do..”</strong><br><strong>함수형 : “It is..”</strong></p><p>함수형 프로그래밍은 다른 말로 <strong>선언형 프로그래밍</strong>이라고 한다. 객체지향 프로그래밍이 각각의 객체에게 어떠한 행동을 명령형 프로그래밍이라고 한다면, 함수형 프로그래밍은 하나의 거대한 함수를 디자인하는 기법이다. input에 따라 output이 확정된다는 이야기이다.</p><p>객체지향의 경우 각각의 객체에서 개발자가 예측하지 못한 일이 발생한다면, 프로그래머의 기대와 다른 output이 나올수 있지만, 함수형 프로그래밍의 경우엔 함수의 동작에서 변수의 부수적인 값 변경을 원천 배제(=immutable)했기 때문에 input만 동일하다면 언제나 동일한 output을 기대할 수 있다.</p><p>즉, 객체 지향이 동작에 집중하는, How에 집중하는 방식의 프로그래밍이라면, <strong>함수형 프로그래밍은 동작을 최소화하고 What</strong> 에 집중하는 방식의 프로그래밍이다.</p><br><h2 id="람다식"><a href="#람다식" class="headerlink" title="람다식"></a><a name="lambda"></a>람다식</h2><p>람다는 코드 한 줄로 작성해서 호출하는 방식의 함수식이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( parameters ) -&gt; function body</span><br></pre></td></tr></table></figure><p>소괄호 안에 파라미터를 정의하고, 람다 연산자(-&gt;)를 기준으로 오른쪽에 람다 함수를 정의한다. 람다 연산자(<code>-&gt;</code>)는 람다 함수로부터 파라미터를 분리해서 표현하는 역할을 한다.</p><p>여기서 알아두어야 할 점은 람다 함수 본체에서 <strong>return 키워드를 사용하지 않는다</strong> 는 점이다. return 키워드를 사용할 순 있으나,  그럴 경우 반드시 중괄호<code>&#123;&#125;</code> 를 사용해야 한다. return 키워드를 사용하지 않는다면 중괄호를 사용하지 않아도 무방하다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123; <span class="keyword">return</span> a&gt;b ? a:b; &#125; <span class="comment">// 이것도 맞고,</span></span><br><span class="line">(<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a&gt;b ? a:b          <span class="comment">// 이것도 맞다.</span></span><br><span class="line">(a, b) -&gt; a&gt;b ? a:b                <span class="comment">// 심지어 이것도 맞다.</span></span><br></pre></td></tr></table></figure><p>오히려 헷갈릴 수 있기 때문에 중괄호도, 추론가능한 파라미터의 데이터 타입, return 키워드도 생략하는게 더 편하지 않을까 생각한다.</p><p>람다식에서 이렇게 파라미터의 데이터 타입을 생략하더라도 자바 컴파일러가 데이터 타입을 추론가능한 이유는 인터페이스를 통해서 추론이 가능하기 때문이다.</p><br><p>람다는 함수임에도 불구하고 메서드 이름과 타입을 작성하지 않는다. 그래서 람다를, 식별자(identifier)없이 실행가능한 함수, 즉 <strong>익명 함수(anonymous function)</strong> 라고도 이야기한다.</p><p>간단히 쓰레드를 생성하는 예제를 통해 람다가 어떻게 쓰이는지 알아보자. 하나는 람다를 적용하지 않았고, 다른 하나는 람다를 적용했다.</p><p><strong>without Lambda</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambdaExam_01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// without Lambda</span></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Lambda!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>with Lambda</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lambdaExam_02</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with Lambda</span></span><br><span class="line">    <span class="keyword">new</span> Thread( () -&gt; System.out.println(<span class="string">&quot;Hello Lambda!&quot;</span>)</span><br><span class="line">    ).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello lambda!</span><br></pre></td></tr></table></figure><p>둘 다 정확히 같은 결과를 출력한다. 람다를 사용해서 코드가 더 간결해진걸 확인할 수 있다. 여기서 확인해야할 점은 단지 람다식 덕분에 코드가 짧아졌다는 것뿐만이 아니다. 쓰레드를 생성하기 위해서는 쓰레드가 상속받는 <code>Runnable</code> 인터페이스의 <code>run()</code>을 구현해야 하는데, 개발자가 직접 명시하지 않은 <code>run()</code>를 어떻게 알고 자바컴파일러는 <code>run()</code> 을 구현하여 쓰레드를 생성할 수 있었을까?</p><h2 id="함수형-인터페이스"><a href="#함수형-인터페이스" class="headerlink" title="함수형 인터페이스"></a><a name="functional-interface"></a>함수형 인터페이스</h2><p>이 비밀을 알기 위해서 <code>Runnable</code> 인터페이스를 열어보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object&#x27;s</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>추상메서드가 <code>run()</code> 하나만 존재하는걸 알 수 있다.<br>그리고 이 <code>Runnable</code> 인터페이스위에 <code>@FunctionalInterface</code>가 작성되어있는데, 이것도 열어보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  ( 중략 )</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class="line"><span class="comment"> * method.  Since &#123;<span class="doctag">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment"> * default methods&#125; have an implementation, they are not abstract.  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  ( 중략 )</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class="line"><span class="comment"> * lambda expressions, method references, or constructor references.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  ( 중략 )</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure><p>다소 길어서 중간 부분을 좀 생략했는데, Functional Interface(함수형 프로그래밍)에 대한 설명을 해놓은 것 같다. <strong>함수형 인터페이스는 하나의 추상 메서드를 갖는 인터페이스</strong>라고 정의해놓았다. 그리고 이 함수형 인터페이스의 인스턴스들은 람다식으로도 표현될 수 있다고 설명한다.</p><p>즉, 람다 예제 코드에서 <code>Runnable</code> 인터페이스를 사용할 수 있었던 이유는 Runnable 인터페이스가 추상 메서드를 하나만 갖고있는 함수형 인터페이스였기 때문이다. 그리고 <strong>추상 메서드가 하나만 있었기 때문에 람다식과 1:1로 맵핑</strong>되어 개발자가 <code>run()</code>를 직접 선언하지 않아도 함수 구현체를 <code>run()</code>으로 구현했음을 컴파일러가 인식한 것이다.</p><br><p>이번엔 직접 함수형 인터페이스를 만들어서 람다를 <a href="https://gist.github.com/youngjinmo/bb9d908cbf4371425daf13a60ea2433c.js">구현</a>해보았다.<br><br>이 코드에 대한 실행은 아래 링크를 통해 확인 가능하다.</p><p><a href="https://repl.it/talk/share/My-First-Repl/43587">Repl에서 실행하기</a></p><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
            <tag> lambda </tag>
            
            <tag> functional interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>자바8의 신규 기능</title>
      <link href="2020/06/java8-new-features/"/>
      <url>2020/06/java8-new-features/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/pw/ACtC-3f6VBScfjtaT1IIG83l5FS8_gb39ZKiBpF4rErtOcOK6xpHB1lVCKg6MP8mQ6TM26wodzXBIJ4Elp7LdCexeoP9qeE1RmvAuqUwRE0Y5R3-Ym_zsuawDOHNmJvXjpeRJQdVZBBljgRrPqEXQ4sJPICi-Q=w600-h338-no?authuser=0" width="650px" /><p>우분투에서 JDK를 설치하며 JDK의 가장 최신 버전이 12이까지 나왔음을 알았다. 그리고 프로그래머스 강의를 듣다보니 내가 그동안 사용한 자바 코드는 과거 버전에 머물러있음을 알았다. 그것도 5-6년 전 수준의..</p><p>그동안 사용하지 않았던 자바의 새로운(?) 문법도 공부할겸, <a href="https://johngrib.github.io/wiki/%EC%9E%90%EB%B0%94-enhancements/">이종립님 블로그</a>에서 영감을 얻어 자바 언어 버전별 변경점을 정리하기로 했다. 회사에서 자바 8에 추가된 기능들을 정리해주었으면 좋겠다는 제안을 받아서 일단 자바 8 부터 정리를 해보려고 한다. 추후에 개인 <a href="https://github.com/devyoungjin/Wiki">Wiki</a>에 다른 버전의 변경점들도 정리를 해나갈 예정이다.  </p><p><a href="https://www.oracle.com/%EC%9E%90%EB%B0%94/technologies/javase/8-whats-new.html">오라클 문서</a>에 정의된 내용을 모두 정리하기 보다는 개발자가 알아두어야할 부분만 정리하기 위해 Udemy에서 자바 8 features 로 검색하여 나온 강의들의 목차를 추려서 자바 8에서 개발자가 알아두어야할 변경점들을 정리했다. </p><p>그래서 자바 8에서 알아두어야할 특징들은 다음으로 정리하였다. 람다식을 시작으로 하나씩 정리하도록 하겠다.</p><h3 id="New-features-in-JDK-8"><a href="#New-features-in-JDK-8" class="headerlink" title="New features in JDK 8"></a>New features in JDK 8</h3><ul><li><a href="https://devyoungjin.github.io/2020/06/java8-lambda-functional-interface/#lambda">Lambda Expressions</a></li><li><a href="https://devyoungjin.github.io/2020/06/java8-lambda-functional-interface/#functional-interface">Functional Interfaces</a></li><li><a href="https://devyoungjin.github.io/2020/07/java8-stream">Stream API</a></li><li><a href="https://devyoungjin.github.io/2020/07/java8-default-method">Default Method</a></li><li><a href="https://devyoungjin.github.io/2020/07/java8-method">Method References</a></li><li><a href="https://devyoungjin.github.io/2020/07/java8-optional-class">Optional Class</a></li><li><a href="https://devyoungjin.github.io/2020/07/java8-joda-api">Joda API (Date API &amp; Time API)</a></li></ul><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - File 읽고(Read) 출력(Write)하기</title>
      <link href="2020/06/java-file-io/"/>
      <url>2020/06/java-file-io/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/pw/ACtC-3fUJwNzRQvTFrAOewA11cQhHnaD4gUG2r6eV8usHwBgMSO85XhtWBpkZ3vYwBoQ_5kKZQkrcjqkgPQ1pXFnEiYBhESsWdRpzcyvbqtnt5aymse8tlEvcDxJaHFPIsr2K-VQR2QEPh07WfLksHhbFVB94Q=w1024-h532-no?authuser=0" width="650px" /><p>Java에서 파일을 입력하고, 출력해보는 예제이다.</p><p>Java에서 파일을 입력하기 위해서는 <code>FileInputStream</code> 클래스를 사용해야 한다. 마찬가지로 입력받은 파일을 다시 새로운 파일로 생성하기 위해서는 <code>FileOutputStream</code> 클래스를 사용해야 한다.</p><p> 사용하기 전 먼저 초기화를 해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>이제 <code>FileInputStream</code> 클래스로 생성한 인스턴스에 입력할 대상 파일의 경로(path)를 지정해주어야 한다.</p><img src="https://lh3.googleusercontent.com/pw/ACtC-3dDs-adJRwAgzKQtoSF-4wZ_obJIUq1ZLlfcALUzbcDk_3lOGc0hHbe5Drp6oiVddG9fcBPwB3hLdD6g_SL_1Ebygcw7NITq4maW2SwhtwRI_1a7Xfwed_tNiS9W-WD6XJluI2UhINTrXAu3AmP-DvSbA=w1034-h688-no?authuser=0" style="zoom:50%;" /><p>그런데 이렇게 exception이 발생할 수 있다고 경고가 발생하고 있다. <code>FileNotFoundException</code>이 발생할 수 있기 때문에 <a href="https://devyoungjin.github.io/2020/05/java-exception/">try-cat문</a>으로 예외처리를 해준다. </p><p>File 입력 인스턴스 아래에 출력할 파일의 경로도 지정해준다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/io/helloworld.txt&quot;</span>);</span><br><span class="line">   fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/io/cloneHello.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>입력대상 파일은 미리 만들어주자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br><span class="line">My name is Devandy.</span><br></pre></td></tr></table></figure><p>입출력 관련 인스턴스를 생성했으므로, 이제 파일을 입력하는 코드를 작성해보자. 파일을 입력하기 위해서는 <code>FileInputStream</code> 클래스의 <code>read()</code>를 사용해서 입력할 수 있다.</p><p>Eclipse에서 command(windows: control) 키를 누르고 <code>read()</code>를 클릭해서 확인해보니, byte 단위로 입력을 받으며, 더 이상 읽을 데이터가 없을 때 -1을 출력하는걸 알 수 있다.</p><img src="https://lh3.googleusercontent.com/pw/ACtC-3ffz6s-NbKmahftgdsT3h2K3TpPRMhPqXQyW10cp8nXmUD8FWhoJjhVZlHK1O3LwW3kbuz7ljKmSMtYxhifCcJhrJo1G1wHExS2g0LANpwxbSyGxMQtf0FBMI9IcQqsy1K59cZIXYdGMHfu_4XFwNeUVw=w1390-h494-no?authuser=0"/><p>그럼 <code>read()</code>가 -1을 반환할 때까지 반복문으로 파일을 입력시키면 될 것 같다. 한 byte 단위로 입력하기 때문에 출력하는 시점도 byte 단위로 읽어들이는 그 순간, 순간 해주어야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readData = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((readData=fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">  fos.write(readData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>int형 변수 <code>readData</code>는 <code>FileInputStream</code> 클래스의 <code>read()</code>로 읽어들인 byte를 저장하는 임시 공간역할을 한다. readData에 byte가 담겨지면, 곧바로 <code>FileOutputStream</code> 클래스의 <code>write()</code>를 이용하여 <code>readData</code>에 담긴 byte를 출력한다. 이러한 행위를 <code>fis.read()</code>를 통해 <code>readData</code>에 -1이 들어올때까지 반복한다. <code>fis.read()</code>에 -1이 들어왔다는건 더 이상 읽어들일 byte가 없다는 의미라는걸 앞에서 확인했다.</p><p>파일 입력이 끝나면, 끝났다는걸 콘솔에 알려줄 print문 하나를 while문 아래에 추가하자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(readData==-<span class="number">1</span>) &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;Read Done!!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>최종 코드는 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevAndyExamIO</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/io/helloworld.txt&quot;</span>);</span><br><span class="line">      fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/io/cloneHello&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> readData = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span>((readData=fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">        fos.write(readData);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(readData==-<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Read Done!!&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FileInputStream</code>,<code>FileOutputStream</code> 클래스의 인스턴스의 쓰임이 다했다면, <code>close()</code>로 클래스를 닫아주어야한다. </p><p>Stream 인스턴스를 닫아주어야 하는 이유를 공식문서에서는 다음과 같이 설명하고 있다.</p><blockquote><p>Streams have a <a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/BaseStream.html#close--"><code>BaseStream.close()</code></a> method and implement <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/AutoCloseable.html"><code>AutoCloseable</code></a>, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by <a href="https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html#lines-java.nio.file.Path-java.nio.charset.Charset-"><code>Files.lines(Path, Charset)</code></a>) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a <code>try</code>-with-resources statement.)</p></blockquote><p>모든 stream 인스턴스는 닫아줄 필요가 없긴 하지만, IO 관련 stream 클래스의 경우는 닫아주어야 한다. 그러나 명확한 설명은 작성되어 있지 않은데, 그래서 구글링을 해보니 10여년전, 이미 이것에 대해 <a href="https://okky.kr/article/138656">OKKY</a>에서 여러 의견이 오고갔음을 확인했다.</p><p>요약하면, <a href="https://devyoungjin.github.io/2020/04/java-memory/">GC</a>가 메모리 관리를 해주긴 하지만, GC가 인스턴스를 언제 종료시킬지 알 수 없기 때문에 사용이 끝난 시점에 개발자가 수동으로 종료해주는게 좋은듯하다.</p><p><code>try-cat</code>문의 <code>finally</code>를 추가하여 <code>close()</code>를 작성할 수 있지만, 공식문서에서 <code>try-with-resources</code>를 추천했으니 이걸로 수정해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">   FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/io/helloworld.txt&quot;</span>);</span><br><span class="line">   FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;src/io/cloneHello.txt&quot;</span>);</span><br><span class="line">) &#123;</span><br><span class="line">   <span class="keyword">int</span> readData = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span>((readData=fis.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">     fos.write(readData);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span>(readData==-<span class="number">1</span>) &#123;</span><br><span class="line">     System.out.println(<span class="string">&quot;Read Done.!!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">   e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 <code>try-with-resources</code>를 사용하면, try{}문 안에 작성된 코드가 모두 실행되면 자동으로 try문에 선언된 객체의 <code>close()</code>를 실행시킨다고 한다.</p><p>이제 main 메서드를 실행하면, 콘솔에 메세지와 함께 디렉토리에 helloworld.txt를 복사한 cloneHello.txt가 생성될 것이다. Eclipse에선 즉시 파일이 생기지 않으므로 io 패키지를 refresh 해야 생성된 파일을 볼 수 있다.</p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cjo5BFQLTEVGSslW__03UoHu49STNNzQQVtdUR5bIUIMC3N3oSE34Y2Gx4CxFZHEr33T2Xq3AtaylBjvOSJLaVLGliv_5Lq2hvPE6uExHVHYPwHvLeCIAh1u01-OoN3NAo6CApEehkROwigjWSBqd0Pg=w1154-h1036-no?authuser=0" style="zoom:50%;" /><br><p>이렇게 해도 파일을 입력하고, 출력할 수 있지만, 한 byte씩 입출력하는건 효율적이지 않다. 입력을 한 번에 많이 받아두고, 한 번에 출력하면 입출력 성능이 더 좋아질것 같다. 이를 위해 buffer 개념을 적용해서 출력해보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readData = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span>];</span><br><span class="line"><span class="keyword">while</span>(fis.read()!=-<span class="number">1</span>) &#123;</span><br><span class="line">  fos.write(fis.read());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 해야하는 이유는 기존의 한 byte씩만 입출력하는것보다 효율적이기 때문인데 왜냐면, 개발자가 한 byte씩 입출력을 하더라도 운영체제는 512 byte씩 InputStream클래스에서 가져와서 OutputStream으로 가져가기 때문이다.</p><p><strong>마치 512명을 태울수 있는 비행기가 한 명만 태우고 비행하는 것과 같은 개념이다.</strong> 한 번에 512명을 모투 태워서 비행한다면, 비행 회수가 줄어들것이다. 이 방식으로 buffer를 만들면 입출력 성능이 개선될 수 있는 것이다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>REST</title>
      <link href="2020/06/rest-api/"/>
      <url>2020/06/rest-api/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/pw/ACtC-3epNTvVcqt_yUGAWuMtMoi55gBkx1SGwoMgnW0RZ7_mS_XupcooKE8d7FrcxgcYBnJ8GpWhOWOrK_TsCBmiIb_nIHseUWK5pQhrg2N_kP6loYwgus4NmeVl_GSHVh9XDTkQy7g9V6PVN-C67THENYdN8A=w914-h571-no?authuser=0"></p><p>회사에서 REST에 대한 강의를 들을 기회가 있어, 강의를 듣고 정리해보았다.</p><h3 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h3><ul><li><a href="#rest">REST란?</a></li><li><a href="#why">Why REST?</a></li><li><a href="#restful-api">RESTful API?</a></li><li><a href="#features">REST API 특징</a></li><li><a href="#guide">Rest API 디자인 가이드</a></li><li><a href="#lorna">Five clues that your api isn’t RESTful.</a></li><li><a href="#weakness">REST 약점</a></li></ul><br><h2 id="REST"><a href="#REST" class="headerlink" title="REST"></a><a name="rest"></a>REST</h2><p>REST를 한 문장으로 정의하면, <strong>REST는 HTTP 프로토콜을 사용하는 아키텍처</strong>이다. </p><p>REST란 일반적으로 HTTP method와 URI까지를 이야기한다.</p><br><h2 id="Why-REST"><a href="#Why-REST" class="headerlink" title="Why REST?"></a><a name="why"></a>Why REST?</h2><img src="https://miro.medium.com/max/1276/0*GN2n0rtrVwEN5XlM" style="zoom:70%;" /><blockquote><p>How do I imporve HTTP without breaking the Web</p></blockquote><p>HTTP의 주요 저자중 한 사람인 Roy Fielding이 HTTP 설계의 우수성에 비해 제대로 사용되어지지 못하는 모습에 안타까워하여 <strong><u>HTTP의 장점을 최대한 활용하는 아키텍처</u></strong> 로써 박사학위 논문에서 소개한 아키텍처이다.<br>한 문장으로 정리한다면, <strong>API 역할에 따라 HTTP 스펙을 더 잘 사용하기 위한 아키텍쳐가 REST</strong> 라고 할 수 있다.</p><br><h2 id="REST-특징"><a href="#REST-특징" class="headerlink" title="REST 특징"></a><a name="features"></a>REST 특징</h2><ol><li><strong>Uniform Interface</strong><ul><li>자원의 위치가 아닌 HTTP 메서드로 접근하는 대상이 무엇인지를 구체적이고, 명확히 표현한다.</li></ul></li><li><strong>무상태성 (Stateless)</strong><ul><li>세션, 쿠키없이 HTTP로만 독릭적으로 통신이 가능해야한다.</li></ul></li><li><strong>캐시가능 (Cacheable)</strong><ul><li>REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹 표준을 그대로 사용하기 때문에 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다는 점이다. 따라서 HTTP가 가진 캐싱을 적용가능하다.</li></ul></li><li><strong>자체 표현구조 (Self-descriptiveness)</strong><ul><li>REST의 또 다른 큰 특징 중 하나는 REST API 메세지만 보고도 이를 쉽게 이해할 수 있는 표현이어야 한다.</li></ul></li><li><strong>Client - Server 구조</strong><ul><li>REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보) 등을 직접 관리하는 구조로 각각의 역할이 </li></ul></li><li><strong>계층형 구조 (Hierarchical Structure)</strong><ul><li>REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있으며 Proxy, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게한다.</li></ul></li></ol><br><h2 id="REST-API-디자인-가이드"><a href="#REST-API-디자인-가이드" class="headerlink" title="REST API 디자인 가이드"></a><a name="guide"></a>REST API 디자인 가이드</h2><p>REST API 설계시 신경써야할 두가지 설계 가이드이다.</p><ol><li>URI는 리소스를 표현해야 한다.</li><li>리소스에 대한 행위는 HTTP method로 표현한다.</li></ol><p>REST의 뜻인 Representational State Transfer에서 알 수 있듯이 REST는 어떻게 표현되는가가 중요한 아키텍처이다. </p><p>REST는 HTTP method만 사용한다고 REST라고 할 수 없다. URI 설계를 잘해야 RESTful API라고 할 수 있다. <strong>URI만으로 이 API 메세지의 의도를 개발자가 직관적으로 이해할 수 있을 때, RESTful API라고 할 수 있다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HTTP-method &#123;service-name&#125;&#x2F;&#123;api-version&#125;&#x2F;&#123;resource-category&#125;&#x2F;&#123;resource-path&#125;&#x2F;&#123;path-variable&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET tmap&#x2F;2.1&#x2F;location</span><br></pre></td></tr></table></figure><p>URI 설계를 직관적으로 하기 위해서는 HTTP 메서드를 용도에 맞게 사용할 수 있어야 한다. 아래의 테이블은 간단한 CRUD를 구현하는 HTTP 메서드이다.</p><table><thead><tr><th>method</th><th>description</th></tr></thead><tbody><tr><td>GET</td><td>리소스를 조회한다. 리소스를 조회하고 해당 도큐먼트에 대한 자세한 정보를 가져온다.</td></tr><tr><td>POST</td><td>해당 URI를 요청하면 리소스를 생성한다.</td></tr><tr><td>PUT</td><td>리소스를 수정한다.</td></tr><tr><td>DELETE</td><td>리소스를 삭제한다.</td></tr></tbody></table><br><h3 id="URI-작성규칙"><a href="#URI-작성규칙" class="headerlink" title="URI 작성규칙"></a>URI 작성규칙</h3><p>RESTful API를 위한 URI 작성 규칙은 다음과 같다.</p><ol><li><strong>명사(noun)</strong><ul><li>HTTP methods가 동사(verb)이므로 URI마저 동사로 작성한다면, API 의미가 직관적이지 이지 않게된다. </li><li><code>GET /fruits/bananas</code></li><li>요청한다. 과일들 중 바나나를.</li></ul></li><li><strong>복수형(mutiple)</strong><ul><li>API는 특성상 리소스들이 하나기보다는 복수형일 수 있다. 위의 API를 해석하면, 과일 중 바나나를 요청한다고 했을때, 바나나가 1개만 조회될리 없기 때문이다. </li></ul></li><li><strong>구체적(specifically)</strong><ul><li>URI 만으로 해당 API가 RESTful한지 아닌지를 판단할 수 있기 때문에 URI는 추상적이지 않고 구체적일수록 좋다. </li><li>과일을 요청하는게 아니라 바나나를 요청해야한다.</li></ul></li></ol><br><h2 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API?"></a><a name="restful-api"></a>RESTful API?</h2><p>RESTful하다는 표현과 REST를 아키텍쳐라고 표현한 부분에서 알 수 있듯이 REST는 규약(protocol)이 아니다. 따라서 REST는 이분법적으로 판단할 수 없으며, 추상적으로 판단할 수 밖에 없다. <strong>REST의 조건을 충분히 충족시키는 API를 RESTful</strong> 하다는 다소 추상적인 표현을 하는 이유이다.</p><br><h2 id="Five-clues-that-your-api-isn’t-RESTful"><a href="#Five-clues-that-your-api-isn’t-RESTful" class="headerlink" title="Five clues that your api isn’t RESTful."></a><a name="lorna"></a>Five clues that your api isn’t RESTful.</h2><img src="https://i.ytimg.com/vi/hC5dPhM_LFo/maxresdefault.jpg" style="zoom:40%;" />PHP 개발자인 Lorna Mitchell이 작성한 *당신의 API가 RESTful 하지 않다는 다섯가지 증거* 라는 제목으로 작성한 글이다. Lorna Mitchell이 언급한 API가 RESTful하지 않은 5가지 증거는 아래에 정리해두었다.<ol><li><strong>It has a single endpoint.</strong><ul><li><code>GET /phones</code></li><li>이런 API는 RESTful 하지 않는 API이다. 아래의 API가 더 직관적이며, RESTful API라고 할 수 있는 API이다.</li><li><code>GET /devices/phones</code></li></ul></li><li><strong>All requests are POSTs.</strong><ul><li>무조건 POST method로만 API를 작성하는 것도 RESTful하지 않은 방식이다. API의 기능에 따라 HTTP method를 다양하게 활용할 수 있어야 한다. </li></ul></li><li><strong>Response meta data is in the body.</strong><ul><li>메타 데이터는 최대한 HTTP header에 포함해야한다.</li><li>status는 body로 보낼 필요가 없는 데이터이다.</li><li>response 메타데이터(결과 값, 세션 키)는 body가 아니라 header에 포함되어야 한다.<ul><li>요청 경로에 리소스가 없을때 : 404</li><li>요청 정보가 정확하지 않을때 : 400</li><li>인증에 실패했을때 : 401</li><li>요청에 성공했을때 : 200 </li></ul></li><li>body에는 결과 값이나 인증 키같은 메타데이터가 아니라 순수 데이터만 포함시켜야 한다.</li></ul></li><li><strong>There are verbs in the URL.</strong><ul><li>HTTP method가 이미 동사(verb)기 때문에 URI이 명사(noun)로 작성되어야 API가 더 직관적으로 표현된다.</li></ul></li><li><strong>The URL includes method names.</strong><ul><li>REST는 resource를 표현하는 아키텍처라고 설명했다. 따라서 URL에 메서드명을 노출하는건 RESTful하지 않은 방식이다. </li><li>더군다나 url 작성 규칙과 프로그래밍 언어단에서의 메서드 작성 규칙은 다르기 때문에 메서드명이 url에 등록이 되면 안된다.</li></ul></li></ol><br><h2 id="REST-약점"><a href="#REST-약점" class="headerlink" title="REST 약점"></a><a name="weakness"></a>REST 약점</h2><ul><li>HTTP 메서드를 사용하기 때문에 모바일/웹 등 사용할 수 있다는 인프라 범위가 넓다는 장점이 있지만, HTTP 메서드를 사용하기 때문에 제한적이라는 단점 또한 존재한다.</li><li>표준이 존재하지 않기때문에 REST API 디자인 가이드가 따로 존재하지 않는다. 그래서 Lorna Mitchell이 작성한 글(Five clues that your api isn’t festful)처럼 RESTful API를 위한 약속들만 존재한다.</li></ul><br><h3 id="참고-문서-및-함께-보면-좋은-글-영상"><a href="#참고-문서-및-함께-보면-좋은-글-영상" class="headerlink" title="참고 문서 및 함께 보면 좋은 글/영상"></a><a name="references"></a>참고 문서 및 함께 보면 좋은 글/영상</h3><ul><li><a href="https://www.youtube.com/watch?v=iOueE9AXDQQ">(Youtube) 얄팍한 코딩사전 - REST API가 뭔가요?</a></li><li><a href="https://meetup.toast.com/posts/92">NHN Toast - REST API 제대로 알고 사용하기</a></li><li><a href="https://lornajane.net/posts/2013/five-clues-that-your-api-isnt-restful">Lorna Jane - Five Clues That Your API isn’t RESTful</a></li><li><a href="https://www.youtube.com/watch?v=RP_f5dMoHFc">(Youtube) 2017 DEVIEW - 그런 REST API로 괜찮은가</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> architecture </tag>
            
            <tag> rest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>웹서버와 WAS</title>
      <link href="2020/06/webserver-was/"/>
      <url>2020/06/webserver-was/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1498050108023-c5249f4df085?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1052&q=80" width="650px" /><p>웹서버와 WAS 차이를 이해하기 전, Static Web과 Dynamic Web의 차이를 먼저 이해할 필요가 있다.</p><h3 id="Static-Web"><a href="#Static-Web" class="headerlink" title="Static Web"></a>Static Web</h3><p><img src="https://static.javatpoint.com/servletpages/servletterminology/images/website-static-vs-dynamic2.png" alt="출처 : Javattpoint"></p><p>정적인 웹 애플리케이션이다. 클라이언트로부터 리소스 경로를 요청 받으면, 웹 서버상의 리소스(html, css, js 등의 static 리소스)를 반환하는 기능을 수행한다. 사용자의 요청에 따라 능동적으로 반환하기 보다는 그저 리소스의 경로를 요청받으면, 거기에 맞는 리소스만 반환하는 제한된 역할을 수행한다. 현재 이 블로그도 이러한 static web의 형태이다.</p><h3 id="Dynamic-Web"><a href="#Dynamic-Web" class="headerlink" title="Dynamic Web"></a>Dynamic Web</h3><p><img src="https://static.javatpoint.com/servletpages/servletterminology/images/website-static-vs-dynamic3.png" alt="출처 : Javatpoint"></p><p>동적인 웹은 클라이언트의 요청에 따른 리소스를 반환한다.</p><p>예를 들면, 브라우저 검색창에 <code>https://www.google.co.kr/search?q=devandy</code> 라고 입력하고 접속하면, 구글 검색창에 <code>devandy</code>를 검색한 결과창이 출력된다. Google 서버에 <code>q</code>에 대입한 키워드로 <code>search</code> 결과를 요청한 것에 따른 반환 결과인 것이다. </p><p>다른 키워드를 검색하면 당연히 검색결과는 해당 키워드에 맞는 문서들로 출력될 것이다. 이런 웹의 형태를 클라이언트의 요청에 따라 dynamic한 응답을 한다고 해서 dynamic web이라고 한다.</p><br><h3 id="Web-Server"><a href="#Web-Server" class="headerlink" title="Web Server"></a>Web Server</h3><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cLdcQJjPcoa8N6krWKQCrl77h-3_Oqo_VnPewiLa7GI03qW1qTJripXhTn1S2G547-v-5NsxgzEqXueRUDtPIgS87R_4K0ACm_zHNOHgLGDMeyh4GEPF0nt6yGQIvpTek-gvvVJNWanyBoWp24CIv1ng=w785-h366-no?authuser=0"></p><p>웹 서버는 크게 두 가지 형태로 구분한다.</p><p>하드웨어와 소프트웨어로 구분할 수 있는데, 하드웨어 웹 서버는 리소스를 저장하는 물리적 서버(컴퓨터)를 이야기한다.</p><p>소프트웨어로써 웹 서버는 클라이언트로부터 HTTP 요청을 받아서 리소스를 반환하는 프로그램을 이야기한다.</p><p>Apache와 Nginx가 웹 서버에 해당한다.</p><br><h3 id="WAS-Web-Application-Server"><a href="#WAS-Web-Application-Server" class="headerlink" title="WAS(Web Application Server)"></a>WAS(Web Application Server)</h3><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3dMfhLYCx7I0s6lSD3RGA56iIvz-ieoIrekoLf3STt8FGauegj8SovRs0oLzilVcDMDVrQOQqYewX6d2j5ent5Gmko42tNXfETfLbR0CvXuxNyC6WHzLZuHXiNpazBKKqRWBHx-6IUPduzRCSH_g4SOFA=w1023-h428-no?authuser=0"></p><p>WAS는 웹서버와 웹 컨테이너를 결합한 형태(<strong>WAS = Web Server + Web Container</strong>)를 의미한다. </p><p>웹 컨테이너란, JSP, Servlet을 실행시킬수 있는 소프트웨어를 말하는데, WAS가 웹 컨테이너의 구동 환경임을 제공한다.</p><p>WAS는 dynamic web을 구성함과 동시에 트래픽을 분산 처리하기 위해 사용된다. 정적 리소스에 대한 요청은 웹 서버에서 해결하고, DB 조회가 필요한 경우에만 웹 컨테이너가 동작되게끔 구조적으로 분리되어있다.</p><p>웹 컨테이너만으로도 웹 애플리케이션을 구성할 수 있을것 같지만, 웹 서버를 따로 분리한 이유는 역할에 따라 구분함으로써 서버 부하를 방지하며, 로드밸런스를 위해서이다.</p><p><img src="https://post-phinf.pstatic.net/MjAxOTEyMTBfMjE3/MDAxNTc1OTU0ODk1ODQ3.-GJxkoK7Apn4l0K5L1OXN4NFGsseRoaNhW2r0KIQJdog.0BchcWEI-WS-uEb3iRRrD0JyO_6eZoIWh7xf4f4J2fMg.JPEG/%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98.jpg?type=w1200" alt="출처 : 가비아"></p><p>여기서 로드 밸런스란 하나의 웹 서버로 모든 요청을 처리하면, 클라이언트 요청이 많아질수록 서버 부담이 커지므로, 서버를 증설하여 요청을 분산하여 결과적으로 서버 부하를 방지할 수 있는 웹 서비스이다.</p><p>로드 밸런스를 구축하면, 하나의 웹 서버가 뻗는다하더라도 클라이언트 요청을 정상적으로 작동하는 서버로 보내서 무중단 서비스를 구축하는 일이 가능해진다.</p><br><p><strong>같이 읽어보면 좋을 글 또는 영상</strong></p><ul><li><a href="https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html">권희정님 블로그 - Web Server와 WAS의 차이와 웹 서비스 구조</a></li><li><a href="https://www.youtube.com/watch?v=NyhbNtOq0Bc">[우테코 10분 테크톡] - 희봉님의 웹서버와  WAS</a></li></ul><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jar </tag>
            
            <tag> war </tag>
            
            <tag> webserver </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git - Stash 활용법</title>
      <link href="2020/06/git-stash/"/>
      <url>2020/06/git-stash/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1418669112725-fb499fb61127?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" width="650px" /><p>rebase를 다루다보면, stash 기능이 필요할 때가 있다. stash는 현재 staging된 파일들이 있는 status를 잠시 저장할 때 사용하는 명령어이다. 아래의 예제를 보면서 이해해보자.</p><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>저장소를 만들어서 a부터 d까지 이름을 각각 갖는 txt 포맷의 파일 4개를 생성했다. 그리고 a.txt만 staging 해두었다. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add a.txt</span><br><span class="line">$ git status</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3e3FeEBALMqs9i81zrK68UiDzDHuCiWIPkg_Lhmgvk37vEpoKipsVbU0cJIQW8OnAxxfLN4WNOKG_0nXjzh0RD3MxntvgHaWFW8uMIC9WGHEhy68RmprtjIW0474EWjPQXu7W78yZ9lDfG7CdVE1Qq0tw=w1440-h846-no?authuser=0"></p><p>현재의 상태는 다음 그림과 같다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eccXs875VtpwXaPJdE52wudbUyuAO1xceYhznYdpOzd6IrIRsNp3PeUeyJ4nPDakSS8EjXcmVo5SDMMD1zfNVjHLRpxH_7JDTXG8xyNNXajbVUC9dzYJyO07u3mFuzSDeCkDTU27sVn7jZirLH39MDgQ=w659-h477-no?authuser=0"></p><p>Git은 stage에 있는 파일만 버전관리를 하기 때문에 stage 바깥에 있는, 즉 아직 staging하지 않은 파일들은 추적되지 않는다. 따라서 따라서 rebase처럼 stage가 비워져있어야지만 진행할수 있는 상황에서는 현재처럼 staging된 파일이 있을 경우 다음으로 진행할 수가 없다. </p><p>이 때 stash를 사용하면 stage에 있는 파일들을 다른 임시 저장소로 옮겨두고, stage를 비울수 있다.</p><br><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><p>현재 예제로 작성한 저장소가 커밋이 없는 관계로 stage에 있는 a.txt를 커밋하고, 이번엔 b.txt를 staging하고 stash로 저장해보겠다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;add a&quot;</span></span><br><span class="line">$ git add b.txt</span><br><span class="line">$ git stash</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fX5a055_aeGTESSlol5MIN0Tiqcv-7Y5k1F8_Wd0TyIC7roPu1-vH5k2-r3NeaUOGeTwIgxS8kjZZGGgN6GT9OtHFWS_V6nVZfuucbdVwaPXkSBU_5xJuUki_zZ7IQG0-kv4VnfRIQgD7hIFC4bnTdgA=w1440-h846-no?authuser=0"></p><br><h2 id="git-stash-list"><a href="#git-stash-list" class="headerlink" title="git stash list"></a>git stash list</h2><p>커밋을 하지 않았음에도 status에서 b.txt가 보이지 않는다. 성공적으로 임시저장소에 저장한것이다. 그럼 임시저장소에 저장된 b.txt는 어떻게 볼 수 있을까?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">$ git stash show</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fhJsZ0fO2tHZPT7bqXCMv8rQzoGdoy_sLuAyp9XsN-e7YKexIdVcg7YPzmZZa1XPwyAwVc8u3bq7LRYE53KjM-MeBMi2SxT6WG-NBDlh6mwNI8lTcDfnyfZd-Lsl4OZo9S06wjoFrZhaXvHmEOw2GxgA=w1440-h846-no?authuser=0"></p><p>stash 명령어의 list 옵션으로 임시저장소에 저장된 stash 리스트를 출력할 수 있다. 그리고 show 옵션으로 해당 stash에 어떤 파일이 담겨있는지도 자세히 볼 수 있다.</p><p>그럼 이 stash list에 하나 더 추가해보겠다. c.txt로 staging하고 stash로 저장했다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add c.txt</span><br><span class="line">$ git stash</span><br><span class="line">$ git status</span><br><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><br><h2 id="git-stash-show"><a href="#git-stash-show" class="headerlink" title="git stash show"></a>git stash show</h2><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3fswQPkHCktEZ8dqGUb9utu89s5rSFKvC8GGRX6WgfTbQPNJLRDe2OzhkbBdAddgBxTprtiZtfQfvqPsyoHYUpKZ5ecEheam84fvN4t90gCvHxQj6KZnFPt55JaIhckKJg0HEqWLpSrw6_B2TZcbjIa4Q=w1440-h1418-no?authuser=0"></p><p>이렇게 stash list에 두개의 stash가 생성된 것이 보인다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stash@&#123;0&#125;: WIP on master: 205a72d add a</span><br><span class="line">stash@&#123;1&#125; : WIP on master: 205a72d add a</span><br></pre></td></tr></table></figure><p>add a라는 커밋메세지를 갖고있는 커밋(205a72d)를 바라보는 stash들임을 알 수 있으며, 인덱스 갖고잇음으로 이들을 서로 구분할 수 있다. 따라서 각각의 stash에서 어떤 상태를 저장했는지를 보고자 한다면, stash의 인덱스와 함께 show 옵션을 명령하면 조회할 수 있는 것이다.</p><p>새로 추가된 stash의 인덱스가 0이며, 오래될수록 인덱스 번호가 증가하는 방식이다. 따라서 첫 stash를 조회하기 위해선 현재 상태에서 인덱스 1의 stash를 조회해야 한다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git shash show 1</span><br></pre></td></tr></table></figure><br><h2 id="git-stash-pop"><a href="#git-stash-pop" class="headerlink" title="git stash pop"></a>git stash pop</h2><p>이제 다시 돌아가서 b.txt를 커밋하고자 하면, 어떻게 해야할까?</p><p>저장해둔 stash를 다시 꺼내야 할 것이다. 이 때 사용하는 옵션 명령어가 pop이다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash pop 1</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/FWH_OXA0s6sblsRuP5cv4n4pQVIqwboyPx4RVt1ql-6CO4PjjSXp7oscoc9czDV7OlCokzYV63fRMbz8O-3eogxtyEt_Bgf7wX1rliW0vr87v2CIwOX76K-bbdeEWzDGvx9Xfj29xK60EEk-G5AW_tYabWKDPAFJQsj-mkktE9LGoEfBTRv5vtEwjp08_ou9_fm605RGix563Q5LKAhOacVjRWuCS8b1_lwQtEAF1EpO-kGMOAJnkbxcygEGERJEiX7u_GvlqoNNQDCayjuvtfunIGBCAfuS2cMSWAr-Kg_yDVyCyHaHlYb6hRiFOc7_bamr1luYIOXZ5w8oqAH_HbUg0orrpx1SUahoEozH8awbYSw-O3MFIfa6ELVsWvY4qXxV_AuEhdl6TvVlQGLg_H9jw4iEdPRS_e-U674VbpIiPvZPEa6Epkr55a78ir3k9nvaoPW-dQUZsWhqHkcroaA9c_J-GYj349zfS36yMsq0w-Gg4GikKsXh57q1B4NqpTS3Lw77tDVdZhQaAcemxg55dE_MTGr87ZcEd_eo1DveZ6ctC7dDWIKJCWEaL2Ottag7To-tUk6yZ_eax1afmmLobNuaGipeRbFTSsHDjzqlko7D8so4YIJEylAI9iWREtBLfOfyg8LiRDuvGTtU4p9SwZzUlUm3s294hghgUY6wF8qBgO2zgB0Tb68XMIc=w1440-h1472-no?authuser=0"></p><p> 이외에도 stash 명령어의 clear 옵션으로 stash를 비울수도 있지만, 위험해보이는 옵션명령어 같아서 앞으로 얼마나 쓸 일이 있을지 모르겠다. clear 명령을 하면 당시 staging되었던 파일이 아예 사라진다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git stash clear</span><br></pre></td></tr></table></figure><p>이상 git stash 명령어 정리 끝!</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String 객체 연산시 StringBuffer를 사용해야하는 이유</title>
      <link href="2020/05/java-stringbuffer-better-than-string/"/>
      <url>2020/05/java-stringbuffer-better-than-string/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1544847558-3ccacb31ee7f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80" width="650px" /><p>자바 프로그래밍을 처음 배우던 시기에 문자열을 반복적으로 연산하는 방법으로 String 객체를 사용하곤 했다. 사실 StringBuffer를 알게 된 바로 지금까지도…</p><p>별을 1만개 찍는 코드로 String 객체를 사용하는것과 StringBuffer를 사용하는 것의 차이를 비교해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shinningStars</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">         str = str+<span class="string">&quot;*&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게만 코드를 짜면 별을 1만개 찍을수는 있지만, 성능을 체크할 수 없다. 따라서 System 클래스의 <code>currentTimeMillis()</code>를 이용해서 성능을 체크해보겠다. <code>System.currentTimeMillis()</code>는 해당메서드가 호출되는 시점의 시스템 시간을 불러오는 메서드이다. 프로그램이 시작되기 전 시간과 프로그램의 종류 후 시간을 연산한다면 프로그램의 실행시간을 알 수 있을 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shinningStars</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">     </span><br><span class="line">      String str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">         str = str+<span class="string">&quot;*&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;실행시간 : &quot;</span>+(endTime-startTime));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행할때마다 실행시간이 조금씩 다르지만 대체적으로 46초~55초가 출력되고 있다.</p><p>그럼 이제 이 코드에서 문자열 변수를 StringBuffer로 타입을 바꿔서 다시 체크해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shinningStars</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">     </span><br><span class="line">      StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10000</span>; i++)&#123;</span><br><span class="line">         str.append(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(str);</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">      System.out.println(<span class="string">&quot;실행시간 : &quot;</span>+(endTime-startTime));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이번엔 실행시간이 1-2초로 대폭 줄어든걸 확인할 수 있다. 같은 내용을 출력하면서도 속도가 10배이상 향상된 것이다.</p><p>이렇게 차이가 나는 이유는 String 타입으로 문자열 변수를 연산할 경우, for문안에서 계속 새로운 String 데이터를 생산한다. 반면 StringBuffer를 사용하면, 새로운 객체 생성없이 기존의 객체에 값만 append하기 때문이다.</p><p><a href="https://docs.oracle.com/javase/8/docs/api/">Java API 문서</a>를 보면, StringBuffer에 대한 설명으로 StringBuffer는 가변적인(immutable) 문자형들의 순서집합(sequence)이라고 정의했다. StringBuffer는 String과 같지만, 수정할 수 있다는 특징도 언급했다. </p><blockquote><p>A thread-safe, mutable sequence of characters. A string buffer is like a <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html"><code>String</code></a>, but can be modified. At any point in time it contains some particular sequence of characters, but the length and content of the sequence can be changed through certain method calls.</p></blockquote><p>StringBuffer는 capacity가 존재하는데, 모든 StringBuffer는 이 capacity를 초과하지 않는 문자형 시퀀스를 가지고 있다고 한다. 여기까지 읽으면 배열의 속성처럼(?) 들리는데, 배열과 달리 StringBuffer는 internal bufffer array를 초과할 경우 자동으로 capacity를 늘린다고 한다. 이게 append()를 이용해 값을 늘려나가는 immutable한 특징을 설명하는 것 같다.</p><blockquote><p>Every string buffer has a capacity. As long as the length of the character sequence contained in the string buffer does not exceed the capacity, it is not necessary to allocate a new internal buffer array. If the internal buffer overflows, it is automatically made larger.</p></blockquote><p>그러나 String 타입에 비하면 StringBuffer는 무거운 타입의 객체이므로 immutable하게 사용할 목적이 아니라면, string을 사용하는게 전체적인 프로그램 성능에 더 도움이 될 것 같다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> io </tag>
            
            <tag> stringbuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - Exception</title>
      <link href="2020/05/java-exception/"/>
      <url>2020/05/java-exception/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/kUPM-94-DCKhZ7hh_xTEl_ynnjqNmEwmpHRqr_bvx6rCJBawpro9zSDkX83rVTdEyEp1cDtBQhyDnDmJHw3GfyE3R8AhBYQh0J8NCZzsISx-c1ujqMeLGj8OGosyzgO6itHdbLlHB5GVUtcwwMj2RWRnYZCrgO4CqzZ3-DYjwMUhSzYL7dsZhBaYC6KjvDMHc-MG4JzwU0xnBj-Zv97VcGFkfOPf-MQGTUF6MbO7HoTvoyHhcV9KQXqjestOGZ3B559hh5MuoPyW4ewunPIEnPvN1kImSEVS4zV8_Sp0LHe7Hup_4xa-B3ddDrWQB40XVT1u7dKZSqhgUS1BkKdSaY_efQO_6vzvnxbl59KphIvQNJfgrVsNpyQ-3IykrpNxDaU8__jaoVkF3gaV-2iFuIi3yqDsxUjlASGbhnVsmJs4MzrhcWIbLgllLEGzhFyUaBlVbRvN3dgdq4mMHIPejcF3xOKJb2fOnRhSAJs9UXydwxCJCkvvS9TWixaAvn-4Xo4uqW9vnWPTEj5PtHkrLKhdDq7BK8dpFty1f9UJRBSspQmj0Q0lkBEAIlSx60GhPyT5tx2SxSqqxoYo1R83Zp12DrKAbHv1Xs8eMs2Lt6gz45UXciJrniIY_udIz19jtzEtNWFfdKTi0pWTJpajPkTVXoSh9RLF9d4v1jwzEGLN4NFP7Dw-Mktu7NQgjmLy1XdbA5le2GtzMg-xXsIzE_h-fcOeVf2dcJreSlIUdR_M0tPPY3IqxAM=w1026-h770-no?authuser=0" width="650px" /><p>코딩을 하다보면, 예외처리가 필요한 순간이 있다. 위의 이미지 속 코드만 보더라도 위의 코드는 에러를 유발한다.</p><p>실제 이클립스에서 실행한 결과이다.</p><img src="https://lh3.googleusercontent.com/gZIMA_mG15Zq8k1CfxM3hl-TT5QQ78F3Aid0NuvHhpDPp44jlKV76VioJ2I-sPSolXv5hhirtPQdjJmWOW8trGYpO0hPtSADybVfp4trDUmpOF92lnNn-sNr39mKVYDvhcpZqqykNdFMDWVN9p5kyffCGTHuFA4UI9J8kA6I3FtrzOma5UaW2wfaETMZ-JrpmE4hl1ltOapmDxVLICIiaeKaOKvN_YEz3c4i3rsfk8NQqK-jeiNjwDLqyZ0KdBGKbBByMaWnN6wG__56Z1Sa6Ofl6Naq9X6l8eLqMIFzLxLVObwECxPYcpMTIDHsn3wbj2XnHRRQiDURmd7vj1_dnEDk5IEgRnL9s6gcJqe2Dcmjl8u_2-pbJQ44euscS0GkEPgBAAio1ZH_IiMWiqW7VojMelG85paktchNL_w-3cPIYoRGGejYj8q-wWerQ_75Ck_R6hw8FsODgfSfWiZmeO5G8s-qgZB_gPpOJcsX7xKB_66LBhq3IBkDivnba9mET_rpZtTbPh_FAsjstEgYublLHN4w2y2cSphmDjmQOrgLkTlfrWkljuHGAdLDyqWI_-2Lv7cXFZOljnj1Sn0N3ux97wBshekH9y95yrZxY4zBP2FQFReUHXLEuBjxAJJ06pcX3oldGV4UeRbjd6iUwN4CthITwuB7InFcH9abmKMeFtOHNaFp6KGLjuLrFeRlB2hSvTnyE9_ctjPmsbpj5OSFtrR0uLrb9xQbEz7rlJAE6E6pj03WK6c=w1458-h808-no?authuser=0" style="width: 85%;" /><p>연산 처리에 예외상황이 발생했음을 알리는 ArithmeticException 이 발생했다. <a href="https://docs.oracle.com/javase/8/docs/api/?java/lang/ArithmeticException.html">API 문서</a>를 보니 ArithmeticException에 대해서 아래처럼 작성되어 있다. RuntimeException을 상속받는 클래스임을 알 수 있다. 다시 RuntimeException은 Exception을 상속받고 있으며, 가장 상위에는 Object 클래스를 상속받고 있다.</p><p><img src="https://lh3.googleusercontent.com/Wfg91z2JuMxZ0JFwJ-ed1xG5kxR-HSLf-vKaQSg5QxNeVj6_xSOQv1XzmAslUiL408sFm3XBJNPKnhXTgr0LaWyJ5qr90gvA_qzuZFmcg6WzMq-cUhBQZiqL336tUCH6FtojbArzwTZntDChay9fDlxAwEOeeaLsuGWOvNeGW4QGmawbjZH5kFEZWHGhxwlOqD2z9TuIutX7llL1I3cLr-pa8IcZMwDIau26JeFVg3iE-Q1IKUqzfXmsEq1IOu0R5bqelaT5PYDpRlYTVvZbOC1vCdm-BQ0e48JGVLzFRrUy5bca-oS2y9SDL_bKiZkvzHdKs7-9C7griyhUPPcp1PJ6COuSYasxOo4trIAs6CQjmyTjWCJLdvjt29IzMZEfRRoOnIIXn5Df0hRZdXRDEAX0O5y5G1I2sfzo2cDLGlNPa4vsWCvvVGaGAYyIupSbN6C2dfxDEfjQZj1Ov2DHLl2SRxGU8CY_9x5qMc-kw8d4TEE21yM1tGlUXRoWlxdT3meN18_ZKKIpcVvKVgPLHM_qhbS2DbHKEGOgzu0_ENikJDF72AvbBrOGVbLAbEA6va396M8yJn3RHX_EklnER_BU93lGDbNFUgK24DJhCxD6VR9VVnaTTJvaQub7PkGdxZH_fHYz0PCSBl8Wf0r1fXv9SYqctYbs5Ni0LKS_L5Atho7t-_1e8jX8wxnyyU2Kf7pQBGOR2rR7J_w4cXSb9wurVq7_xWINTJoUzMEqVzVOBHYnLUGUmH8=w387-h281-no?authuser=0"></p><br><p>예외처리는 크게 2가지로 할 수 있다. 예외가 발생하는 곳에서 직접 핸들링 할 것(<code>try-catch</code>)이냐, 아니면 예외가 발생할 가능성이 있는 객체를 참조해서 사용하는 곳에서 핸들링할 것(<code>throws-exception</code>)이냐.</p><img src="https://lh3.googleusercontent.com/pw/ACtC-3eIF4RrMNlC00cPQM6zqi5BAS-9F9tXzZbGc9P3qyRjDjDAxBVNswRJnIFM0j2tf-5uSMXHFchhMU5uJRe7Izmk1YI5dBDfWqOvBo1boUGZGhFGb_45_ZTURwM_hz0vEw6QKE6ECKSLpuTG-0CrZtg8qA=w945-h480-no?authuser=0" style="zoom:60%;" /><ul><li><a href="#try-catch">try-catch</a></li><li><a href="#throws-exception">throws-exception</a></li></ul><br><h2 id="try-catch"><a href="#try-catch" class="headerlink" title="try - catch"></a>try - catch</h2><p>try-catch는 예외처리가 발생할 가능성이 있는 객체 내부에서 처리하는 방식이다.</p><p>try catch문을 적용해서 위의 코드를 다시 컴파일해보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmeticException</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         result = i/j;</span><br><span class="line">      &#125; <span class="keyword">catch</span>(ArithmeticException e) &#123;</span><br><span class="line">         result = <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;결과는 &quot;</span>+result+<span class="string">&quot;입니다.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/I8C_zhtbsmu9Yby9AJrsD0zKXUdhJqaSXYMxPB3sJLE4TQV5U_jhdWJAtyY6Qoj9z1K-1c_1aT81FSaIrmRPqooBhmp-0mB5K9K4LvD8XZBsDi42rRtaNKtdtfTZLPq_4zRHJLuoQ32UsAlFzE4zACfpQmIXdolzxhB9fwguOW9Dm_-jclW9Ga2ECyioXk3gZpviE9Eouj5fv0rg430Cgyjv5qsuawENuQ37TlXKAJsYsYx5ZRfiY7ADxnK274Jd7vQE0HNp85Z1StKN6n3WLytMHe6cgXR-ZB-4rZ-UBDAG8MF72H_fbFhnt-vsoEGP_xaOOKWAjSPagjOnmdr3QN9iWCxGMUTwqraXWu_pOyf9nkCOLtoOfK-TVvVPuiJE7HDbVnxho54-yMW9rmsYgH4xlqBtTEondv4I0KZi_iPEbesqQG2ixHl2x07Oj12kP8ABuQ68wrrph0mfApEYswbaHS1ap_t8fGsgIWVG3b_NWiLA4VWIAeDGiUeRD4SFBEOTHRqBJ9-zXnCPa-CmSzf0Ld6IIC2ToaMws4aiaQbBE3ZdLZ0uXztgSsp9xGc-nMEEkbeb57RkjDuhoDse4PxOtX8IEsOVpdZVNGTf1N-ZzlLx72EcxYxnRPAgMJA57u650c0Jth-ZChPo2qUDUBOz8kttJ1BkSyMuJddCl0wKTMZjjp0V90xXQbx00lCa4ijirOLNH7zNl1aD9eAHQ5q9Hmu9IayYy7aw8n_bbrXHGqBfV9FGu10=w1182-h802-no?authuser=0" style="width: 80%;" /><p>이번엔 예외가 발생하지 않고 출력을 할 수 있었다. 이 때 사용한 try catch문에 대해 알아보자.</p><p>try catch문은 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// 예외가 발생할 수 있는 코드</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(예외클래스 변수) &#123;</span><br><span class="line">  <span class="comment">// 예외가 발생할 경우 대신 처리하는 코드</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// 예외 발생 여부와 상관없이 작동하는 코드</span></span><br><span class="line">  <span class="comment">// 반드시 finally를 사용할 필요는 없다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try &#123;&#125;</code>에는 예외가 발생할 수 있는 코드를 감싸주고,<br><code>catch</code>에는 try 구문에서 예외 상황이 발생할 경우 대신 처리할 코드를 감싸준다.<br><code>finally &#123;&#125;</code>에는 예외발생 여부와 상관없이 작동할 코드를 감싸주면 된다.</p><br><h2 id="Throws-Exception"><a href="#Throws-Exception" class="headerlink" title="Throws Exception"></a>Throws Exception</h2><p>throws는 예외를 던지는 키워드이다. 즉 ‘예외가 발생한다면, 네가 예외처리를 해줘’ 라는 메세지이다. 즉 예외처리에 대한 책임을 예외처리가 발생하는 메서드를 사용할 객체에 넘기는 일이다. 이를 통해 사용하는 객체에서 어떤 예외처리가 발생할지를 미리 알 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmeticException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      arithmeticException ae = <span class="keyword">new</span> arithmeticException();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> result = ae.calculate(i, j);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(ArithmeticException e) &#123;</span><br><span class="line">         System.out.println(e.toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> <span class="keyword">throws</span> ArithmeticException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> result = num1/num2;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 연산하는 부분을 따로 메서드로 분리한 코드이다. main( )에서 사용하면 <code>ArithmeticException</code>이 발생하는데, try catch문으로 예외를 처리해두었다. 이 예외가 발생하는 로직이 담긴 <code>calculate( )</code>에는 예외처리에 대한 책임을 넘기는 <code>throws ArithmeticException</code>을 작성했다. 이로써 throws 뒤에 exception 관련 코드가 작성되면, 해당 메서드를 사용하는 쪽에서 예외처리를 해주어야 한다는 것을 미리 알 수 있게 된 것이다.</p><br><h2 id="throw-new"><a href="#throw-new" class="headerlink" title="throw new"></a>throw new</h2><p>throws 키워드가 예외처리를 상위 블록으로 넘겼다면, throw new는 강제로 예외를 발생시키는 키워드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">arithmeticException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      arithmeticException ae = <span class="keyword">new</span> arithmeticException();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">int</span> result = ae.calculate(i, j);</span><br><span class="line">      &#125; <span class="keyword">catch</span>(ArithmeticException e) &#123;</span><br><span class="line">         System.out.println(e.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(num2==<span class="number">0</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">&quot;0으로 나눌수 없습니다.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> result = num1/num2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>분모로 들어오는 num2가 0일 경우 <code>ArithmeticException</code>이 발생하므로 <code>calculate( )</code>에서 아예 num2가 0으로 들어올 경우, <code>ArithmeticException</code>을 던지도록 작성했다.</p><p>메서드에 throws 키워드를 통해 작성하는게 더 편해보이기는 하나, 이 방식으로 작성하면 조금 더 직관적으로 왜 예외가 발생한건지를 알 수 있을 것 같다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu에서 JDK 설치하기</title>
      <link href="2020/05/install-jdk-ubuntu/"/>
      <url>2020/05/install-jdk-ubuntu/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/xqV3DT8ySuZYuCkPgGeT35e8E5JveyzYk48NLDKU37xArR5m8E25eUSexA38tfuK1WpmsE939WQZ4dyAZDt_xSCioLeciW5heEQoruZBxd4Q47ymAR_CXqZI0g2nyz6H8GJcCFiBnRv2pnhaLH2gLiZID3FJ1tU4PUR0qGGQr8W3Xw1MNmUecPei6AT_X8T2p67iTqVL6GEDhwvdjrcA27ud6HDnwcPSPyEnVuooOHdPKETLx5Z-p8PEBjAkbl4zyLJrnpEtvr9yXSV34S0JmlkE9h9Jt8xUth4LBXRVXOitQOX0HpVl74BNeXd7FcfUTseRf9ObNX9Oz31aWUB2MN6faNv9eWQAuAiEhrVC3-R0J5DHbH3Qm628cwM5rn0TCkxnLODRFxs1OVUo_LaE_FIc2ROQxxudtdYglyGcSOX-_yAAlz3SW6WuG1xdB3sGDk9-iBVzSG2CyzcVaUZKd7AYaY-qE6ELTZpppemNWDnr3MOHyuDcgXpY7bfiLGZzjAcSYLVZvuqy3PnoYeRl3b03NOqdBAx-E8aJba2CCmuMAnSMkH3SsYZ438sz2HxgpFW117EyMv3ylWeh43HggA2XBLiWmu1kx2RANrQXvvIPp_rCsnjuqynVKvfkKnXxSBWR2l-qA1mK9iqcaeJtQ4mYTeWJ2YEBx_fdQORAlg7inZC93bFO_dy41p1yHtQRftCrhBOn4xiD2NP05UGEBUydk0o60L-mbXmeCa-KEBQ2kLS89XSge-o=w750-h478-no?authuser=0" width="650px" /><p>JDK를 설치하는 방법은 2가지가 있는데, default-jdk를 설치하는 경우와 add-apt-repository를 이용하여 원하는 버전의 jdk를 직접 설치하는 경우이다.</p><ul><li><a href="#autoremove">JDK 설치 전, 관련 리소스 정리하기</a></li><li><a href="#default-jdk">default-jdk 설치하기</a></li><li><a href="#add-apt-repository">add-apt-repository 사용하여 jdk 버전 선택해서 설치</a></li></ul><br><h2 id="JDK-설치-전-관련-리소스-정리하기"><a href="#JDK-설치-전-관련-리소스-정리하기" class="headerlink" title="JDK 설치 전, 관련 리소스 정리하기"></a><a name="autoremove"></a>JDK 설치 전, 관련 리소스 정리하기</h2><p>jdk를 설치하기 전, jdk구버전을 깨끗하게 지우고 시작하는 방법부터 알아보자.</p><p>openjdk라는 이름의 패키지들을 삭제하는 명령어이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove openjdk*</span><br></pre></td></tr></table></figure><p>마찬가지로 oracle도 삭제해준다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get remove oracle*</span><br></pre></td></tr></table></figure><p>openjdk와 oracle을 삭제함으로써 더이상 사용되지 않는 패키지들을 autoremove를 통해 깔끔히 제거한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get autoremove --purge</span><br><span class="line">$ sudo apt-get autoclean</span><br></pre></td></tr></table></figure><br><h2 id="default-jdk"><a href="#default-jdk" class="headerlink" title="default-jdk"></a><a name="default-jdk"></a>default-jdk</h2><p>default-jdk를 설치하는 경우를 알아보자. 작성시점인 2020년 5월 기준, Ubuntu 18.04.3 에서 default-jdk를 설치하면 jdk 11이 설치된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update -y</span><br><span class="line">$ sudo apt-get install default-jdk -y</span><br></pre></td></tr></table></figure><p>참고로 <code>-y</code> 옵션은 설치과정에서 묻는 [Y/n]에 대해 미리 Y를 입력하라는 옵션이다</p><p><img src="https://lh3.googleusercontent.com/vjHv5uPXV2BzkOfmu6Z2dwQnu7rC4Q5_RCp4t6IH_2FvZu4f4IYfNUZWJ5ejZDi2goLgkSRdf5JYez34CbmSp4hvrdq1JrPMNx2QbU19iFdBTSi_inBtchfZ78hTYcI5DWpRNRBxGfszW6VaULDw_EG5LOam-InP5Dvyofk6Y6rdPAjy-4VgryZMwH0V4uQbBZv8Pfkf5YcLqjhcU72SDXPzZD8fRfsdQ-XEl1XLzFHNwPTYuKVZ8DWY0Uq-ciVtzGiPanTYBU_qTNEVQzWZLQDjSxw1Lrh9ToAfE3Jra97LWqjBT7igBDs2KiaPXQyxCimQpjOjSdaiIf2pvAARiik17yHabsLLNhVNYL1iEJ4_dsQ6s-pLDxDlpr2I9hWpNk6xzTan4IAcvjuLUJbDZWIjiBfS2BdyJqwwzmqaWEsRBqLB_puQzyka9UecjXqO0_Tf2Ci9yavMqTX11nGCafpFH7mW0hsmTKdK9Fi25dTNKhlWoUgpDSYROEXyIqf-8NG1E0l4hOsZtKvCCs0VAyRMDseoLtNDk9wVvVE_x0vAFTgY3YbpQU9H7gQtZ-X4UVBnq-5zOl4IW8plRkt3h-5Nj8ox6RDrvLq7iD3GP2icHYKNqgzyHDyEnuVGUx3mb2QQNA7D2_CO7kTzKZZ5r0w-3YoxyJcx5iSVeF6hjYCXp2Atqydsp4m5yo4KnFHOx5DdJoPgdKKmhynK1sfWgsiHLW-g77QFvQR_VwPanvWApAGmVbEcDNM=w1042-h227-no?authuser=0"></p><br><h2 id="add-apt-repository-사용하여-jdk-버전-선택해서-설치"><a href="#add-apt-repository-사용하여-jdk-버전-선택해서-설치" class="headerlink" title="add-apt-repository 사용하여 jdk 버전 선택해서 설치"></a><a name="add-apt-repository"></a>add-apt-repository 사용하여 jdk 버전 선택해서 설치</h2><p>add-apt-repository는 파이썬 기반의 스크립트라고 하는데 이걸 사용하기 위해서는 software-properties-common을 먼저 설치해야한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install software-properties-common</span><br></pre></td></tr></table></figure><p>이제 add-apt-repository를 사용할 수 있게 되었다. jdk 설치파일 소스 리스트를 추가해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository ppa:openjdk-r&#x2F;ppa</span><br></pre></td></tr></table></figure><p>이후 apt-get을 업데이트하면, 설치한 jdk 리스트를 조회할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update -y</span><br><span class="line">$ apt-cache pkgnames | grep jdk</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/_rZTBGyYXCEYGTqLqiyYS_lEF4dnv5CjNN9jiB3hdxVs0EhNjVHgHlOPgvkBpf6AHmGsxbRNRvxGTPoSydmVgbZEvJIPgbFpUb0Hr9ULne9qL5KQE6sijNEx8Q109DJWp5MS-NhChcimA3eQP0EwkjkERfG5zKK_hNL2mKf4H4Ub-EXS7tCE9cyEfTr7sKeNYbRoWPt6uBH-sOwWacUUf93HU0qGs60h_2ti2X036DAIgWIVmUxv-HSrR93Bu-Co9thaih2SoBfeG-kAed5xEoGXGETQTAFl8BmDQ6xLQDq4vFZ151rIrdb2mQNO6QgV_pz9EpfS5QvGKMQ3NzWV6HqrR_ZAsbY4sQh0obgmxpkcKg0TxmUCQux7Hplq1pZSDIKm2Li1eFcAOjrd_O0jsgj0-x_sPtuW0e2V3-WXBnA941I3TxinI_danmhQa1SMgKEsyYbG7pes4COuq63i-03pfS3Wx8Q_b0h4d_i_KY7KVqWhJdcDdZB9FylK0wYEeYN-cb5CKKUo41Bxkec60gqwHtJH3LEAtbD2FaGOz-qd4uiGc236rhpFb1mF0XIXPE8wPRUPwDAsXpa2iuAss5LFKWgl2MUcxLFogmkIFac-7-Ya4QILjI2xuQNwbYRK9JcJ4SvA0A7owwmyvN1_Jrt1q0YvJXPFwvPWh6bBdvLFnBeVrMCjtoNuvn9h0jt3Ehvjs6m-DK-FCZPIzMV1I1kzuCA-OXxx_C6arKF8LdZOEh7vm--qQGI=w999-h924-no?authuser=1" style="width: 80%" /><br><p>원하는 버전의 jdk를 설치한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>버전확인을 해서 원하는 버전의 jdk가 잘 설치되었는지 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - String 클래스 메서드 정리</title>
      <link href="2020/05/java-string-methods/"/>
      <url>2020/05/java-string-methods/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/reserve/oIpwxeeSPy1cnwYpqJ1w_Dufer%20Collateral%20test.jpg?ixlib=rb-1.2.1&auto=format&fit=crop&w=1516&q=80" width="650px" /><p>String 클래스가 내장하고 있는 메서드들에 대해 정리해보았다.</p><ul><li><p><a href="#append">append()</a></p></li><li><p><a href="#length">length()</a></p></li><li><p><a href="#concat">concat()</a></p></li><li><p><a href="#substring">substring()</a></p></li><li><p><a href="#indexof">indexOf()</a></p></li><li><p><a href="#lastindexof">lastIndexOf()</a></p></li><li><p><a href="#charat">charAt()</a></p></li><li><p><a href="#isempty">isEmpty()</a></p></li><li><p><a href="#replace">replace()</a></p></li><li><p><a href="#touppercase">toUpperCase()</a></p></li><li><p><a href="#tolowercase">toLowerCase()</a></p></li><li><p><a href="#trim">trim()</a></p></li><li><p><a href="#split">split()</a></p></li><li><p><a href="#tochararray">toCharArray()</a></p></li><li><p><a href="#getbytes">getBytes()</a></p></li></ul><br><h2 id="length"><a href="#length" class="headerlink" title="length()"></a><a name="length"></a>length()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자열 데이터의 길이를 반환하는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터는 존재하지 않는다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line">System.out.println(str.length()); </span><br><span class="line"><span class="comment">// 출력결과 : 10</span></span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat()"></a><a name="concat"></a>concat()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자열과 문자열을 결합하는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터에 추가할 String형 데이터가 온다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello &quot;</span>;</span><br><span class="line">String lang = <span class="string">&quot;Java&quot;</span>;</span><br><span class="line">System.out.println(str.concat(lang));</span><br><span class="line"><span class="comment">// 출력결과 : Hello Java</span></span><br></pre></td></tr></table></figure><h2 id="substring"><a href="#substring" class="headerlink" title="substring()"></a><a name="substring"></a>substring()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자열을 자르는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터에 어디부터 어디까지 자를지 문자열의 인덱스가 와야한다.</span></span><br><span class="line"><span class="comment">  첫번째 파라미터가 시작 인덱스, 두번째 파라미터가 마지막 인덱스이며,</span></span><br><span class="line"><span class="comment">  파라미터를 하나만 넣을경우, 입력받은 인덱스부터 마지막까지 문자열을 자른다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line">String lang = str.substring(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(lang);</span><br><span class="line"><span class="comment">// 출력 결과 : Java</span></span><br></pre></td></tr></table></figure><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a><a name="indexof"></a>indexOf()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자가 위치한 인덱스를 반환하는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터로 char형 문자를 입력받으며, 해당 문자와 일치하는 문자가 </span></span><br><span class="line"><span class="comment">  문자열에 존재할 경우 인덱스를 반환한다. </span></span><br><span class="line"><span class="comment">  만약 2개 이상 문자가 발견될 경우, 가장 먼저 오는 문자의 인덱스를 반환한다.</span></span><br><span class="line"><span class="comment">  문자가 존재하지 않는 경우엔 -1을 반환한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line">System.out.println(str.indexOf(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// 출력 결과 : 7</span></span><br></pre></td></tr></table></figure><h2 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a><a name="lastindexof"></a>lastIndexOf()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  indexOf()와 비슷한 기능을 가진 메서드이다.</span></span><br><span class="line"><span class="comment">  문자열의 인덱스를 반환하는 것은 같으나 indexOf()와 달리</span></span><br><span class="line"><span class="comment">  뒤에서부터 조회해서 인덱스를 반환한다는 점이 특징이다.</span></span><br><span class="line"><span class="comment">  마지막 문자의 인덱스를 반환한다.</span></span><br><span class="line"><span class="comment">  파라미터로 인덱스 조회를 하고자하는 char형 문자를 입력받는다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line">System.out.println(str.lastIndexOf(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line"><span class="comment">// 출력 결과 : 9</span></span><br></pre></td></tr></table></figure><h2 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a><a name="charat"></a>charAt()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  indexOf()와 반대의 메서드이다.</span></span><br><span class="line"><span class="comment">  인덱스에 위치한 문자를 반환하는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터로는 int형 인덱스를 입력받는다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">1</span>));</span><br><span class="line"><span class="comment">// 출력 결과 : e</span></span><br></pre></td></tr></table></figure><h2 id="isEmpty"><a href="#isEmpty" class="headerlink" title="isEmpty()"></a><a name="isempty"></a>isEmpty()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  해당 문자열이 빈 값인지 확인하는 메서드이다.</span></span><br><span class="line"><span class="comment">  문자열의 길이가 0인지 비교하여 boolean값을 반환한다.</span></span><br><span class="line"><span class="comment">  파라미터는 없다.</span></span><br><span class="line"><span class="comment">  문자열의 길이가 0이면, true</span></span><br><span class="line"><span class="comment">  문자열의 길이가 0이 아니면 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line">System.out.println(str.isEmpty());</span><br><span class="line"><span class="comment">// 출력 결과 : false</span></span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace()"></a><a name="replace"></a>replace()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자열의 일부를 다른 문자열로 바꿔주는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터로는 2개를 가지며, 첫째 파라미터로 바꿀 문자열,</span></span><br><span class="line"><span class="comment">  두번째 파라미터로 새로운 문자열을 입력한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line">String newStr = str.replace(<span class="string">&quot;Java&quot;</span>, <span class="string">&quot;Python&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(newStr);</span><br><span class="line"><span class="comment">// 출력 결과 : Hello Python</span></span><br></pre></td></tr></table></figure><h2 id="toUpperCase"><a href="#toUpperCase" class="headerlink" title="toUpperCase()"></a><a name="touppercase"></a>toUpperCase()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자열을 대문자로 바꿔주는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터에 대문자로 바꿔줄 String 데이터를 입력한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">String strUp = str.toUpperCase();</span><br><span class="line"></span><br><span class="line">System.out.println(strUp);</span><br><span class="line"><span class="comment">// 출력 결과 : HELLO JAVA</span></span><br></pre></td></tr></table></figure><p>toUpperCase()는 subString()과 함께 사용하면, String 클래스에는 없는 첫글자만 대문자로 바꾸는 capitalize를 구현할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;hello java&quot;</span>;</span><br><span class="line">String newStr = str.subString(<span class="number">0</span>, <span class="number">1</span>).toUpperCase();</span><br><span class="line"><span class="comment">// subString으로 첫글자만 가져와서 toUpperCase()를 적용한 코드이다.</span></span><br></pre></td></tr></table></figure><h2 id="toLowerCase"><a href="#toLowerCase" class="headerlink" title="toLowerCase()"></a><a name="tolowercase"></a>toLowerCase()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자열로 소문자로 바꿔주는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터에 소문자로 바꿔줄 String 데이터를 입력한다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;HELLO JAVA&quot;</span>;</span><br><span class="line">String strLo = str.toLowerCase();</span><br><span class="line"></span><br><span class="line">System.out.println(strLo);</span><br><span class="line"><span class="comment">// 출력 결과 : hello java</span></span><br></pre></td></tr></table></figure><h2 id="trim"><a href="#trim" class="headerlink" title="trim()"></a><a name="trim"></a>trim()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자열 앞뒤의 공백을 제거해주는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터는 없다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;  Hellooo Java World   &quot;</span>;</span><br><span class="line">String trimStr = str.trim();</span><br><span class="line"></span><br><span class="line">System.out.println(trimStr);</span><br><span class="line"><span class="comment">// 출력 결과 : Hellooo Java World</span></span><br></pre></td></tr></table></figure><h2 id="split"><a href="#split" class="headerlink" title="split()"></a><a name="split"></a>split()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  문자열을 잘라서 배열로 반환하는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터로 자를때 기준이 되는 문자열을 입력받는다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line">String[] arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(arr));</span><br><span class="line"><span class="comment">// 출력 결과 : [H, e, l, l, o,  , J, a, v, a]</span></span><br></pre></td></tr></table></figure><h2 id="toCharArray"><a href="#toCharArray" class="headerlink" title="toCharArray()"></a><a name="tochararray"></a>toCharArray()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  split(&quot;&quot;)과 같은 기능이지만, 반환하는 배열의 타입이 문자열 배열이 아니라</span></span><br><span class="line"><span class="comment">  문자형(char[]) 배열이라는 차이가 있다.</span></span><br><span class="line"><span class="comment">  파라미터는 없다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>[] cArr = str.toCharArray();</span><br><span class="line"></span><br><span class="line">System.out.println(cArr);</span><br><span class="line"><span class="comment">// 출력 결과 : Hello Java</span></span><br></pre></td></tr></table></figure><h2 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes()"></a><a name="getbytes"></a>getBytes()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  byte 배열로 반환하는 메서드이다.</span></span><br><span class="line"><span class="comment">  파라미터는 없다.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">String str = <span class="string">&quot;Hello Java&quot;</span>;</span><br><span class="line"><span class="keyword">byte</span>[] bytesArr = str.getBytes();</span><br><span class="line"></span><br><span class="line">System.out.println(Arrays.toString(bytesArr));</span><br><span class="line"><span class="comment">// 출력 결과 : [72, 101, 108, 108, 111, 32, 74, 97, 118, 97]</span></span><br></pre></td></tr></table></figure><p>여기서 출력되는 byte코드는 <a href="https://www.ascii-code.com/">아스키코드 테이블</a>을 보면 어떤 문자열을 의미하는지 알 수 있다.</p><p><img src="https://lh3.googleusercontent.com/y82u1xMYdpei4fNvYZxEiUnbHuR5p8I0D29cSN0hWmN5uRLN7MLdjxyNj08j90655x6GgnD12StW5PKVZoS40f4-OWYGy-eG1qQ2hM0OOc46vw-sK-b4_hZwbO9rGe73U5RpSiEfHrRp7hmKp7QCQku47KwQkXU2Bb5MOB-r3-DRD7t4LlOkVxdL49YnkLGZZAgKiGSsRS-kyisPhgGfdQQTafl782mbM1un6zc-hwYD9HwkZQ1_rADp_7NQNH4aXFq7v_txuFF_PgkaNyeo41SyCZJoxArORrufHDFfwav8sgx4KUgtS1XES41ArL4ry1pDkeXB3-I9dEDI_DfnFFee3EjZDjJqkoVn2xzswlyg3lQNwOUcvTAVhL4XyL3baJk7AgW0SChvJ5wvTjnRVgC3erSDHM8rHCeOUdT8Rln29ic2S474gNGlCcKjBkZQ2OF4wh4iEH6U0U3CpbJA_pE05LCUNubY9x-QVt2nz4HYGDGfEfLJ6Et1UDXcyeRBigjyTBRIBYUH4yUZbLQesE9C3ZSEnI-W4C8BVWiU_3jiGxkFKOy_RQvRb2nQRNXndTSS0mW4B-bfmMB9iJypKpVU10OlLynm-z66U22aL5KsZyRo58d4pBGqdbumVIFSWKbQ2JzHnFx8DT34u4QR9pQyG6kFGitTaaGS6Rc81zet6mFNitL4hYZwfBQbVPJdWDgg9cfPv2dAJ1kk7IUSuVwPj51znMbdHhi-72X7wSYWLrbluRtt9W3M=w870-h240-no"></p><p>아스키코드 테이블상 H라는 문자는 10진수 72와 매칭된다. 따라서 문자열 str 변수에서 H의 문자와 매칭되는 바이트 코드는 72라는 걸 알 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> object </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - Date</title>
      <link href="2020/04/oracle-date/"/>
      <url>2020/04/oracle-date/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1541232876724-6e25c6dfa788?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1952&q=80" width="650px" /><p>오라클 DBMS에선 날짜함수를 사용할 수 있다. 현재 날짜(OS 기준 날짜 출력)를 출력하고 싶다면, 아래의 명령어로 조회할 수 있다. dual 테이블에 대한 설명은 <a href="https://devyoungjin.github.io/2019/07/oracle-function-number/#dual">이 글</a>을 참고바란다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sysdate</span></span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><h3 id="목록"><a href="#목록" class="headerlink" title="목록"></a>목록</h3><ul><li><a href="#operation">날짜 연산</a></li><li><a href="#months-between">날짜간 월(months)수 조회</a></li><li><a href="#add-months">월(months) 연산</a></li><li><a href="#tochar">날짜를 문자열로 변환하기</a></li><li><a href="#todate">문자를 날짜로 변환</a></li><li><a href="#extract">날짜에서 년/월/일 추출하기</a></li><li><a href="#extract-from-timestamp">날짜에서 시/분/초 추출하기</a></li><li><a href="#round">날짜 반올림</a></li></ul><br><h2 id="날짜-연산"><a href="#날짜-연산" class="headerlink" title="날짜 연산"></a><a name="operation"></a>날짜 연산</h2><p>날짜 데이터는 연산도 가능하다. 현재 날짜에서 1,000일 뒤의 날짜를 조회해보았다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sysdate</span>, <span class="keyword">sysdate</span> + <span class="number">1000</span> <span class="keyword">as</span> <span class="string">&quot;After 1000 days&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/Yj-CQYTEBBiyWlhDbbI3Yg4d2YQUuZCDi1Q0DD6Y6dlrWJoG2tiYRaULqs80Igqj9pm2Hvjc6z4e4UVr48M1_L5F6OyIGHUbINpbDxrjNfa3C4TCshHHTDEnFQoWm4qs9Bs7-n9Yhke-mDzgdts_rpSaZkLiZZG3xA6OlZ3C2RUceNXB1QVO95kYipq9pSXt2x9YNbp7ui7X17VAQMymqWuRREnzWRsM3wd3u0ZB7uyExRz-ZxL93hm4_F7A7HT9AhMayyAA2UthEBIaFEQiyRYogblpjDB_U9jQMFZTQa1wFc7l-am8CJoD85qp504KrovT_0O3U5NjlSZkESgZ47jThrM844E0ICDw0MvRfXggTs8p4KBt4RNeyJxxdaRvsegQtmeTW6EdY99LLnzpbCQyAQ7BK3oJBOphPUBRspRW_wZECW-xbbF0FMAaz_OaA6HqFzkQ_OsoIHgbp7JTd-xD3VnHQodwbAHddPYwGjfooLk4M7jpva0qe3I7THIx376BVxh56hdxV6Cljlj9bDhuSNB-p01WNBnx5Gaj1wBDzDyhM8GpT9y27AbaHbEhSkPuWXTTu4jsS_JknZZUbBCPzO6S9nBzW9MFvnw6oPMlrRblJRkVkWIBDnQgjVd8iaAEbv0piRo0EjIs8kUQvgNLwPsBet-ZuW-sHHK5AOkPfvMnwzZZh5zPe_N0Dic-n_IGvMEbrX7vtOs_xiMw4DmvGNGsR2vghotUqWnyNY5g61XaBBONgG6q=w1032-h392-no" style="width: 80%;" /><p>이 때 연산되는 숫자는 일(day)를 기준으로 연산처리된다. </p><p>날짜와 날짜 역시 연산할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> hiredate, <span class="keyword">sysdate</span>-hiredate <span class="keyword">as</span> <span class="string">&quot;long service&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/NqnDDogwbuMuXs1L3azP4uMbavgHHklvIReQl6yFYheRUYyc3bUs4QLtIOUQum2fs0kCuUL6JlcxZo7xVUH_6IQhaKgSgxSitQ1SVM_BlNlzzkt1Xqabi-fieedL7c8hGc6BNXebQ16_B6smdK2iLix7zQ9XUAYULnXBue_LdFqi9_jodBrk68uTt65YdQdIqWud5rtLohWSYaGfYdlruZmKadutpw66QIZUcMZ0YCu2g5HFL1O0kbC1GwMRJLR9nA7YOrS6UI2_ruX6e3tBuoBzCbH3acYv7fucOeZiCfCXa3-oGVYeza6jl9QTHXZEsX4GHMp2fxHOLGspUerkiQTPSRjp5HtvB8pe80MsSxapcNd07_IylP7XgFhnUg9dSFFBT59gRRu7cKCuZTQWColcLL3xp3GLtgZj8D0h2u9vks9Vp6aRzwObeurJ9K_4AiwRDEAbJ-Bc_WD8krhatHLABGJ_FOcwuIeM2wQC-TcnY6c3eayElCejRkjI1CDUeuT9rsPhpd7pMlxuRNh6EpRrwWo2-8SU849_4t1RaoY7I0SN3UPAmdR4tmsWMHRfWBfI0wFmoF4B2COXKA9yZoIjp2DfKXxOzhnB3AWy652JhVahkSjUj8eciIjhosc0Ct3fEjaywzpnkbMrztlV_TbvWvnKNkqUy3XmOIorY7dntkWFomCX0asEOTQsDi1xWKzaissUiEqbQt6wW0TufjY_KmnmGqRpjYtfcKRt8tf95DrdhIk9io8R=w1020-h860-no" style="width: 75%;" /><p>그러나 연산 결과가 이상하게 출력된다. 날짜인데 왜 소숫점이 찍히는걸까. 알고보니 정수 영역은 day를 의미하며, 소숫점은 시간을 의미한다고 한다. 따라서 시간은 제외하고 순수 근속일만 계산하고자 한다면 숫자함수중 버림역할을 수행하는 <code>trunc()</code> 를 사용하면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> hiredate, trunc(<span class="keyword">sysdate</span>-hiredate) <span class="keyword">as</span> <span class="string">&quot;long service&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/Is-Vm_2wevUbeU27fX10fxz2cvm3JwwOqFtpqDsRJNnQEyZBIwgyexvgll0Jr_AGh-wTP87mey4DFQB7VCqQESByllVr2Wr9Lp388NZRSAoH4Wxg580xK9uvdMQK_4-7CkVWv5QEFslUGFMDGFaWnIJ7pW6aGA-LXOKzXW00XClcBZMQb3c525b3jU4oQV42IjSCBqbwiBqf-MQw4Zv3Xf_Q1Lsp3dAsWtuZ9QRHtr-ROtSuX4YA700ej1tMPBVZJIaiLtnPcadCzTRNX6fJ3P3Xdn8bsA4kqE9Se10O9PWSA6BmaC4J0GZ4Wq0Do4REpbxDrnf2Vh6p0uy24s1Popswj7Lj7M4rCg_XVB1o3A70KgIYWsbN9oaK8eHzzaWW0lrgE1Y2FvGSO_K-jbJ68_UbVY9CCV6jyPN7OQCnAy6TA-TBMbpfz2kpmSDwnsdVjVbSVtEVONnk-BukJXfsxLSV1_jfrPinozSSGw6bn1sZHucSsHky1tkhFXsAIDEV-4lbuztT2Yujo90_v1z20lgfKLEgFqO-rwPYGBfzsJTO7cBt_--RJdKe64qSy57TvRZBjm-nYoFavGAjb16YprEw_cWTDtqTtPiv28WE8WxwLz6Y18Rh0bfoLoC8TdboHhFrlekIOFX-2gikLFKEr6k0D-6kkqDl66zabjr16f1JFwYvmt3rfTJT9pCPvYGF1w93wv42vcDwM5BkLr9u_3emuWevGoY3RimmrhoWl6scVebEA3WZ7b8U=w894-h886-no" style="width: 75%;" /><p>이를 응용해서 현재의 날짜를 기준으로 내가 얼마나 산지를 조회해보았다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;1991/03/23&#x27;</span> <span class="keyword">AS</span> <span class="string">&quot;내 생일&quot;</span>,</span><br><span class="line">      trunc(<span class="keyword">sysdate</span> - <span class="keyword">to_date</span>(<span class="string">&#x27;19910323&#x27;</span>, <span class="string">&#x27;YYYYMMDD&#x27;</span>)) || <span class="string">&#x27;일&#x27;</span> <span class="keyword">AS</span> <span class="string">&quot;내가 산 날&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/62VciJGV2vbVEcMyaBcAadBuFriwxv7QSQcgtLs4f3VkLGiFNAfWHJbLeT2OFf321FLn_WGP8C23qxjgMtA4Dz22ji-4STJGlpgXmzRlE0ESn2sB2JQE67k8lCLsdmUmDW6zKUbMEUVBM5P3inlcxqd9vW3sZafnLUARFfGzxdWwX0vJt6NgXAtoLUTxTHjkPOXfU_9QQvpjsVbSPLNGdz3PL_ya85KJE_yi1EZFbD-ZajlRJsqgiMR4azE_Wg3fktv2CcjOGXmTzmJaf9M1CMc_oEk2Qnf67u7dLmIImjJYZvB3aBlw58DwlQkWmCWSDrc9kAHVecOvyDfc9GYD1CKfrGOF_rGnOLMvWeNbKDpGn5amC4EswQi9KWqCwxm7qSgXA84klxLG_896fYix7v4zXrcaQyGipWRd8IHiNGhl9upe3Lj9WVwuEBYtLYDZEg4g7i9od2s6XnCWSYgAsb9ZP8eikYXuW_-kNbR5z9Ie1B1-C4DTVXeWKSzerHtX8WoJJ50qpdsS1wMQ4DeeV9Bs3W5tMpkYAMM_0DAYXoAciGPB8QuBBDjfvquLyg79Z7-4gn2C1WzgeCuZ5zK2B29bXGJEdone43i9iE44YkFSSqsZnzuSaSCRnW2xY71j9DjE3rt_TdsdkIoPWx8E_teBCmbP_VfAWGzFGc8mN3YzzB0lLdgPBiumdfXGO0zZUwiH5bgu8xMF6zI1GUJ4VM46UFEA0B6HIkrUgT3zt5bhWtX9ZmiZXPLE=w1226-h442-no" style="width: 80%;" /><br><h2 id="날짜간-월-months-수-조회"><a href="#날짜간-월-months-수-조회" class="headerlink" title="날짜간 월(months)수 조회"></a><a name="months-between"></a>날짜간 월(months)수 조회</h2><p>날짜와 날짜를 비교하여 몇개월의 차이가 발생하는지 조회할때 사용하는 날짜 함수이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> months_between(날짜<span class="number">1</span>, 날짜<span class="number">2</span>)</span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><p>파라미터로 2개의 날짜를 입력받으며, <code>날짜1-날짜2</code>의 결과를 월(months)로 조회한다. 아래 퀴즈에 대한 쿼리를 보면서 확인하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emp 테이블에서 입사일(hiredate)로부터 현재(sysdate)까지 몇개월 근무했는지 조회하시오.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, trunc(months_between(<span class="keyword">sysdate</span>, hiredate)) <span class="keyword">as</span> <span class="string">&quot;근속 월 수&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> months_between(<span class="keyword">sysdate</span>, hiredate);</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/faQ61ipFOiCsDrMmF0KDcRSj_pqjXtA5H47XCkNrsFPhQJcgDF4QCvk3TZWzHSkGUOLHXKiFmdjE1YxjSvOCSuhZiJ8naFNeRyZ4nYSPuwGsHA0gziUvhQPwcMSt9MLLjonEJhrsGiRF3KFWFj4lJGqmT_W1H3DiRv4Aob6Y2pn3HbF5dWXZFxTXm0W_HchFxC8exT_noXQkuIhh43D_xRy_IVKbvDdQ0zMIPQHrhV__tPfKHXPsx2of4zDX8--q5bmvK7SdwXqTfWusUC7q1lkL5MCfC-ll4DRf-JEPoltSCEkkeeOVxzh2OZTsVrYxLahqmGjr4r2uCintIBj0WJBrkpCvcyaC0W9BAXqlLIWMziIiD7e-_bvP9cvmI9AmsNE0GzSbcaXfHHsx_BggwmwME8nvht9pCjkFaWEcsRbkQyZoMPuxqIX4Q4kwZ8J9c8CjvOfLHzbyy2R1efVOhwwzdVVi97d33EADTFYL-jhUE8_NkHi4o8j_N1FPmSuUPWEIbDB5mEr53GxNkuzJDQt0aOF4AdmEGsFBA1C2BrlTX27PCokNzS6G2ESnTuW5VLUX0h_xsFb5ebFj9xoHqj9joG3EOd008tUQXEmg1G-P8hTYq3rhh_JH10XVu3O0kezofnXqoP5y02Rmr42OaAM6X801Pfk4Ef_b9vpJt_7a6gDAu-LOlOdtEMnNTCMAc9oJPS8EUIbA1l6L2HSsk96G0qlfuVa2Cuci0mnrEZ04g-mExP-O7qVT=w1240-h964-no" style="width: 80%;" /><br><h2 id="월-months-연산"><a href="#월-months-연산" class="headerlink" title="월(months) 연산"></a><a name="add-months"></a>월(months) 연산</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> add_months(날짜, 연산하고자하는 월(<span class="keyword">months</span>))</span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><p>기존에 날짜에 연산을 할 경우 기본으로 일(days)이 연산이되는데, add_months()는 월(months)을 기준으로 연산하도록 하는 날짜함수이다.</p><p>emp 테이블에서 hiredate에 36개월을 더했다. 연산이 잘 된다면, 연도만 3년 추가될 것이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, hiredate, add_months(hiredate, <span class="number">36</span>) <span class="keyword">as</span> <span class="string">&quot;3년후&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/_pIi7TBtRzpLqAGcKrccvXPFtYMHF-cjPTe-jcU6lKcEvZXxYcH_XVXK1LNTgSbgSvrtKQ4m_iJapbYsONEaW8vBRfL9QCikginYzQC26zVJeD3dPrDOdEIOFwv8knY63xH5iqbr8sWf7JyDu1ENJyRAbXzVLGTeZJucXtGS27MSLEnib2fH13IpF6wjF6S-3BXVF3yaLOUblHr96k61Q0Qi-fOhhIiwZVpcl2uynv16sftf3E9LFilMFlTVhPPSblo3xJWSqbQDNy6Rj9y6DI7L6T3c0Jr-AWXJF1o5KB4LnpG5CW8-YZ-M2EcC5p58785DgAXAz4emXbBiUzAH2JcnGL5r8Oi3XHPsDw0k8cWUFwKAgzp2XXBuLsZLgjNVyHRqfLT0XuYN5rkVs54CrNeR0sD3wjAH0kgdvMW_7RIf31q2PGfO6CeHB8iPuQutU-U3E-eJDOxwgmKuxao1ZwYnIMvl4gko44pzvIB3hFjhPnaiOb7nx0FiVRn4wYBTUdA1n--UeP8rweJVzeka3B3rtQ6eBzFelOXi-6OmCmtRIcUz-nLMiFYrXpHnQzPX2awFNwCLmiEE8kT4upBywCJXlomwpmW96QF4DKAQcuhmYnMRpbzD9jAwfbSGF--kx7tIZlTi-v6g3gHO_k6MVPMXq3IRTCJav08NeLjt6s042-cue-j53FrBsh6Vmk4MAqfVeh90XrrdvII6WJJ8obVCcBoZo8KJtt7J7BPx6LXWET3CZij8pmi5=w1188-h872-no" style="width: 80%;" /><br><h2 id="날짜를-문자열로-변환하기"><a href="#날짜를-문자열로-변환하기" class="headerlink" title="날짜를 문자열로 변환하기"></a><a name="tochar"></a>날짜를 문자열로 변환하기</h2><p>dual 테이블에서 sysdate를 조회하면, 년/월/일 포맷으로만 조회가 된다. 그러나 변환함수를 사용하면 sysdate안에 포함된 시/분/초까지 출력할 수 있다. 날짜와 관련한 변환함수가 2개인데, 먼저 소개할 변환함수는 <code>to_char()</code>이다.</p><p><code>to_char()</code> 의 형식은 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> to_char(날짜, 형식) <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><p>위의 형식대로 작성하면, 형식에 맞춰 날짜가 조회된다. sysdate를 원하는 형식대로 조회해보겠다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> to_char(<span class="keyword">sysdate</span>, <span class="string">&#x27;YYYY:MM:DD:(MON, DY):HH:MI:SS&#x27;</span>) <span class="keyword">as</span> <span class="string">&quot;Today&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/oVN3DOnOgtTkUlFCXwKHM-MLQXNnG2Taf7UprHjvpniSVHpgBRRH2hokIHSZwKL_8grRMPQrDEMgzWBXEiiw6GsbB4eoQ34RRlgVqVMq011m02uGU7iBGbG_WkebZ306FFuWISkBlTMZ0awgY69xIe6mCc7Onca7eOCGrzEYFysVhLtmeejy9uJipI04uci7HnWVZxdotX_DZFtmnNZQjV7gbSTAzHc_yOy_nfQl4cCcHSqaDLbsBj6u_w6PMfiLI2NIJzNBnR8kzKqM-TtDL2GABu3LSuzraMktHekVj286SczLbp7o_j54WwgVZDt8pAKs40FLeeLl5Yj6hOszgWXF-xB3FJ9gQ9cJ76dihMcF7pup00mo_zxjvxJ-zXOATGpY2Y4xmm2Fhy6fSQRHDnt8u2_BD8cALvVs6p4rf6Z8I1mhpZnFDV82IgS2vjajK5-Q65mnTL0sWAy2ptkAuxQjveoBRiMTmc_323Qc1tb80nGpPzvoDyENBDmwWNdRDU9KbpJJwCQLivO8jVSbFwUubu1zkseke7fHkTpkvCCDDv2BlR_rMb6Q7RsphoSbRbTSzau5ECmYFVE4JsEB7zeuqHUalnLTRJbkhKlFrL_BlOL8a0EP_i-t1B3yNtoNOVaFvuKEI-HpZKeFrinFWp63ByhAaKY_0DbKhsMz57nxto2_ch74F7MR-odBQsZrwyeX5OaBv2jpwoMpJxMmBJkVPa-e3VQutUloXXrd1hNT-ywZqsJ8-nao=w1420-h1090-no" style="width:80%;" /><p><em><span style="color: gray">맥OS 시간과는 차이가 있어보인다. 왜 이런 차이가 발생하는지는 모르겠다…</span></em></p><p>date 포맷에 대해 알아보자. </p><table><thead><tr><th>symbol</th><th>description</th></tr></thead><tbody><tr><td>YYYY</td><td>연도</td></tr><tr><td>MM</td><td>월</td></tr><tr><td>DD</td><td>일</td></tr><tr><td>MON</td><td>Month</td></tr><tr><td>DY</td><td>축약된 요일</td></tr><tr><td>DAY</td><td>완전한 요일</td></tr><tr><td>HH</td><td>hour</td></tr><tr><td>HH24</td><td>24시를 기준으로한 hour</td></tr><tr><td>PM/AM</td><td>PM 또는 AM을 쿼리에 작성하면, AM/PM이 계산되어 조회</td></tr><tr><td>MI</td><td>minute</td></tr><tr><td>SS</td><td>second</td></tr></tbody></table><br><h2 id="문자를-날짜로-변환"><a href="#문자를-날짜로-변환" class="headerlink" title="문자를 날짜로 변환"></a><a name="todate"></a>문자를 날짜로 변환</h2><p><code>to_char()</code> 함수가 날짜 데이터를 문자열로 변환하는 변환함수였다면, <code>to_date()</code> 함수는 문자열 데이터를 날짜 데이터로 변환하는 변환함수이다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(문자열, 날짜형식) <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><p>첫번째 파라미터로 문자열 데이터를 받아서 두번째 파라미터로 들어오는 날짜형식에 맞춰서 문자열 데이터를 날짜로 변환 조회한다. 아래 예제 쿼리를 확인해보자.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">to_date</span>(<span class="string">&#x27;2020/04/02 11:45:20 AM&#x27;</span>, <span class="string">&#x27;YYYY/MM/DD HH:MI:SS PM&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/1ssJsYnmgsprY7Z8Rl4M_e4QeisC4FrRtARCz87eUjmDKHU5N7R5k-mB8jJ8JrqVTjv3la1lTi990anbyk7odhmNmxoyH63bt0McGz8xT5k-USRd455GWvQaq-9R9zAcofXeLcOxIAZ1KhPEyBtPDVBCCw7xq7hNEiNzV0-a15uB4jkL4ObKxNrEEWegMlEDOnWPG7hpl2hMIV60pHfuyg_Fm8UVcQ9n-LslxtPgkkJW76rhVIcmcJBl8aEL9CT6E7FhoT6IRW2RVtxd2jt1wObwAAfysvFqLCjury6OTp7S3XLE34qkNGIvJjJRyha8UDBWBgPXLia1S6REr8pjwQ69LJAummNv12FqZmgT4xaJSGd2J0PIiJWPCqzL_1HUGpP8JpdCFKpowJQm7x4F6MHm1zqLspKPxK96iBQ2wKnKsTt0-qgceMGP9n0YnpkGaNhH985zXkRsVRfd6Gl_oupL1n10wVRQrmSUPXWt3dTEF3l01aQ7rw0WLcKjMCZNa-lY8iuWWWvbOPmB8R9SS7cfk8IwgrVnsT6pPrSaWN4Y-inWR0PawGmsow98ItJsewZJRnSr74bQbmfyw0tUAGr08bTzzXal6ziwSDGJYyWBtBoL4weO0uKbw7RdqRgAuWn1szHza71qNxxqZ50dh2ULzHGIInygQ5S5upNeXg2WwAAMXwYTc6TjlWrSY5cZfQJ8SO6_8JfAsuiyaDOz6YZvl4QzmoaFVtFFJ7ZQpW2pl2FBEapJ8gTh=w1292-h466-no" style="width: 80%;" /><p>데이터 타입이 바뀌는 것일뿐 기본적으로 <code>to_date()</code> 와 사용법이 같다. 첫번째 파라미터로 받는 문자열의 형식에 맞게끔 date 포맷을 작성하면 문자열을 날짜 데이터로 변환한다.</p><br><h2 id="날짜에서-년-월-일-추출하기"><a href="#날짜에서-년-월-일-추출하기" class="headerlink" title="날짜에서 년/월/일 추출하기"></a><a name="extract"></a>날짜에서 년/월/일 추출하기</h2><p>날짜에서 원하는 포맷만 출력하고 싶을땐 <code>EXTRACT()</code> 함수를 사용한다.</p><p>현재 날짜에서 월(month)만 추출하고 싶다면 아래의 쿼리를 입력해보면 된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(<span class="keyword">month</span> <span class="keyword">FROM</span> <span class="keyword">sysdate</span>)</span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/IqZBQFRjEBT-aOY60um0BjgLQcilRmPyg9mI2yGuwl8bv4EkHTbHT4Qb0DV9wmZUSN9TQ9O6wZ_p9Nf-DtFjuPLK1dPkQ73v6kKQVD8utJtRcV2et0lOWmb2WypAEfhzx3FIQFbUpsWnTOViuek3zWKmR4N0pFL5p1LV8j_IiCu1dCWEm2cPzT_OntoDOzXymuvIMMgaoeA8gUpEndCWWUAK0Mpu48ZipJgo7Rd3hVsQ4XdtjtW4JfJMttkAofZWB6kUukpEHuahGN66iwaRTftv0fY2kSXfK6WHV24ozBq7VyN2QGIyKgwiu6zViXHtP0sFQK0P0yNYso3aUbZDDyNy0imu2AviaF8uG4MPMIRKkyl8TIzclc4LLGDdhibatsYo8iyhrgEfEqPgx3rKSpdHfGGEG0rfRofnzOmnEFeYr8UzjQNRRrvF8oyKx2rETUg84z0gdzQbJ1qJfQp5sNYY-OdKLEw-SyPmFt4uiqidRt8cLcicJtc9YSS1bSUO6lnyzCK7cB9_kngXLlL5u-5s-5BRs3a8uaJP1lRzcsqQi22tP7y3JV2rDoIgAIe8Mt5JiZTt-6tnHT1AdW1FubH8cOSThuLsz1c3PmG7no6bEU2P9OfEPdX6vuLO_TLA_CDq3RyP_r9Z_9PznhEcNExpr60A-qSrA6DPSir924tqfkJn5X1Qwxdx2q9UcLWga4VE7GCyy39ORI4p7ZrBNAtJAlxRmzVnxxk6Afz_sMI4Ar4R7VtMADRq=w792-h408-no" style="width: 60%;" /><p>위와 같은 방식으로 년도를 출력하고 싶다면, </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(<span class="keyword">year</span> <span class="keyword">FROM</span> <span class="keyword">sysdate</span>)</span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><p>일을 출력하고 싶다면,</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">EXTRACT</span>(<span class="keyword">day</span> <span class="keyword">FROM</span> <span class="keyword">sysdate</span>)</span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><br><h2 id="날짜에서-시-분-초-추출하기"><a href="#날짜에서-시-분-초-추출하기" class="headerlink" title="날짜에서 시/분/초 추출하기"></a><a name="extract-from-timestamp"></a>날짜에서 시/분/초 추출하기</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> <span class="keyword">sysdate</span>)</span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><p><code>EXTRACT()</code> 함수를 사용하면 년/월/일은 추출이 가능한데, 시간/분/초는 추출이 되지 않았다. 왜냐하면 해당 날짜 데이터에 시간데이터, 즉 timestamp가 존재하지 않을수 있기 때문이다. 따라서 이 경우엔 프로그래머가 임의로 날짜 데이터를 시간 데이터로 형변환(cast)해줘야 한다.</p><p>형변환시 사용하는 함수는 <code>cast()</code>이며, 형식은 아래와 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast(날짜 AS timestamp)</span><br></pre></td></tr></table></figure><p>이를 적용하여, 다시 쿼리를 수정하면,</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> <span class="keyword">cast</span>(<span class="keyword">sysdate</span> <span class="keyword">AS</span> <span class="built_in">timestamp</span>))</span><br><span class="line"><span class="keyword">FROM</span> dual</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">extract</span>(<span class="keyword">hour</span> <span class="keyword">from</span> <span class="keyword">cast</span>(<span class="keyword">sysdate</span> <span class="keyword">AS</span> <span class="built_in">timestamp</span>));</span><br></pre></td></tr></table></figure><p>sysdate와 비교하기 위하여 쿼리를 다시 수정하고 조회해보았다.</p><img src="https://lh3.googleusercontent.com/cVb7700_Yu0S_9NqINo9M8pOFoMsuFCl2DKcEiw6cTLRAtu5KpGKWQ1Er-IInGy6Vl7dQj8YhjRlftcG-qi1kiOUBkuuRVjQBjGlK1c7Gj0I5Py6ezlP43NUFE7GyiuUWgcxGNPNq5bx-elEeU5iNL2bakQ1JJgfBmPloKuepV2GSy9euKzaPww7o5AEVFmXe-bJFshiG9fnROSCa-5ohrZYC6565Dffc4BeiCgCStHChcZYlRJ8t6iW-wNxaWYMQaFZAK2SpW0jbdzsqR7x7bHaltMe5VQ2BlLDGc7UIDF5jlAolBfzZaHc73NjD2ZgPJHo_BGA99INdQKrvMC6um4Qf7BEZa56s1N7jtaLQZ1irVLq7htU4ed10NLr3o5iGwJm3pojbMYKxbj6XkdyEy_Fell5HYSrYEL0HJnwMockJWPTqm681nIXiNOIchLwjUbGqKdrcl34pRaOcor_5OsgrS2JyNIQWNAwItwezgRbJ1dU0NGkfRUdZ-_K-dOua1WyXLINjJZaw0BUD9zMsIKt26NLWQiR2j3sa24XbKZO-kq2Ed5XXmR8Lq_0UjFXSGY7qnFttWpt-Ga59AmUCExhHFBMsKHfoIv0ecuYd9t3kaEr9MGQvRUaXB1dThEzgBCfZIV8fz1G4dafOCJiAJzDbAl_fAzNnTVQIp4N4lkfUT50LqSm5PRb_xPnYUzdPDZ9bfngkoXNww9NvQ0Jg3J2V5APuMYA-z8QPqPuFRh_3P5af7WmHtZ3=w1250-h478-no" style="width: 90%;" /><p>현재 오후 2시인데, 시간추출이 14로 나왔으니 제대로 출력된걸 알 수 있다!</p><br><h2 id="날짜-반올림"><a href="#날짜-반올림" class="headerlink" title="날짜 반올림"></a><a name="round"></a>날짜 반올림</h2><p>날짜는 각각(연도, 월, 일, ..)을 기준으로 <code>round()</code> 함수로 반올림이 가능하다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sysdate</span>,</span><br><span class="line">   <span class="keyword">round</span>(<span class="keyword">sysdate</span>, <span class="string">&#x27;CC&#x27;</span>) <span class="keyword">as</span> <span class="string">&quot;year 두자리 기준&quot;</span>,</span><br><span class="line">   <span class="keyword">round</span>(<span class="keyword">sysdate</span>, <span class="string">&#x27;YYYY&#x27;</span>) <span class="keyword">as</span> <span class="string">&quot;month 기준&quot;</span>,</span><br><span class="line">   <span class="keyword">round</span>(<span class="keyword">sysdate</span>, <span class="string">&#x27;DAY&#x27;</span>) <span class="keyword">as</span> <span class="string">&quot;week 기준&quot;</span>,</span><br><span class="line">   <span class="keyword">round</span>(<span class="keyword">sysdate</span>, <span class="string">&#x27;MM&#x27;</span>) <span class="keyword">as</span> <span class="string">&quot;day 기준&quot;</span>,</span><br><span class="line">   <span class="keyword">round</span>(<span class="keyword">sysdate</span>, <span class="string">&#x27;DDD&#x27;</span>) <span class="keyword">as</span> <span class="string">&quot;hour 기준&quot;</span>,</span><br><span class="line">   <span class="keyword">round</span>(<span class="keyword">sysdate</span>, <span class="string">&#x27;HH&#x27;</span>) <span class="keyword">as</span> <span class="string">&quot;minute 기준&quot;</span>,</span><br><span class="line">   <span class="keyword">round</span>(<span class="keyword">sysdate</span>, <span class="string">&#x27;MI&#x27;</span>) <span class="keyword">as</span> <span class="string">&quot;second 기준&quot;</span>,</span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/Ut3Ys4e09vUd5dNCKDC6ieGpldcMBSeutUEoghqwnWWnNwjrnFCvRRJDag24AQtrjuy2j_t5d32j-QuqKkoSuYf8oZgo3MbPvsQHArkY8hBWJQRVKqNBj-dIAQiGV0QSbGvlSIy4nmc_1fMZhBz3f3d41SRpNFuWFWNf3Tz_zBOg1Buo6V3zMWCcCpc3jx3DwkD8O1lJHlGi0BFi03Hm4RX1DZBahtz1E8jewgChRTv7Je9Yh9gyYX-bg7NgcoLgdRx4K5J3bbSFKgsJdTtiaZAyv02iG-c9ssS_QttzJmD_tFCOHIus12O4Aw_8KrweZYzNEPMV8qjY4k-b3P6g9IiyHY-6LYVUHYeP7lO6BhLVZykH9KWxrO7BUNV0Svq1DR2aQXO_nD7jDoSHxDX6HPGvvOVU4zRKm3VEBWYHF7-brDBE2ys7xzv9tnnW8ALb9MDp-GS3AfsgCmtkQlLLZE0IGovaYFjcw8df0FtXTJNZewujV9du3R3xWh03VqBTQ4XfRxteRo7vxgWlkqcz3LCktWlwAOLltw7nVu1-zaEhcIxa7m1-8w8lXsplNwz4qeWwZM7PsTW9StzGOnsSeTUrwsZdPWtfdQFG10ZMCYXQdTQW1Taa9aiheh8IEj4l13YuJvFl4ZYbrjuT1xleEyAF4ekR81QgWX1p-GncpHuxTICz540RgxYp8ZA8yQIH7jk7dMpliIihchiZfuhpdb2C7BAM_uTlCCW-YxHiGYDcVdIzY-FSRkpP=w1440-h690-no" style="width:80%;" /><p><code>round()</code> 함수 조건으로 삽입하는 포맷보다 하나 뒤의 date 포맷을 기준으로 반올림하여 조회되는 것을 알 수 있다. </p><p>일(day)을 기준으로 반올림하고 싶다면, 일(DDD)이 아닌 월(MM)을 기준으로 반올림해야 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sysdate</span> <span class="keyword">AS</span> <span class="string">&quot;오늘&quot;</span>, <span class="keyword">round</span>(<span class="keyword">sysdate</span>, <span class="string">&#x27;MM&#x27;</span>) <span class="keyword">AS</span> <span class="string">&quot;일 기준 반올림&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/A3qz1rsUArLnZ1_xI0PbbFX_qG45VnZGkeN3eEXRfhN1rNpM7-TkJH6sSeye0mH9d0Zb1VAnI676ECJ76t16ovm3YdWAv-bUJwwNqnpn4pF2bm8PO8bnd4ZrsexSE_mn17UeN723QJgbtTImyu1WAXxRjbNBEFykbgBuXbPpLbeVtSUyr_dN8mkJ9lvxOHiPAbK6AlNJd1mASeMvjZJhGb0SbRSc8HKLq57nni30KT0hU1kpgPA1cc4TMclF_X_umYmVI95S0jLce9KnuDju5KD9CDc60p5-HkZjV2IWOBEvaDo6mPF0NxaiW1C9PNxG8F6OXa_h6gYj4Hg8L3l1Cp1tKCXbk5F7SkG_CUc3pjqcxAW5CVi6Zm0gp8VMyg71zUgPyRa1Md4cGlnXDp2a9XJFkihSPj1oO-TYqsv_cEpIzww4qUI--ZaLaS0YjOEDC7Kqe7pWcFzwVBYvC_suvRl4AvK04d4_6R6c-XcU-rmfSUf2vHZjV0PVhcjS6QUNlYi9y8_JKiWV02J3FUIBSPcGRr8p8jP5tPfSR0ojZk_Pnce-hY3k9M-LpULcATockRv3si0gkbq7QF1CDV-EKOOeppBLLdL6A4D2x72rLeCs7ZrT1CE_kDCeriw2-VD966uSH52s4xEQcoYGX3X6NncYjNAB42keIavPgc2G0PdJXwn99Gv4XrUDnx_zUvTtq3zn_1V--w8D6ELIEeqyAYgaFtKy0opqzgXeegtEqfj29UViRncWAs_1=w948-h446-no" style="width: 80%;" /><p>현재 날짜가 4월보다 5월에 가까운 26일이므로 5월로 반올림되어 조회된 것을 확인할 수 있다. </p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - LIKE 연산자</title>
      <link href="2020/04/oracle-like/"/>
      <url>2020/04/oracle-like/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/G4N6J9eaf6r0piKxIOmPEpOfGooYGk3_GXnppvsswvfgVVJf7A97uOvbKJkIcSK0WrZ1TZ1Ibnv3hyXMAcQExR2t57ZpPEbbfMxxqEnwufFfHoGYfzChFHHvN6QhrcBiTATaiNtweHz8VqEKFd_yvIE3125kYPcQQNL8FjQDZw2-W__dj7KPqvisr4HKLBALyLMZuU7KIgL1L3LgeUZ2OOA11K5i_m6QYCiDH2bhJnTU08P1klA2TvUxt4s6aejZkEXzb1-1_nn5dMZXt9bl3yzDyFFikNfNj1bX71rO9LetjKzZ0gFek2a8X2jaDYUs320jFq5gim6XgOJVsdBr4MYQcrf70Ag2Inw5pl8R99_rJ3ALqJFnQLf4wKa-q-rroGoLHBemhWVjyHo6FV_BnoCDnGC1QJTSZx20hqM1bOqUOBgcIwd9oXF6wlKl4Qw2JCohJJBBnUOcav5hZUEW3kSlQMf0yL0hsMth7SB-o434hLCHcQFtNzEa0XwbkohQ_6Dvk5vHMExr_QAcV54hcLuqjRqVqzDT23Rqc-wND919btp7Cw_7nl1kYgYPn79uUIFglmJ9aKf-IkjqjuwREwXH7SFSzqk-pNTz83AIjOJ0FeCs2yUiZisNPJkAZE8xNlXf1OmyWpBSam7VqIY5FlzBCECwFs0_a7PM4ieB2XZl3erGS9Do6ye3OcshefMjlsjMed7c6oM_YeaxXf5Llle18k-LsEWbbfAufAWOrxZU19sxvLGsomKZ=w1024-h480-no" width="650px" /><p>문자열을 검색할 때 사용하는 키워드이다. <code>WHERE</code> 조건절에 함께 사용하는 키워드이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, empno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;FORD&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/nm5aXsBH1KujyWR1aVg0X4XVBWHGpRGl8br4gj3NoMUCz4YFaP4l6S0Ggqg0h01C9G9VYKrxjlVK9YYAhQ6fy7h2p_9IqOI7eAg7cpP4xnTCKzc3fandVlVT7dXFvL_4dMQeJMz_Hfb4-PBTAq85jp5__clb4mzc1uESg6Dt_WMZ_M8pIkjeti60aK-wlW0IXVO7cPXEMWjlRfejLaZt_993WltJjC93LFmd3U7A04WUBdgp8dMJPjhkIil7TZDzN8V2mjP08QmkUGDfLviK-CZrFajsQ4zxcbe5mQXGgGtOAP3DRM4MS94lCIxydzQSYoj1JmQofflbILrBuvUDV5_SI1fJOjTZflFF6WS_Pmhy-llz1AeH96-Lcpwpqgs1bcZpUJvXohH42uNa6faeRxVYLB_lfSNQmAVp1yx51CdJg20CMwNbEsR9VxybI38-iwUaKy_JLnYV6yGrDNdQs4MrfgFSndMAMeWFYXxeEEDjRiqWGLi70xn9igDn7c34OdqSOrrDeil6uQR-Cr0H_NbTiudnz0ODAVktNq1fvKVYHlZKJidFWCEgCUl9zzvedFFwc1rGLGe1xCeQ9DGBdvBoMivJ1wjxHUu9k3vqK5dIJYhC2URgURaidJnUJC4c-xcj_E3TpoZqhumozDt3WnZnfBTeGezm23jgq2k9rUgK0XbniqgNhCzHxlJSE0oM5kAZvZN0BLOze8D9nQnyjudMMlP2-cG_u7Z2znk-ayZgfVTPvwTa3VR3=w804-h428-no" style="width: 50%;" /><p><code>LIKE</code> 키워드에 포함하는 문자열을 가진 모든 문자열을 조회하는 방법이 있다. <strong>두번째 글자가 A인 사원의 이름을 emp 테이블에서 조회</strong>하는 쿼리이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, empno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;_A%&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/aM9L6qBU2GBQKVrpgt28Hfy02kM_feokGFA4XEZwYCPlXUAXkt5S2mV5x-0YVUwUeWZE8BBC3Ghb6jR_IUMSDWTbmR3rVmf-TvhKgIWQczpmuJr_Md0Z5lzw-p27hHGSdeYZQi8WDSqQs8GS8Wi7zPI09U0CD7qD-f1GD65QeIrBAVPiWJIrHe-CIkGZrcQFfFGbLvWXBesN1MNfx-1DolNSN7QrCus3tkBzKwLzWUz8Lz0Sy2r8tCRfV1J6DWJFSi4FDRaCiLE_uC3_qZwPf0p-PJkV43Kh1EGEOmVzqtJFxf6cF3tcVD6EuRJsnmFnsx3DXVNAnu3SsYP3Zv_Yvl6PTjNgSmkF2kXx013vvSSOosFF8l6RYUGFFVXAAoET4jnkhEzDihYJqz1xMkqYPLQP36WiB9nQxPVP-s9XDLuGGUy_9q7x2srH2tLJoZ5yxipbD7ozz8_Fh5gbeN8LHvaz71QDENKtAnPfi2pGlAlADpgKX2MvlWUx31eoMZx9a81pNQ4_YiuE1MjeIzvGthA2yCbvUmuqyuTAf0yvCBUEBenv7VIMcADTtvnY1SVDvWLNCsC5QC6TZC5edf69jCBiG1tdcTd4WakGoaDVyhT6S-AtaGRmiAcMMHOdQmMvHclt1dB2EgyPT8gPMsbmZlD8Brdmpsef4D3oUm8ebIvKBnY-56767cYCNVnH8KO87I388NXjHFLF2QsjFVHnQAww10CEuJOq8nQcYV8AXRUQswFfM9iLBZw2=w840-h472-no" style="width: 50%;" /><p>위 쿼리에서 <code>LIKE</code> 조건절만 해석해보면, <code>_</code>는 하나의 글자를 의미한다. 반면 <code>%</code>는 복수의 글자수를 이야기한다. 따라서 <code>_</code>를 하나만 입력했다면, 앞에 한 글자는 무슨 글자인지 모르겠으나 두번째 글자가 <code>A</code>가 따라오며 뒤의 글자는 어떤 글자든지(글자가 없더라도) 조회하도록 하는 쿼리이다. 그 결과로 ename의 컬럼중 두번째 글자가 <code>A</code>인 ename의 데이터들이 조회된 것이다.</p><p>쿼리성능을 생각하지 않는다면, <code>%</code>를 붙여서 사용하는게 더 많은 글자를 조회할 수 있기에 <code>_</code> 연산자보다는 <code>%</code> 연산자만을 사용하는게 좋은 선택일지도 모르겠으나 <code>_</code> 연산자가 필요한 경우도 있다.</p><p>예를들면, 문자열 속 문자로 조회하는게 아니라 문자열의 수를 통해 조회하고자 할 때이다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">이름이 4글자인 사원의 이름(ename)과 사원번호(empno)를 조회하시오.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, empno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;____&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src=""></p><p><code>_</code> 는 한 글자를 의미하므로 4글자로 이루어진 ename을 조회하기 위해서는 <code>_</code>을 4개를 입력해서 조회할 수 있다.</p><br><p><code>LIKE</code> 연산자는 문자열 뿐만 숫자 조회에서도 사용할 수있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> empno <span class="keyword">LIKE</span> <span class="string">&#x27;%00%&#x27;</span>;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/6NAFKQ-yV9h72B9VKLQi3yuaZPC1SjimLTNDj-htEMLJxbVzi7FV1cVIEjyhEmwQkVgaGQcnBzGtC0oyn5TVxi1C4-mt1m7DhXYueovM1jBe9kBaGuiWjvfgVqGNXw4DYGOYoc77KrxBfzn6W3AkWOgq3oo77dZ5JqVIk2PxZmYiYw9poYhA3av5-l0o4mm25oEARzyxOTfF5hu1Dfysl_ngmDzKCQOzXq23spZzTPOoktq4HL0egZziojZzOfhJBXIXZO4BuRUgoN0QOdQRv2wcXX8si1TS7SN7P7-YVjeTPgP6Wt6L2siri5LR4jFAb5FsqEo90qr6O4OGrvvNhiN6r0kmi5lLU24M-2YQvlWKeXXQ-7Mqwap1V50YMCZDSq25Z3m1_qZj8NpNjylDJHSRnRKo_0xnOyNG2eDrZ98ZDuRhw7qnO4LaRH6RzijTV8c9tQtNPUhAc1_Y62HBLIU13UNu9vueDrkpLUxIwA2vyHNOZqqAufCWoxbTkeFWSHwivPtPoED3J1KBXosvmkrG67acGVW0Xd6UKQc6wm47-rEBhj7UAd8uLlTiyXuv8ouutYEHuGRRQ8AMcQ6jY04-ny-PrKYe1xKfrYmRYtV0nXTqtj-1AgCLXoFVu-iugWymXlt6mpoPoJ6koN8Q_QddsTAlC7Fv5Nc9NkLdmGL6FxaDmVcGw5WwLXab0zd_JQs55wu_DN8mq0Ab2x-scvyjWUT-DwPg2JlYcROsobRd5UXH_iCGaWcU=w798-h412-no" style="width: 50%;" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>main(String[] Args)에 대해 알아보자.</title>
      <link href="2020/04/java-main-args/"/>
      <url>2020/04/java-main-args/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/saamq3sICZFLhrmGP0hmftYS4JsZPwlVZxDo8GfLSvCNQB1adqeWGxU3zJU42bzKenPFv13HYSYV5tQUjuKlSb3P7jJJpkkceCxqK6x_1CKQ4O9205bKavDQHOE8EIIloiNBKOynmW8pcnEfL8FSg59ZNY2mmNwpHNVsxOwBwZdltt8GpsLr4OXsq2n1QwBaahO5eTzuCbnXQycJervvDBEuK1NUB_EinIykcJv2FIj8YnKDS8MigxQto09fg8B9yR6lka0F2yD5dmNZxR-lCR_OnFoEuTQmshIGKf7sN6nHIlXBT_JVVSksKgsVYRkSMmdBaYNkXVUieBGGev-VS2uQ80GFkuHfLJc4KAfOjc5HXxIEXXy88KoFnN1Wzk0qACPfrG27otBEuIAu54LcaoTelhgVPLX6m-GkUdKbBxlrtMror79kZ3F4-yFQKyZUGZsZZPl3rm0zjoKvFZzOZ25H66V1JTxvV4a8wWsz_ti-GFN5KE4waEBdWEsnSvKfiB6bxaRqV44OiRGcdZPIR3GwKKt5Vkb_pBrCNUOoa3vvyMmELmj36o1kqLjTyAQ5Zu96oYFNcRVGWRyvZF7GIudlFjZqZj0XX6Xf8x_xSAqxtbu8FdWd7N2G7NI-nrVdeamgKaVLjsfLTMIVjPF6dPmuYNu76IrxzzWvP8i78QpO1I7LPSdS86x2E_TEaL3RLEGypYyVE5lw4pqY9193vssU7VWZluAi70KkLxotkrFo3IVkyH-eHBSY=w992-h626-no" width="650px" /><p>자바로 그 어떤 프로그램이라도 작성을 하게 되면, 반드시 작성하게 되는 메서드이자 모든 자바 애플리케이션의 시작점인 main(). 항상 입력하면서도 여기에 대해 자세히 알려고 했던적이 있었나 싶다. 한 번 쯤 정리하고 싶어서 이번에 정리하게 되었다.</p><p>우선 main 메서드는 다음과 같은 구조로 구성되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p><code>public</code> - 접근제한자이다. 어디서나 접근가능한 메서드를 의미한다.</p><p><code>static</code> - main 메서드는 그 자체가 애플리케이션이라고 할 수 있을만큼 생명주기가 길기 때문에 당연히 static 키워드를 사용하여 Heap 메모리에 할당해야 한다.</p><p><code>void</code> - 리턴 타입이며, 반환하는 데이터가 없음을 의미한다.</p><p><code>main</code> - 메서드 이름이다.</p><p>여기까지는 이 글을 읽는 사람들이라면 이미 모두 알고 계실 것 같다.</p><p>이 main 메서드에서 파라미터로 받는 (String[] args)에 대해서 잘 모르고 있었는데, 이 파라미터는 <code>&quot;&quot;</code> 로 입력받는 문자들의 집합을 <code>String</code> 이라는 클래스 변수로 정의하겠음을 의미한다고 한다. 그냥 String은 아니고 String[] 인만큼 연속적인 데이터를 입력하면 문자열 배열로 인식하여 데이터를 저장한다고 한다.</p><p>테스트 코드를 작성해보았다. 간단한 코드여서 IDE를 실행하지는 않고 vim 에디터를 사용했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    System.out.println(args.length+<span class="string">&quot;개의 String을 입력하셨습니다.\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;args.length; i++)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;args[&quot;</span>+i+<span class="string">&quot;] : &quot;</span>+args[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>터미널에서 곧바로 실행했다. main.java 파일을 컴파일하고, 실행할 때 입력값을 넣어서 실행해보았다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ javac main.java</span><br><span class="line">$ java main 123 가나다 abc</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/BxmUpLBjEumuPlDP5mh3SWBiTl0izks-sJJWPDIOda_oufUEn7US_8H7wY2HAC9IV9p0OeOrxNPY5VBvzV7Sjrdv2owjDnQZrfqVG4ftkRIANMwoFcxxbAstHHPCl_f-6TV2vUOzrA8ywaPF6PMAyuaVS50eAt4oj-kQfIHK2egOkcr1Lq_SzTLpiLMF4Yk80EFrTcfvg-SKSqdTAcfXYyahTcuvjZtOfT-opCEZYrxSWBoZgcz7XO43whRsW18ZPZaAGHIZc7Mv_aY_GtbINu_5f-qotkHPEkZrKiM3X8ZYIgTv1Z7l8zGMqaS9iMs4C6Z0eJk7hIJj0IdO4-zqGrtrWpcZ-3sPqAb9pTnWxC5uLLje6EPedyNV37uwQYBqrVp82gDYswk9XfC_k5-EfDUmuydnSQXHo-VelYla0j1OPiannGzrJCKaGssl-96Nk6I9-n11d8CtRxvtam26i81B4221cTvslwopcI7uZmYiLOA_W1UHJ_uXoc1dI-MK6Kl-fdyOGsjkGXQJ7GySlCYV_MgJMdYE6iadTqBnWo-WLxu8NxQAItMon98IFTvOR1ODZGHW9hZcw1fTgAPIi1nvevsavxHY02krr0gxtI4F0niNyEwCS-4oCKS5NUKvXtHXcRqNp-rzEXYiVtEbZPh5xOd_WB4hxT87TUa1EJv3ji_1U8Y5jihq1jxQizBuXp_loV-7FkqqKQNQKSpEkiddObeBbP2qyTYwHJWEbphKnQARLdh9Ptj6=w1440-h956-no"></p><p>입력값으로 전달한 문자가 args라는 이름의 문자열 배열로 저장되어 정상적으로 출력된걸 확인할 수 있다.</p><p>출처 : <a href="https://javacpro.tistory.com/11">https://javacpro.tistory.com/11</a> </p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - Sub Query</title>
      <link href="2020/04/oracle-subquery/"/>
      <url>2020/04/oracle-subquery/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/d0ri4fOfnP6N5BPr-Uf9HHlKEUNN19MiAiCNc5qmOrVSo-dCPZj3pscHhOor6KPiYdItQOnD6ybfYxUSM67Qh2mViSEKSis9tg8Z4DkzjOheD3wkAEWabLKBK9Z9UdFgdSVnu9520Z9wkQ7VAK9vaKco-N-54vYq2MFxYAUKHXtIE-rZOysg7UIhNEEFf6Wowxt2TfXR0_eqkk_iBhMNI2nO8gXYkUgSddxYv1AYX1rhMR4VwT1kYdwccjKA7KGmptza15Ozgqp_bOG5imGrMAe8hSnCOkAVO2srUtrHlxsMfbtztJSXIspNiW6Dj7YeUqQJ65k9hK2gXZ13NRUKbJJR_gloAoIh3Ma-sfZtKyxAzggkZVEXn5gK57yBRI_lk4efFmXhDA-P8c02EK6CI_07fgs-yk628iJuQvUAKfyLSVLPbsa11xuQu1Np-Tg5L-7vj3hXiVceAx5Iz23zFci2CN1qAnJDj6qyA2jcK2JvvucJI14O6e12wJdVuCZEV0DJsTJ_sInJA48jVYcloV676EAN7MJJzq3ncl6Yee468mkwrrShqO59jUXV2FptMQHSbMCojxCvuwPbiuoFeFzsw5ZBh7_T-2oZ08v3fnlslpzXm_BnsxWRaXx8HlBADnUZN0K6PiwtlDF29c0Z4muNpawiv108MH4jP2YIsy6_9HmJ7uYjD1ZUdoJxhaTI8hjxVrGlh_TAwW2gOI4_2uPxdKHEkX1wwbQ08twab6MPgVsGvZjmCT4=w1024-h480-no" width="650px" /><p>서브쿼리란 쿼리 속 쿼리를 의미한다. 서브쿼리를 사용한 쿼리는 실행시 서브쿼리를 먼저 실행된다고 한다.</p><p>SQL 퀴즈를 바탕으로 어떻게 사용되는지 알아보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMITH와 같은 부서에 근무중인 사원들의 사원번호(empno), 이름(ename), 급여액(sal), 부서이름(dname)을 가져온다.</span><br></pre></td></tr></table></figure><p>‘SMITH’ 이름을 갖는 사원의 emp 테이블과 이 사람과 같은 부서에 근무중인 사원들에 대한 emp 테이블, 그리고 부서이름을 가져올 dept 테이블이 필요하다. 따라서 <code>FROM</code> 조건으로 emp e1, emp e2, dept d 3개의 테이블을 조회해야 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e2.empno, e2.ename, e2.sal, d.dname</span><br><span class="line"><span class="keyword">FROM</span> emp e1, emp e2, dept d</span><br><span class="line"><span class="keyword">WHERE</span> e2.deptno = d.deptno </span><br><span class="line">    <span class="keyword">AND</span> e1.ename = <span class="string">&#x27;SMITH&#x27;</span></span><br><span class="line">    <span class="keyword">AND</span> e1.deptno = e2.deptno</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> e2.empno <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/v-ck0bDFSj__TcD1pmO0vSaU-C3WmLRpi0_-3DVHQE5XG4W9wKp-qWKzaNcQwV7RwsUSxnwiOAhS-tQVVMZp4hKhiIkKBdYJzIMQaPiC9fJNmPRdzkF-wfs7hfPIDTbqDewW0SK-sMVZiLzhCYR-Wi5qMlTl5hG6e5PnAnSovhN4AJFPtO729vFR4lbqZQli40khA7_xRNFCfZVOJfRHFc9cunY_OUcf2NwdTe1nLAo37utVxiZ7AuR6Ymm9l6ftyP_ZAXXcdWHd2Tj4kbD1WM6fc05XDKBhDNkabpxpGbaQxGOyjmq2N5QADiJ0n7d42PwRxqcz120J72P7kjIadQi0DzVwXJ5VXFFUmfNF7KdtviEhG43V9GbSSe2dwGTA1sUUaD6-Vg2jLITNVssDZ3q88cTKcXFW5EJaz0-hREE-EHFa-MQN6KXXmBwCdR48YhAGg59RgcLNSrspbBxMm9YmI2wCCIrn4wby9eOQguW0xU7rXkHM0DOsFxtWiF5RueURY9qxNGRKBI3-L7s24X8oJ8qTd7lnyOco1eOIhEQ6PXJ4XEIrgQthK_T3wiN7tjOMr_6nw01K1ao-juZBXblywJry2FBkhD6EvL8KshStngZMsWkRqsZGF0U_S4RNZJFB0Rm1xaSO-Km7QgsrJvE92L6isTW-I9RSGvArCynuQKDj6_S63384olUzeONhmiqs2WDw10WK3NFZLyajNYxwW2K9UqKDtvyvb0am2HeDEvrNS_Xl-eE=w920-h722-no" style="width: 70%;" /><p>단순히 Join으로도 해결할 수 있는데, 이 쿼리를 서브쿼리로도 작성할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> emp.empno, emp.ename, emp.sal, dept.dname</span><br><span class="line"><span class="keyword">FROM</span> emp, dept</span><br><span class="line"><span class="keyword">WHERE</span> emp.deptno = dept.deptno </span><br><span class="line">    <span class="keyword">AND</span> dept.deptno = (</span><br><span class="line">        <span class="keyword">SELECT</span> deptno</span><br><span class="line">        <span class="keyword">FROM</span> emp</span><br><span class="line">        <span class="keyword">WHERE</span> ename = <span class="string">&#x27;SMITH&#x27;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> emp.empno <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/bW2C_YnieoKCF51Df0Ke-ku29qmuaxG6nqYui63ABF6lSp9hnzwalr0pYOsF50UfjHjV7mFB29lC4jmcxCdpAYSQINdmruBqNpnuPgp8x6BbWAdlNjv6aCDHxfuwtAlEp-dRuMWwv8QsJYr3tZ7jfFs37ozlqx_L9p947CLwvztodSOYcrnZVXnG_c91fELcf0GhCY4yvbkg8ikJzJZ2Jh4syBmQCw3_6tX_G1pPZCwxLaUOc7vBh6uh-jOxkc78qrBZwQMDexrSn32cyB219a43xhiURUadd2WEtWdZHmuWp9aLEUeeIvXSM3scFw1yuBeSqrUiODhJeMsKrwEEjREe2HIyYw233Xz6KM7US4VdahL-EBFJj-BgQ9CsY1uRRl3zKqlmDoJER3O2TtVCtNyQEpIwvpkaRSZjiRcmeTNGRCvHZcSP90AwRb6g0JvgSqqqcwUkcTKsvh0cpuGL3CoZxE1UV3NFOJg6IC7UjelKSIyVno9rhCQvG90f9hHYk1bBjBhonLTMTLa4B9sl51hrbSlHIMBgFQ1IKcXfeRwGlRVCwmUsluEgTb_9nmaj_L9XusMEwLkPTEc9TztwKfoeDWLk4MEZ6laq1Lhd7I5CR2fGw-cl0ZiVdyYTjo7S9ATTY2U39MW-ZSvEboYbQgmXUHK4ITQRRW5TOP_-yYmlhAsQqmy0irLVwc2FC-TEmy3MnpavzQEKrSfbOOBHnuvjuGacnMEITymnGbNtwwe0mJUX9cpF4PA=w1002-h772-no" style="width: 70%;" /><p>완전히 동일한 결과이다. 코드 직관성은 서브쿼리가 더 나은것도 같지만, 간단한 데이터 조회여서 그런지 Join이 더 작성하기 쉽기도 했다. </p><p>구글에 서브쿼리의 장단점에 대해 검색을 해서 Techwalla라는 웹사이트의 <a href="https://www.techwalla.com/articles/what-are-the-advantages-disadvantages-of-a-join-or-a-subquery">문서</a>를 보니 서브쿼리에 대한 장단점을 다음과 같이 정리했다.</p><blockquote><p>서브 쿼리는 쿼리 구조를 이해하는데 도움이 된다. 단점으로는 테이블을 수정할 수 없고, 동일한 SQL 문에 있는 하위 쿼리 내의 동일한 테이블에서 선택할 수 없다는 것이다. 또한 database optimizer로 인하여 하위 쿼리를 Join보다 실행하는데 시간이 오래 걸릴 수 있다.</p></blockquote><br><p>서브쿼리를 <code>AND</code> 키워드를 이용하여 다중사용도 가능하다. 아래의 퀴즈를 통해 확인해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CHICAGO 지역에 근무중인 사원중 BLAKE가 직속상관인 사원들의</span><br><span class="line">사원번호(empno), 이름(ename), 직무(job)를 가져온다.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno = (</span><br><span class="line"><span class="keyword">SELECT</span> deptno</span><br><span class="line">  <span class="keyword">FROM</span> dept</span><br><span class="line">  <span class="keyword">WHERE</span> loc = <span class="string">&#x27;CHICAGO&#x27;</span></span><br><span class="line">) <span class="keyword">AND</span> mgr = (</span><br><span class="line"><span class="keyword">SELECT</span> empno</span><br><span class="line">  <span class="keyword">FROM</span> emp</span><br><span class="line">  <span class="keyword">WHERE</span> ename = <span class="string">&#x27;BLAKE&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/Td8Z2OR7YCSRBHz-Xf1tUyQNtaDNtmktJJQl4rktPTf5aqKsW8rzzs5uG55fANg5rGq9P0NZyFxzTrBXsmXXHnEfhdZyGajAiWGQWWlN2U9L6HzhhSTH0O5k7sOv2ajrwq8jyt93lyOa7k9PW7QMoBIOwEMf2htEohF3eEHiFP8UyHugyvWg15vveBB70A12c2dVdi8_IdWaaoLzdsRQ5NsxjdMhcPddYliG5cbjBI6RwNsqmL0uCRilAfdxnBoHU1H34ULDdGBFh4J7v2QaLDTAJfLqdtXp4zTlUfC2xjAfnoSPJAVap6P3OloXCqAxSUORYy-Umbhjd8d91XPMhKzjCutOM41-yvXCztAbcdyP-Zh8_DnMzye5GWDblTd-odvf-ywwOMng0iceVEv-cG6BiZFu1VqQmWpkEuafSEozOGZFTgGJLuWlnsKfeIqHMM9_LHvvTbXfu4iHqSJfYcGVbdqyoex1O0BFdAFybrcRMsaLIM4a60MPTTuRPu-G-gATn8FXAgGc5AdFvC01RPPOiYEjJIkldvyzhoSMn95m0Fxb-oGxZ3uZmYVXyk9nGBckVN0P5-FOvxEjnsvKg135AFOi2KyP8fADHv7dGlLaXOn9DLGyADzZGKA9TPTpzblbMbKs8lYRvzHpdzWzgGBRAIjmFxujaNHuSTPFFur-tVCqz8xSW3BxGFsWwCxFYPxkSXlLHZK5AVOQrC9wNlW329liR3hjOSxE3souLEeeUghcX3WNlwQ=w996-h902-no" style="width: 70%;" /><br><p>지금까지는 서브쿼리에 대한 결과, 데이터 컬럼이 하나일 때만에 해당했다. 그러나 서브쿼리에 대한 결과 데이터 컬럼이 2개 이상 조회된다면 어떨까? 아래의 퀴즈를 풀어보자</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3000 이상의 급여를 받는 사원들과 같은 부서에 근무하고 있는</span><br><span class="line">사원의 사원번호(empno), 이름(ename), 급여(sal)를 가져온다.</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, sal</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno = (</span><br><span class="line">    <span class="keyword">SELECT</span> deptno</span><br><span class="line">    <span class="keyword">FROM</span> emp</span><br><span class="line">    <span class="keyword">WHERE</span> sal &gt;= <span class="number">3000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>3천 이상의 급여를 받는 사원</strong> 과 같은 부서(deptno)를 갖는 <strong>사원 테이블</strong>을 조회하는 쿼리이다. 따라서 3천 이상의 급여를 받는 사원 테이블을 서브쿼리로 조회했고, 이 때 출력되는 결과를 deptno로 가져와서 이걸 <code>where</code> 조건절에 삽입했다. 그러나 결과는..?</p><img src="https://lh3.googleusercontent.com/cSIDtLGwax9oM6mCSxsd4TLFVw51-gaSFN-HMM9eq9WSHpYJoax40rpQrg68EHNFU4DYUPdcDeLFLh1DP-3-rFXUNDxvlvqcUw6RY1YCusvGgVEDQ9E0r45cPlp0MM6u6f-xHh-jSawoyLA1sZQOVVPZ4fHXI9CWfAT9-Xjyk2Ij4-weZm6XfwQsm_MxXRPVBnhK5BvsDu6O5FtD51MCSIFsE1Zi8ciiIsZDZz3-r0R8jXaUeGFHNgjRBoRoKV9qwaPTs45EfJEXublkamlSnun55m1-73uZ_BV4BYexAHgCXDlT2p2U-fogNIJ1Y302F-gRFM-_9oYHW0LA0mB7FZgvwdoX19cos3g9k_zPQefvYVrw_InF7QFnWa9BMtqsBaGeDgRtS5a6ZM8hEMReO0FWvveYSHT8lAcvGCgHXM6n05WeXS8gkbY5SRooqkQnGOMk4dJdsXzFJ1JNkH8gzUUL5-eOn8StJ4hshLAoIJluEK5LDM8ngQ2VcUmJTN7ZNX9NKxtA5CM1Pbn_BoYAGQWBjjzF4qVZnWexPDBqGvucTZ6cFKziyZCFPAX-AwpB66k4klnZ0mfo361eoDxLBmXukssThNKaQzmfTZE6W2TzQtzfkmzfGdAvz17cGnIY0B8S-XZrxRfbPZMccws8lOPZemz48JGimwNXv3rkB4t25yaK-kkILMFT0pxuiaT-ziY1qUdIwQkN7JxyiHEaIuXUbQoFxqr-UnmE4I5gJnp7tDNZoJHYUVg=w1002-h658-no" style="width: 70%;" /><p>에러 메세지를 확인해보면, “single-row subquery returns more than one row” 라며, 한 줄 이상의 데이터가 반환되어 에러가 발생함을 알 수 있다. where 조건절에선 deptno가 하나의 row만 검증하도록 쿼리를 작성했는데, 서브쿼리를 통해 반환되는 row는 2개 이상이었기 때문이다.</p><img src="https://lh3.googleusercontent.com/uIiZz4Y1ElAJbuJDjql7dbERlYJ0ohMV8EDU0BZwiYSjuiRnTjfgVrJnWOGDFh7vKEy7zct6PUkePyfGMdZIAxCriSC5B5oOvcthORot6HDVqK_GKBJFrrepIrsqxGcq9AkxYnhPnKBkarNACwKrysYakosbkNT23Kt0b15mr6AdmVDg5Sc76Je-rvzLB32JfnPMFTkROT4d5Go90lnfi7QOVyMoKOIi8qG0Uz9O9WQAm2-eXLokYGeg70-36pNqTRNZg0oy6yeIsdRHuJowsFTZiFsZ5guWj7ctfWHf6dbGIgRerne3oEHpOfIH3NuaYqWLkEp1Kb41eELZ-WvyzsX7ARrvG1utuzl2Fx2YPFWLSUK-uqppEyJ1ovSsW_3zrRJ7pFZClN6yIUw3nTc64QLRCOm39MtyjdQ_6HpljzNfeRcsrxSEaWgp6xUmTuBMpqOb4NQm9LjYMqjajMBPv7I-G0QS3tNDeM2EWG_g99E4rtb8mkmRWOznqFL_u0dIqqpOHsZscDbkWzupt_8Jp7Wcm8QojaAllwdv07YK2aa8xWap1lbrP4p-RUGlSNfbmzLnE7ovhaVC_U0_rEuqaVR_0sIyRrUsLU8vvgIgEzSmzhMwHzsd5lv0-0rEt_MgL5uNBGEcjmkjWsVCpQNmUaQHQz04wVVk0bOpUgLZR49YDxmNAtizJxKnIhSUqZEhy9_PFjf3tuMCgX9TVlkHchB39SwaJwJ0ELxvQho813r7uXR-V1kxT4g=w796-h526-no" style="zoom:60%;" /><p>확인해보니까 정말 서브쿼리에서 반환되는 데이터가 3개였다. 이 중 어떤 row를 deptno와 비교할지 오라클 데이터베이스가 인식하지 못해서 발생한 에러였던 것이다. </p><p>이럴 때는 다음과 같이 <code>in</code> 키워드를 사용하여 서브쿼리에 대한 조건을 충족하는 데이터라면 모두 검증하도록 할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, sal</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> deptno</span><br><span class="line">    <span class="keyword">FROM</span> emp</span><br><span class="line">    <span class="keyword">WHERE</span> sal &gt;= <span class="number">3000</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/jRmZRaZGsPO7CeQiIkA1VGfSIC2b18jPMctUWkZmc1C3bMNea0Y1pDF2Boc4BmDkPtJAqedHjqNedU4QZ5mLR2A-yEfv2olwzpuWwTzw7DFGF1owPEJPmF45r0u2s2nDtP2XntUAHTRx9IyeWlLSltECVFD636Jq3QYW1dSAqNG22hR4qQwV2fi9igSQ6P8qJMsyOQD1xnezsN5vKx69rZDO7yR31dlupKFVcCjHk881BnWA2DcLsLMKNJ9QvgPuQPzx5Y-WbD12G5qx31iij8-_zxmXL2MGCrz8FauuDmiNLo6Q9C74a5-a_fKrwUwlw17MzXUPJcn1LJvDJDk_QqbXGEvAWy0qCRMjGjVDeNiwfuBfDmfapH3vNiAnWcAH0pmVNvMGJlEWfUq9Pu0y2WmNN7uMmliHgZIhf14Pm3Iyi4PNHcthrIG0gQpJ-tt0xwi7QVQvsBP5jHyJuHGYYodqdeCoSq97wCugthUQpGX4CW2BfycP82CSV-ZLUYIK3c5vhAQkkRsFD8M2IoCH8ct6VTNiMZQ7yTpYVpnc_a8LfzPNQo6xjN4TeXakrOQHC5MPOIWH1Me879968cGyKoyxKo2tU-VzmOZRfTWkfmyRcxVAjr_I1OfVNv5se0-dO4rhmnEsaACDuVUT59OD4cp30pCVonG6vHe3GwtP-68HP0icJRW9RueTbR7SUm4pvjFo3FAbA0ol79ErcljWwDwzAMQjOLEaSXudM-7DJVtR2_io0FduTQU=w934-h906-no" style="width: 70%;" /><p>정상적으로 잘 출력된 걸 확인할 수 있다!</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>객체를 직접 호출하는 것과 인스턴스를 호출하는것의 차이 (메모리 주소값 비교)</title>
      <link href="2020/04/java-object-instance/"/>
      <url>2020/04/java-object-instance/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1573307838698-8aad85a83a33?ixlib=rb-1.2.1&auto=format&fit=crop&w=1266&q=80" width="650px" /><p>객체지향에 대해서 정확히 이해하고 있지 못한것 같아서 인프런에서 <a href="https://www.inflearn.com/course/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9E%85%EB%AC%B8/dashboard">객체지향 프로그래밍 입문</a>와 생활코딩에서 <a href="https://www.youtube.com/playlist?list=PLuHgQVnccGMAb-e41kXPSIpmoz1RvHyN4">JAVA 객체지향 프로그래밍</a> 수업을 정주행하다가 정리한다. 10분 짜리 영상을 정말 거의 10번 가까이 재생하면서 계속 이해하려고 노력했고, 그러고나서도 다시 포스팅하려고 하니까 더 긴 시간이 걸렸다. 하지만 이렇게 정리하고 나니까 조금 뿌듯하다 :)</p><p>그동안은 외부 클래스의 메서드를 사용하기 위하여 항상 인스턴스를 생성했었는데, 메서드가 static으로 선언되어 있다면, 인스턴스 생성없이도 해당 객체를 직접 호출해서 사용할 수 있었다. 사실 작성하고 나니 당연한 것이었는데, 그동안 별 생각없이 인스턴스만 생성해서 사용했던것 같다. </p><p>두 개의 클래스 파일을 생성해보았다. 하나는 객체를 담았고, 하나는 콘솔로 출력하기 위한 클래스이다.</p><p><strong>exam.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exam</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String classVar = <span class="string">&quot;class 변수&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String instanceVar = <span class="string">&quot;instance 변수&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>classVar는 <code>static</code>으로 선언한 변수이고, instanceVar는 키워드 없이 생성한 변수이다.</p><p><strong>Main.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 인스턴스 생성</span></span><br><span class="line">        exam ex1 = <span class="keyword">new</span> exam();</span><br><span class="line">        exam ex2 = <span class="keyword">new</span> exam();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;ex1.instanceVar : &quot;</span>+ex1.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;ex2.instanceVar : &quot;</span>+ex2.instanceVar);</span><br><span class="line">      </span><br><span class="line">        ex1.instanceVar = <span class="string">&quot; changed by instance&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;ex1.instanceVar : &quot;</span>+ex1.instanceVar);</span><br><span class="line">        System.out.println(<span class="string">&quot;ex2.instanceVar : &quot;</span>+ex2.instanceVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>exam 클래스로부터 두개의 인스턴스를 생성했고, 그 중 ex1 인스턴스의 변수만 값을 변경해보았다. 출력 결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력 결과</span><br><span class="line">ex1.instanceVar : instance 변수</span><br><span class="line">ex2.instanceVar : instance 변수</span><br><span class="line">ex1.instanceVar : changed by instance</span><br><span class="line">ex2.instanceVar : instance 변수</span><br></pre></td></tr></table></figure><p><code>ex1.instanceVar</code> 값을 변경하고, ex1과 ex2의 instanceVar을 각각 출력해봤더니 ex1에만 변경된 값이 적용된걸 알 수 있다. </p><p>이를 통해 인스턴스를 생성하면 같은 객체로부터 생성되었다하더라도 바라보는 주소값이 다르다는 걸 알 수 있다. 실제로 확인해보면 다음과 같다.</p><p><img src="https://lh3.googleusercontent.com/VhBDNt2yuwJ2mAFCl9TZWBfLBkKRBO3y6FtpmibNJXNws4QPZLGU8binIk7PvtA9V9Bs0gfDda6jIu8W6gWhGpr-gJxhGPBQqvTKRNPGrCJKve6Lb0Jnro2S87H1389ZS_vVM0EwgDslk1RgfTjkWm6hnRBHh2HEBnXZubgvL3kRX6bzOubhwKEIR2e729NurB8Cq5m6AfDsGCIqYcpOh_lGm47OwCZae7UU61DvBBQHbqub1LcdIXmc8KzyPImuqamFJzOi_9YVS9124Uf_LUwYWOt5UkcvIUt5MOqHZqj15Bl615lu6DylI_-sddBV-LXOmTtoC2rwu5WkJzI3--4nu6ONLagzsXSukIJ5PjN_jiwauKcdqNGWrySTX9hD2Drx2X-nqK9FFqTmDdTnP_VvdT8g7jJWWRqOZ-wTkO6fqxW_1tQEyOssu-Mi2bsyIaJL2edQUImSt7_ursefoDUG3wHQY_tEDYeGvjugs1zGUpgj318XKrxFhjxxjDbi-c3-GXq3oi46SUBl-7DfEys2sX9b9h5gAWye9_MA25lSZhtuJjDDxTLy3BUqM7sWWrOx6LZfRciMlIlqkYOCaQfLZz-KaJR-NiS0U5Ka9VjkhNs9tEK3zaDbpwxUhv9kbOvw-7_aQjTWhKQoptSh8E-cPeEkd606-190P4lzcaB3NPPFZUnsm3v9l5Nomz1ThTH_PvVW3pHPwWStQKfN5H8UAm_2QkumW31XD6K943OYrfwpvQ7Fw5Ra=w1812-h560-no"></p><p><code>System.identityHashCode()</code>는 OS(System)에서 가지는 주소값을 보여준다. 두 객체는 서로 다른 주소값을 참조하고 있기 때문에 ex1 인스턴스의 값을 변경하더라도 독립적으로 값을 유지할 수 있었다.</p><p>관련 내용 참조 : <a href="https://datamod.tistory.com/57">https://datamod.tistory.com/57</a></p><br><p>이번엔 객체를 그대로 호출해서 사용해보았다. 아까 작성한 exam 클래스에서 static으로 선언한 변수를 호출해보겠다.</p><p><strong>exam.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exam</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> String classVar = <span class="string">&quot;class 변수&quot;</span>;</span><br><span class="line">   <span class="keyword">public</span> String instanceVar = <span class="string">&quot;instance 변수&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>main.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 인스턴스 생성</span></span><br><span class="line">      exam ex1 = <span class="keyword">new</span> exam();</span><br><span class="line">      exam ex2 = <span class="keyword">new</span> exam();</span><br><span class="line">      </span><br><span class="line">      System.out.println(<span class="string">&quot;ex.classVar : &quot;</span>+ex1.classVar);</span><br><span class="line">      System.out.println(<span class="string">&quot;ex.classVar : &quot;</span>+ex2.classVar);</span><br><span class="line"></span><br><span class="line">      ex1.classVar = <span class="string">&quot; changed by class&quot;</span>;</span><br><span class="line">      System.out.println(<span class="string">&quot;ex.classVar : &quot;</span>+ex1.classVar);</span><br><span class="line">      System.out.println(<span class="string">&quot;ex.classVar : &quot;</span>+ex2.classVar);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력 결과</span><br><span class="line">ex1.classVar : class 변수</span><br><span class="line">ex2.classVar : class 변수</span><br><span class="line">ex1.classVar :  changed by class</span><br><span class="line">ex2.classVar :  changed by class</span><br></pre></td></tr></table></figure><p>이번엔 다른 결과가 출력되었다. <code>ex1.classVar</code>의 값만 바꿨을 뿐인데, ex2의 값도 바뀐걸 알 수 있다. 왜 그럴까?</p><p>마찬가지로 이번에도 <code>System.identityHashCode()</code>를 사용하여 각각 인스턴스들이 어떤 주소값을 참조중인지 확인해보았다.</p><p><img src="https://lh3.googleusercontent.com/CY4-c64Dasyhpm7-aPMlJkcM1vVDj7PVs0aVFi5ivHfGyyt2WM1wphDuIdo6oi06sXm4oy2R2sV6R1U1ayHDo8OEVIehYs9_fEO3XB5twdSAMTfz7I-hIkYtkSR-S0CLoh32Pb2X9LUXGV2iqc1zzkF_obg09qq-FXqucYw83FzxBbcFFUxzY7sFNGucNPbdANEzJQIVAvo9_FhXeq-oEsJwnkkTF2kzncsy7YtlH6hB5FM_Ryu-f0sWvkz-21lyHAnag5W3fu7MGXYSWpNNYNJGMDDfC6h_ov5YCXQtYT0fDg9qIKWMkePyveyxxOKfMVf0qJIOVGsP69rLd3toomhVEg_bDvPkg9wD6rjSqQcGH3rxjwL1KY7pTElhZi9xfKuIhIalsiXRkqat1xwJssjZMN9fBM8atXiOqfTAqOIIfTGgt-ojDygDERHExnm_0L3HCIt_O5W1GlhVwlHQ7bzAaLwHZKdpMCcjPBvdFgQYK5nG-ca08EBsnmz1MXqiduhGV7iKjwbLp0DSwmLTb1qcB8TJ3WJT4p5vWFJNtZEf4fEZt0FB2aWa3ulzus5zeGX2tqHw-K68N58G8v8cqrRMiQgAdPTCCwruc9GhuAtJBQB3X_hAxx8Oz9AaWnlBfiNwvRH79QtJ5B81XTCQec_cJ665lKdF8Ec29MPDJ9wsC9lQ1tCSJvaPJ-_F5a68Wa2P3kcl4mUJ5WJyeFnscxzZGc2OcaK7PLUEKazwOYYU94D7IPEKzBT5=w1820-h612-no"></p><p>모든 인스턴스 값이 참조하고 있는 주소가 같은 주소를 참조하고 있는걸 확인할 수 있다. 따라서 하나 인스턴스만 바꾸더라도 모든 인스턴스에서 값이 변경되는걸 알 수 있다.</p><br><p>static 변수을 가져와서 사용하는것과 인스턴스를 사용하는 것의 차이는 다음 그림으로 설명할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/zCGEjOCWmhOBv8g1TS3QewtLzoRqT69lUd0Nmy7XQqFy4nr5hE8AwJ7MviASmGzHy3OR1EjxK0FcVlrqQe-enRRQR24cC7rRvehqJTAs49q4ka1AqxqpEgiGB4-fSMIU0jLlKSXeMK6eRbAdejI_831WMVDqvdtakaV1nvHIgxQHEo2sOLIK8YgGQo3LLPNxhYI9QYUpjhJUTMuW4uHwd8l98csjVOKS6z1yNeP8k6VmVjbqGlYz1k8xPyKYhfllFwsLp7yNvREdwoUgzJeUMvC-QatLfr2vpjXsNcD5CHSniCxARr9rs5XX8xZ7hABWc1mEHRmhRCfSq_O7zG2nBtJ5iQikO5FAS7nf7ZkIW8YfhDkiIeXdsPetM8sBDlmQghxoqewKLFZZFhe6KhaBfFcaepH9PgjbMCrJ7vEXaNFhBAwMgbW2NWnjml1O6V6vCYwArrLGzGlEllFpbPIHNb2_zfcm_iFCCc7ohDL17A6ZdSKX0xTqh-890_EWpZ2HMj3Q0l7XCg71u5Gs74kAGRX01kh-tGpKVSb4uPO6X4b7KjyewQZajNVuKKIVBqwPDTBLA8eML43FdMUuILpB5EvL3-gnna7G_TGFNCnQN0Bl1uexXSOgmUF9QiwGdB_e5MGS59eFCOeMowswx3Hfthg_x5TwjmJHEchvY2uFLYSc19_XgDiUNbcOx-wd8yq-DLLfl-JTdVSe4Nee5LRGy7KamWK324xnovEK_71tj9X8wy_pLY1heeWh=w1024-h340-no"></p><p>인스턴스를 생성해서 사용하면 사용하면 인스턴스마다 새로운 주소값을 참조하게 되기 때문에 값을 변경(=주소값 변경)하더라도 다른 인스턴스에 영향을 주지 않는다.</p><p><img src="https://lh3.googleusercontent.com/pw/ACtC-3cotST5KpyGdXIUogASHnfmjdh40deZ7R3Q8hfXDT8CGGkPo_JwVuzsVFSOpddsRppwHlRziD9JbirTBftodeLOYdS-bvPHjyu2ekCTIuxVc_1-XswZAnIe0Y1Btsr6ad5vhfaSktwHJwvUgueUfDQqxw=w721-h240-no?authuser=0"></p><p>반면 static 변수를 사용할 경우에는 같은 주소값을 서로 참조하고 있으므로 값이 바뀌면(주소값 변경), 당연히 사용하는 모든 인스턴스의 값도 변경되는 것이다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>메모리 구조</title>
      <link href="2020/04/java-memory/"/>
      <url>2020/04/java-memory/</url>
      
        <content type="html"><![CDATA[<img src="https://www.baeldung.com/wp-content/uploads/2018/07/Stack-Memory-vs-Heap-Space-in-Java.jpg" width="650px" alt="출처 : baeldung"/><p>메모리는  <strong>Method Area - Call Stack - Heap</strong> 영역으로 구분된다. 각각의 영역이 어떤 역할을 수행하는지 알아보자.</p><ul><li><p><strong>Method Area</strong></p><ul><li>클래스 파일의 바이트 코드가 할당되는 영역이다. class 파일의 자바 애플리케이션 코드가 JVM에 의해 기계어로 변환되어 실행이 되는데, 이 때 변환된 기계어가 바이트 코드이다.</li><li><code>static</code> 으로 선언된 클래스가 여기에 할당된다.</li></ul></li><li><p><strong>Call Stack</strong> </p><ul><li>지역 변수와 매개변수가 <strong>임시로 할당</strong>되는 영역이다.</li><li>메서드가 호출되면, 수행에 필요한만큼의 메모리를 스택에 할당</li><li>메서드가 수행을 마치고 나면 사용했던 메모리를 반환, 스택에서 제거한다.<br>아까 지역변수와 매개변수가 <strong>임시로 할당</strong>된다고 이야기한 이유가 여기에 있다. 변수들을 호출하는 메서드가 사용되고 나면 해당 메서드의 모든 변수를 삭제하기 때문이다. 불필요한 메모리를 삭제하는 GC(Garbage Collector)가 작동되는 것으로 보인다.</li><li>호출 스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이며, 바로 아래에 있는 메서드가 현재의 메서드를 호출한 메서드이다. 일반적으로 <code>main()</code>가 실행되면서 애플리케이션이 실행되므로 가장 먼저 호출된 <code>main()</code> 이 Call Stack의 가장 아래에 위치하게 되며, 이 <code>main()</code>이 호출하는 메서드들이 <u>선입후출</u> 방식으로 Call Stack에 쌓이게 된다.</li><li>**가장 나중에 실행된 메서드가 가장 먼저 종료하고, 가장 먼저 실행한 메서드가 가장 마지막으로 종료 (선입후출)**하여 자료구조에서는 이런 구조를 **스택(Stack)**이라 이야기한다.</li></ul></li><li><p><strong>Heap</strong></p><ul><li>프로그램이 실행되면서 생성되는 <strong>모든 인스턴스가 할당되는 공간</strong>이다.</li><li><code>new</code> 키워드로 생성된 인스턴스 변수들이 할당되는 곳이라고 이해하면 된다. </li><li>Heap 메모리는 메서드 호출이 끝나도 인스턴스들이 계속 유지되는데, 그러다 참조하는 주소를 잃게되면 GC에 의해 지워지면서 Heap 메모리에서도 제거된다. 사용이 끝나도 계속 유지되는 Method Area와 다른 특징이다. <strong>Method Area에 할당하는 키워드는 <code>static</code>, Heap에 할당하는 키워드는 <code>new</code> 라는게 직관적으로 이해가 될 것 같다.</strong></li></ul></li></ul><br><h3 id="정리하면"><a href="#정리하면" class="headerlink" title="정리하면,"></a>정리하면,</h3><p>컴파일되어 생성된 클래스 파일을 JVM이 실행하면 클래스 파일을 분석하여 <code>static</code> 키워드의 클래스 정보만을  JVM의 메모리 영역 중 Method Area에 저장한다. Method Area는 고정적(static)이므로 프로그램 종료시까지 언제든 사용가능하다.<br></p><p>Call Stack에서는 <code>main()</code> 부터 실행하여 <code>main()</code>에서 실행한 다른 메서드를 호출한다. <br></p><p>이 과정에서 생성되는 인스턴스는 Heap 메모리에 저장되고, 인스턴스라는 이름과 Heap 이라는 단어처럼 <mark>Heap 메모리에 저장된 인스턴스는 호출될 때에만 사용되고, 사용이 끝나면 바로 소멸되는 동적인(dynamic) 특징이 있다. 이는 정적인(static) Method Area와 대비되는 특징</mark>이다.</p><br><p>그럼 언제 인스턴스를 사용해야 하는걸까? </p><h2 id="정적할당-vs-동적할당"><a href="#정적할당-vs-동적할당" class="headerlink" title="정적할당 vs 동적할당"></a>정적할당 vs 동적할당</h2><p><strong>인스턴스의 공통적인 데이터 또는 자주 사용해야하는 데이터의 경우는 고정적(static)일 필요</strong>가 있다. 이런 데이터는 <code>static</code> 키워드를 선언하여 Method Area에 한 번 할당해두면, 필요할 때마다 참조만 해서 사용할 수 있다. 메모리 관리에 효율적이다.</p><p>그러나 Method Area에 할당되면 프로그램 종료시까지 메모리를 사용한다는 특징이 있다. 따라서 프로그램 종료시까지 지속적으로 필요한 데이터가 아닌 <strong>잠깐만 필요하거나 각 객체 별로 서로 다른 값을 저장</strong>하고 있어야 할 경우에는 <strong>Heap 메모리에 임시적으로 인스턴스를 생성</strong>하는 방법이 메모리 관리에 효율적이다. <strong>Heap 메모리는 Method Area와 달리 사용 후 즉시 폐기</strong>된다. </p><br><p><strong>One more thing.</strong></p><p>Heap 영역에서 참조타입 변수인 객체나 배열을 <code>Null</code> 값으로 받으면, <code>NullPointException</code>이라는 예외가 떠서 사용할 수가 없다. 이 때엔 초기값을 넣어서 <code>Null</code>값을 없애야 한다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datastructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA - 내부클래스(innerClass또는 nestedClass)</title>
      <link href="2020/04/java-nestedClass/"/>
      <url>2020/04/java-nestedClass/</url>
      
        <content type="html"><![CDATA[<img src="" width="650px" /><img src="https://images.unsplash.com/photo-1517148815978-75f6acaaf32c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80" width="650px" /><p>클래스 안에 클래스, 즉 내부 클래스를 생성할 수 있다. 중첩되는 객체이므로 nested class라고도 하고, 그냥 inner class라고도 하는 것 같다. 내부 클래스는 크게 4가지로 분류된다. 일반 내부 클래스, 내부 static 클래스, 내부 지역 중첩 클래스, 익명 중첩 클래스가 있다.</p><ul><li><a href="#1">일반 내부 클래스</a></li><li><a href="#2">내부 static 클래스</a></li><li><a href="#3">내부 지역 중첩 클래스</a></li><li><a href="#4">익명 중첩 클래스</a></li></ul><br><h2 id="일반-내부-클래스"><a href="#일반-내부-클래스" class="headerlink" title="일반 내부 클래스"></a><a name="1"></a>일반 내부 클래스</h2><p>클래스 안에 생성되는 또 다른 클래스를 의미한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> innerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerExam1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Cal</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         value++;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      InnerExam1 ex = <span class="keyword">new</span> InnerExam1();</span><br><span class="line">      InnerExam1.Cal cal = ex.<span class="function">new <span class="title">Cal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">      cal.plus();</span><br><span class="line">      System.out.println(cal.value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main메서드에서 사용하려면 우선 외부 클래스에 대한 인스턴스를 생성하고, 내부 클래스에 대한 인스턴스를 생성해서 사용해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnerExam1 ex = <span class="keyword">new</span> InnerExam1();</span><br><span class="line">InnerExam1.Cal cal = ex.<span class="function">new <span class="title">Cal</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><h2 id="내부-static-클래스"><a href="#내부-static-클래스" class="headerlink" title="내부 static 클래스"></a><a name="2"></a>내부 static 클래스</h2><p>클래스 안에서 static 키워드로 생성되는 클래스</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> innerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerExam2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cal</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         value=value+<span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      InnerExam2.Cal cal = <span class="keyword">new</span> InnerExam2.Cal();</span><br><span class="line"></span><br><span class="line">      cal.plus();</span><br><span class="line">      System.out.println(cal.value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static 키워드로 내부 클래스를 생성했으므로 외부 클래스에 대한 인스턴스를 생성할 필요없이 바로 내부 클래스에 해당하는 인스턴스를 생성해서 사용할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InnerExam2.Cal cal = <span class="keyword">new</span> InnerExam2.Cal();</span><br></pre></td></tr></table></figure><br><h2 id="내부-지역-중첩-클래스"><a href="#내부-지역-중첩-클래스" class="headerlink" title="내부 지역 중첩 클래스"></a><a name="3"></a>내부 지역 중첩 클래스</h2><p>메서드 안에 생성되는 클래스</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> innerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerExam3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="class"><span class="keyword">class</span> <span class="title">Cal</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">plus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            value++;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      Cal cal = <span class="keyword">new</span> Cal();</span><br><span class="line">      cal.plus();</span><br><span class="line">      System.out.println(cal.value);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      InnerExam3 ex = <span class="keyword">new</span> InnerExam3();</span><br><span class="line">      ex.exec();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 실행결과</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>처음에 좀 이해하기 어렵고 난해하다고 생각했다. 왜 난해하다고 생각했냐면, main 메서드에서 인스턴스를 생성할 때 일반적인 내부 클래스(nested class)를 생성하듯이 <code>InnerExam3.Cal cal = ex.new Cal();</code> 로 생성이 가능하다고 생각했기 때문이다.</p><p><img src="https://lh3.googleusercontent.com/Wzyg_HwBsGJrVJx-fQpBJgwn8Sl9oEyGT80gS0TGdkkmFz_82EyZM_IGVa1PdGkyi916sjqX3TQmDbhTC00Rt2MUV9iuIeyAjHYVTqxVZzRTS_FnyuECDKVsfSQ4ZW-0PnD5OrFvj4iapRwVKSKvNjXcKpfGmEvRbXhfG7K_1AEhV2f5y1RleE0LexZ-goOR8bM0YPWVx9U6AwGoDuFtxKR9QiYgEZOkW4WZuEEwY2PteGPNEWqyPBOrtHZaNyNS67Ja1sbIuvRrkqD8o1mLY4oshst-jn_4z8uFIMEy0oGuxm6HMF7O3hWH3_o69uhPM5I7FQYzz_YBaxVJjTZlF2DhQxrxOGqk8Ncls5Dxb96cc0c7PDT0iMgvduB43XnbfBy-oLOyyeOiOvjYlWaV5t4MOXfHcbEqrusSlV3dEAj71tg4GNAgpSbQCeElMwkvYPWLvqS-bstni7pEWi8nFRJDCWPVKHWwR_IBV68BpSLp7kQ-6E3Q10Gu9W3Wg3jFnuKmMzHkw1lXyFPraaal01Fiemd0DFM8L1g8l1WC2YPEnVXJQUJFDhu09mT6tofq6zVtxrHmX_nroDudIDRogE-tpzDqwbLgdwJ-fWdaAUON5VEnnR0GXouVP_PPxl3HLuJrsC26MjUAapkb0XBSClYyBFR56PwfiolBH-IfipYCfwHd1Uq_P7z7sQGTBvN84N0bAu94E782RYhOd6M_2WQzI18ou2dB9My5OLiVDvGQyzX-QbdaYaCp=w956-h698-no"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InnerExam3.Cal cannot be resolved to a type</span><br><span class="line">Cannot allocate the member type InnerExam3.Cal using its compound name when qualified by an enclosing instance. The member type name is resolved relatively to the qualifying instance type</span><br></pre></td></tr></table></figure><p>에러 메세지를 <a href="https://papago.naver.com/?sk=auto&tk=ko&hn=0&st=Cannot%20allocate%20the%20member%20type%20InnerExam3.Cal%20using%20its%20compound%20name%20when%20qualified%20by%20an%20enclosing%20instance.%20The%20member%20type%20name%20is%20resolved%20relatively%20to%20the%20qualifying%20instance%20type">해석</a>해보면, 인스턴스를 InnerExam3.Cal 객체 타입을 사용할 수 없다고 하는 내용이다. 다시 보니 내부 지역 중첩 클래스는 클래스 안에 클래스인건 맞으나, 메서드 안에서 선언된 내장 객체이므로 main 메서드와 동일한 클래스에 있었기 때문에 두번 인스턴스를 생성할 필요가 없던 것이다.<br><em><span style="color: gray;">(쓰면서도 말이 이해하기 좀 난해한것 같지만…)</span></em></p><p>따라서 그냥 <strong>외부 클래스에 대한 인스턴스 하나만 생성해서 내부 메서드를 실행함으로써 중첩 클래스를 사용할 수 있었다.</strong></p><br><h2 id="익명클래스"><a href="#익명클래스" class="headerlink" title="익명클래스"></a><a name="4"></a>익명클래스</h2><p>말그대로 이름이 없는 클래스이다. 상속받는 클래스를 굳이 만들 필요가 없을 때 사용한다고 한다. 예제 코드를 통해 알아보자.</p><p>Action이라는 이름의 추상클래스와 이 Action을 상속받는 MyAction 클래스가 있다고 가정하자. </p><p><strong>Action.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nestedClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MyAction.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nestedClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAction</span> <span class="keyword">extends</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이를 실행하는 클래스 ActionExam이다.</p><p><strong>ActionExam.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> nestedClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Action action = <span class="keyword">new</span> MyAction();</span><br><span class="line">      action.exec();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 실행결과</span><br><span class="line">exec</span><br></pre></td></tr></table></figure><p>여기서 MyAction 클래스는 한 번만 쓰이고 다른 어디에서도 사용되지 않는 클래스라고 가정해보자. 이 경우라면, 굳이 MyAction을 생성하기보다는 그냥 ActionExam에서 익명클래스를 선언해서 사용할 수 있다.</p><p><strong>ActionExam.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> innerClass;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//   Action action = new MyAction();</span></span><br><span class="line">   <span class="comment">//   action.exec();</span></span><br><span class="line"></span><br><span class="line">      Action action = <span class="keyword">new</span> Action() &#123;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;exec&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      action.exec();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 하면, Action클래스를 상속받는 하위 클래스(MyAction.class)를 생성하지 않아도 main 함수 내에서 익명클래스를 생성해서 사용할 수 있다.</p><p>그러나 솔직히 익명클래스를 사용하는 것보다는 한번 밖에 사용되지 않는다 하더라도 main 함수는 실행하는 코드만 남겨두고, 하위 클래스를 만들어서 사용하는게 객체지향적인 의미에서 더 낫지 않나 생각이 든다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
            <tag> inner class </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>인텔리J에서 Gradle 프로젝트 인식안될때</title>
      <link href="2020/04/intellij-reimport-gradle/"/>
      <url>2020/04/intellij-reimport-gradle/</url>
      
        <content type="html"><![CDATA[<img src="" width="650px" /><img src="https://d3nmt5vlzunoa1.cloudfront.net/idea/files/2019/11/blog@2x-3.png" width="650px" /><p>인텔리J로 gradle 프로젝트를 진행하려는데, 자꾸 같은 에러가 발생했다. 분명 gradle 설정(build.gradle)에서 jpa 관련 dependency를 주석처리하고, 웹서버 실행을 했는데 아래의 에러 메세지를 출력하며 웹 서버 실행을 중단하는 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Failed to configure a DataSource: &#39;url&#39; attribute is not specified and no embedded datasource could be configured. Reason: Failed to determine a suitable driver class&quot;</span><br></pre></td></tr></table></figure><p>그래서 다시 gradle 설정으로 가보니 인텔리J가 build.gradle 자체를 제대로 인식하지 못하는 것 같았다. 그러다보니 빌드를 다시해도 여전히 같은 에러를 발생하고 있던 것이다.</p><p>이번에도 이동욱님 블로그(<a href="https://jojoldu.tistory.com/364">IntelliJ에서 Gradle 프로젝트 작동안될때</a>)를 통해 도움을 받았다.</p><p>동욱님은 두가지 방법을 제시해주셨는데, 나는 Event Log에서 Import Gradle project가 보이지 않아서 두번째 방법으로 해결을 했다.</p><p>터미널에서 프로젝트 디렉토리로 가서 인텔리J 프로젝트 설정을 담은 디렉토리인 <code>/.idea</code> 를 삭제하고 다시 프로젝트를 빌드/실행했다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf .&#x2F;.idea</span><br></pre></td></tr></table></figure><p>처음엔 이마저도 안되는듯 했는데, 두번째 반복하니까 build.gradle 파일을 제대로 인식하며 color scheme가 적용되기 시작했다. 그리고 프로젝트를 실행하니 정상적으로 웹 서버가 실행된걸 확인했다.</p><p>이런 에러가 사실 처음이 아니다. 이번이 두번째였는데, 유독 인텔리J와 gradle 프로젝트 사이에서만 발생하는지 이유를 모르겠다.</p><br><p><strong>참고문서</strong></p><p><a href="https://jojoldu.tistory.com/364">기억보단 기록을 - Intelli J에서 Gradle 프로젝트 작동안될때</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ide </tag>
            
            <tag> intellij </tag>
            
            <tag> error </tag>
            
            <tag> springboot </tag>
            
            <tag> gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - 인터페이스(Interface)</title>
      <link href="2020/04/java-interface/"/>
      <url>2020/04/java-interface/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1544256718-3bcf237f3974?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1502&q=80" width="650px" /><p>객체지향의 주요 개념중 하나이다. 인터페이스는 추상 클래스의 일종이지만 추상화 클래스보다 추상화 정도가 높다. 추상화 클래스와 달리 인터페이스는 아예 몸통을 가지지 않기 때문이다. 오직 추상 메서드와 상수만을 가질 수 있다고 한다.</p><h2 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h2><ul><li><a href="#rule">인터페이스 작성규칙</a></li><li><a href="#implements">인터페이스 다중상속</a></li><li><a href="#implementing-methods-in-interface">default 메서드와 static 메서드</a></li><li><a href="#difference">추상 클래스와 인터페이스간 비교</a></li></ul><br><h2 id="인터페이스-작성규칙"><a href="#인터페이스-작성규칙" class="headerlink" title="인터페이스 작성규칙"></a><a name="rule"></a>인터페이스 작성규칙</h2><p>인터페이스는 다음과 같은 형식으로 작성한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 인터페이스이름 </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> 메서드명(파라미터); </span><br><span class="line">  <span class="comment">// 추상 메서드지만 abstract 키워드를 명시하지 않아도 사용가능</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인터페이스에서 가지는 멤버 필드(변수)는 오직 상수이기 때문에 가변성을 지닌 변수를 생성하고자 한다면, 인터페이스에서 생성하지 않고, 인터페이스를 상속받는(<code>implements</code>) 객체에서 변수를 생성해서 사용해야 한다.</p><p>추상클래스와 마찬가지로 서브 클래스에서 인터페이스를 상속해서 오버라이딩을 통해 인터페이스의 기능을 구현해야한다.</p><p><strong>인터페이스 작성 규칙</strong>은 다음과 같다.</p><ul><li><strong>모든 멤버 필드는 상수</strong>로만 작성가능하다.</li><li>**모든 메서드는 추상 메서드(public abstract)**로 생성할 수 있으며, 이를 생략할 수 있다.<br>(단, <u>static 메서드와 default 메서드는 예외</u>)</li></ul><br><h2 id="인터페이스-다중상속"><a href="#인터페이스-다중상속" class="headerlink" title="인터페이스 다중상속"></a><a name="implements"></a>인터페이스 다중상속</h2><p>자바는 원래 다중상속(<code>public class a extends A,B&#123;&#125;</code>)을 지원하지 않지만, 인터페이스를 이용하면 사실상 다중상속을 사용할 수 있다.</p><p>예제코드를 통해 알아보자. 다음 예제코드는 LedTV라는 클래스가 TV라는 인터페이스와 Electronics 라는 인터페이스를 다중상속(<code>implements</code>)받고 있고, 이를 tvExam이라는 클래스를 통해 실행하는 예제이다.</p><p><strong>TV.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaceStudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> MIN_VOLUME = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">int</span> MAX_VOLUME = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">(String tv)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">(String tv)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeVolume</span><span class="params">(<span class="keyword">int</span> volume)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Electronics.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaceStudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Electronics</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LedTV.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaceStudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LedTV</span> <span class="keyword">implements</span> <span class="title">TV</span>, <span class="title">Electronics</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOn</span><span class="params">(String tv)</span> </span>&#123;</span><br><span class="line">      System.out.println(tv+<span class="string">&quot; tv켜다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnOff</span><span class="params">(String tv)</span> </span>&#123;</span><br><span class="line">      System.out.println(tv+<span class="string">&quot; tv끄다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeVolume</span><span class="params">(<span class="keyword">int</span> volume)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;볼륨을 조정하다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;전자제품 모두 power on&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;전자제품 모두 power off&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tvExam.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> interfaceStudy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">tvExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      TV tv = <span class="keyword">new</span> LedTV();</span><br><span class="line">      Electronics electronics = <span class="keyword">new</span> LedTV();</span><br><span class="line"></span><br><span class="line">      tv.turnOn(<span class="string">&quot;거실&quot;</span>);</span><br><span class="line">      tv.turnOff(<span class="string">&quot;안방&quot;</span>);</span><br><span class="line">      tv.changeVolume(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">      electronics.powerOn();</span><br><span class="line">      electronics.powerOff();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 실행결과</span><br><span class="line">거실 tv켜다.</span><br><span class="line">안방 tv끄다.</span><br><span class="line">볼륨을 조정하다.</span><br><span class="line">채널을 조정하다.</span><br><span class="line">전자제품 모두 power on</span><br><span class="line">전자제품 모두 power off</span><br></pre></td></tr></table></figure><br><h2 id="default-메서드와-static-메서드"><a href="#default-메서드와-static-메서드" class="headerlink" title="default 메서드와 static 메서드"></a><a name="implementing-methods-in-interface"></a>default 메서드와 static 메서드</h2><h3 id="default-메서드"><a href="#default-메서드" class="headerlink" title="default 메서드"></a>default 메서드</h3><p>인터페이스는 원래 추상 메서드만 가질 수 있었는데, 자바8부터 <code>default</code> 로 생성하면 완전한 메서드 생성이 가능하다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Meter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">stop</span><span class="params">(<span class="keyword">int</span> distance)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterMidnight</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;인터페이스는 이렇게 default 메서드 생성이 가능합니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>deafult 메서드 생성시, public 접근제한자는 생략할 수 있다. 이에 대한 예제코드는 아래 인터페이스에서의 static 메서드에서 다뤄보겠다.</p><br><h3 id="static-메서드"><a href="#static-메서드" class="headerlink" title="static 메서드"></a>static 메서드</h3><p>인터페이스는 <code>static</code> 메서드도 가질 수 있다. 접근제한자로 <code>public</code>을 선언해서 인터페이스에서 static 메서드 생성이 가능하다.</p><p>단 <strong>인터페이스에 생성한 static 메서드는 인스턴스 키워드를 통해 사용할 수 없고, 인터페이스 객체를 직접 호출함으로써 사용이 가능</strong>하다. (아래 스크린샷 참조)</p><p>Calculator라는 인터페이스가 있고, 이 인터페이스를 상속받는 MyCal이라는 클래스가 있다고 가정하자.</p><p><strong>Calculator.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiple</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">exec</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exec2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a*b;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MyCal.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCal</span> <span class="keyword">implements</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">plus</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a+b;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiple</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a*b;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이를 실행하는 클래스, MyCalExam이 있다.</p><p><strong>MyCalExam.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      MyCal cal = <span class="keyword">new</span> MyCal();</span><br><span class="line">      </span><br><span class="line">      System.out.println(cal.plus(<span class="number">3</span>,<span class="number">5</span>));</span><br><span class="line">      System.out.println(cal.multiple(<span class="number">4</span>,<span class="number">5</span>));</span><br><span class="line">      </span><br><span class="line">      System.out.prinltn(cal.exec(<span class="number">4</span>,<span class="number">9</span>));</span><br><span class="line">      System.out.println(Calculator.exec2(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행하면 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 실행 결과</span><br><span class="line">8</span><br><span class="line">20</span><br><span class="line">13</span><br><span class="line">24</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/RTZ1e2rzbih8AScv2DLyod0K2d-tqR3hbJ-4fEJWbFyopDQmGk2j5U4w5RepQJcWsF0c6586Pn15wlRMR9KML6UOG6hPrO9bdoekb2lmwWOz8BcR8qn9BwYxaXrFypAWw_M3TTN1XwsCvsMPrHbt27sZ9_iW5TRRKv_fGEF34JRz34CYzbinHn0WdBszYQtoIKL7RZDsg1OLXdl0KKMU80MgyJfw7DImotvRilCiUVfxMNJuVHjbx1UPRZvN1kX4kRHrRjpFoqZEy7Weenf0kfq9CD3v2sgYJoGqNfHpC4URmjB2z_gphPnDtnwKMBFr9z4Mxwb4C8NdyjbNZC6jGRD75wNSpw7gCWDeY341CKspTj-hUrNlcIkMqbbfRAqtKCcaM7FYU2TuJQ3x1AiFRgk2M5XPPXeeuQwS1xyDg2rOGmfVzKDeqytfp6iMDdwpO61HuryQbsp9uxpcba_Nqe_TUb5NU-EZ86JmSAy7OEHzugMlq7OgGlNKo6Y1mQfyLfPOsf86Ja9TdtZgyRSDsL4Y82tTXCB0LMMvwjlkxxhaWKBVlivCQx9Jx2ezOuOkv-G24RRlDcrqiKxg4IvlwtN1T2lMJ6Utb3kyyRuKhEAqqpitTufx5xQLhItvWJe3xaLTq6Z2jt2XkLht3NXtLvC1-s76_vDTQinaAyz9IOMyQ4Du9X5O1qnTvyxRL6tOz7wzoG7QusLddOMw4DsxzXCrG9xpp7ZGmA6VUxRIPIYiJeaO1vmKBhZE=w1003-h797-no"></p><br><h2 id="추상클래스와-인터페이스의-비교"><a href="#추상클래스와-인터페이스의-비교" class="headerlink" title="추상클래스와 인터페이스의 비교"></a><a name="difference"></a>추상클래스와 인터페이스의 비교</h2><h3 id="공통점"><a href="#공통점" class="headerlink" title="공통점"></a>공통점</h3><ul><li>추상클래스와 인터페이스는 선언만 있고, 구현내용이 없다.</li><li>상속받은 자식(서브 클래스)만이 객체를 생성할 수 있다.</li><li>상속받은 자식이 구현을 반드시 강제하도록 하는 것이 목적이다.</li><li>추상클래스와 인터페이스를 상속할 땐 각각의 객체 타입에 맞춰서 자식의 객체 타입도 맞춰줘야한다.</li></ul><h3 id="다른점"><a href="#다른점" class="headerlink" title="다른점"></a>다른점</h3><table><thead><tr><th>인터페이스 (Interface)</th><th>추상클래스 (Abstract Class)</th></tr></thead><tbody><tr><td>구현 객체의 같은 동작을 보장하기 위함</td><td>추상클래스를 상속받아 기능을 이용하고, 확장시키기 위함</td></tr><tr><td>다중 상속 가능</td><td>다중 상속 불가능</td></tr><tr><td>추상메서드만 가능</td><td>일반메서드 + 추상메서드 가능</td></tr><tr><td>상수 + 추상메서드 형태</td><td>일반변수(가능) + 일반메서드(가능)+추상메서드 형태</td></tr><tr><td>생성자와 일반변수를 가질 수 없음</td><td>생성자와 일반변수 모두 가질 수 있음</td></tr><tr><td>implments</td><td>extends</td></tr><tr><td>메서드 선언만 가능</td><td>메서드의 부분적인 구현이 가능</td></tr></tbody></table><br><p>참고문서</p><ul><li><a href="https://programmers.co.kr/learn/courses/5">프로그래머스 - [자바 입문] 인터페이스와 다른 형식의 클래스</a></li><li><a href="https://private.tistory.com/20">공부해서 남 주자 - Java 인터페이스와 추상클래스이 설명과 예제</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
            <tag> interface </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS로 텍스트 값을 바꾸는 2가지 방법</title>
      <link href="2020/04/change-value-by-javascript/"/>
      <url>2020/04/change-value-by-javascript/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1472437774355-71ab6752b434?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1334&q=80" width="650px" /><p>오늘 면접을 한 곳 보고왔는데, 이 때 받은 손코딩 문제중에 하나를 기억하고자 남기려고 한다. 사실 코딩 테스트라고 하기엔 좀 쉬운 문제였는데, 긴장을 해서인지 이것조차 못풀고온게 찝찝해서 정리해본다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>quiz1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    이거슨 당신이 자바스크립트를 다뤄봤는지를 묻는 테스트입니다.<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    아래 문장에서 java를 javascript로 바꿔보시죠.<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      당신이 공부하는 언어는 <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;quiz-text&quot;</span>&gt;</span>Java<span class="tag">&lt;/<span class="name">span</span>&gt;</span>입니까?</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;jqueryBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changeByjQuery()&quot;</span>&gt;</span>Run by jQuery<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;jsBtn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;changeByJS()&quot;</span>&gt;</span>Run by JS<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>정확한 코드는 아니고 대충 비슷한 상황을 만들어봤다.<br>자바스크립트 코드를 이용해서 <code>class</code>가 할당된 html 텍스트 하나를 다른 텍스트로 변경해보는 문제였다. jQuery로 풀어도 되는줄 모르고 순수 자바스크립트로만 접근하다 결국 못풀었지만, 여기에 정리하는 방법은 jQuery를 쓰는것과 순수자바스크립트로 해결하는 것 두가지 모두 정리해보았다.</p><p>* 작동하는 코드가 실행되는 화면은 아래 <a href="#codepen">code.pen</a>으로 확인할 수 있다. *</p><br><h2 id="jQuery-사용해서-해결"><a href="#jQuery-사용해서-해결" class="headerlink" title="jQuery 사용해서 해결"></a>jQuery 사용해서 해결</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#jqueryBtn&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   $(<span class="string">&quot;.quiz-text&quot;</span>).text(<span class="string">&quot;Javascript&quot;</span>);</span><br><span class="line">   $(<span class="string">&quot;.quiz-text&quot;</span>).css(<span class="string">&#x27;color&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>id=&quot;jqueryBtn&quot;</code>이 클릭되면 함수가 작동되도록 비동기로 작성한 코드이다. element 셀렉트를 jQuery($)를 이용하기만 하면 된다. 심플하기도 하고, 직관적이어서 별로 설명이 필요없다.<br>* 작동하는 코드가 실행되는 화면은 아래 <a href="#codepen">code.pen</a>으로 확인할 수 있다. *</p><br><h2 id="순수-자바스크립트로-해결"><a href="#순수-자바스크립트로-해결" class="headerlink" title="순수 자바스크립트로 해결"></a>순수 자바스크립트로 해결</h2><p>jQuery를 사용하면 저렇게 쉽게 풀리는 문제였지만, 멍청하게도 jquery 라이브러리를 호출한 코드가 안보인다는 이유로 순수 자바스크립트로 접근했다. 그런데 <code>document.getElementById()</code>외엔 생각나지 않아서 결국 못쓰고 나왔다. 문제 속 텍스트는 class로만 명시되어 있었고 id가 명시되지 않았었다. 그래서 StackOverflow에서 찾아봤다. 순수자바스크립트로 풀수 있는 방법을..</p><p><a href="https://stackoverflow.com/questions/21813122/changing-content-of-class-using-javascript/21813259">StackOverflow</a>에서 찾은 보고 좀 당황했었다.. 그냥 찍기라도 쓸걸 그랬나 싶을만큼…ㅋㅋㅋ <code>document.getElementsByClassName()</code>을 하면 element를 잡을 수 있었던 것이다… <span style="color: gray;"><em>(젠장)</em></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeByJS</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> x = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;quiz-text&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">   x.innerText=<span class="string">&quot;Javascript&quot;</span>; </span><br><span class="line">   x.style.color=<span class="string">&quot;red&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 특이했던건 element를 선택할 때 getElement가 아니라 getElement<span style="color: red;">s</span>로 작성한것이다. 그리고 마지막에 <code>[0]</code>을 붙인건데, StackOverflow에서 답변한 사람의 의견을 해석하자면, id처럼 단일요소가 아닌 다중요소가 될 수 있는 class를 선택하는 것이므로 Element가 아니라 Element<span style="color: red;">s</span>이라고 한다. <code>&quot;quiz-text&quot;</code>의 이름을 갖는 클래스중 몇번째 클래스를 의미하는건지 명시하기 위해 배열처럼 <code>[0]</code>을 선언한 것이다.<br></p><p>code.pen으로 작성한 코드. 버튼을 클릭하면 각각의 방법으로 단어를 변경한다.<br><a name="codepen"></a></p><p class="codepen" data-height="265" data-theme-id="dark" data-default-tab="js,result" data-user="youngjinmo" data-slug-hash="YzXgOBe" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="YzXgOBe">  <span>See the Pen <a href="https://codepen.io/youngjinmo/pen/YzXgOBe">  YzXgOBe</a> by DevAndy (<a href="https://codepen.io/youngjinmo">@youngjinmo</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script><p>참고문서 : <a href="https://stackoverflow.com/questions/21813122/changing-content-of-class-using-javascript/21813259">Changing content os class using Javascript</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>백준 1110번.java</title>
      <link href="2020/03/baekjoon-java-1110/"/>
      <url>2020/03/baekjoon-java-1110/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/0xAI5yh0Wyx3RZGiA-f8qvl-5hK47CvYV87gFGNsouB8AiAicCp1N0VUUlPxtQD5WllgeB1sHzVmhzbXLWfGrAGuPHsseNNWmTaaCUBH6OtGZVtUURTiK7sicqhaEOnK0cjpvqEIwItfcvz2D7ixrYKg9UT0D7ckQwcfgeG6O6b6VNEKtbkZM1LFQOyPjByXvpPDFDnVvYcEG9b5kofpooVhES80kUOb62MOwjx-xA7f_FeUhvXsW9VL2DAAxULU93wpI3ZrP2Wj6mWhC6xL-azkrTstYjrIGEnoW0FKHobmGWeLrqU7-nNTJZLx7O9H9isvN7X94-ekEZjK1lQB5bVWerOk1IE5tpubmZlxNX9ueZH21gWyLIcor0uSDMd6wWVIkI9KVlcBL5b87m_M11aWE_72Rgag7mZtKT7nBaav_uod9GUogSLwAF19tNm3lqf8-HkKHyg5eU2IKsv92vfosAldfTX_Pp9kgEEhi32yiFF7Vhu3Z1yWVuVzeCsNqCdOEpzTgr3jNi36kWx1Lh2KRnbcJ1RB_o3BG4LX86qzxWAS29EEakrgHuArKp_a1a-Xhjl7xDz7VIswusQGiSkYBquB2aY-3aVurJeqQb2DQv09BHAHoZEYG9JjHYARD3Zkl5yC647R9cpT0Zj1tW509KDpmC4kTxddzIUc8w-3NbkJr0aIeJhj4pOdTNknEvwzu8KvSN4TuB1cCjtAQne43WyuDYkRG1Z5P9yQYrK_AVXdgCa4Rjk=w750-h346-no" width="650px" /><p>백준 문제 중 풀었던 문제를 다시 풀어보는중 처음 풀었을때도 고생했고, 다시 풀어도 고생한 문제를 정리해보려고 한다. 한시간 이상 풀었는데, 풀고나니까 민망하다… 그럼에도 다시 한 번 공개적으로 정리를 해야 다음번에는 술술 풀 수 있을것이란 기대를 안고 정리해본다..</p><p><a href="https://www.acmicpc.net/problem/1110">1110번 문제 링크</a></p><h2 id="문제"><a href="#문제" class="headerlink" title="문제"></a>문제</h2><p>0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자.</p><p>26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다.</p><p>위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다.</p><p>N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오.</p><h3 id="입력"><a href="#입력" class="headerlink" title="입력"></a>입력</h3><p>첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">예) 25</span><br></pre></td></tr></table></figure><h3 id="출력"><a href="#출력" class="headerlink" title="출력"></a>출력</h3><p>첫째 줄에 N의 사이클 길이를 출력한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">예) 4</span><br></pre></td></tr></table></figure><br><h2 id="내가-작성한-답안"><a href="#내가-작성한-답안" class="headerlink" title="내가 작성한 답안"></a>내가 작성한 답안</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> init = sc.nextInt();</span><br><span class="line">      <span class="keyword">int</span> firstNum = init/<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> secondNum = init%<span class="number">10</span>;</span><br><span class="line">      <span class="keyword">int</span> num = (secondNum*<span class="number">10</span>) + ((firstNum+secondNum)%<span class="number">10</span>);</span><br><span class="line">      <span class="keyword">int</span> cycle = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span>(init!=num) &#123;</span><br><span class="line">         firstNum = num/<span class="number">10</span>;</span><br><span class="line">         secondNum = num%<span class="number">10</span>;</span><br><span class="line">         num = (secondNum*<span class="number">10</span>) + ((firstNum+secondNum)%<span class="number">10</span>);</span><br><span class="line">         cycle+=<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      System.out.println(cycle);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>처음에 작성할 땐 do-while문으로 해결했는데, 이번엔 do-while을 사용할 생각을 못하고 다소 장황하게(?) 작성했다. do-while문으로 하더라도 성능은 별 차이가 없는 것 같지만, 가독성이 더 높으니 do-while문을 사용하는게 더 좋을것 같다.</p><p>이 문제를 푸는데 어려웠던건 문제를 파악하는 것이었다. 10의 자리수와 1의 자리수로 구분해서 1의 자리수를 10으로 곱하고 다시 (10의자리수+1의자리수)의 1의자리수를 더해야 새로운 수로 정의하는데, 내 머리로 받아들이는데는 좀 복잡하지 않았나 싶다…</p><p>또 <code>%</code>를 써야하는데 <code>/</code>를 쓴다던가 하는 실수때문에 IDE에서 테스트해보면 계속 무한루프에 빠지는 에러가 있었으며, while문의 조건을 잘못 작성해서 또 무한루프가 발생한다던가..</p><p>지금 코드를 다시 봐도 어렵기는 커녕 쉬운 문제인데, 문제를 제대로 파악을 못해서 오래 걸린 것 같다. </p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Quiz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> baekjoon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>쿠키, 세션 그리고 캐시.</title>
      <link href="2020/03/web-session-cookie-cache/"/>
      <url>2020/03/web-session-cookie-cache/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1486312338219-ce68d2c6f44d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1652&q=80" width="650px" /><p>웹 개발을 하면서 빠질 수 없는 개념 이다. 그러나 대충만 알고있고 설명할 수 있는정도로 Session과 Cookie, Cache를 구분하지 못하던 차에 박재성님 <a href="https://www.youtube.com/playlist?list=PLqaSEyuwXkSppQAjwjXZgKkjWbFoUdNXC">강의영상</a>을 보며 세션상태에 따라 페이지에 노출하는 리스트를 변경하는 개발을 하다가 정리하게 되었다.</p><p>클라이언트가 HTTP 프로토콜의 GET/POST 방식으로 웹 서버에 페이지를 요청하면, 웹 서버에서 응답받은 HTML 페이지를 파싱하여 렌더링을 하는데, 이렇게 클라이언트와 서버 간의 데이터 왕복과정을 <strong>‘라운드 트립(Rount-trip)’</strong> 이라고 한다. 웹은 이 라운드 트립이 최소화하도록 개발하는 것이 좋다고 한다.</p><p>이렇게 라운드 트립을 한 번 거치고 나면, 사용자가 입력한 정보들이 손실되는데 동적인 웹 애플리케이션에서는 사용자의 요청 또는 입력 정보를 유지할 필요가 있어서 이런걸 저장해두고 사용할 수 있는 기능이 존재한다.</p><p>눈치 챘겠지만, 이런 기능이 쿠키, 캐시 그리고 세션이다. 차례 차례 정리해보겠다.</p><h3 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h3><ul><li><a href="#cookie">쿠키</a></li><li><a href="#session">세션</a></li><li><a href="#cache">캐시</a></li></ul><hr><h3 id="쿠키-Cookie"><a href="#쿠키-Cookie" class="headerlink" title="쿠키(Cookie)"></a>쿠키(Cookie)<a name="cookie"></a></h3><p>클라이언트에 대한 정보를 클라이언트(PC)에 저장하기 위해 웹 서버에서 클라이언트(브라우저)로 전송하는 정보를 이야기한다. </p><p>쿠키 안에는 사용자의 로그인 정보 및 웹 사이트에서 어떤 행동을 했는지, 몇 번 방문했는지 등 서버에서 유저를 식별할 수 있는 데이터(패킷)가 저장된다고 한다. 그리고 이 쿠키는 해당 웹 서버만 접근이 가능하다고 한다. 트위터에서 전송한 쿠키는 페이스북 서버는 접근 할 수 없다는 이야기이다.</p><p>이 쿠키 덕분에 로그인을 매 번 할 필요없이 한 번만 하면, 여러 웹페이지를 돌아다니다가 다시 접속해도 로그인 상태를 유지할 수 있다. 그러나 편한만큼 보안상 위험하기도 하다. 스파이웨어를 통해 사용자의 웹 브라우징 행동을 추적하거나 이 쿠키를 취득하여 웹 계정 접근권한을 얻을 수도 있기 때문이다.</p><p>건물(Server)에 들어가기 위해 사용하는 출입증카드(Cookie)에 비유되는 개념으로 이해하였다.</p><p>쿠키는 두가지 종류로 구분된다고 한다.</p><p><strong>세션 쿠키</strong> : 쿠키에 만료일이 포함되지 않으며, 램 메모리에만 저장되어 브라우저를 닫는 순간, 쿠키가 소멸(손실) 된다고 한다.</p><p><strong>영구 쿠키</strong> : 만료일이 포함되어 있어서 만료일까지는 브라우저를 종료하더라도 사용자의 컴퓨터에 저장되어 상태를 유지할 수 있다. 만료 시기가 되면 자동으로 삭제된다.</p><br><h3 id="세션-Session"><a href="#세션-Session" class="headerlink" title="세션(Session)"></a>세션(Session)<a name="session"></a></h3><p><u><strong>사용자가 웹 서버에 접속해 있는 상태</strong></u>를 하나의 단위로 인식하여 이를 세션이라고 하는데, 클라이언트가 아닌 웹 서버에 저장하는 데이터이다. 상태를 일정하게 유지시킴으로써 <a name="01-word"></a><a href="#word-1">라운드 트립<sup>1)</sup></a>을 거칠 때마다 사용자가 로그인해야 할 번거로움을 없애준다.</p><p>서버에서 쿠키에 있는 로그인 데이터를 이용해서 세션상태를 유지한다고 하는데 활용한다고 한다.</p><p><em>예. 쿠키를 이용해서 세션을 유지하는 과정</em><br><em>1) 클라이언트가 웹 서버에 접속하여 로그인을 요청</em><br><em>2) 웹 서버는 클라이언트에 세션ID를 발급, 이 세션ID를 쿠키에 저장(JSESSIONID)</em><br><em>3) 클라이언트는 재접속시 이 쿠키에 담긴 세션(JSESSIONID)을 서버에 전달</em><br><em>4) 서버에서는 세션ID를 통해 클라이언트를 식별하고 로그인 상태로 유지</em></p><br><h3 id="캐시-Cache"><a href="#캐시-Cache" class="headerlink" title="캐시(Cache)"></a>캐시(Cache)<a name="cache"></a></h3><p>한 번 내려받은 데이터를 저장소에 저장해두고 재사용할 수 있도록 하는 데이터이다. 웹 사이트에 방문하면 웹 페이지를 보여주는 이미지 등의 리소스가 한 번에 로드되는데, 접속할 때마다 리소스를 내려받을 경우 웹 페이저 접속 속도가 느려질 수 있다. 따라서 한 번 로드된 리소스는 클라이언트에 저장해두고, 재요청이 들어올 때 캐시에서 로드해와서 더 빨리 로드 할 수 있도록 돕는다.</p><hr><p>여기부터는 네트워크 공부를 선행하지 않아 잘 모르는 영역이지만, 언젠가 이해할 그 날을 꿈꾸며.. 일단 적어본다.</p><p>네트워크에도 캐시 기술을 응용할 수 있다고 하는데, 이 때 응용되는 캐시의 종류는 3가지로 분류된다고 한다.</p><p><strong>1) 브라우저 캐시</strong><br>클라이언트 애플리케이션들이 내부적으로 갖는 캐시.</p><p><strong>2) 프록시 캐시</strong><br>실제 서버가 있는 곳이 아닌 네트워크 관리자에 의해 네트워크 상에 설치되는 캐시로 latency와 트래픽을 줄이는데 이용된다고 한다.</p><p><strong>3) 게이트웨이 캐시</strong><br>서버 관리자에 의해 설치 및 운용되는 캐시이며, 서버의 앞단에 설치되어 요청에 대한 캐시 및 효율적인 분배를 통해 서버의 응답 성능을 개선한다고 한다.</p><p>정리하면, 쿠키와 캐시는 클라이언트에 저장되는 데이터지만 목적이 다른 개념이라고 할 수 있다. </p><p>참고 문서</p><ul><li><a href="https://asfirstalways.tistory.com/68">Jbee - [개발상식] 10. Cookie/Session/Cache</a></li><li><a href="https://jeong-pro.tistory.com/80">정아마추어 - Web 쿠키와 세션의 차이, 용도, 사용법</a></li></ul><hr><p><a name="word-1"></a><a href="#01-word"><sup>1)</sup>라운드 트립</a> : 클라이언트와 서버간의 왕복 통신 과정, 라운드 트립이 자주 발생할수록 서버에 부하를 주기 때문에 라운드 트립이 적게 발생하도록 해야한다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cookie </tag>
            
            <tag> session </tag>
            
            <tag> cache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA - 추상 클래스/추상 메서드</title>
      <link href="2020/03/java-abstract-class/"/>
      <url>2020/03/java-abstract-class/</url>
      
        <content type="html"><![CDATA[<img src="https://www.hackingwithswift.com/uploads/shadow.jpg" width="650px" /><p>추상 클래스란, 미완성 클래스를 의미한다. 일단 선언은 했지만, 완성되지 않아서 오버라이딩을 통해 기능을 작성해야 한다. 아래 코드를 통해 확인해보자.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.abstraction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;날다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fly()</code>는 정의했지만, <code>sing()</code>은 새의 종류에 따라 달라지므로 따로 정의하지 않았다. 이렇게 미완성된 메서드를 <strong>추상 메서드</strong>라고 한다. 그리고 단 하나의 추상 메서드라도 보유하고 있다면, 해당 클래스는 <strong>추상 클래스</strong>가 된다. 따라서 추상 메서드를 작성했다면, 클래스의 접근제한자 뒤에도 <code>abstract</code> 키워드를 작성해야 한다.</p><p>추상 클래스를 사용하는 방법은 위에서도 언급했듯 오버라이딩을 해야한다. 그러려면 추상 클래스를 상속받는 클래스부터 생성해야한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.abstraction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;꽥꽥!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Bird 클래스를 상속받는 <code>Duck</code> 클래스를 생성했다. <code>Duck</code> 클래스에서 <code>sing()</code>을 오버라이딩하는 메서드를 생성까지 한 코드이다. 여기서 <code>@Override</code>라는 어노테이션을 사용했지만, 사실 작성하지 않아도 컴파일 에러가 발생하지는 않는다. 가독성을 위해 자동으로 생성된게 아닐까 싶다.</p><p>위의 코드들을 컴파일해서 콘솔에 출력해보겠다.</p><p><strong>Bird.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.abstraction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line">   String bird;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(bird+<span class="string">&quot;날다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fly()</code>에 어떤 새가 나는지를 함께 출력하기 위해 <code>Bird</code> 객체에 String형 멤버 필드를 추가하고, print문에도 멤버 필드를 추가해주었다.</p><p><strong>Duck.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.abstraction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Duck</span> <span class="keyword">extends</span> <span class="title">Bird</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;꽥꽥&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Duck</span><span class="params">(String duck)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.bird = duck;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>수퍼 클래스에서 상속받는 멤버 필드에 값을 주입하는 생성자를 추가했다.</p><p><strong>DuckExam.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.abstraction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuckExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Duck duck = <span class="keyword">new</span> Duck(<span class="string">&quot;오리&quot;</span>);</span><br><span class="line"></span><br><span class="line">      duck.sing();</span><br><span class="line">      duck.fly();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Duck</code> 클래스 타입의 인스턴스 <code>duck</code>을 선언할 때 “오리”라는 String형 값을 인자값으로 넣어서 선언한다. 그럼 <code>Duck</code> 클래스에서 생성한 생성자에 의해 <code>Bird</code> 멤버필드에 값이 주입되고, 그 값이 출력될거다.</p><p>실행결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">꽥꽥</span><br><span class="line">오리 날다.</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/qRCq_TM9Jr6oE-ie3a8URCbaNHvuqQ3m28JdbNVWVBfNtOqQV_3Yhm8G74_ulMDYPlry9_ztw2p5sgZJ2F_IHzmtI2K_mW1O2sYqKq4ygXEpIDjNgdtBJqNFWSnsHpHye1U0KLd6VRioyaxdPjqNMezw_IFyvRuciDK7igp3CSmHCuaBS8YNGWRF5c-MO7X9aHrpBYLyREpDBC-2KnyICkySL6vUGvTh0CZ_bHpNTEi0iUQ0D6VxYFwf102WvzAA8VyuOWebXH1du4szLGPmDoh4epA2f_A7h6-50VJq8I7F61_czSqCnGFggD3JbD4SAjSDwWEaXaDFFWQrFlc21PR9w2E-7KQbi7TLFa54bwXg3bNYB81jHA53wxGOUF7aR2za9c6KVjw2qPQtjAcwtD9MQyrB7ZRNlvMFjm9Hf4CQjG2KQ_FvAHLtRNfrfzftDx8fBUJ-MBfKPSpO6rIur7t6ysNgT3Edp-TmNHoiWUo6vwWjbdGc6N7Kv__0C_RhbjDTmihyG_7fBhdbpiQCxVIvk_1w641CONRGWG4IoyA5mKaZBM2nNGDCOmzBrYvaVtM33FPxRLwAGF8jByhv3vBANLC-uFCawSf0J2wk2ytEKJHN4G5bng486eAg8asx0XZOFJYA29SxhacB7Zx9ORVsRw5Qer--D4ISE5BymfGPQDt3b5ho7pGXLq_HvU5DHBHkv6XU5zMizrhinqWsswcr5FSoDeohyM8O3yZ-cs0EomhRc0EWfiY=w943-h712-no"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA - 클래스의 형변환</title>
      <link href="2020/03/java-conversion-of-class/"/>
      <url>2020/03/java-conversion-of-class/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1553830591-fddf9c6e2ed1?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80" width="650px" /><p>클래스는 형변환이 가능하다고 하다. 보다 정확히 이야기하자면, 상속관계에서 수퍼 클래스를 서브 클래스처럼 사용할 수 있다는 이야기이다.</p><p>원래 서브 클래스는 수퍼 클래스처럼 사용할 수있다. 서브 클래스에서 선언하지 않아도 수퍼 클래스에 선언 또는 호출되어 있다면 해당 기능(메서드)를 사용할 수 있기 때문이다. 그래서 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>위와 같은 상속관계를 <code>Sub 는 Super이다</code> 라고 표현할 수 있다고 한다. <code>Super</code> 클래스의 기능을 <code>Sub</code> 클래스에서 똑같이 사용할 수 있기 때문에 <code>Sub</code> 클래스를 <code>Super</code>클래스라 하더라도 맞는 표현이 될 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B는 A이다 는 아래로 표현될 수 있다.</span></span><br><span class="line">Sub sub = <span class="keyword">new</span> Super();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이건 에러를 유발한다.</span></span><br><span class="line">Super <span class="keyword">super</span> = <span class="keyword">new</span> Sub();</span><br></pre></td></tr></table></figure><p>반면 위와 같은 상속관계에서 <code>Super는 Sub이다</code> 라고 할수는 없다. <code>Super</code> 클래스에서는 <code>Sub</code> 클래스의 메서드는 사용할 수 없기 때문이다. 예제 코드를 통해 확인해보도록 하자.</p><p><code>Car</code> 클래스와 <code>Bus</code>클래스가 상속관계이며, <strong><code>main()</code>에서 <code>Bus</code> 클래스로부터 <code>Car</code> 클래스 타입의 <code>car</code> 인스턴스를 생성했다.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Car car = <span class="keyword">new</span> Bus(); <span class="comment">// Car 클래스 타입의 인스턴스 car는 새로운 Bus 객체이다.</span></span><br></pre></td></tr></table></figure><p><strong>Car.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.conversion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;차가 달립니다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      System.out.println(name.concat(<span class="string">&quot;가 달립니다.&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">      System.out.println(name+<span class="string">&quot;가 시속 &quot;</span>+speed+<span class="string">&quot;km/h로 달립니다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bus.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.conversion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;버스가 시속 &quot;</span>+speed+<span class="string">&quot;km/h로 달립니다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CarExam.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.conversion;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarExam</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Car car = <span class="keyword">new</span> Bus(); <span class="comment">// Car 클래스 타입의 인스턴스 car는 새로운 Bus 객체이다.</span></span><br><span class="line">      car.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>car.run()</code>를 호출해보면, <code>Bus</code> 클래스엔 없는 파라미터가 없는 <code>run()</code>를 <code>Car</code> 클래스로부터 상속받아서 호출을 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">차가 달립니다.</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/Jj-I7y0akddk4CV2_lg1yoiYASNsGNa1VcrjIZ6aqwxxkUxxx7OXnbjrpyDPr_-83BKnfuucvPoQ-eEBmaoUyLLvcKrtOUjzhwVx6_QeIcIPlhOj9BR3FfdTuNz2-x0xGKn6oVQFooHFjwchumqTZl7gos9pOtrpTEIytBBB3ZArOafx0S3AcDHzkddYmd1qFn0TiAKK4WiqoD_ZkpIT9q4LNiUd5gjqQN_uiiEdqA4kBTzFuWALDzYYbbcQ_BDnALrcjdO0dVBLWYLaeWhnOJQfgy9Dd2Mq80EYUTM4ry_O-Qv39EFuLETHui-KsqMi7N2CI6DLkYHvZ6bu3YnfHQImYqCGBsOUefyDzuwJnXm_P-DV1sjcLOS6Oo9mUjlKvqr6Fi3okx8sVlDRS6waKeXFdqieDsZbZLW-BbuzHC-l_h5CRDPmZZzck3Ei7__ioUlXY4t21NPg_5rcBeGHFdcJSZNjJG0R1beNgXlZd5fHs2WA9tG_iDEIrdBUUTrQmgMC0CTSuUpCEqKE4U5jr-_oQCgA6D3AXcvGAUy6N0nOrM9pfWkmPof0fNQUbqX_i_Yl6VLK4lJl0eTUVnj7cko5oY0HDItGtCu05QQy0mxLBzXh-yLEfQwHxylEMdViURGN5pWB4TdlVAcPsNUz0rZhbVSiKf-2shygJViw6tzawfLW3IMAuibA-fGZAcVWrYMSmDndIEqf8PuyrwrHvC-t01pf1iowyJ4oIbeOyb32VhRK7Ek8n4c=w1111-h702-no"></p><p>그런데 위에서 생성한 인스턴스로는 <code>Bus</code> 클래스에서 int형 변수를 파라미터로 받는 <code>run()</code>를 호출할 수가 없다. <code>Car</code> 클래스 타입의 인스턴스 <code>car</code>는 서브클래스인 <code>Bus</code> 클래스의 기능을 알지 못하기 때문이다.</p><p><img src="https://lh3.googleusercontent.com/rVaveNXoERVQcrSFHs8xPaMsW6arqdwmJVlxNHDi62w19BMfa6ZSvNnyEMLdijUwGWWisdBeVLcRzQNplRzAIfO4djUPEYVLL29Qr5TSWkd5aKgR8VBSH0povci8ABBNDm0rnbFxFPw1zrrJUhnhqI6Bu-T_uLuL8YY08h10PwneQT7Np1YHmcAentM-ERREwM3kuwpDND7k2TQ8WTuxLkLMqvyNEvDFU34hlevBdzH9rt6JW24uVMTdso_CnrH4Qbu6J0r9uAwbB32txEX18vQlKLkgRyX7aJSp0aobSp3KIKW3uYKTOyuQ_JpvrF0BqItR3TiJvmO525ruvCNK1pGbvRy9tVFA4mo46wroZoLpZ2jKoBmRIx0J943ZcrHd4HlBEQTFawLGM36wz-eZAnXAXb6bG7LfDafS66ofvAsj698Z7PACLpPle96A-5S7XbpDpUPTikwKF1PqaVnkHO3UsOjY8JM9cdNax4VKH_VXk-wWAK0-yX0bXuEjx9R_pNyBP-82cVq7ON_C5E2dlJLbx_ih211ixsYmWCMAkrnWWUaD-MiHaMuJrI1SnbLB4w345DDnAF13wMwWNZPTTCiOfAnmaJZzchClfpPmisLpKrUdZVqNEX54LIIkxEv7Pj9soTkpjYJrByknhMZ4eC7MGD3txbQhBMIfJuaiTk_2fP8et9FY06DDmgZKcMoMKUc7mOFjPfwwffUWJrFKqkR8IJ5oacfdbs7l9zXXLn2xjqrP6WLPK3k=w1142-h759-no"></p><p>따라서 이럴 때엔 <code>Car</code>클래스 타입의 인스턴스로부터 <code>Bus</code> 클래스 타입의 인스턴스를 생성함으로써 <strong>형변환</strong>을 통해 <code>Bus</code> 클래스의 메서드를 호출할 수 있다.</p><p><strong>CarExam.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.conversion;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Car car = <span class="keyword">new</span> Bus();</span><br><span class="line">      car.run();</span><br><span class="line">      </span><br><span class="line">      Bus bus = (Bus)car; <span class="comment">// 클래스 타입의 형변환</span></span><br><span class="line">      bus.run(<span class="number">70</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위와 같이 코드를 추가하고, 실행하면 다음과 같이 원하는대로 출력이 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">차가 달립니다.</span><br><span class="line">버스가 시속 70km&#x2F;h로 달립니다.</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/yU0To6uYEFvWQ1l6DcGyUrLqvU21KpjeuSSphybne9yCkQdqAFwF6aR9zXZV6JPlOkBiIH80ISbYRzPQ6LYal7HsdRnoXBO1wCEBXv6zMOhJ--kXxa_aBaSePeqAETy0j1XNRkg4wJhboDvtxq56jDcmT4W9J1cBKipk3Z508kQcoAfJF8xxKIZEzpXx_3cn-N9appExaoWn2NnphA7QZGnFLc73W1XJwa-Um_b1T457o27Vqvu-fgTvN4udSRptxZLLoo1qnP7MVRU4QypFtAzVSwvDSmAy9foZny9s5-ifCzD4El6KFfZPsnKPdtnndefkYuNipwRQ0-KZDjxsZnwG3i9Np8d_4ejfZS8kvm4Wojab489dCbQJ4Q8lqVk40l5RTePfxOgCLod1YdGzrztDmuodL0x_NM9TJM9oEU1F9oJ3VAG7WN6WR-2-4Uh3L2N3IZsZHj1m0mZ0MVs4FMv5tGrsS4NBO4IUpGbjS4H3ourg7UdXUq6lpiYuHzGZN6XQni9-9cEctPuRq7Ev567YoUHElNE3nbj1n5DxJ6OG4Pm_JmBZXZonQaEyoLwclFP1YwYwvQge3RpcM8ZW3XWcj9xErq0hX3YDiqq4WAod3lQ01kMUZWMd78RS16CLeHoOBIMu6hTeyzhtyBlmf_sd_shkW1y1q3jeaTMxpPjWqF22-zXJSyYX31g7ddHdo-vgu3d2raDysRs_a6iSatjDNlmQzS8xeB6w67Ayj6paW4FnVVgAYbo=w1117-h724-no"></p><p>결론은, 서브 클래스로부터 수퍼 클래스의 인스턴스를 생성할 수 있지만, 서브 클래스의 기능을 전부 사용하지는 못한다. 따라서 이 때는 수퍼 클래스를 서브클래스로 형변환하는 일이 필요해진다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java - 상속 (Extends)</title>
      <link href="2020/03/java-inheritance/"/>
      <url>2020/03/java-inheritance/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/TyUk47LCOAA6ZovnFa85hJwToTN96xco_8r0436hrCI25FZWouRIfUy9vyxX6sgJgILJyRwuoOVdnp4cpcOSsm-KyGh3Z9C_nQ6_63ANYI6Jhm0HvZkEL9dKj0t9_rSVmBcYFH8KymYdXWj2UXeu04ldXITFr7fcwpxfKMki_mAFVPZI_S179AdO01VrKuGt-m3CVGPviiC5nCzgI86aV8Hxsrabd-XaWRnTLI6Pa4FmWX-NxfeMLf8ud3snwymPxIcsxMqmlEuTikk9JQHMYZDvyYijY3sfpG2pO-Ul9BWOV_Glrvg4xZ90mISBeQFMcgnYDXcQRBr4Q8QwUXWzOdssvYyZgwJQ1G5ipjYUTqICdd4nikm-zgGYahljdlWI8Wlz_hUy-2LlTFSZCLlXhN7m22idcKqItAJawgbHniHHgp9V4oZ_gFR1Ar12wWJjjagI2hQy_SZ1SRpKqAJTIiLVvXoYgWUMZx8_36rVbXq1iyDCkVIQbNDUPIFYNyO8eCHtPSgyB-Rm7rylW6PVEFtlPOlqvDo5DWdQvjQOweSEjVcRY9rFdLn0atRkvwlUPiJ4muxoyID0NUuFbTHk8IK7wYXWuIpa8GA2oYPheX83c10useeRVYQIDfAi_a8GhACmaYFfLVQvmcWx1RWW_AV6N3cat1yYDEZygKDx5PytofwFAhpMSko64JwGFNnO2BrZprcuJ_jbiGDQA_XatREaxHNDqhYWpOudzmCV07_l3xxzKYMmNKM3=w988-h632-no" width="650px" /><p>상속은 부모 클래스를 상속받은 자식 클래스가 기능을 물려받는 걸 의미한다. 아래 예제 코드를 보자.</p><p><code>Bus</code> 클래스는 아무것도 선언되지 않았지만, <code>Car</code> 클래스를 상속받고 있으며, <code>passenger</code> 클래스에서 <code>Bus</code> 클래스의 인스턴스를 생성해서 <code>Car</code> 클래스의 메서드 <code>run()</code>을 실행하는 코드이다. </p><p><strong>Car.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot; 탑승하다.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bus.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>passenger.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Bus b = <span class="keyword">new</span> Bus();</span><br><span class="line">    b.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">탑승하다.</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/w1BF2mQefbHlwNOSpKvthKwo3pYPXiddTTmLJDt1eECymADq-megKNZ-ZTjxH3M6jQfevajSvfB0mJT0W41S_AE8SBeLas6gIej3Sw99CbYZb9T81D2T9ItHrFdvDE5ouJ2o7xGZ_TkMj_H0ACzOgW3fxHavbcsi3V9Ad5fravaejW5k9n5FEQoaHHbCQ1CEecxaip0efsHSKxeDRWtiAyMRy4jQ7Zh-7RVhejE-lBAfAeWNPnp4nSqfhg_tmGvXMe9c_vBdBU-ueHFexXSm-tv4rv-qY0EECGQKMLnYDAgY55JzOeG6NpcuPhZTCvbaTvOl_FxVgClOe4USCsYVhvLRbiD_fnaYST_i30mYWUMDp-0lb8WsLAfaiFgvT_yIwVOwqEEoTmCfkRm8r4Hq9AYxlnlCTvE2Uv_fuuxf-rp1r83ffBKah5dPd69cjRu6Uu2lgwViKfReRbJl6B5LjJVvgp-tov_zmxUss1DOa1Muw3-n_psxTkO5emcKiHiKP022wy_xp4v1O9loJMEGYsCQuaFhrWi0BW6vxOKVu7untFGM1Ul7I8iGiSLrzo-8DQ1MJlYx_bzjsA2TwSsBbnIeEXfGiRiwakgRxgHWbi1kFpdpg8kVF1wye3nH2TPuFvR7nPRbkSeZMzl_mhDhTcqh4wq4kQU9w80cfxcriSi68YSYAlaLZQ02flL24BI4DqRwG1gj88Zvi-Y5pMV5FTBNd2rdjR8Jc1qtrZn61biNwIN5EH0OpYQ=w1251-h541-no"></p><p>아무것도 선언하지 않은 빈껍데기 일뿐인 <code>Bus</code> 클래스의 인스턴스를 생성했는데, 인스턴스에서 메서드를 호출할 수 있었다.</p><img src="https://lh3.googleusercontent.com/ZbzP5QBDYEGAgJ8Cb9IEHXDefjr6puaLgB5ugAV1jzebLj7phGTVYtVi3Dx9cjKsF1EpOzEAdWpZ_WejANtZQ03JHQtbjXX1AqrfH6gO-IIeEEiTVn7Gqb5NzP-ln8mBk1DRawHVRc0yvi49WFaT3I214GX7KGbx3zVvFWtXM_tPuycY0w6RCaiyWYOWm0VCRSZUb23cYIiNptjs_9L9sV5U63CXGFHpNstOaYa7pMnKR7Rqrm2hSVA1Ozu9GvwSKdfMNuQXlrqP7J8VTAjsYTTjt87bn9O7k9HmWg9Cf9mGjtLMrgmOCmoFNLnnIZZfsTEjMm0V_y517SNC_N4zzjBCi2eFMCqll8-Y7Kk6hLOnH6TikoKm9twC2fYpX1X6Piam8B7am8UpVlGLCHwnZw74dS2scqtb3Rglq_BY5hNb3zQhDbLFTMrGildomaHO-Q_P9g9lB-JGR6TOUk1EcLeK81zTJ-CSigTcXSL-fX_AO90KIBWghXr_Y4vGhLAn1KgrPyqb954YVRsBHvFOcT0H6onFgdKPjGXAqiiErDq3xasEVkpXLKtaZuW3_QKh-c_o5Lv3UFGhcfm-RcibwCFSuOVQlTW5r87zFDnZFV1QGknIdQs0icd9Ytr0GlCni5vhuwWeODLXCi0VGdEfKMG0rQONDuKiO1ig5wa8Pd1d9DqoDPhlXug2aPTT41l8Or66wxdJQtY2bGxcg9oRNzXSlVTcoFgws95azO1mpK_vRwSXli-_mXk=w589-h379-no" style="zoom:60%;" /><p><code>Bus</code> 클래스가 <code>Car</code> 클래스를 상속받으면서 <code>Car</code> 클래스에 선언된 기능(메서드)들도 사용할 수 있게된 것이다.</p><p><b>상속을 활용하면 중복코드를 줄일 수 있는 장점이 있다. 또 이런 특징때문에 객체지향 프로그래밍의 핵심적인 개념으로 사용되기도 한다.</b></p><p>추가로 서브 클래스에서 수퍼 클래스의 기능을 직접 호출하고 싶을땐 <code>super</code> 키워드를 통해 사용할 수 있다. 위의 코드에서 passenger 클래스에서 <code>run()</code>을 호출하는 것이 아니라 Bus 클래스에서 <code>run()</code>을 호출하고 싶다면, 아래처럼 작성하면 된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p>위의 예제코드를 활용하여 생성자를 추가하는 것으로 조금 변형을 해보았다.<br><code>Bus</code> 클래스에서 생성자를 만들어보았다. 이 생성자는 숫자를 파라미터로 받아서 <code>number+&quot; 번 버스&quot;</code>라는 문장을 출력한다. <code>passenger</code> 클래스에서 숫자를 인자값으로 넣는 인스턴스를 생성후, <code>run()</code>을 실행했다.</p><p><strong>Car.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot; 탑승하다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bus.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> number;</span><br><span class="line">  </span><br><span class="line">   Bus(<span class="keyword">int</span> number)&#123;</span><br><span class="line">      <span class="keyword">this</span>.number = number;</span><br><span class="line">      System.out.print(number+<span class="string">&quot;번 버스&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>passenger.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Passenger</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Bus b = <span class="keyword">new</span> Bus(<span class="number">1415</span>);</span><br><span class="line">      b.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행결과이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1415번 버스 탑승하다.</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/n0j-c_wIM9Yla2TTYzwjmBNkX0DcI3cgAgifCeVvC5racBeCN2IkYkP2Iv21ck6jmfULGmt40OMXU85PZ78lZ53Y5aCOLsfyg3Mt3w9hIeRBLTypbqBFihh3UEzkCwQEWikcuGgbK6Adl2agtzdydJF5ECzHZdtK8bJ_3hNSABZHGu5jLRyBQWcksE5KkRk9WKGKmZdG4XN2oSf1p-bh-rOrCDUON105shAxmDne-1npo8UKmUeWfot81dKwf7PiTWnuEJlkzW-nqanv2FK4uRmcBe5M64F4vINC4ACVRfpwbMi2WCi2B74a_YNFGI1B7FXy5580CKgfDsRYF_9ajR7okCVNb8ogvTSMtfcW5rJD1QMvVuaFK6SJGFzUHHD6yNKSQLzzfR5vLdyMscQKpusm2WCu3vUeuw1LjNWM99M_8f2lg6hSZuAu_RGTehneKwkpnnRCyFQcfy_SSQK-S6HxMlZrJyWT2o09cCZzHjZxEgm0VDTr_5sfhTujatV1sLds0vSW9OE5V-zdxcD9kGYI4gkTo3VW22lrtFCprfvRa7rxV1K8QwoeO5HeSea4satkGmGvmHuzaQDXbmA4XZQzI7buF1_9AowZxBN5As47S510GMW8fE0H02Mv_pC4JsnG9sbgZHWsVG0Jh1MJVoCN73p4Onbj2tFcATa-fVykn5nK2UNDXB-_Q7PshnXdRSHIrZV8AkwWFp13MQAaXchcE4pTFB_3xdFJJMzJ3alvJ1maT8Ec3oM=w1384-h537-no"></p><p>위의 프로그램이 JVM에서 작동하는 순서는 다음과 같다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bus b = <span class="keyword">new</span> Bus(<span class="number">1415</span>);</span><br></pre></td></tr></table></figure><p>우선 <code>passenger</code> 클래스의 <code>main()</code>이 실행되고, <code>main()</code>에서 호출한 <code>Bus</code> 클래스의 생성자가 실행된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.run();</span><br></pre></td></tr></table></figure><p>그리고 인스턴스의 메서드를 실행하기 위해 인스턴스의 클래스 타입인 <code>Bus</code> 클래스가 호출되고, 찾는 메서드가 <code>Bus</code> 클래스에 없으므로 수퍼 클래스인  <code>Car</code> 클래스에서 찾아서 호출된다.</p><p>예제코드로 확인해보자.</p><p><strong>Car.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   Car() &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Super 클래스, Car 생성자입니다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bus.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">   Bus() &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Sub 클래스, Bus 생성자입니다.&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CarExam.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarExam</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Bus b = <span class="keyword">new</span> Bus();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>실행결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Super 클래스, Car 생성자입니다.</span><br><span class="line">Sub 클래스, Bus 생성자입니다.</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/Ee3gfRR3Xg582QHqjfaX7PetC31OTP4sZJ3d2VoReBdgI-348DwaiWUzVWDXGXhFp5xGJK_FfBxRe1XRowrsREfxkgep7KR5Y5ptlX1S43vvPpaRIu4eSwQR_Xru0ccCwgMgmStt4ssbX76BrTEduqMtkXZmNRisX0440MmMb2kN5P__ORKzJYbu5Z_v6rG6d7g24VSYsNTQEgK5kPiFKHXQ7VrVfAlDmT5IG_i4RwflJG1QaVBDLBUQJm9loPttH4f728dIVbEtE1ItrEiCnvnep6kqaDDBwgkEpuHPneCN7wwKvzxanFwi7ByY2mQbPO_DHxnbdNMEcG8I8yJV6K9Ntd-MUQZ6kntkqkpKcJ-3yQq7t7a7N8FyGuM3K2h2pxTZIegZV1bxNFWDsqiVFt0LlAJBznLibnP8T-XV5xjPCChkES-gbZGfTWeWB9pGVZnqfI5CYzsP0ALW8uf39yvN5zizngFc1J4XrKejLxSsp6ZqsV0vqNQzNyyad0YJWg5zUGN407RS6gTpXh_5di9PnaXYjSPCsSl873US1dcIR5Eh9hvxnQv0fdQTN0FrJ9pQdRAnTMJ7ywzhu5Ne6By3ySnGFyOSVPEjI7EeuI7Hc065ylnc72tiHu0Tdb_7bbnX6g_h1LHvl8MpRdX-OI4KrgfH26wIz1Qf6TkLY4ecrWydqZxoLHT1YKb12Er8A7E6RaYNnSkeSjU3arBxNR9rCxoc9tlCJ-W3DpBxCjaweFh92Xoucrk=w1049-h553-no"></p><p><code>Bus</code> 클래스의 인스턴스를 선언했을뿐인데, <code>Bus</code> 클래스의 <strong>수퍼 클래스인 <code>Car</code> 클래스의 생성자가 먼저 호출</strong>되고, <code>Bus</code> 클래스의 생성자가 호출된걸 확인할 수 있다.</p><p>서브 클래스에 해당하는 객체를 호출하면, JVM에서 자동으로 해당 객체의 수퍼 클래스를 호출하는데, 이는 **<u>JVM에서 서브 클래스에 <code>super()</code> 를 자동으로 생성</u>**했기 때문이다.</p><p>위의 코드는 정확히 아래의 코드와 같다.</p><p><img src="https://lh3.googleusercontent.com/tavQZlcHE083eVVugW47d69aa0HhmRdIVHf4nC91K78PHYm4k13swsmwbIhjYA8vNaIXvP2NrYCVwLfWAHwo9tVqKroA16TEvys6m--812PmZt6t7WqCO_fVeNyvAbGysrENL9FjYSTBT3XwvVob82lRvrQGEhph9dccp0ZI-XVX-k5nYXvPwaLQUWPvs24pV7aleWNHvD13KnuRk_HNenr1xYr7lnx6DqP9TsaEVyaRCkcwWXp81ZDOvvK0-j0wzkXLYU0QbaAidRmWPHu-N4HjIKOMuqpb2-u5knUYkLhDzAIZg6BngIK0tnjjFFS_XFIK5OPZWJG8hZqGEO6AR0_8GkXoOEmND7R24sdEMDmuXSqO_YyP9EazOUM70scuZXuom7efa0FIYTDKQJxxHmnq5IDiC3k3CLn8_xFwADXG80bgo0ZSzQcuTq2ATMx2O71Sf242f0aMqc3_z-P2N5Ci7jy98_YbQUQgU0wXy0SJ_ZTIPIYjGplosSMOy7g0GgU7IbuFPIYYMAlGEXd-geX5DK4PX3gJuAufSwbNHX8X1CConFTrLOdBBJeW9NEq0HkiKK6nNMgMNyU5hGdQVR8rKRVyrwh6iMp2jwH7IJFcYnYCayb0FFE8ROsNGzu2qTc-LCVs-ZM41LkOFHzfLkP1Ub70m4L1FzVC7AT0T2j-W56jkhyBYKv5oUvcy2_sZEyHsAtRIFxJzURw1vL9tskZCCJIX-72lYgU5dKbYDl0b_XdWGmMGtM=w1056-h538-no"></p><p>달라진 거라곤 서브 클래스에 해당하는 <code>Bus</code> 클래스의 생성자에 <code>super()</code> 를 추가한 것 뿐이다. </p><p>아까는 수퍼 클래스인 <code>Car</code> 클래스의 생성자가 <strong>기본 생성자</strong>였기 때문에 프로그래머가  <code>super()</code>를 생략하더라도, <strong>JVM에서 서브클래스에 자동으로 <code>super()</code>를 생성</strong>해주면서 수퍼 클래스의 생성자를 먼저 호출할 수 있었다.</p><p>반대로 수퍼 클래스의 생성자가 기본 생성자가 아닐 경우에는 프로그래머가 임의로  <code>super()</code>를 작성해주어야 한다.</p><p><img src="https://lh3.googleusercontent.com/zqpaX4jV95gkUv0gBy9j-E9u9HnVfZjB_bSfJjcSYhD_90MHMJHuIbVLO_HLYPq9DB_tO1xnTkhoKrcoZT7uOlymn769AzLXoTede7s7uFnzAhtBTIe-nks46SRlpRrAX_LOI7Wt8dVWCKOX52k7sdCrKH2HibKJzSddG50-82WkL7--LUcxiCryPT3EHY3nF5dWe1JSTZClBEmn2-uXm4fmbMA2kSFCeUZQUrCVDQMwxOW8TR5GWAtyzh_XlRBhATk9f4ZLk1k61v5HHazzNTGX2DK3OBiUBFR8hnAPqeqTTvZB5vatwta-zXEugvtaz2Q31ONTpjzO9RDAzCMN3QNE3LGlEUQdMLFhy7fSEb-W-LDofZYmwgj2wbAUGq2__w_zfdCu806fVUckLP3z-XNHMTuFpTdvPetnefnz4y6PL8LzHXUoxMGQ1aHsSstKQoj-UkqSihZDrniSqL7ecySy8WXiEXOxaTVpDJGj-PgtrxzuwX1Hmb_OuOIJnJZBYzxe1VYap5UGjjF-cdLJSHP9XIffIM5SoI6_HQham92RJtVASuKP3DHN8a4dij92-BM0lEzS9jkw5Tskd1AtjxID3cQy8bjjh5RfX2IcR7j0_Aytg2oMBYBbFirHCVaM-1xikuan9sR_OdwI4lbpD58lnTgRlJqZaqxVJmY124MRgqYUpFLyBBzoErbiPVAhughgW3s_KpMwXxIDS2zgnkdFpbLwkcSanxO2XCpDz9KkB6fLxjbrEtI=w1034-h426-no"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Implicit super constructor Car() is underfined. Must explicityly invoke another constructor </span><br></pre></td></tr></table></figure><p>수퍼 클래스의 생성자를 기본 생성자에서 파라미터를 받는 생성자로 바꾸자 위와 같은 경고 메세지가 출력되었다.<br>수퍼 클래스인 <code>Car()</code>가 정의되지 않았으며, 다른 생성자를 반드시 명쾌하게 적용하라고 한다.</p><p><img src="https://lh3.googleusercontent.com/czEAAssjODQcCg0dwXWtv4T7FpjkfhczyfEvWo9WALSO1C0YUqYOjMqLgePutEFwY7Hax5NAmzOLSicZrwdVzOPEzmRRUSHbp0xwTTPle5moyJUBzZGtjDgT9HcQ6_Su0wBXo-qjorynbFlikrtWeCox6q4IR6LIt7W05-uH8FA5RxnKiInpd21Bqg5HQhIehmaskyIro87hJlsefZh_3zx9woXP8-lXpjSgXVGKIjU6dgoJn1-XB6rim59Ads0vlw53qHq1xSw_f7_V8h3mb6qjH4zAWB7v1bRTfLLm-FlFWMhrWWJhVm5Q_L2Hdf-T3vp-UOwcNYRgxVaAFfVW_aLhHokcvNDiYR2N9UJNW-hmkGBISrgB4WefTtMKf5TFG0AqEIZMuxgmG1ggag-93fNCIOp8abXyOQZsDAix9RhX40_xG80pyXal9RpUjwcMD-eddw94Mel8nD1zqQYISegX745vsJh_bJmDsENozp-vf-k0i2gpNH1EYuiwjKacIzbN7W9zMtYsHOsaMB56Yi8V-oEHv0ruWP1IrlxUXLfpi6tCA6m2SH4kVm9T187B8TM9T_7ByWMc5WDZOxpFiLttxJPplBib2OazHyPv6ophNL7t9Gm9nJ_L5rEfaTPhe-LqnwhFa6NijsH6nDd_uVLSr5Tm7KIt2Cv9a-OzMLOHLqBWkSAlzL3i6EjKuUyyu3Pfi4lF19LmVVsmIX94TMHbO8DClTVESAvLeGkA38upaHf4vyQ6pqQ=w1030-h537-no"></p><p>서브 클래스인 <code>Bus</code> 클래스의 생성자 내부에 임의로 <code>super()</code>를 생성하고, 여기에 수퍼 클래스의 생성자에 주입할 수 있는 문자열을 인자값으로 넣어주었다. 그리고 서브 클래스에서 입력받은 인자값을 출력할 수 있도록 Car 클래스의 생성자 속 출력문도 수정을 해주었다. 정상적으로 출력된 걸 확인할 수 있다.</p><p>이를 통해, <strong>수퍼 클래스의 생성자가 기본 생성자일 경우</strong>는 프로그래머가 따로 호출하지 않아도 JVM에서 서브클래스의 생성자에 <code>super()</code> 를 생성해주어 서브클래스를 호출하는 것만으로 수퍼 클래스까지 함께 호출할 수 있었다. 또 <strong>수퍼 클래스의 생성자가 기본생성자가 아닐 경우</strong>에는 프로그래머가 서브 클래스의 생성자 내부에 <code>super()</code> 를 명시함으로써 마찬가지로 수퍼클래스를 호출할 수 있었다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - 오버로딩과 오버라이딩</title>
      <link href="2020/03/java-overload-override/"/>
      <url>2020/03/java-overload-override/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/qzIG1H3x1mt_b4_MZIsrDLcUP5lJaaOEWY5O35A29UbXW_2F0bX-8MkgBrEuOsIEq-8b6jsxqQJSa4yVVCQJx132yZFXa9Mt_-SXYszcW1ORZTlWbbIpmmjCrkcp9apJz7FmNN2gi5y-OJZgVT33mLIj8TAGTVWD8B7cKsloRs6Qwm5wwfo4HPZQBwU6HKyO3r4t3rBKRUfhLI6hL41g6Xa1M5pJpO1taJkYqO40nnVP13yfQ3SIQrxepoK2S3FRgURlzRVlhX71WmeRy8yx4LnoOMk-TVSr5n_RnRxKPFoQR36VUKdqxpb7E6HyKP44KIQ6rvy38apd59LdHegn-a27S31oyV4c3ZLqugkPZS03d651mZxPOQVd2Q-ZfIl6bXMDMbx2nk_2EdiLMlsTX8DsE4ebW9BCXEPbc7VQidS90hwKuO84_k12CHsSidBG1y8pk6_lHKN14kdEQYuRUq7IugPEJQopvbUFK4JF6jmm3ldBb464X1ysrUHl_0g5dm0D9lqjlvzIkhmDyzpnP_WgLe7p7O7k_huSKFGT56sV0OGL5AbuQVlovAh969UBPDz1HxJF-a5A_GPmoxJmpVrcKRSiMSQOGzPpqUsgD-QAucGiBGx3qzChInbyqt_mdnMCbuQ-16mZXizobP--EiWC0RFriE1c98Im97WODHwRS3yygZkKKto6SmM9indBwsfY55FvMYIZ0xjC5GwrWwe2_GDGMGHSIefEC4BmFrOp4J87tGphMx4=w720-h350-no" width="650px" /><p>상속을 배우면서 빠질 수 없는 개념들, 오버로딩(overloading)과 오버라이딩(overriding)에 대한 부분이다.</p><p>간단히 정의하면 아래와 같다.</p><table>  <tr>      <th style="width: 25%">개념</th>    <th>설명</th>  </tr>  <tr>      <td>Overloading<br>오버로딩</td>    <td>오버로딩은 수퍼 클래스와 같은 이름의 메서드를 서브 클래스에서 여러개 만들어서 사용할 때 쓰는 개념</td>  </tr>  <tr>      <td>Overriding<br>오버라이딩</td>    <td>오버라이딩은 상속받은 서브 클래스가 수퍼 클래스의 기능(메서드)을 재정의해서 사용할때 쓰는 개념</td>  </tr></table><p>둘의 차이는 <strong>오버로딩</strong>은 새로운 기능을 <strong><u>생성</u>**하는 것이라면, **오버라이딩</strong>은 기존의 기능을 **<u>변경</u>**하는 것이라 할 수 있다.</p><br><h2 id="오버로딩"><a href="#오버로딩" class="headerlink" title="오버로딩"></a>오버로딩</h2><h3 id="조건"><a href="#조건" class="headerlink" title="조건"></a>조건</h3><ul><li>메서드 이름이 같아야 한다.</li><li>파라미터의 개수 또는 반환 데이터 타입이 달라야 한다.</li></ul><h3 id="예제코드"><a href="#예제코드" class="headerlink" title="예제코드"></a>예제코드</h3><p><strong>Car.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;차가 달립니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bus.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;버스가 시속 &quot;</span>+speed+<span class="string">&quot;km/h로 달립니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(name.concat(<span class="string">&quot;가 달립니다.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String name, <span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;가 시속 &quot;</span>+speed+<span class="string">&quot;km/h로 달립니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CarExam.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bus bus = <span class="keyword">new</span> Bus();</span><br><span class="line">        bus.run();</span><br><span class="line">        bus.run(<span class="number">70</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CarExam</code> 클래스의 <code>main()</code>을 실행하면 결과는 아래와 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">차가 달립니다.</span><br><span class="line">버스가 시속 70km&#x2F;h로 달립니다.</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/B-_Q_ivyb-XMF0wRUE19wqrPXMPwwoZYFIvfZOcUj0Cfgb2QTXQ1RSPtX4kziNMy4uO79FlNK4bEdtsrgf_odNasuuYraALbNw0hgWjvPIZpADsWhU56kVoLYsl8jiMQss5pnl5XM1UwbtCf_O4G-uE25TV_iPWrvpyt0Pckfga8yKzWEcc37zRrjCn6sryGc4Xj7GhGgJZOFkP78t0qAp-ABmqp2h63OpyH0Y6encXj23lXq1ktrOY8jg2OhFguBJTdckj9sLLLS7SCsUBNQrKWdWALHnDHENl6gDBKrXppYOWNcJKWAJNyvaKeL8XMCuCuA4dXcQ_P7kelCIP_kz0Nhl0Y6b7esQtCeZDp65aP__2vni04g7SXi40aJHyomtvHpngfValdupDiNj3kx3nUEe_wBTjGmHbSt9dIaC_jH_d-wS3LmlPUglBzalfFgvyYebT6uy2wqnL-rUZyFReDvg_l9Udz4zfkWL_4iyQRZ2cVm2FMQ7LoGWohd1jBE_R-OWmmDLSgEiUyemNrxwiJSibDHtqeilvnC-77xl6Chmdc2dBM7Ezerwzd8j-x72I9_PF45cOIilRHandcNBmYWze0is_umUWPdogJEzksV8WDHs3d4-dA3mkrDPXQAuEe0C51hfHhkj7Kn1uLEXPadzvgP7UE3N0BNZIn8fXRIc7AlPcsbhggaGWEoI7HaSIf6MA-IOXaJsQADtcJMQBDxs0c0p7hFXN7k-ukGB5W7I7h1ELKiPU=w1097-h726-no"></p><p><code>Bus</code> 클래스에는 선언되지 않았지만, 수퍼 클래스에서 선언된 파라미터를 받지않는 <code>run()</code>을 <code>Bus</code> 클래스의 인스턴스를 통해 실행할 수 있었으며, 이것과 이름은 같지만 파라미터를 주입해서 생성한, 즉 <strong>오버로딩</strong>한 <code>run(int speed)</code> 도 실행할 수 있었다.</p><p>이처럼 메서드 이름이 같더라도 파라미터의 갯수가 반환 데이터 타입이 다르면 서로 다른 메서드처럼 사용할 수 있으며, 이를 <strong>오버로딩</strong>이라 한다.</p><br><h2 id="오버라이딩"><a href="#오버라이딩" class="headerlink" title="오버라이딩"></a>오버라이딩</h2><h3 id="조건-1"><a href="#조건-1" class="headerlink" title="조건"></a>조건</h3><ul><li>이름이 같아야 한다.</li><li>파라미터까지 같아야 한다.</li><li>반환 데이터 타입도 같아야 한다.</li></ul><p>오버로딩과 달리 오버라이딩은 수퍼클래스의 메서드와 완전히 같은 형식으로 선언될때 오버라이딩을 할 수 있다.</p><h3 id="예제코드-1"><a href="#예제코드-1" class="headerlink" title="예제코드"></a>예제코드</h3><p>위의 예제코드에서 <code>Car</code>를 상속받는 <code>Bus</code> 클래스를 추가 생성했다.</p><p><strong>Car.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;차가 달립니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Bus.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bus</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;버스가 달립니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> speed)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;버스가 시속 &quot;</span>+speed+<span class="string">&quot;km/h로 달립니다.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CarExam.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> devandy.java.inheritance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarExam</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Bus bus = <span class="keyword">new</span> Bus();</span><br><span class="line">        bus.run();</span><br><span class="line">        bus.run(<span class="number">70</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Car</code> 클래스의 <code>main()</code> 실행결과는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">버스가 달립니다.</span><br><span class="line">버스가 시속 70km&#x2F;h로 달립니다.</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/2Av01DJi2ReskudERMNo3NR8cVXpeCpOmVYNqVJI2mxTXXvVOXWhLlXhXndOmo55mKTGn0TOnyabJRLt3L0YqkdAE10bScdYabQ7R5ueZzLEWmANsWgQ8oBMMDZ3nXhDe61NtNgGzpst6qo8J_J9c2yMMRXRe1br6b0Q8AJ2emVwEx-V0w6V-LcIsLiM_JSoocC8_zGKi95_pp5V36WMsTewE9ij-oxWzOtixb5m1uBl57hKIIUzzefrYA1samA-GbaVddAXLvHELgBQkwiWHpz7VZVzXcgH6UDnLvkD5vaVCXUZOu6AUp1VWcbj255fWk2HAd3nEs91y3AE4m_yAMQXTJ-5Ufk_vLLunCzvRqf4k4_iAamU4b2iZyhq4xMJ50uRdmEfnFod_9mMHjExmN0nSK9l43IJ3mMeorsYAQVHuLhDLswGNTW0BwnQOKHCsMYf03TIbtVLTYHMufav24kbL6-JfZUTpmTTEuV1WDf5xtZ5afhsMTDplx8IL_r9jVvej57RRQ8wx-KSuB921OYhXJ0at2iPJdBk9yRON2ODiAu34aj_CXZ3Hw5NvOzB7Um0uSCrgWNaJRKAjD-XxxsXhZd7c9AsBWJ4zOa4Oi3C09PQFlD9h_2Lcci1H5qRgJLKV9ONyDNz6cLogHCb3-ZvVMbxWhKc06eTflR87YqcpuRqQOrsY8B114qTbj7oTn3uVyBA8-D_dbqaBDBKNZYQI7Qb9fRsiDEI9eylXApl7IX3o0ZIEiQ=w1138-h727-no"></p><p>수퍼 클래스인 <code>Car</code> 클래스의 <code>run()</code>에 선언된 print문에는 <code>&quot;차가 달립니다.&quot;</code>라고 작성되있었지만, 서브클래스에서 선언한 <code>run()</code>의 <code>&quot;버스가 달립니다.&quot;</code>로 출력된걸 확인할 수 있다.</p><p>이처럼 수퍼클래스의 메서드와 이름도, 반환 데이터 타입도, 파라미터도 같은 메서드를 서브 클래스에 선엄함으로써 수퍼클래스의 메서드를 무시하고 서브클래스의 메서드를 사용할 수 있었다. 이를 <strong>오버라이딩</strong>이라 한다.</p><p>다시 정리하면, <mark>둘의 차이는 오버로딩은 새로운 기능을 부여하는 것이라면, 오버라이딩은 기존의 기능을 변경하는 것이라 할 수 있다.</mark></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA - 생성자</title>
      <link href="2020/03/java-constructor/"/>
      <url>2020/03/java-constructor/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/ml-iZ0-FI_yZRtVV7aD_3paZvY96WR0cPOMhCIE0OieC8OrDSJNrXgTELF844nVrVoYZzQkEwrh8Ey_MOdV_ia4b4B7jnEFpskJ1siyO9f_hTQUadlQkTE2Dgq0m116wID4JUiVIrO3B3pDHLrRSZhswG_8IYx05FZrfINLrw5zjFb7_5D9gYBJ8q7eQCz-I-kWX4DBJ6JYX8Ls61LocMHC7SlJY38cjB5Dzcl3Zc4P0Vbr0bGohNkS8iQj4RpmfdSotar046nhKEAnAyBhl60Mi25kWRMBZ02PVHyhbW4ZJx1XRktP4AQQ8mJH94RmvKMlrfm5ns1LoRqLODnS1yrxvso4yJGxZd8KKQREVG_Uk-tsYXPPLNFcZGoqh0CGBPvlDnB8RgpUgv_4WTd2-my9F4pBB2MReWORevyq3o2nvaWpBiOz_7gFmUYtJYmiXlsyHtYFBP6UmBhuWKh2MFg3YTfcKkpTR-7tpBh0PRiN0wvB7k7-nYvsUaTrQhk5NGI-NNhLontoEVKZnPQIrW-5jOwzEGcap6fJq1-EJWMH3aqsAc_unf1opxGyxzmsVORZhEq7h9K742T5FoyYBGbFygOL8hhI-_voqZyKyeuiFvV_S0elp8BU64QjwiE1Vbkml0nJIAUIw52BgKZnlrDXDXlp3Y0HW4-72ma05nZcQaZv4Jc6nVppAVtZJ3JoxCR4utDVFuyDOa6a2psMQSO9GMeaOStlHCkemHgZpSV0OS-iwI3ntHsu_=w1108-h708-no" width="650px" /><p>생성자란 인스턴스가 생성될 때 호출되는 **’인스턴스 초기화 메서드’**이다. **<u>인스턴스를 생성하기 위해 객체를 초기화하는 메서드가 필요</u>**한데, 생성자가 이 역할을 한다.</p><p>생성자는 기본적으로 메서드와 동일한 역할을 하는데, 메서드와 달리 아래의 두가지 조건을 필요로 한다.</p><ol><li>생성자의 이름은 클래스의 이름과 같아야 한다.</li><li>리턴값이 없어야 한다. (리턴 타입은 생략한다.)</li></ol><p>생성자의 조건으로 리턴값이 없어야 한다고 했다. 리턴값이 없으면 리턴 타입은 <code>void</code>가 되지만, 생성자를 선언할 때는 리턴 타입조차 생략된다. 어차피 생성자는 리턴값이 없기 때문에 아예 리턴 타입을 생략한다고 한다. 이는 옵션이 아닌 필수이며, 반약 <code>void</code>로 리턴 타입을 선언하면, 다른 클래스에서 인스턴스를 생성 할 수 없다.</p><p><img src="https://lh3.googleusercontent.com/bl-CWbnejUqhiJ2s-vv0LtlG9TBEt6fAq9nyEB3bw093xmbWHb4jQbAXLE0L9vI4bA3jMEGFENypQI3x5HRaw6E7QJCddrV31AsLH4x43lSLGCiXT7eNeRJInPlQmNkAY5msoOc0YzNB0-kuRFxwFqPwvOvmL6pRB0pj8vjH1DrP7xOsuTzUHKKySaSL-JxOLFlOFEDYuogTtkDMt1SWVGmq4nD9pOYlcqdnMEcD7na5w547CfTTO5XQkHuIUu3D_FV20HHOgtKtAZcig1BJ4AvibwUtUJqC4ECjGfEEINZnc-nQ-AijCoDtZ9Lq5ip_J9DUMTjEQ9axIOm68COJaMZoQWuALqFHlDf0Qb9BLgLXYRj-zcWViThnSfBzWwtqc0MRW17eYbUBTkDaJk3qnmh7lTZaSyO2eZqI9XynPFsyAhQ3cLbiDhnjsZoRocilpx6J8RqV8KBZPEbtJL8uiEKL1oIEY6teebw-c3ohSry6Vd8iubTWhcnh0rn5L2hcR3WorpgPdCMZwyuNDcU6B1AF0LL8M-76OsE-MUJrTT5BNSvt-ESLClUO_ybkgEgwtRqYc03mqzD1Rexgq5BuD2R-e4lh2gBsoEFOUS60-k1JYql1WuISKR3kZ1Q2m8_2qwFzIImXoI7U9qgnRi-wJ3Sk3JTXLn77Ap4_SOp4qfMTSfCy0P0QCFo7_K5bucZblAccHscNM422Jj2NKuJRBoJukvq6wBpnMoXO8kMcX1nG91m1GXc_oo74=w504-h483-no"></p><br><p>생성자의 예제 코드를 보자.</p><p><img src="https://lh3.googleusercontent.com/0Rv1EqLm8f4fl1Gy_rZhZ5lOzfSkn2cD2uu0jbui6f1ri8TpouLMYbx9-v82VRQ7aqN53TVJ4FzTSTq8Nz8w0A3coVimjqJBNJm2DD_a20hv3yKTkHTmx3B3gOcLlIfCV1EB41NDtXGVecXlWrqzaaKxfaV5UqNN70vLVxbDWlT8PrWaS6PJI9TbU5vwcS2RpxTK1Dtz47FFY5HnCeBK79ZAlViKS7dpUWWjA7zrwqwIcG_TpQFGaxo94x2JKtB2zJAaGzQP21273DF-Dlic6kc7pldpPm2gqESTAOdaQ_1r9OX9OlgLp_zhkPGKr9UCLiDAgHoE4zv5281tkJId03XA0ntqwESI9UcdBc4Ed1CvotdZr7mNha5d5eZ79V6Lri4eGQZj1bl1e3zI0P33DCIJMTP3iFpIs3FLcUlL4sETiDmYLrfiV_4m-sNtYPrrw4Zdt8l3rJyBNgR-ZRTAVeivlhUVpWFnHiU3AWh2v6-0J4NFXAVFZUbTmclrQQIv47oMBvcoI2TZz3d1WnJz13TQFot1pcrCZzESrNbOPJTUuNIPN_8IusxbN7vpfWy7zJB0I3uOFX5T_hI1d-09hF6vM-ZtpBRouxA_dhxB2rNJUfrBiOGKql1Q4VbZoERIQ6YfQpr6Y7qT-IBU0S0xZg-iWH9uhNezveDxVgJUqbUF5FGZ7iNhRona3hfbdS2rmWJrLjpQsi-adJTjcLTDLygRtS7jTAo5Ow4juxVbW6U2k5Zk7sFBViVh=w778-h477-no"></p><p>Car 클래스에 String형 name 이라는 필드와 int형 number 필드를 생성했다. 그리고 CarExam 클래스에서 Car 객체에 대한 인스턴스를 생성해서 필드를 출력해보았다. Car 클래스에 필드명만 선언되었지, 값은 넣어두지 않았기 때문에 null이 출력된걸 확인할 수 있다.</p><p>여기에서 Car 클래스안에는 필드명만 선언되어있지만 사실 Car 클래스안에는 기본생성자가 자동으로 생성되어 있기 때문에 CarExam 에서 인스턴스를 생성해서 사용할 수 있었다.</p><p><img src="https://lh3.googleusercontent.com/ZPLkfZIHV_L17QG2vx694ccWm49BNfuoQETcWUeGhvQl-xAH6vYAeyGfHGoqSnHW4HTtwE1_fhF_UJusfjr__kwi3pCxYuMqiRlQIxPT3Fx3Zjv4nNd9vfzRjxAVy_yQE3eLBNbMEXI49EqGFbQK7ezhF_dNlnboldshLRiKoS22itxGfkv82DQYZgGM3Qoyr-DHTRsenltEsvUy4RwuqJZacccnsXK6NOKEl3cl-Svb0a6M9jrrHKKBB8TsPF3r1ul69eZgeU22Ndvog6nj7Riyu35fgpxdzDgW3bA3wK4Xi7eqampkyoyPxVOik0He5iLcFtvX-yohPuiZpRhjaFMgssNGXRHLeaVw91oePmaTwAwnFz9a3HscTiWHpynnNoD-fHkD_L2em6SLivCNxhuZ8GdjiqK84HWVRs8OEX0UbrzcOQYLZRgLTl3mv-K_ZLakj02GGmyiBh5XReAMdtGl4EMkLdIeSq4ymkRNDCUyVmNVQOXuykZs-cSMjrcgYT60X3sUlQG_2Vwr_hTW_O-BsiqtK_j6WDG9Xrbks-fUhr5fFeOwQCoOnqClLcf6iXLxvkym8qKh7vNSbQuYuB8f6G0K6MNd7mUKajVgZ9XUdRpkugfjVHUZRadd8RCzH_Au2dkuj9vhNVWoo0qGqmJPRAiURucQ9mIwFzsq29nU5AIiCBGxylctOgyyq-EAX4kfFTz_5ZCob23XwUsfTBBgy88iPoJh61Y8r5xJi7K3JyF1aYPsAZ60=w823-h483-no"></p><p>이처럼 <strong>프로그래머가 따로 생성자를 만들지 않으면,</strong> 클래스를 생성하면 <strong>컴파일러에서 자동으로 기본생성자를 생성</strong>한다. 기본 생성자는 위 이미지에서 필자가 작성한것처럼 파라미터도 없고 아무런 내용도 없는 생성자를 의미한다. </p><p>이렇게 컴파일러에 의해 기본생성자가 자동으로 생성될 경우 각 필드값은 데이터타입에 따라 아래처럼 초기화된다.</p><table><thead><tr><th>데이터타입</th><th>값</th></tr></thead><tbody><tr><td>int</td><td>0</td></tr><tr><td>double</td><td>0.0</td></tr><tr><td>String</td><td>null</td></tr><tr><td>boolean</td><td>false</td></tr></tbody></table><p>단, 프로그래머가 따로 생성자를 만들면, 컴파일러는 기본생성자를 생성하지 않는다. 예제 코드를 통해 확인해보자.</p><p><img src="https://lh3.googleusercontent.com/07KjdJTy3cz0mojBION4TjgMEHrUYwnzX-RsBXy2uE976SgVCwe9guDQCCN0J08zmdYngezkc1njWfomKD6tcE7ZyH3Aih0wWKOyxiF8m95gTW7WCDWWUpzdStLrBisufW6crmURnDXtqSHvYhUN2C0LHauDpLyq1XpBafQ39zu4ixQoWU6LPWAQGgLc9eyqMYXmm4qJx0yZIrdTPxfzLpW0azmgjUJ_wiGUsDPyeCUzUaDnW-YCIy2fghALWiEPEZrGAQVQpU4nH-qhPG8-M0KVKD5VZIhtLk3n48U2AJXM0_njIJuQWzncA3AcpfucmJorccXdNxJk6t_2-5r_-ZLsoN33BkzLbTBtCr_efWqs1LkoJfQhdU3G1zkq5uUwlgeONSx5UiwXKXY6It6MFAA0X_XTNfLmxQUv8bw6B_jrH4FUqTwvzDnKH9P_oNJ2_MoMBFSFVcQd1CUU2i3qlBhXSwrts5V_YMww0btBIoiw0vqilMwNJKH8Qpg_I120_eaNpv5po772EWXsTLoxEB_KcICNbR15sbF08l7wkNqrhh4kWAt5vkjMPM1UWiX4TW2chrtpgujhRU_crB3qbravf2II7fMsAaBMhQdhkCp1gh_9_qqc6aQvy3knYrXFZDJ77UOGljCt5KBul7qpLl31KFkfZxvht84tPPz-YoG0Xf9mS5bCS4f_Wgpeh9tc9wTfukSna41vaiAT7bQ2UmNXPuD-NggE-q_b84uQwww6_Is-dSiiEkU4=w845-h357-no"></p><p>파라미터를 받는 생성자를  Car 클래스에 생성하니, 아까 작성한 인스턴스 c1을 선언하는 코드에서 에러가 발생하는 것을 볼 수 있다.</p><p><img src="https://lh3.googleusercontent.com/koCx6Si7EkJWtCCFmODK_LntOUq3RtlNPKrWeW3gKOe0vm5IrgL5RMaTA956wmhsggwJ9pHvs6FqFDNOfiC0Jmqa6HovaZs2PTodSK5T-pFEadDiUxnWFWOcOkX0dFW3vIo9P9-hf8T-HVZpt8FMaRS4oEqdEH7RVq_I8vyLUQ4LG3SxIaeU5Afzr7uM4O1CbNUFy2IgGEcg6mSUere9gX3bM3E5qLVTuE7UtSp4kOfYBwVNu7ERAO0WLDSW2Eqa1aWs7JfzUA3PxB8v1OPQnS7wEF35cgmcKsghqswjohtexW8Br7gK9SxnLlDRI9Jsgc6TEnQeQay1960X_q86nnvruMy-juVMUdzoISHhuDLH7iiZ9aAWjnv2WPMyvGDe9n3zNX6D9DKAzwwHG2nsn0wjIGoJsouXynvrBNAePmAvELHiMk4EEYnL2MV52EImzJmJjadlRO6pLKj9tsldpaaaoytufSex1ANqtSBSJr7KpEu46UmRDXkWBYtz4IBPzwEIYXtaPL6LuOhzIwpAadKZeGf3FPE0PELs37-Mv4fUc2s5GbwPjrojCwPnRFdOY-sZMxgsBhEwgSEGfjGnZKX5wA29EHcaTccpTGsMcWF6J6NcH39kyPDEcmFZkhg4zpRTkWlkaq9wLt8v2q8a7-k7imfmIak7QpQEuURPX33MdV1rHAsewBlwZPsTQGYID-_B45YxMZgryQjvK6BQsRJEhRgsa2YFopP0JEWWH_Z5wfDI-PfElF0B=w312-h169-no"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The constructor Car() is undefined</span><br></pre></td></tr></table></figure><p>더 이상 컴파일러가 기본생성자를 생성하지 않은 것이다. </p><p>이렇게 프로그래머가 임의로 생성자를 생성해서 컴파일러가 기본생성자를 생성하지 않을 때엔 기본생성자 역시 프로그래머가 임의로 작성함으로써 사용할 수는 있다.</p><p>기본생성자대신 String형 파라미터를 받는 생성자를 이용해서 name 필드를 출력해보았다.</p><p><img src="https://lh3.googleusercontent.com/F8sNTb-R5joCEqdrT9v6Mf54XiZExBfMtnKE9-w0taHzWn7HCGk8QZOlekVoC5BvBSQ8oCW3pwKAfTu1AumW1Mvrq973ETa118Jg3twSISD-4bPSZU07Hdj9IzdTb1ElXWdLN0WAhpK8MirsckXq7qApYvfIlCFb_wlml2u24lm4O2ScBzPfbCvFk4Q0aQUyNdJ1kCpa3I--CrwKd0VUn2y1KDEVj_ICcl7JT4pWk-8pLzPCS8Ib5upp7HMW5EF1dhIPh4MhYIPiFIfMU7e_DMy5kiryjopxfYazmpPh_oqD3t8IzV2j2DQ8mnHoh6g7KC-u3mjZJZJAi30pJYTyTQq-1-XNRGEVTxz778ehKCBO0EstGs6b1xIvnwpB3wz6i0x18Vj7KXeYxJICUHcBehWp1AmbYdyiXG1UGsUFM1-ZYrvIY_axJmztrWEJz3IBmhwvyMCifrpWbol7qhsU1dq7t3tC43ZlxcGtA_pgJ3FXS2vR_jXCbZLyHejGyFS_oY7r2Xy9fmZiqsyvlvkHg9SeUC6D5ip3Cy437ApGv07VfwbtUjinUQ2nIyYfQjZlqGjq-r_Q2hz_jlq0T0DyrTFZIntot6rWvrNm31CXd0M8J1FMJOqXmp5YVbN_-ANXlNL6DPKXT4TJPq4VUR5X4VX6_SDZx6uYozk400_8ReBk4fwjYuTU0wu0drpLgVKBfAjFGlNPDqzyK8xR008zCIcn4-OYUwlSwRi_StQjqHOuE7Myv6TQgN6h=w857-h474-no"></p><p>생성자에 String형 값을 입력하니 Car 객체의 필드에 입력되어 CarExam 에서 정상적으로 출력된걸 확인할 수 있다.</p><p>이쯤에서 생성자를 사용하는 이유를 정리해보자.</p><br><h3 id="생성자를-사용하는-이유"><a href="#생성자를-사용하는-이유" class="headerlink" title="생성자를 사용하는 이유"></a>생성자를 사용하는 이유</h3><p><strong>생성자를 사용하면 필수 입력값을 강제</strong>할 수 있으며, 프로그래머가 입맛대로 인스턴스를 생성(오버로딩)할 수 있게된다.</p><p>추가로, 생성자에서 <code>this</code> 키워드를 사용했는데, <code>this</code> 는 상위 scope의 객체에 접근할 때 사용하는 키워드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    name = name;  <span class="comment">// 아무 값도 대입되지 않음</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이것처럼 Car 클래스의 필드 name과 생성자 <code>Car(String name)</code>에서 받는 파라미터의 이름이 같을 경우 컴파일러는 nam을 인자값으로 들어온 name으로만 인식하게 된다. 따라서 이 때에 this 키워드를 사용해야, 상위 scope의 필드를 적절하게 명시할 수 있게된다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scope와 Static</title>
      <link href="2020/03/java-scope-static/"/>
      <url>2020/03/java-scope-static/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/Kla9BkFl7V_wmrZF_Q9B4AfxWP2J5neLeNojx71GXP_CqLFmwILCJAF6jhukK26xfpX1_o3zRVLNk7xbBl_sGfGyAXNZbgPhWZEr_BIZTnaPe2fZCqCQ3F1BvkCkqdii-TfLSZnSxuuzbF4jtWTPFowzQT60lCETgg7C762Kxh_sJsajr3kodNozSmXIeVXtBhRzdkm1RMxs59ffakpd3Pfu0xQyTlb604pSzWsX9DVR44Zq9w0yUoi2TvB9XY_Vk9Qd894_2V5UwSmgAdE_7Wz2m2LYbrBzT1lsgo5DwlXsRvLz1VNQbAfdneOfddQhmDsNQU_y4EYxJTZblpiLSKxG2qPgZbZbT1pbKSRRXSTcLwvhwSgtlWRyWP2GOI0SWEYm0Wu8Dyl7FkiFMmGxiDBrkkntbS4m2_0G9Qfinrcoqhd88D_FUegQxYPsmNDIEPG3bs5jfOXIrs0ipgJu6ChuqabD2YGUPwXgxk3WF1cDvyjGbYIjA_Lzbc7kPo52aqhyn8iq05hn_rRFFu9wbUsT0mBHT4RTXNgdJVrEHSAK9HvkOuB0KhfjuMKOaqw3sd2E-PD2EK1vPRf5HblQPq6NrW5eFGKqPxr5Cz_gv-6qW-3B-laobBT_9YnQ6yiQAyhgDyt85EG2_1B2Coms93JjJbL1C_4I0s-OHvjHaLkvRhIYfJOIRh_y6Od2Y1nat2mepIV2InTikhVu7q_dUm3wTu_ZUUWl1pkcAjHlASUCljAXcnKigko=w1308-h884-no" /><p>위의 이미지처럼 <code>Car</code> 라는 객체로부터 인스턴스를 2개를 생성해서 <code>Car</code> 객체의 변수 <code>wheelCount</code>를 사용하려고 한다. </p><p><img src="https://lh3.googleusercontent.com/uhzdNBjVBwQCoH_UYHAlcwwkbm4KEkLxLdzMRv9EWA5AMuPSsgAC7xb_7_gKenuDm5cD8BeW8XWv2fbQaRNbMElXOn692laQm8ZGsDjR8WHHJ6wucChrbpsb4Mo3ClOPuR4fU3M7s2YfWoWVd5Emjm7upuFNOxqhqDX4Z2a_WVkAcDv84_nyyo_MB8STReP2jT8xfMfzp6RvoAidNcihhfyx5bGuU8WfNPKT13qX5zYjx1UiRwQr5EYsm6FzEQUqURIpx_0erBQPqQ3hVJngEx4j0t31NrEtsnjOP0DW1Jjh5G03eFfc_tm3tCxfSdPu1j9jr50SAs8Opkuy-U-ig2CXN1q17Og-_f1corbSSQBnsedoMl-5dG_lbXe9zpEi_kwrRacAIbFLv58K5vD3Far2uhCqqzNtMFBkqHfoLVIT18wGKpBbYReaTpft44ccZZ-9dlsz8XxEgXLMMhjX9eXg01P9ziKSowcq1_nN5lbeQ1QvBNL7C-IXN0Wm05WLbZACIdM-6Zg7_dNxcMCPTusYbi944UUjEHALVs81ge9iHjHV9WF6PcOTyUlW2bRPSD10gb_Aw5GGkreKD-IjWTpDJfu0ODlAQzaTeufvge-3WyB6GTCEl85UI8Ub4FcxFg1Gp0YvF0LRLcZndd7bNjeUcqrpJWhRiLgHTSuV_HYJFTw4yJ523wrNgxdWmm-JD0GwNxhfDtpEDeBaX9slG3fOEN5VscSzGjv8reT_r5qLEoWkwlFTWnIp=w954-h555-no"></p><p>먼저 이렇게 작성해보았다. taxi, suv라는 이름으로 각각 인스턴스를 생성했고, 각각 다른 값을 <code>wheelCount</code>에 입력해보았다. 출력결과는 예상대로 출력이 되었다.</p><p>이번엔 좀 다르게 해보았다.</p><p><img src="https://lh3.googleusercontent.com/xJikn0ZGjAoRbtNKxPIlpORMxIfGGfKVGQsNuIoMh4UAfMmmAxD9sKWnYnWpL-z1cttKPuLj731zQvfgoxnHifMshuRc_MMoe8ZOJbNoRfvP0Q4pbXPEak8XfDkk4tLKN7fCeqXLHFyW6iFCTI78rqqIJExLBUvpR-OARiOAv8bBZYC0gMoU8nNU3AY86ObZfWK6AR2se8Z6TTryQBo-Y0QOS86VDoHcEOmpcks9ko02kOXHo-ttnrcXnOmHYl5x3YOiKQ-M9kwHYCYy-NyawQiZsiUjlTmkENjKoRfK-_XkSTWglFbxh_fDGuSvZAfehA1v9_ZGV4xA60czCrAPRrX_LaCY8NsmAgs9IzJnQ5kCV7VpZXpJVznt-9WyIO2_zzUKQxJFBIarieit0l8KkLCHUc7oRpHws_eHj_Z_3yjEel3fXZKtX9S8AVS8EzNC36YQE6TTpOgqOfe_EPTVimI4P8KvfUCTTaQNB7jwtVnr9TxE79ljxMnZmIMChfnyCvhY-gI3pnUafaXgl3pXM8L8e05sMlNBebNp-N-47behF8ELoNm6adalbxGyorhUfycWNV827dV5JTiBP_ZfzJJR3lwcdUVQRbEf6BIaYQZHYd_QyP6IK__-XTfiEc8GD3BnB92XeNn4NeLKMrB0vYUuLI5UMx3VX4exHxD6UI3e5lRuAu_UVrdo74Vbsdm6dmu3iGxiT60yxmrxbKSTikVdyD0aWpWaXRriw1Ef9pfzuntHdtJKRsGw=w927-h526-no"></p><p><code>Car</code> 객체의 <code>wheelCount</code> 변수를 <code>static</code>으로 선언했다. 출력을 했더니 위와는 다른 결과가 출력되었다. 각각 다른 값을 대입했건만 출력해보니 서로 같은 값을 갖고 있었다. 왜 이런 일이 발생했을까?</p><p><code>CarExam</code>에서 사용한 <code>wheelCount</code> 변수는 서로 다른 인스턴스에서 사용했지만, 결국 <strong>같은 메모리 주소를 참조하는 변수</strong>를 사용했기 때문에 마지막에 값을 대입한 <code>suv.wheelCount = 4;</code> 가 최종적으로 메모리 주소를 변경하여 <code>taxi.wheelCount</code>와 <code>suv.wheelCount</code> 모두 같은 값을 출력한 것이다.</p><p>위에서 bold를 적용한 문장 “<strong>같은 메모리 주소를 참조하는 변수</strong>“ 란 <mark>static 키워드로 선언한 변수</mark>를 의미한다. </p><p>System 객체의 내장메서드 identityHashCode()를 통해 확인해보면 다음과 같다.</p><p><img src="https://lh3.googleusercontent.com/2zwWTaEHcrkJRwRuyI6NLhraGeEkos0NgBSPOvRCzA3bLWqq-b2qzqxGL-SULhj7P5ibnJz26xtru6jHROzHoCOn_AmXQHYk1W1LdTFNgexYAt2IbJmitwR_3MLvxQzSek9FX2dJcvprHJLl89XZ3656NxeDq45ZacWNZF_QaDnbVDAJI1Y-vpFVfDlSIv4iRxWNgSnMA4ZGqpbu5dm8mCUF-cJFk5nL30sXQZMTaJIvDqFteCDl0KNiqeO6FqKxZjoK7V2okf6jWyeLVxsXDA38rd0fBWoIfBLRkqVAn2vk5x0e7smUhuG9bkm-KrZes-xo5mTgbnAK7y-8hQ0pDW8TMMNwn2xmH5HZv-WEWydYKMp6Vg90dbFdzf6YSMh4nA8SPOKF_FQAZOMLuDRWLwuAahCJ2HMK9TdYnrWqP-xJY3fXdhp0A965tOd-ED4AYaX07AXICKzD7LjK-JAv-HrCwDrsK3S2Kv88qtbud_ux9iS3Y7rRzdoqkC9vAI1noR5uI5p9RTnae_BHSg6-skGn9POYGzimC65KrY1D9I6Of2WeKbrGW0jb0cYdkQ3KUyCisbx4zRWqX8NKaPBCbK_RwNpb7EB9XkI57QN5248AWsp4434-ou6EiUqlJsItnV5fNawqnRFSuNnOKf3_ipS_RLrRGIN3nFXclchCRpqiKAQoTEA2YIGFM8_b3hSzvFwW7wgL7-YbQ5dx0ajgyPJASJe0nND5omb-OYutpgXHRTRZtL8aoZNm=w1402-h576-no"></p><p>taxi.price와 suv.price는 서로 다른 주소값을 참조하고 있음을 알 수 있다. 반면 taxi.wheelCount와 suv.wheelCount는 서로 같은 주소값을 참조하는걸 알 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA - This()</title>
      <link href="2020/03/java-this/"/>
      <url>2020/03/java-this/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1498050108023-c5249f4df085?ixlib=rb-1.2.1&auto=format&fit=crop&w=1952&q=80" width="650px" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> number;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    name = <span class="string">&quot;undefined&quot;</span>;</span><br><span class="line">    number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.number = number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 그런데 이렇게 생성자가 많아질수록 this 키워드 명령이 중복될 수 있다. 이 때엔  <code>this()</code>을 사용하여 인스턴스 변수에 한번에 파라미터 대입이 가능하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  String name;</span><br><span class="line">  <span class="keyword">int</span> number;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">&quot;undefined&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String name, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(name, number);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this()</code>는 클래스의 멤버를 모두 파라미터로 갖는다. 따라서 위의 경우처럼 생성자에 파라미터로 들어오지 않는 멤버가 있을 경우 값을 초기화해주어야한다.</p><p><img src="https://lh3.googleusercontent.com/nFYfKkwILN1YRUsyFFzNuQQeeWJg9LbSoLOfhO2soe5mlwXMaEzXdD-zXcZKpCZaM3-ga6UEMQpSPUZJWfVkLQAbm4BowPAgJbuzYCjMbHfBmX7c_zT9iS0x4IzMNOcmtDW8Y-pOqBHtTi7G1urGCa9UMwLY1M8yYVw5IJvawhPh0WLKYirk1Qd0SIvmC5Boje4m9ZOl4Z8EyeN0zXPCfOdQDxZZCTDAUoD2EvdIbQelS8DiVPN2rL_omM3t7DaEajeihOSs6SPPb3qtqwMVPa-qI38xgGufBnzDiNRN1CDX24GPQVpCzR2l5H9EWWezfvx7cWkjyAM6h13WOY0zyCGEMk4ZL4IqjYr7yP2HdX59-DwEKEup80WkAjay1S5rk3mlFz5FpAvTYGUF-8kuzi75e2pP72AjT7aS2MrboFrCMS_flzfr36ZnQQHw0XVxP7vzWxnSZip1cbphwiMlDoqdobbQSADOY030OqcwBg4vSUczOeKmynlaJ1ut2u1YgK6VGHLuvlNRboLIGidNEeteXUt7s4p0sorPfnja6wvamUhg3cy81Ej5qwm_JaE7pA8rXo2n2FT_x2wKJNMFtEM-KcCPLJSahYtJCKXTnAE36n5zStOETISE6k2njnsUNQeojVBTk9UY39cTQKENd8jOzapc8DZz8OXTj0Ps0pPqzxWbENqTozab_pwuzqGkLEpwdIMXoAOfei9UDNLlYjrGNFQKi1Ej366g0QnzaO8jyJCTwuTkCi4=w540-h466-no"></p><p>IDE에서 this를 클릭하면, 이 this가 무엇을 가리키고 있는지 알 수 있다.</p><p>위의 예제를 통해서 생성자는 오버로딩이 가능하다는 사실을 알 수 있었다. 오버로딩이란 파라미터의 갯수를 다르게 하는 방식으로 같은 이름의 메서드를 여러개 생성할 수 있는 걸 의미한다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>대입연산자=가 실제로 대입하는 것</title>
      <link href="2020/03/java-assgin-reference/"/>
      <url>2020/03/java-assgin-reference/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/WjuUEVHysDc5P8AHjkcNjdGxJVaZbo8FsaqdzZwpn7sFNw_q-PqZZm_SadI15HqEFyibtMbhbS4Ga3Kh4iN-2UPD4cgf5pc8aLLkNg7IWKSzg1uth3K8qQLplDYE1FTxCjcBZCd74xN5vMvolUdtTd7i1Qp5kzKP1VmQGF7XSXabyP2vTuIzIxyaTyA2XKaENlyl83e-PC2Wv4ZCsMqtHnDqZG8Ob_xy8mTC-wBnSVVooa6jdcT-7drI75mfMS3Uexkz8f6wCP8GVa0bljQKDsEll5cRF_FdHQHoVWGtzXmC-6T1uUgEZ-JvEXI5ArHL1a4lmzT-OVEUyQB5-V2FPQg0KLqU6DSqZvdeqx6PIKQE6BCyUfL0_wXEmgmlv73K8QdeKiZJCb-cDCozsDfZXMhy8cyCrM5WqCr-TcWHTah419PTjERefPj6CqCK-zzaUb6ppjCgpTM0T2MnHG_MVApQq6i87aVRrKcbQVZbp1olMzMrk_dR0a8CHoNSpvslkPY0RGO1wms9sLLhoX5TgA_lizqP3prxpZXlp22PYVy_JlPCd3uyc0bPxpVTT4X_vJuChXh94B4OBqizhOIoUadkDyVmsrHIjOqGABUo926RINh7I2-8gZoUcQABybR9LYcoW1AxABTcsT6oyoiubcK5E0t6DhVRe4nTtTm-R1EMKLz-1Lq2DeeDZSPLhkkqbdF0x8ZkxxsClO5dFPS38JUasmI0tkeI3MeHMd_OUS2bbqoz51_LcAxB=w1110-h666-no" width="650px" /><p>자바 배열 변수를 대입연산자를 통해 복사하는 것이 어떤 의미인지를 정리하기 위해 작성해보았다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array_2 = array1;</span><br></pre></td></tr></table></figure><p>복사라고 하면 값을 그대로 가져다 사용하는것처럼 들릴수 있는데 사실 반은 맞고, 반은 틀리다.<br><mark>대입연산자 <code>=</code>는 값을 대입하는게 아니라 변수가 참조하는 주소 값을 대입하는 것</mark>이다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_1[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p><code>array_1</code>의 값중 하나를 바꾸었다. <code>array_1</code>을 참조하는 배열 <code>array_2</code>는 어떻게 됐을까?</p><p><img src="https://lh3.googleusercontent.com/G6E-Dv7Q4bXBdWT28qrOTEBb3seZei-DL9cHwbBkpS3zbBHPlxUP5TSJRIbP17izBxUgfyASbvpgvnTUV1Htq1f5Y4U9HqqkCEXOr6R2QESLO98RA9v7rq4ezC0K3zjITjH-p6ORYlN4dD7_9bMgH5zdo_OEZLuKOA2plPCbrAnGtFyit8tt7mvkG_aKY6Efw4F4imWPz7PoJww3H7n0hWnJnSUUEEtoyNGDIjkbJQWzfDVC6jJKux9EEMgBh3eQ6mp-q3pFidGE_pZbe1bFbDr9Y_mGahtXG3VtMWCemDs9wffK86KkB3mJXzSW3lqEgARjv1tWvzQqQBOvd1IJON99KiTT2o4JeA7zZzlk5FkDXQ6-e8-it44-Z3HjO46Ovwr_uvGrBduGWZa-jL_wE7MffQmg8BzhWNP-tbwdiUD39R9QfvUte5fInLa9fE7z0n_UF-AtCBLQl_W3-Ov24asvx-reuRLp2uJxVOCLqJlIN63RQ4kkToKTOH5hlgd6_d0EkqlbXylMuwD147y97fBA0wLiy1SkwvdVPvX-m97v5CbnJVyoc8merxGGl6pmMtMFtAUcOFTnEhbdRPtvA8niVhOA_mLO960Y9qD6NiCPf5-RKEpNWQ8Jgwvigp3eG0ODhS86IJbWhRLL6qpOxL_7WVVqtXMB2J6K9q4_lS95J02eN8TsHVvF9Dg_QoAijtwBjz38nop49XuFb1ac26YYeHIzcSXZsLx6pF7vBmFmq9ufx-7hh_WI=w1068-h618-no"></p><p><code>array_1[0][1]</code>의 값을 바꾼 후,  <code>array_2[0][1]</code>도 값이 바뀌는지를 확인하기 위해 출력해보기로 했다. 그리고 컴파일해서 실행해보니 <code>array_2[0][1]</code>도 함께 바뀐 것을 알 수 있다. </p><p>위에서 주소값을 참조한다고 했는데, <strong>주소값이란 컴퓨터 메모리(Heap)에서 값에 해당하는 주소</strong>를 의미한다. 따라서 <code>int num = 5;</code> 은 int형 객체 변수 num이 5에 해당하는 객체를 참조 또는 가리키고 있다고 할 수 있다.</p><p>배열을 선언할 때 <code>new</code>라는 키워드를 통해 선언을 했는데 이 키워드는 메모리 주소를 갖는 인스턴스를 생성할 때 사용한다. 키워드에 대한 설명은 이 글(<a href="https://youngjindev.github.io/2019/02/java-jvm/">JVM의 구조와 역할</a>)을 참고바란다.</p><p>배열을 생성하면 프로그래머가 입력한 값을 담고있는 메모리상의 주소를 참조하는 변수가 생성된다는 것을 이해해야한다.</p><p><mark>대입연산자 <code>=</code>를 통해 값을 복사한게 아니라 참조하는 주소값을 대입받았다</mark>는 말을 이젠 이해할 수 있을 것이다. 따라서 대입연산자를 사용해서 **<u>복사하는 것이 아니라 메모리 주소값을 가리키도록 명시</u>**하는 것으로 이해해야한다.</p><p>자바에서는 JVM에서 메모리 관리를 자동으로 해주기 때문에 프로그래머가 주소값을 명시하거나 알 필요는 없을 수 있으나 그래도 이해는 필요하다고 생각했다. </p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Tool Suite4에서 Git 프로젝트 불러오기</title>
      <link href="2020/03/eclipse-import-git-project/"/>
      <url>2020/03/eclipse-import-git-project/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/AcMyhDXgzmInJ8uiugnIv5UAOqqHwoYwpNHq8iAPrmBx7BoZOPFNefXCG6XDzvLAm7URVLZw59joFsZDkKfhYL8hB4oQ2LpEaguK-KCsBmzsAtKOt8gSwYmhAXxEuO0gro0O1gA-X9g0BNQgTarXK6SB4VrX3-B3b-C9xhqt_eGVOCXvz561Y_lvM8XQ7Ryx6CcKuVUR8wfVmmDc_tEG-ua5VdHv-OJtnVbwgZKPbQ5N0L2ReY3vO-lSZcyXJdi0tzABBZ-u887p-HL6bMHRFtKiHAaDlKqG594eL_maUuF4QaW6FLeWYZx2KPSWHmIRpWpL5Z7RelDDIyNibS5PDAVVJRUeZXfi_aZnnBtI9S3n7ylSiPYgoooHeLOPRgKO_ZRsKxZaBUgiEJfi9O-b0xwti1hVxLrrpitrTeGQ3pMvCKb7Lh4Y8StB7Y3NynhI8RBhnGvumlb4GWMqsfPWjsBVwURSWu5hHzJPXccKSYtEvwMbeYo3ek47v5-_6gH5CkXt4ykvJ2es_G_Fjpf-DdNWPRVnkv-i81diczEy2EDqs4FhXNDHztuLxvnBlMHZ81GZal-Yi-lf4vJAdYV8Qh3ShMCdNCaqErHndEohBQ97uuCDDyrXrJb0XJH5eilTvzqRxEoGYnpuGBtO4xNnHC6fLxzBuHiuMTxCiCGQ-yS57K6K9DHsHZfht6fQYBFCwxI3f6xWdpcHUeoinIYICuKSjFoDTNN6X--VrItOEnzmeDujWb_2qAQ7=w1356-h635-no" width="650px" /><p>어쩌다가 프로젝트를 날리고 다시 해야하는 상황이 와서 하는김에 정리해보았다. Spring Tool Suite4를 다시 설치해서 Git프로젝트를 불러오는 작업이다.</p><p>먼저 IDE를 실행하고, 왼쪽 Package Explorer에서 **[import projects..]**를 클릭한다.</p><p><img src="https://lh3.googleusercontent.com/-X4_SeztVhO_WEQqBue9ijpe1SOrCGpQ12up_QhMD9v9yZuhfucc84GjiB_W6ploQSt6dpf3cbVSlaWmX3fsegKcEEwEiJAtnjAtXOJs73IqmDxoMTfGn04GYAyQrkwGRS0sghzXYw5YqHEtgP__pWpjpXFpD6Fop6sOgo-sJ6TsfkNqcW7aOM8a6wozZc-1dYdsdjW9CsVIQD6vCeH6TBz6FSgmHlxdmpxAGm0k5UpupDg0jqzLeOlZ2UVSB9sUr0EeYx6_obgDPePCooW5ngmIvVW4tDM8xlCkrXGLmNqN6H_ZXEMJsHH5Vh-xxiSM0xfnrSNRNL5R0h58rDL_oIWi1vFTThjZrz0pEhgFdR_DfzrdE3LPV7uocoOhgcjKj7hRvMTkyU0zXF1_kJttlt_EktbOKs0bh3ErFkXAncaqxf3Sqaw0FHtO_qVk6-J856b09qvpoar7c8ye9sU-EbSrqJTx7G7HpJQkE3L2yp48eJaRQJ8mJiY3O9gqJXtRxyEgfXOygj62zqkLx1RrQYurZj-fHxNtf0ZLaZmYx7DUaaturazv2wu9LWAc2RyIDNJ6CaDfUvMjs4orBq5RE16TC-0EAh1O1L2jtLHha8Gj9wB-wlWWaYlZwiFgq04WEKZUeZyC-0GdGOo1zejL6R5gJqe0qxzQDAWYd5fjAJpgQyddB7phEv_r2ot8JWC0JignMTH7TkYiaAHJjfkNw9tONfDV1GkrnmRo3CWtv-JXfnO36eIna-vE=w765-h615-no"></p><p>Import할 수 있는 프로젝트 형태중 <strong>Git을</strong> 선택하고, <strong>Project from Git</strong>을 클릭한다.</p><p><img src="https://lh3.googleusercontent.com/-5y7ITDOIcj3BPcMlHBmObfjFRIq0-uTk4DDK_5Pa2C_HFTHzxI1XTe5WsBbJWFvr2SAACkYKRd1lv4iul4usteoEW8PTASO-7pD0cI2QawxpjwheGqj5RISD2damp9rUx816BLkpc5PFVAzSXDTSI_0ny7gXCLWaB35tDtnVL69_qbEOEHT-MrxF7HXdOcRne9FB2LlbpvQGpgwa80Lpw6qGiR6Faav4NbTJ38GU92cVFoA-I9MfGG5D4mXD9UFHpcZ2inHReqyH2oamkpfjdhJY3QCZ_KLOedChshYJ2K1Gsb6azYjPfUDDU_KwcE3YpFrucSSEyQQ7580D9KNoAKhUNFz7JLPsDyRcNxcfF2xfOQ6aQyV0D_FC8VN5M-q08y71zNLpnNQj8TLrAqeOJMP1oWDpcv41KliAIkV2b-U88f259oY1m-VKbszjq4gYRsi6grHeb2oSUx5fbF99beqe9cNGDpemxBEtxe6v8dF9MphwWpJ1FJxlPOBRpOcK8Y0yuywjW160IJy9M_72FUC6mjsod3uTEgaQG6rzT89qBBImybsA82vXsIuqSVUnAeOWEDvm18fl6MbambZMrN_GtVx5UXnbNm7vmOOjreMfdpIoh-O1HkcytCwVyjI3Jf7PYOaF5rskBX2AdXuDodQoob1BbPTgi0IWACO1SMFqt-Xyocy1snG3GG2ZgHbm4ZeV78zn3NtxlTOTAh3JOpDcieVvAbPNCGbqzw8F-PHRDERtCRQfetW=w591-h547-no"></p><p>그럼 로컬 레파지토리를 불러올지 원격저장소 URI를 통해 불러올지를 묻는다. 현재 나는 로컬에 프로젝트가 없으므로 Github에 있는 저장소 URI를 통해 가져와야 한다. <strong>Clone URI</strong>를 클릭한다.</p><p><img src="https://lh3.googleusercontent.com/elPzRq-cbuepJf5rLVB3mpnl2i7ddQvx3h8PsCUrSIOFQO3iHB6F4rz-BtLMeBUxO5KigU6e4pX1X_eK8hsxS40LlREA0yZ9QfiGhs32aSHmZNdeqhKpqQt-N99AivaZN8I6hu6r5vIwROWz925gQXMu6UWIyYfmG4r3naxjNgfMIesH6rcVfduDWU7XnQfAJIEbdSa7VqDhQ22x4xfccw6Qx0cqMrvajSaGVoOdYaRRQfuQcvucvgjS4QeMjTa5sbMUiL9oH-IJMke_rQMELuZqz86MUW-4_LWeqc_dBEBlJ1A9beVbIsRLtF2GV4iYKF9YcMEi0w6P1dM2WDNjIwPEgwqnwBxjxvtGerlHPrYhDj4vHxX5AAsTJPDXS6dA5cBEM5DOWx6j7lB19-8FyH9mUQNfPwgg54QCmCqwPPBp7YIW3g8ASz2LCzAiOpa5M7fT8bidz7QpAWcBVgdPN8E10YCN28fz9m7OracOtxCSKNw6vTnYwhmrOvYN3b_sA25PjzYeTOhXypGpuAi0CoMb_GYBldeKueAZqDXD_rzsuDne_var9zfuzGuEaE-Ena16pQiGpj9EU-5ZSopPQdGdtvC1xlWv0lU4bHs3v73Tp7jP9KZpWtZgfrQx22SvBJAASiEumgmfTXxDsFJYk_pUeknJ-qe_acRp8svL_cp2My2nNqsHohTzrwLvuGV35KIxUnSBKhU9i0vBmV8OOKItWd1bt7C92wGfpIEIKn2dGrZB5PINnM1I=w591-h552-no"></p><p>Location의 URI에 Github 저장소의 URI를 복사해서 붙여넣는다.</p><p><img src="https://lh3.googleusercontent.com/VQyk7iklFoB7ZyLLBGmSktNzpSkXsGGOdEL4mT01dE3WrSiTdgL8aJTzyUHZ1ZzFynHGnhNNgx0t_u_cml8wKsRVQQivzg9q-e1fTA0sNZ-fvUqJc8T7xo1PaoMVsP4GPymrd_UYYqcehkoHim2D6Wu6zbi3v8HrioYcNOPK9v_ubYZDV_f4LgSQIYOWWnU_pnP3fu6rSmFbBaS0jjCq-KHejzd_qvn6QrW9WlUBQ0uugn_7mkGwPq4NIhi9l4hxhcRR7kgoEkbHGiBImDP-gf6udMMFY6Pe5jjOfackxb6E3SDvh6KNTVU9pnHrQL0mqB-TuJJc2DN1DZte7t5IdSG-IgZM5n8jV-RCHdSSWFZ5PRzwRFBD1LnpezZbd9jmJhSaml-eFdrX58Xy8M0mV0-noTeImNFekZYIUOQQvl3kGUd1rnHQeiH_iZZEzP-3wBXSxGE2Ey3ViQi3hOPVoYh27wNdPPZEuwixkdYRpkPBeLouS5YXQ9PYPnX8PwnJZDqj5JlreKwaw3oRR4co1yruFeRdPC3wN14RoDRG98z3vs8rOvLvcBR6of67kOchz86jz7wGnhC4UrYWBJNA3MqG2KvtnjObUZ4Dnr3goryfL81sTA_xAfnFlGfnkO4IvWKc1f_fMthN2B6qd2JdszjCMu1gsCn81nVA2_El7Ztu0dAkBXqB7grGb0k3s24I11V15un7zHJchEoArpTW_EjFebXLO3gWlFcJodIfVtLVMZ0Mk_ZTWabc=w589-h549-no"></p><p>이 URI는 여기서 가져올 수 있다.</p><p><img src="https://lh3.googleusercontent.com/ev8LnodZO-VgnLb35WjPkc7wZgDAu9zPxEJVrJiZnRHsQJLlMIreFnRbxWWcSxsCfscMYMSYd7K7NpI-OJQxxcIbRXs1YnbLlfEgzdHnKLgkTEhbmvVXTvz78gJn3CgUzwZicLsojGOH2We8adTQ4PRMHNkuhuVI2vPlPsGQvhO_Z4eALI5PPeERZvJODEceYm7oSIJ1SNqSPvnx0g8HX6hn2WN3k-_ekAxEUHSTLkvhbQdCZbAF9zP_Thm8c1PVYE9pYh61sZHlTLDPZn05mm1jYzt7c4d9HPqLVW0GVIk5Y1l038qUcHGNhD7niTWKn1Y_eXUEkligHJLGS3yosZ-38AO5roj96BBp6nUJSkYPhOOIqHe6BV4043TBrCySuYVTXUNd_JKG-yaj_GHMVrmu5i8Y1KnqRboypVTSvND0WUH1k3r79UbkWnN_Yux7UvXy73doD7a5fP737my_XQcNQ9bs9cR1ImWWYy8bvbHeBdw_F15-oyDpFikmlPiy7JMuDXR-lxFFIFo5Jr6ES-EcJcVsClnwUp29V2LMO6ZZbYfeI3y4L4vh8HJp-5195qIKwS8hOmWbuwaZYr1AWcn8eN1l__ZD5eK56e42IPPac6SOiQUS39sSNmjurbqtmIW1vVATTgiJzjJ7NJU4qY8Xws9CFku8nhZpBvRMh4A-FCfety77sREKeG2dC8zChHdMKB5ZvctxAUq-CIg2peFWKMSJ_10I5t1I0yxPUHPXWPmLn9gWzFhg=w2028-h1320-no"></p><p>Next를 클릭하면, 이런 창을 만나게 되는데 프로젝트에 따로 브랜치를 생성하지 않고 master에만 작업하다보니 가져올 수 있는 브랜치가 하나밖에 없는 걸 확인할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/ygQVCkm9TefkR_2VqX9qCcGhgw6KB7v-ANAKBIKtdkkKiNUtRqx_ur5TPu-wtf8PQV1QzDOieRSjEgyvhCjrj7WDiZbXGGmAUloxBGV1z6RQ7NJ51ZWaP9-ZoJF6b2-UUktvqERRWDZJgMKd_I45oxkUcAWva5dsKbYLTzLjd8DNanbKEwgZc1sVLdXjSRtPL62G0731BVXkphClanMqF40uy2KHrJug7CJB_HYGeeTrIutjzYN3ZrP77Bn6FEtkZ2fs4aHo6pjXCJ6Gn2ysxut6ZgUDw3aXVTHZuMHajF1PFLQ1SjZd8SDbe8i4-uxqQNFrqltjm5JL_AnxiFtxm8vcm3d2h2eG7A2q11oIwIPa-6BlL1pVEhAI0QfYBACeV6eN8afztLCjb8lGbUDJ1AvUb4jkeqdpDBhSh1KUxxydQ4Zh2MhrkqdLdghm5uixWGnLtax_Bdg7uARAdBq9gsN4Pc9mSs0FflbYcm3qSE40ed8PmTZ4TZUTmwKzMeUz8wJwwyQLfehBZRafgzi_ZDSfJCuyX_kxIyw9gccSoBTeTb6EAn-2ymlhwE1xUtdMfF353cD15hfc0igDa_oV3wAyCBlJyUcKusq7RPE9O-nW94_tq-QaDuI0TcIoPsgn4kcpIo8vwLU6QdWRTYtWt2aFF6TP6ksXMZcI6xqdFhtmXky4IG8TKi369SDUDvg0FCHaQFRFBes_SdwbFgTJ6KwTc4q2GcMt51wHKGIO5UVVQ4lunToWmCnc=w1073-h500-no"></p><p>진행을 하면, 원격저장소에서 프로젝트를 가져오는 작업이 진행된다.</p><p><img src="https://lh3.googleusercontent.com/P0cCPkwYsqSN-wYa5c_893RGfQbbWcLHGRhrUidTcAdZ7OuiKuOwDozPgBMBdfbhzMPAGafqHGBCbhBwQXdExN_LG0F1NZUad1U6OlFa56iPA_1yqH-CDs5hko4C4aHZTc2Kao69rR4IRW5R4LzQ4bONOtote8M08SwWFE1MkDmpFZgCXrp2g5FbwcyF9jlQ0Q9KN35bPmES1cSErmtvbAce_WOIY76f-SQoO520m5pPDj1iXgR3LHafkSPqhx2-FBuhwgmgE8sxFa1MPdaTZ1MADTFj0iwuaZxYTV9bjGMM77t7FeKzlySvmYNliZY-zPucIzv9HRtG8b-po95dW1DzRM2dCvqusd9PrkyrwYI_KdYmhvuOQQfmt8kcGU2tU87yGfH8--iWDV20doBn6assePq8QcmeZvq3alaDKUGOMSajPaGjeynpUTOAhkQIBedD6T2bn64mcxmhBWvU2twnVd9rwe8199A1NiovjV-5Sj-vzuM59Tlw1LV6xeXVjVddfm4K79pr-bklaXosUMSSDCYvpbI7aZh1fdJuVRbrn4AJAAPmihLERhmmL12SakyJMijguHJUJYS_7TaWPkIsD4aTf6uTDWQRx65LK9HIbFf3NSVGY6AhOkor8rleT2noG2TzrIJngoOCYXHtUJhamJ_O-YZxuk6TpvE5xr8nnIJMf3UOAi6iFcNbjITN8J-BZY8jjY4w454XtM0n0mfP0AaUCVlDPR4DlwTJxe7CvZQiSokROC9n=w1138-h792-no"></p><p>프로젝트를 import하는 작업이 끝나면 잠시동안 프로젝트에 빨간색 에러 표시가 보일 수 있는데, 이는 아직 Spring Tool Suite에서 프로젝트 빌드가 안끝나서 그런거다. 빌드가 완료되면 아래처럼 Spring Boot App을 실행할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/2hvdGKaBsx4g9Q02LWy71krF_ULMMNq6n85kY-13Clas2WHViS7FoW_UpPGmkfzsR2r2ihrBGs6UsHqmVIdwfa2xf01EcFWsX_pN8ZYhS4Pj3fF42HJiaCKQnfDIarOLaxpNY0KSUUXC43UN-z26CkNmJu2cMfZM1DOltxkHexmGqmyHzfc2ZoBp7Kk-msg3srvsgpGJQZhT-nu2qwz-ASIWxSMZ8Atv6csxKeOtCOaJfCB6Gr1FrdTvVS5ROsqKIaC3cE6cF1Kz2C0SisBwIw8u__2iLKI3xqvGK4I4Oq1Y2eY1BtGh48oEBw84ihtTBLo2zShc7k7QVpTV1Au3fqaJiXzWz9lcnzcWnyj3tGt38iXnhpnfixw9n05Gcx9ytE1mjYjzxpnn1-SEPtPyNQvE5_f1SJVotEbVqlvQOiFRtTcRYflHBst56SFbk3OC7sJ3OLFBFgAoYdwr5S6F7aao77CaZ6dRGO_nQkblFn-DlmiczLqos_BjEBnrOTJIZL-wLSzSrGUU7KBgrdGw9xtJolAn9e6TAWZnb-CWbW9hEXz5narNzvG_gZ3WUa79fYAI6ym7Ey8q3w3gwrxHFstqJOKsTt4Bu5Wx4po9ZW5-H1ykLTEt2895wE8_3wmzKm2tbze75V1JPX8W73YjjnB_S_Mz3G1MINzhfIcZDJbDWn0l5DoZ2C2uJJDU2pTpatyyxyWX3bmwNeId9UaHXtoeq-V3ldgLajiM8w7ivINYhuUz7Z25EQY-=w1096-h795-no"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>넷플릭스를 더 유용하게 즐길 수 있는 크롬 익스텐션 4종</title>
      <link href="2020/03/extensions-for-netflix/"/>
      <url>2020/03/extensions-for-netflix/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/QXUmjEhdLDUGWuLWEPRPYgU8sChxLeJ-mHwtZgEHtWDLB5xQB2dBXVr4ysHJZ1ik3OKFy8E0qmUiP-02IGaI7J4JMxJSOpm1q7IFuK5IfZ195uy2EC6wpKS0oJNTa0nN-JO3zTamv2iDtsrJ9EESQewDeBuALtWhhF_yNUvFm2mBb3qwZOLQyZWloJI95n7r5KtIhYzoBdcvV6n2oCsGsypJ-hpbvDzSnTniSPRWK876NjlbMIGILJ7tDp_gMCtmkHKbFRBC3H8HjUWMToFebC0dUG9Jh3y3U8khpe7cj43I1XJ-2s0zYRztfH7xdiELgXepCYkU_wH8RKk-Yeg6YAZe1KwG1-H-Pal0Bx5e9utevXynjUfUjp1_C28OLctwFXbvkTGvVJBnZWg_Dxz-ZbGN64JA8RReKkxJX5JO2VExGPYNoki2C8D8OGjSLP7zC-dJX_0cfQUI197hFtFVMOvC4F3_S3cTyDhopj7RuSF-rGQkphQc1uCGmWppueEGmNVwTO7mot_VmrDhG0UBddakbijdD438oZXymk_CNORPWlMZC0DghNZctM28w4Kjnvv7a70f163iniWdKA7Is6TkzLMwY2veSwVv7N6hR13IiZoL1ytAhfazInVJYex3Zo0N7pun3cQtYFF2ieWvUYpYf0ALsg8RvBhwYXO7aHUeslfk034PqVVewTkAnLsrxMKUZdG6IQbFjm0lBIFql6lPWnLFXxY7_bkIR32QhXutkk2u9n_Docqw=w1585-h831-no" width="650px" /><p>바이러스로 인해서 많은 분들이 재택근무를 하거나 외출을 자제하고 있다. 이러면서 덩달아 집에서 할 수 있는 다양한 활동들이 뜨고 있는데, 그중에서도 특히 넷플릭스가 역대급으로 가입자를 늘리게 되는 분기가 되지 않을까 싶다.</p><p>사회적 거리두기를 실천하면서 집에서 넷플릭스를 즐기는데 도움을 주는 익스텐션을 추천하려고 한다. </p><h2 id="1-NflxMultiSubs-멀티-자막-지원"><a href="#1-NflxMultiSubs-멀티-자막-지원" class="headerlink" title="1. NflxMultiSubs : 멀티 자막 지원"></a>1. NflxMultiSubs : 멀티 자막 지원</h2><p><img src="https://lh3.googleusercontent.com/WjYDs3qh5kOqGvAOFW2BQi6U-j6P3F-ghuhhTQ0zd0uJ65ZsH7sgdTdxQLfUk6slHcaM00QQ0fJB9wv-76Z1HRZzv7GUSkVCrHfwvw5yVfqqpEOnAnwXZOqlx7TcMvSBgb8_ew9gzmFJWIG4oOetw4z-goDu7RfrXNixzq63qpk8ESw_rRwgD32bIgp-SakDXYa92bAAWskNQMCxd5QyNlMbt5kkn2vQpbmZrqSftZxC2HtVvCC9AXc2xTVpZsWocLxhsBrQIbNf53S2BMSqyNAo6wzDEDwzGSLHPOn7rTliiureq28S6zib774LYoaijMC7jPaJobY-fEbJwTxh2nbLYYA8MsfwgSct0tFVFixQhGw94z89xrxLZNNSVviQHxnIOE8xR6X-hWnkpSqsc2By02YyTpR6JpQlOEdwt_yCVC64XgWqSAMTsvL8TGhR5JV_bAk-KjcqbZkM6UJ3-byaEHdYJCFloHiXNhDhkqaAg8E8wjskg6YRw51W8KLV6X1CNAjdqSw0Xc-5HDbY8P16ebcABwdG-32xnxfN60TvbF81R3XNIEp_H9f3_rZpVMMnGc4GYacfK_rBq4SJoduFPl0QtntWl7UjfpBTRH3sLJpyr9032_H4LN3h-RBF-N8sdnynBRrL_ap9254pNitSrv810qJYT7kfXMHV7jpLwZ1YxXgdoYXjevsEG-a4ychZWSsiNOCUfQS3sBEUK8G1j6oYDc-X-aKzZoQrFlIwUP8XbYfRnVWd=w1668-h914-no"></p><p>NflxMultiSubs는 이름에서 직관적으로 알수있듯 다중 자막을 지원해주는 익스텐션이다. 지난해 국내 트위터 사용자들 사이에서 화제가 되던 익스텐션이기도 하다.</p><p>외국어 공부하기에 더 없이 좋은 익스텐션이라 생각한다.</p><p><a href="https://chrome.google.com/webstore/detail/nflxmultisubs-netflix-mul/pjhnilfooknlkdonmjnleaomamfehkli?hl=en" target="_blank">크롬에 설치하러 가기</a></p><br><h2 id="2-RateFlix-썩은토마토지수-on-넷플릭스"><a href="#2-RateFlix-썩은토마토지수-on-넷플릭스" class="headerlink" title="2. RateFlix : 썩은토마토지수 on 넷플릭스"></a>2. RateFlix : 썩은토마토지수 on 넷플릭스</h2><p><img src="https://lh3.googleusercontent.com/adMc_ZncVDvXweku_bTmYi3WkTGHsXCV2aELK5_Kii1hfSKdupse-feqppk7OGXMH4BbC5hG=w640-h400-e365"></p><p>넷플릭스는 공식적으로 평점을 지원하지 않는다. 그저 사용자 시청 데이터 기반으로 피드에 영상을 노출하고 있을뿐이다. </p><p>원래 넷플릭스는 추천 알고리즘으로 유명했었다. 그러나 오리지널 컨텐츠를 강화하고 있는 지금 시점에는 더 이상 유효하지 않는듯하다. 왓챠플레이와 달리 후기마저도 남길 수 없게되면서 이 영상이 정말 재밌을지 아닐지는 오직 넷플릭스만 알게된 것이다. </p><p>우스갯소리로 넷플릭스는 시청하는 시간보다 피드에서 영상 고르는 시간이 더 길다는 이야기도 있는데, 이런 분들에게 고민할 시간을 단축시켜주는 익스텐션이 될 것 같다 ㅎㅎ</p><p><a href="https://chrome.google.com/webstore/detail/rateflix/dddmgiigenogheihnldadkdooelhepcg?hl=en" target="_blank">크롬에 설치하러 가기</a></p><br><p>만약 왓챠 지수를 보고 싶다면, 아래의 익스텐션을 권해본다. 국내 한 개발자가 개발한듯한데, 직접 사용해보지 못해서 어떻게 작동되는지는 모르겠다.</p><p><img src="https://lh3.googleusercontent.com/Rm6szdDwh0HvjERWklvy1o4z-6oatPtDfzTlS6cxIiNPRxRFlCSalIuIwTcx--BkQZsjPVS2og=w640-h400-e365"></p><p><a href="https://chrome.google.com/webstore/detail/왓챠-별점-넷플릭스-watcha-rating/dhbmedpcgmmdnpfghnkcodafbkbpiije" target="_blank">크롬에 설치하러 가기</a></p><br><h2 id="3-Reveal-for-Netflix-모든-컨텐츠-시청-지원"><a href="#3-Reveal-for-Netflix-모든-컨텐츠-시청-지원" class="headerlink" title="3. Reveal for Netflix : 모든 컨텐츠 시청 지원"></a>3. Reveal for Netflix : 모든 컨텐츠 시청 지원</h2><p><img src="https://lh3.googleusercontent.com/xy-FBH4wGN5dwDzhaZfl7J-lwfCvDwLIki7VUgsXN0_usOPpXjNqlUJZWA89A3PEtdh_FKMu=w640-h400-e365"></p><p>넷플릭스는 국가별로 시청가능한 영상이 제한적이다. 우리가 볼 수 있는 카테고리와 달리 훨씬 더 다양한 카테고리를 갖추고 있음에도 불구하고 이를 공식 사이트에선 보여주지 않고 있다. 이를 전부 보여주는 익스텐션이다.</p><p><a href="https://chrome.google.com/webstore/detail/reveal-for-netflix/fkiohmjdmmcaenljmloepbdpcdfjdcpf?hl=en" target="_blank">크롬에 설치하러 가기</a></p><br><h2 id="4-Netflix-Party-넷플릭스보면서-채팅을"><a href="#4-Netflix-Party-넷플릭스보면서-채팅을" class="headerlink" title="4. Netflix Party : 넷플릭스보면서 채팅을"></a>4. Netflix Party : 넷플릭스보면서 채팅을</h2><p><img src="https://lh3.googleusercontent.com/pwSx6Y9qERnjbTN71STMQv4suYP0ciqU4FMpAldK2oadujQlOpCF7RWbD-WMvHQADzzb76ing-4=w640-h400-e365"></p><p>이 익스텐션은 직접 설치하지 않았지만, 트위터에서 많은 리트윗을 받아서 추천하는 익스텐션이다. 넷플릭스 관련 익스텐션 대부분이 다운로드수 10k를 넘기지 않는데, Netflix Party는 현재 1m 다운로드수를 기록하고 있다. 아마도 전세계적 사회적 거리두기 열풍에 힘입어 넷플릭스에서 모임? 파티?를 하는 것에 사람들이 흥미를 느끼고 있는게 아닐까 싶다.</p><p><a href="https://chrome.google.com/webstore/detail/netflix-party/oocalimimngaihdkbihfgmpkcpnmlaoa/related?hl=en" target="_blank">크롬에 설치하러 가기</a></p><br><p>많이 힘든 시기인데 모두 이 시기를 현명하게 잘 극복하기를 바라며 얼른 이 시기가 지나가기를 바란다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netflix </tag>
            
            <tag> extension </tag>
            
            <tag> chrome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mustache로 Updateform 구현하기</title>
      <link href="2020/03/mustache-updateform/"/>
      <url>2020/03/mustache-updateform/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1565839412225-98641b2d7b5b?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1650&q=80" width="650px" /><p>Mustache로 update form을 구현할 일이 구현하면서 정리해본다. </p><p>update form의 특징이라면, 사용자가 수정하기 위해서는 수정이 필요한 데이터를 먼저 보여주어야 한다. 그러려면 <strong>Model 데이터를 불러와서 input 박스의 value로 자동으로 채워넣어줘야 한다.</strong> 이 과정에서 mustache 문법이 어떻게 사용되는지를 알아보자.</p><blockquote><p>Hexo 에서는 mustache의 <code>&#123;</code> <code>&#123;id&#125;</code> <code>&#125;</code>사용할 경우 화면에 출력되지 않아 이렇게 표기를 하게되었다..</p></blockquote><br><h3 id="update-html로-id값-전달하기"><a href="#update-html로-id값-전달하기" class="headerlink" title="update.html로 id값 전달하기"></a>update.html로 id값 전달하기</h3><p>update form 페이지로 이동하기 위해서는 <code>a</code> 태그를 이용해서 페이지를 전달하는게 기본적이다. </p><p>개인정보 수정 기능을 하는 update form을 구현하기 위해서는 <strong>어떤 사용자의 정보</strong>를 수정하고자 하는지를 알아야 한다. 그래야 서버에서 사용자 정보를 가져와서 수정하고 다시 서버에 저장할 수 있기 때문이다. 이 때 사용되는게 <strong>id값</strong>이다. 그리고 이 id값을 전달받아야 repository에서도 사용자 정보를 꺼내어서 model을 이용해 화면에 사용자 정보를 전달할 수 있다.</p><p>그러려면 <code>a</code>태그의 <code>href</code> 속성값에 mustache 문법으로 id값을 전달해줘야 한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/user/&#123;&#123;id&#125;&#125;/update&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-success&quot;</span> <span class="attr">role</span>=<span class="string">&quot;button&quot;</span>&gt;</span>개인정보 수정하기<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>그럼 이렇게 update form 페이지로 이동했을 때 사용자 정보를 불러와서 화면에 전달해서 보여준다.</p><p><img src="https://lh3.googleusercontent.com/q-99Q1PVirLazawTg_npWns51IwNyIVUxotnSspEeIdxnCLjmVpIXTRzDNSfw9fH_iQfsqrZCgIQLIf3EjhVdv0XCr-9YI1Exn_-ZhRQsTk-blBBOuPwUDlSI1EKDEYFUOnXfkN6FJglOwsWunTrTuG6g73HM_eavyYk9OW6bjSnjnwTKrCLHU2JCH7tVgmwh0T7Nt7GQ0w4CRq3kUuOG73ZztdnGVMbc9VPjREX8TMstB7mXItGF-4g6TieJ9yzaCqEuAGoGaAt31RjtiNCU_qZ5f3woTxAaealNqDLNyCQyjpsHugKqJ-W90eiXqlq6P7LQhe-Gd9Hrjdow9HH8dUDivmznI0kZkY4Xb9xjMpOnA7cWpZ2bjAXEyuYWJlV2v_i5vo3IuPw3hGZ5PEM14sUZZBW0yXncXJniBbzLjJgLbuWMT9Np1M8xdIMwn0Hdi3LMd2x0VOUo4WMordrrhrBlufSEd_geZc7gDVK74cEkO1ofzjavRUQ-BECHEMej3jP7tgSOuTxKcqiu0JS_A1D4Ddb1b8FabKErivQLpOlx2JIzs2VWLjCCLuuxn6udmGeuZS8c7uX_NBamKYqoGH4a3jc3wnlAn5GW3uaIetQEEzP7xkSyluqEdGJ4r-iKItuqBi1kOBHirYCSaglFyFQiZKEhW47SZQ8VV_IeTHD31QUfHyeO9cABSP7gyB0cz6fECm2muf6CYMhviKCR_pG12LlbW4rxbHKwU4OjClYO3FqS5w6tvt6=w500-h282-no"></p><br><h3 id="user-id-update-URI-맵핑-메서드-작성"><a href="#user-id-update-URI-맵핑-메서드-작성" class="headerlink" title="/user{id}/update  URI 맵핑 메서드 작성"></a><code>/user&#123;id&#125;/update</code>  URI 맵핑 메서드 작성</h3><p><code>a</code> 태그를 통해 <code>/user&#123;id&#125;/update</code> URI를 처리해줄 메서드가 컨트롤러에서 필요하다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userController</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@GetMapping(&quot;/update/&#123;id&#125;&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(<span class="meta">@PathVariable</span> Long id, Model model)</span> </span>&#123;</span><br><span class="line">      model.addAttribute(<span class="string">&quot;users&quot;</span>, userRepository.findById(id).get());</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;user/update&quot;</span>;</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>userController의 경우 URI에 공통적으로 <code>/user/</code> 가 사용되므로 <code>@RequestMapping(&quot;/user&quot;)</code> 어노테이션을 사용해서 리팩토링하였다.</p><p>update 메서드를 들여다보면..<br>화면에 데이터를 뿌려줄 <code>model</code> 객체에 데이터를 추가하고 있는데, 이 데이터는 전체 사용자 정보가 담긴 <code>userRepository</code> 에서 어노테이션 파라미터로 입력된 <code>id</code> 에 해당하는 사용자 정보를 찾아서(<code>findById()</code>) 가져오는(<code>get()</code>) 역할을 수행하고 있다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model.addAttribute(<span class="string">&quot;users&quot;</span>, userRepository.findById(id).get());</span><br></pre></td></tr></table></figure><p>그리고 마지막으로 updatem.html을 return하고 있다.</p><p>컨트롤러(<code>class</code>)와 화면(<code>html</code>)에서의 특징이 하나 있다. 이것때문에 삽질을 좀 오래했었는데….<br>html페이지에서는 id값을 가져올 때 <code>&#123;</code> <code>&#123;id&#125;</code> <code>&#125;</code>  로 표기하지만, 컨트롤러에서 맵핑하는 URI에는 <code>&#123;id&#125;</code> 로 표기해야 정상적으로 작동한다.</p><br><h3 id="html-페이지에-mustache-문법-작성"><a href="#html-페이지에-mustache-문법-작성" class="headerlink" title="html 페이지에 mustache 문법 작성"></a>html 페이지에 mustache 문법 작성</h3><p>컨트롤러에서 가져온 사용자 정보가 담긴 <code>model</code> 을 가져오려면 mustache의 문법을 알아야 한다. mustache에서는 model을 가져와서 화면에 맵핑할 때 아래와 같은 형식을 사용한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;#model&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;&#123;/#model&#125;&#125;</span><br></pre></td></tr></table></figure><p>여기에 User에 저장한 사용자 정보의 컬럼을 <code>&#123;</code> <code>&#123;id&#125;</code> <code>&#125;</code>  으로 감싸서 input 박스의 <code>value</code>로 넣어주면 된다.</p><p>필자의 유저 컬럼은 다음과 같이 지정되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Column(nullable = false)</span></span><br><span class="line">  <span class="keyword">public</span> String userEmail;</span><br><span class="line">  <span class="keyword">public</span> String userName;</span><br><span class="line">  <span class="keyword">public</span> String userPassword;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 수정에 필요한 데이터 컬럼인 userEmail, userName, userPassword를 사용할 것이다.</p><p>이를 적용하면 수정하는 페이지(update.html)에서 작성해야할 코드는 다음과 같다. <code>form</code> 태그 안의 속성값(<code>method</code>, <code>action</code>)에 주목하자. </p><p><strong>/user/update.html</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;#users&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/user/&#123;&#123;id&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--이메일 주소 입력 칸--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;userEmail&quot;</span>&gt;</span>이메일<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;userEmail&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userEmail&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;userEmail&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">&lt;!--이름 입력 칸--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;userName&quot;</span>&gt;</span>이름<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">value</span>=<span class="string">&quot;&#123;&#123;userName&#125;&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">&lt;!--비밀번호 입력 칸--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;userPassword&quot;</span>&gt;</span>비밀번호<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">id</span>=<span class="string">&quot;userPassword&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userPassword&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 비밀번호의 경우 value를 가져오기보다 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 새비밀번호를 덮어씌워서 바로 수정이 가능하도록 하자 --&gt;</span></span><br><span class="line">      </span><br><span class="line">  <span class="comment">&lt;!--수정완료 버튼--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;btn btn-success clearfix pull-right&quot;</span>&gt;</span></span><br><span class="line">      정보수정</span><br><span class="line">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clearfix&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">&#123;&#123;/users&#125;&#125;</span><br></pre></td></tr></table></figure><p>model로 가져온 값을 보여줄때 사용하는 mustache 문법은 마찬가지로 <code>value</code>를 <code>/user/&#123;id&#125;</code> 로 감싸서 보여준다.</p><p>여기까지 작성하면 아래 이미지를 구현할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/q-99Q1PVirLazawTg_npWns51IwNyIVUxotnSspEeIdxnCLjmVpIXTRzDNSfw9fH_iQfsqrZCgIQLIf3EjhVdv0XCr-9YI1Exn_-ZhRQsTk-blBBOuPwUDlSI1EKDEYFUOnXfkN6FJglOwsWunTrTuG6g73HM_eavyYk9OW6bjSnjnwTKrCLHU2JCH7tVgmwh0T7Nt7GQ0w4CRq3kUuOG73ZztdnGVMbc9VPjREX8TMstB7mXItGF-4g6TieJ9yzaCqEuAGoGaAt31RjtiNCU_qZ5f3woTxAaealNqDLNyCQyjpsHugKqJ-W90eiXqlq6P7LQhe-Gd9Hrjdow9HH8dUDivmznI0kZkY4Xb9xjMpOnA7cWpZ2bjAXEyuYWJlV2v_i5vo3IuPw3hGZ5PEM14sUZZBW0yXncXJniBbzLjJgLbuWMT9Np1M8xdIMwn0Hdi3LMd2x0VOUo4WMordrrhrBlufSEd_geZc7gDVK74cEkO1ofzjavRUQ-BECHEMej3jP7tgSOuTxKcqiu0JS_A1D4Ddb1b8FabKErivQLpOlx2JIzs2VWLjCCLuuxn6udmGeuZS8c7uX_NBamKYqoGH4a3jc3wnlAn5GW3uaIetQEEzP7xkSyluqEdGJ4r-iKItuqBi1kOBHirYCSaglFyFQiZKEhW47SZQ8VV_IeTHD31QUfHyeO9cABSP7gyB0cz6fECm2muf6CYMhviKCR_pG12LlbW4rxbHKwU4OjClYO3FqS5w6tvt6=w500-h282-no"></p><br><p><code>form</code> 태그 안의 <code>action</code>은 해당 form이 실행해서 어떤 URI로 값을 전달하는지를 알려준다. 위의 코드는 <code>/user/</code> <code>&#123;</code> <code>&#123;id&#125;</code> <code>&#125;</code> 로 값을 전달할 것이다. 따라서 해당 URI를 맵핑하는 컨트롤러를 작성해주어야 한다.</p><h3 id="user-id-URI-맵핑하는-메서드-작성"><a href="#user-id-URI-맵핑하는-메서드-작성" class="headerlink" title="/user/{id} URI 맵핑하는 메서드 작성"></a><code>/user/&#123;id&#125;</code> URI 맵핑하는 메서드 작성</h3><p>지금까지 update.html 페이지를 작성하고, 여기에서 요구하는 URI를 처리하는 메서드(컨트롤러)를 만드는 방식으로 진행되고 있음을 알 수 있다.</p><p><strong>/controller/userController.class</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.devandy.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.devandy.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.devandy.repository.UserRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/user&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">userController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="meta">@GetMapping(&quot;/&#123;id&#125;/update&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(<span class="meta">@PathVariable</span> Long id, Model model)</span> </span>&#123;</span><br><span class="line">model.addAttribute(<span class="string">&quot;users&quot;</span>, userRepository.findById(id).get());</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;user/update&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 추가로 작성한 메서드</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">update</span><span class="params">(<span class="meta">@PathVariable</span> Long id, User updatedUser)</span> </span>&#123;</span><br><span class="line">User user =  userRepository.findById(id).get(); <span class="comment">// 업데이트 전의 프로필</span></span><br><span class="line">user.update(updatedUser); <span class="comment">// User 정보 업데이트</span></span><br><span class="line">userRepository.save(user); <span class="comment">// 업데이트된 user정보 userRepository에 저장</span></span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;redirect:/user/list&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아까 작성한 get요청을 처리하는 메서드 아래에 post요청을 처리하는 메서드를 작성했다. id값은 노출되도 상관이 없기 때문에 get요청으로 처리했지만, <code>id</code>값 외의 사용자 정보는 유출되면 안되므로 값을 노출하지 않고 전달할 수 있는 post요청으로 처리한다.</p><p>메서드 이름이 같아도 상관은없다. <i><span style="color: gray;">(진짜 상관이 없는건지는 모르겠으나 아직 문제를 발견하지 못했다.)</span></i></p><p>이번엔 <code>User</code> 객체의 인스턴스를 2개 생성해서 사용했다. 하나는 DB(<code>repository</code>)에서 가져온 사용자 정보, 즉 업데이트 전의 사용자 정보(<code>user</code>), 다른 하나는 화면에서 생성해서 전달받은 새로운 사용자 정보(<code>updatedUser</code>).</p><p>메서드의 작동과정은 다음과 같다.</p><p>URI를 통해 전달받은 id에 해당하는 사용자를 DB(<code>repository</code>)에서 찾아서</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user =  userRepository.findById(id).get();</span><br></pre></td></tr></table></figure><p>아직 생성하지 않았지만, User 도메인의 <code>update</code> 메서드를 통해 파라미터로 전달받은 새로운 사용자정보로 수정한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">user.update(updatedUser);</span><br></pre></td></tr></table></figure><p><code>update</code>된 사용자정보를 다시 DB(<code>repository</code>)에 저장한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userRepository.save(user);</span><br></pre></td></tr></table></figure><p>그리고 원래의 페이지였던 list.html로 리다이렉트 보낸다.</p><p>이제 데이터를 불러와서 수정하는 일이 끝났다. 이렇게 <code>id</code>값 1번에 해당하는 사용자 정보중 devandy라는 이름을 andy로 수정할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/yALf5fWSOouJT6U9JhV7qANP7b42ZLtVvmta3tWAGqd5Ma3yfb38_dZoFS3Z24CsNkPE0a51nodYvrJ7OyS5CO1TYB8oB0b2DFa5nU2oH-BE7zlobJcLQC6a0TawoxY4E4pHJ5zNQT_YoDlIgvAq6Lw3m5inqas_X1BnlxjHHb9npp90YHV2K3LA-mWT7N5mWfyTactB5Tmb3CSE1ZnJrDPCSyNC8nvln9yRmXrfYskvCx2Y5nich-TExW1kKbybNRedP9NRb9E-MEk5WCUj6efmb0e6w_6sWrrRu8AYNKpWBOgtn-XVgRKHaxgbeoht5NhO78xIXFmtO96gEqHs-n4oN_N9XH6Vb5BkDBqOSNwH5bEvSC5FSzNbmFglVByX7bmbIxboH-MreOZsDrQkjJLXJOadIj8qXMTkfDnOHKlufPPlqv0ZLyozMZT71Xci0bCIKqTRAM4m-fbnA2v2zGDnyLeXRIBEwWz2KLEgIu7zWiZNlfYfyBlfCWv7hL3TooSl2croTA1SEb4-Zi0eKTuksnZXl__OjSXKQRRrIh-P2vqKph3cqXcX234qNsqo0QGK1IvyyizNDa8Kb9hNPhMlW_MykVon8DrsmruFh-_Ef9QrDwiKqLQoI8H-ZAH7S-UkXhkA7eW86wVKB-d5fP17ksmq6Sb34NjnKTK9DOuFtclp7HEV_zXkOlUrnHfXSlBXqCyPP43avbN1MVY38_-560MWCjvronmNLta2S8LxR1bu2UNyHeJz=w500-h308-no"></p><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> mustache </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>맥에서 Xcode 설치하지 않고, Command Line Tools 설치하기</title>
      <link href="2020/03/install-commandlinetools-without-xcode/"/>
      <url>2020/03/install-commandlinetools-without-xcode/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/agSlvmHiGiO_1IxMQGTatd9jBtushkYwLp5aU8GawK6Pi37zYyT0wJFbFaSHChUhMHn6EeYZBzIrYRG1zYR9jM4gRYzZ93LdinndsQ2IaHun9Lt6GHGc_1nHxk0OEqxtf85DyhsPSuPsOGkh8mYZDL3tLdX9t_8kXQjq-1Vb67-4oky5xLqNRF6hNc1WIQ_BUV8IqHgQxHsZTgN-l94leqfREO36BdCU0cZf_8Zj4cotqLBKT2USjbganf2kaOrlBIy_qNwcTyEoCdZ7GDXmhKSTJMF53fxSw8T-XZlZWXN1BrK9U6mfNRX_JrwEraqpy8xm1CyDj4h6rOwJ1CpYwvbMzxzuDgX-_dQSRDSGE1LJ_NWZWhpnQrBS35e1jek_o2x18AAcC-52CRaPrLM62vqOrR7s0OaKCWSVHfN_ix-_QR92nXXdc_z-HpTu2LXmrzBLwpj_8bSYGhKh69MQLYqLQbKiDdvTuCeNMFulR_IqsdbgAJDr9NmViodXiIEwPzzNgEKgEh-QnFxdnmj7-zCd0I4qZBp6VyzmJ8Pu9u5361kwd40OGHubDNgkQKmSDzsDCZWp1qp8luWerJReU_UdMe-Krx_CuFEBhQNpvnCBQfStdKw4QVqxHPirTlPAtobG5YUSRNNr2eMaGq6P8t2NmNzm6yuTaZIkvNDNaG7dXdmUHW7DfjRGIUGD-bIhljCZE2_P5rlrkLBpv4DLcEBziwnZu_gPk39VxqAdJbIg7w3j0Fw9tTso=w1642-h733-no" width="650px" /><p>맥으로 개발을 하다보면, Command Line Tools 때문에 X code를 업데이트 할 일이 종종 있다. 그런데 X code 자체가 무거운 프로그램이다 보니 업데이트 할 때에도 긴 시간이 걸리곤 하는데, xcode 없이 Command Line Tools만 따로 설치하는 방법이 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>위의 명령어를 입력하면 X code를 삭제하더라도 Command Line Tools를 업데이트하며 개발할 수 있다.</p><p>참고 문서 : <a href="https://macnews.tistory.com/4243">Back To The Mac - Xcode 없이 맥에 ‘명령어 라인 도구(Command Line Tools)’를 설치하는 방법</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tip </tag>
            
            <tag> macos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS 튜토리얼(2) - Ec2인스턴스에 프로젝트 배포하기</title>
      <link href="2020/03/aws-tutorial-launch-ec2/"/>
      <url>2020/03/aws-tutorial-launch-ec2/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/qhdDFWnctJLKcX23nrRJ8SPeDluLDJ2T49Qdrd5qUyu0oAeDiJtkjP9IpgMUd1rQneENw9-3aPVXXxob9cvptQexHXxlpEkiV2DEVh7kjTWzLrEZfm33eIcmgCLvn9RabrYkpcRd88bwDHVs1BtKeKLSjdbSAo0TE1LlvQ2KDVb5c1s_mO8KVbeMf60EMfzm3JKFYzJxzp9Z0Rb5-Lx7gBhNlUpttCjHH0B4LN0_qDK9-H3DG0YzD5SExkz7hfGAztWiysUAqfxFIj2x2ykLyLp0XgZW28v19Q0nh9fk0azHj4eUQGnS-F-pA4YYxBtWBOHDOBU0nralDG0kJE8LlzsM4Ug_lQ0dfFSt27Nf3TKbsm5LsvLLcYtti0b4Nmx1Z8xuktbgY-FkthYPGMRuQw8xepxBb-sWV5ZVG6CCb0yuksVbr_nXtolsp7A7IlJM3kxp9mX1t49zIhGbFNBy_J4iRc_0VHBc70uWiJT30E5Uy8SrLzzG3Q9CJo5NQujLz6TPe1ExrqsW0MYYxhVJ6bcwaL13earne2IqoD4g1Dq3eNs9w8phZUZKD2KMySw-FftnVmZJtOF1A9ngR_77n-wU5p5wN47sMtVBHKQY3nA-mde0qoLdp-k86_sr19bzogwxxF1vL_z1RrQIiC6fQx8mq061LiMdYVX3PeJ4xmbcTQq672ttiP7CSDl8Q_d28J9tFtBVK23dQPRyUJZ6HTSziTw7tGkiWWAKsppCpWydZFqNNK7tJ0Gw=w543-h273-no" width="650px" /><ul><li><a href="https://youngjinmo.github.io/2020/03/aws-tutorial-create-ec2/">이전 글 - AWS 배포하기 - EC2 생성하기</a></li></ul><p>앞에서 생성한 EC2 인스턴스를 ssh로 실행할 것이다. </p><ul><li><a href="#chmod">키페어 권한변경</a></li><li><a href="#ssh-ec2">ec2인스턴스 ssh진입</a></li><li><a href="#install-jdk">JDK 설치하기</a></li><li><a href="#git-clone">프로젝트 클론하기</a></li><li><a href="#mvnw">메이븐 빌드하기</a></li><li><a href="#java-jar">jar 파일 실행</a></li></ul><br><h2 id="키페어-권한변경"><a href="#키페어-권한변경" class="headerlink" title="키페어 권한변경"></a><a name="chmod"></a>키페어 권한변경</h2><p>터미널에서 ssh로 ec2를 접속할 때 보안그룹을 생성할 때 다운받은 키페어를 사용해서 들어가야 한다. 그런데 바로 실행하면 키페어의 권한때문에 접속이 되지 않을 것이다. 키페어의 권한을 바꿔주는 명령어를 입력해두자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 600 key.pem</span><br></pre></td></tr></table></figure><br><h2 id="ec2인스턴스-ssh진입"><a href="#ec2인스턴스-ssh진입" class="headerlink" title="ec2인스턴스 ssh진입"></a><a name="ssh-ec2"></a>ec2인스턴스 ssh진입</h2><p>ec2 인스턴스 접속에 필요한 주소가 2개 있다.</p><p>우선 접속에 필요한 <strong>키페어의 경로</strong>가 필요하다.</p><p>그리고 우리가 들어갈 인스턴스의 IPv4 퍼블릭 IP 주소를 복사해두자.  </p><p><img src="https://lh3.googleusercontent.com/3Kn5taO6ytEygRTpy65qfcgQnXgkp4yToVx38K086YfPdH2NEVoau1vJqNTQHbkrkTPYn7lLwf-ZeCYEpF4mbjdL9ej--ekwel9sJIuR_K6Ay_BeZwpLUH7cYtmUzkDAuvFKjn2MuHIY1bajD5mKemcgxzfXYWZOfddKxEc-jU7UI4v7nNWTz7GYsBg5OnnXayF5uZ74ecAsm8zI7QuYSDD5-FkDrwapkoT3OdR8Ya_6bd2GRSc1LAjhIwx28fwdUK3l_5H0LLgC1e7PfNRGyGHqFNv_w7CzCujJ5nNxw0r3AfKH5l888-adBNIz8VxAAblosRgyUJ5CrOFKTw9RAUw7Lok2ZGiamG9yPloKzGBRVc8ewaC5QIFLgsg-0kahyQ7wftWtVibcaKG0h6ULadyJ9C0wCSE7NmuGUn3GJ4bIruEPTTzoMJTmAaFRoLI9G2jAGxYlA8TkZ7-kZA8xPNLHOwKRWgPZ3aYUhlWfDske3X1UX04Vp_3_EQ0376Z4P4a03RNQWwdyj9YEP_pjzCwd9XQcs6-t6A-XT-1ziiiGH43cp9HJikuMbAhe8SzCKOd1ZPAllx4Sg7aSpTFkGX18BTdfM2Wvu_CNVFuqbDBuN-9Fyp0xkSuay2WRTazwB74FThHKc1yzv0D9Agk0hWio69SU50uGXnyKhF6asXDdC2hv4VzrPnnxjvtfIWB_kjrwJPXlSD0Mc5-5War2bROMXLL5TLEZMupr-K1O6nwEc3fbSG7Zj7tC=w1152-h602-no"></p><p>아래 명령어에서 방금 복사한 퍼블릭 ip주소를 붙여넣어서 터미널에 명령하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -i [키페어 경로] ec2-user@[public ip 주소]</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/yPvwxHmknS1kVxQLRom4oaFVyJ7wlBsz-hUYedi3ZrtCe8LKvmKmZASVLVfIcYlfj2kD39IvKZEkYryEw7L9eM27wwrR-tghlZBovTJWPIMmMtJdzZPaAMHQD0YOzztlTQEKrUZFQ4315mDfSopoZEO6nhpPyKRFgzkNF57SysahCADXuI5z4CSApoQ_HnsgI3ihKAC0A3jqzFIikPhUXC2u3uVl--rvQ_jIrAzcAjhplRh_VcEB1l5nawHKoeocI6a29dm4Gsr-zipaMCuLVnxe8t6_uh1cNue_czQTAM5anR4D5_1tKuCk9bDh-3LX650ovPPDiMCIRcvPzNVYKqEfSM3DdRKs8gHwr8D8NGRbQFbsqAMFw5co4_kLrx9lDm-cOU5LHjJhs5R6qI7VK94YZuksQhj755_WDn2Rjl2LeeDiIbBZYgKqiEpTCDvYwJNfTnWiIn92QKdgiL4Vi07c3JKM1sJ2ui9NzyR6OLYrORSEMeP6zAh9Pvges__T62GirNd0lfhg9MAlbVQwkqcnNX_Db7Nc3EkyJBsxcaU0ki8BqWLuReT6ddzDSnoaSsHTj6kVNWgSL3Q0cpQE9SC_xzhtUKXHcUmG70ME86PxmvrQZpaxeplilTC9IYU-tNRATH0IAIauGawuGerfzPUc9bkVJnfZ5mOyFSFEBChF21CGtTZ6qfJKLv6a3X5rSIowcX4H8LNNFOZzS1qwv9iYywSsEpVhCuZAb7D5s-yPSVs5-pTPNFvC=w957-h368-no"></p><p>혹시나 계속 진행할 것인지 묻는 메세지가 출력된다면 yes를 입력하고 엔터를 입력하면 위의 이미지처럼 인스턴스 내부로 진입이 완료된다. </p><p>만약 권한 이슈가 계속 발생한다면, 커맨드 명령어를 잘못입력했거나 키페어의 권한설정이 잘못되었을 수 있다. 위로 올라가서 다시 천천히 설정해보자.</p><br><h2 id="JDK-설치하기"><a href="#JDK-설치하기" class="headerlink" title="JDK 설치하기"></a><a name="install-jdk"></a>JDK 설치하기</h2><p>아마존 리눅스에는 기본적으로 jdk가 설치되어 있긴하나 1.7버전이 설치되어 있을 것이다. 따라서 명령어로 1.8 버전의 jdk를 설치하고, 사용하지 않을 구버전의 jdk는 삭제할 것이다.</p><p>먼저 1.8 버전의 jdk를 설치하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y java-1.8.0-openjdk-devel.x86_64</span><br></pre></td></tr></table></figure><p>이제 jdk 버전을 방금 설치한 1.8버전으로 변경한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;usr&#x2F;sbin&#x2F;alternatives --config java</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/yVY0fMVAiHUxPyw_Ibscv8iF7A2aMWi7KkYjKPEQPFOc3n8t_l1dfEynwFkf1evz-6kvnGS7IVbE80qJXj1K3KVPikynKJiaD9kP90a7BtB2lrjPZZ_FIlYmdaDTAxiCBtUdKQGuiusbffVp1rYVzRctbojT47UWGH-GjYSYeZHZJV7iHSU9dE071-WBW5YPpo5PDotYB1evn8ybBPkFXXmkIffEXnK1aoMXLF23bIQ8YoW1os7YrtdNXvBEyDmowDl9v8YOlqXYSG2JUiVxOGaCyLqwYsCrHDcxbu6f51g5Cor3mrUwRFfB4cuCK7pSipv49tvEeEi3N-1HYJpxr96g0XTnWc2HIxcg13A70QbFgXM9rIbHCuan6erypb5HoWdFw3TfWlfyNsxViYduzuonN-drZ2u-TLGEk06zxpA0YPp3v9ei7wv8965nlkR8VsBwd3jjAg-_oD0CinmWBHBYxNli0hdJmkKemSKZmJGYgdo9I6q2K_lSpUU7EfwjO81xfr8Qs4OkvBqoZPSCq1LDZ3b26zg2SLTxMCl1RsTdghlHHuJLc2Q54z_6Yk4T3Qrg9--yzJw_nLi8mmxdaIZHuiF6tIm6q3TfifwIECuilXWD31Yb8XBxUgMaUHp7Zu2uCXrGf51-d7f2-2f7-XALqnGbpolnR0R8m1VooFPbpp9GJmMG6_1UUTu2D9yl1lLCtEUzcorM53MvDOLbMZbB-czhbnjS11WzLavLYeNKviTo8qm5rKhx=w1097-h505-no"></p><p>+가 바라보는 곳이 현재의 자바 버전이다. 변경하고자 하는 버전의 숫자를 입력하면 해당 버전으로 자바가 변경된다.</p><p>이제 사용하지 않을 버전의 jdk는 삭제하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove java-1.7.0-openjdk</span><br></pre></td></tr></table></figure><br><h2 id="프로젝트-클론하기"><a href="#프로젝트-클론하기" class="headerlink" title="프로젝트 클론하기"></a><a name="git-clone"></a>프로젝트 클론하기</h2><p>아마존 리눅스에서는 <code>yum</code>이라는 패키지 툴을 이용할 것이다. git을 설치하기 전 패키지 툴을 최신버전으로 업데이트하고, git을 설치할 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum update</span><br><span class="line">$ sudo yum install git</span><br></pre></td></tr></table></figure><p>약 10초가 조금 지나면 설치가 완료된다.</p><br><p>그리고 프로젝트가 저장된 깃허브 웹페이지로 가서 https주소를 가져오자.</p><p><img src="https://lh3.googleusercontent.com/ukC3LTG9G3Od0hZbIUWLw2GTmTZjjDWtHR-lz3Gv35U8K6ikT2vmLthldNAriF2dxS5Jqh_oYgwdDORZsYDXCXOyqyY6aELFVkL7WFtmgWJXvZS9gOsG5skJUqHmZMhSLFSe44M4aSHteW2sC1s-PlTPgN-QIBeuLtWffKXT8eyNiqXJapwS7oaGJ--Abri4FYMJ30j2dnf-Ge7OLHx0kRyhkZhpl-vgBOaU_JeGDxSPGYxpYV6cayxxB-e9GPCGMohESsOi_k9765H1mMgbf0miSe6JMTeX-X5_--t437Bz-Fi4Kz4mnRmjxyr57vqonGR7PuIp7NE8G67ACC8fTb0RRFM6XZG1jeKFHsI5gRjRCG79ineEcizc84vIjSjOmXpRvS7d-wooyFJw1WCbA3cUYzsSZJDQ_dq81XmnDFSZQDJSm3L8nToxtJ-ZPQAwDW5tbUjtXnXvufn1u5IxrHF01APDA48Po48Oi8g5A70BroXOfyounqT_ml-_GBl265e_KBfmCXwJWOQErAh_OUhdUtNcldizq7DlvmOI1n4NJVUYwba3fO8WVRUEcZxj0t2WOMW-NHWobK7Sms66AJ9F8XwfmIkBOhfSZ_erL1h2qODzIWh01tEjVvFWJo8q1wQDb97F_ZK2KHjUrOAGl4Y6Rj_h5QQ1YNa2_0lrVtl8qtqnW2ucJKSOq75lUm-Z2cYNizsGki-hoOrlEJx767QfHUcpD9ZH_Yd06CUmaGTFPSZJa1q0Oubv=w1257-h602-no"></p><p>이 주소로 ec2 인스턴스 내부에서 클론하면 된다. 프로젝트를 가져올 디렉토리를 먼저 생성하자. 필자는 <code>/home/ec2-user</code> 디렉토리 내부에 <code>app</code> 폴더를 생성해서 이 안에 프로젝트를 가져올 것이다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone [git-clone-https-address]</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/dx-mYOzFt3z0Z8UzVs14sTyICzQJzvax_rGY6kzXbMGBbQU4vg-1QxIEFuwYtr6OCsar1E94XUgQRWgaUPQRyxjTSxSIQFB4HWa0NEfmevefd6EHWvJN8VQr-pCmOLAlgNx0V83Wn5eKi9ZJOKpYDtigj5bWvEMAm7y8bNCQkBBar3qYjyEKB2Y4ykTe6PFOfbvJ3IpTw8nBA6k9S1PS91K54EowsAcSNp7V3CyP8jciO2ZDXb1RmOEkfVj0M7z5mZ9LF3R8H1gH5wF2wtM_arUyf315ZzW50uE4lJaStLbyCuq26IY9vbydzof6pUhljxOmOGeGmManTJdvHPBlFHTYwzVEQlauo0vn4eFj42D05A0zMwDEa_4kY50Hjw9yD-524TKvWDgXUVqBGwUEgdLK-5nQn4aRenC02iOTS_ACfDAtqOnrykynMtZq0plD8gr2aqpnGqq1eb7SogThcOrw1rLIuZsaA8xxITrWljaCeq3LQtbZ62zCZJvPpPuTNlEvIGhp1-tDXJT96aeF-mKm6tqaRTHCEKwGFA2aIbGjbg_N80gNit5LC0m6hPHdtB3iPujdbITckue5b43-PfNjr5x3Uom45e753vSsm1_XPcv8T9WgVTEW8n1YJDvSHADJaHtsldw5mVOwXZF3zhy_p4T7wiIOzin9HS3csMwT4eKfa5tsIfkwGnnUohpIsg8FMMbLu1ZOvuZDCjvxxpqQn72Fc1hStTc025fWRfvAV9_Na7xp_9Y0=w960-h182-no"></p><br><h2 id="메이븐-빌드하기"><a href="#메이븐-빌드하기" class="headerlink" title="메이븐 빌드하기"></a><a name="mvnw"></a>메이븐 빌드하기</h2><p>이 프로젝트는 빌드 툴로 메이븐을 사용한다. 메이븐을 이용해 프로젝트를 빌드해서 jar파일을 생성해보자.</p><p>메이븐도 권한을 변경하고 빌드한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x .&#x2F;mvnw</span><br><span class="line">$ .&#x2F;mvnw clean package</span><br></pre></td></tr></table></figure><p>처음 프로젝트를 빌드하는데는 시간이 좀 걸릴 것이다. 대략 2-3분 정도의 시간이 소요될 수 있다. 다음에 다시 빌드를 할 때는 이정도로 소요되지는 않는다.</p><p>빌드가 완료되면 다음과 같은 성공 메세지를 볼 수 있다.</p><p><img src="https://lh3.googleusercontent.com/zJdGocxwqgiIlHKXESU5XLVDKS6fuZkpXHX2vbaG_RTNPc4rPAlWQupN7S-Cx5F0K5ZYrdw7BYMkZWWo7o_Zike4AxIz0UbnruoY21WJW63Zm3JCWrUejR29QgPhzUScfXFbPolvZJNJu4Pwplg-U2Lh3CnKv_IF2Fcn9a5RK8t3AFEppg9xuGaKE3TCC4JnzH53pWjbHZ7bCH__qPWmjT9CgnGareKpTOOLoyL629dVWdMB0RuAwFgzxDRrba_nvwpE19bjYPnMNzsHEj7QKs179kgrSySrAtt6MiClfCZjsVsNwwJTXglU5neSdc7Emos0wSAgPuCfd9CYqj-uwdMRNEvfqKJnCAnFpObc-cYNqjfk2GpcTjtOwIwRrxslVFNH2Os280uYXyJcQpe2vyjrbOCyX9mhjegcA2k98b1703HqUz3Jixfd41Q31nXQRAZyCtl9cKGyD-PiJ35PJfcaSC6i5a4M5Y78ngJgXhiUkwE4WkPKez_D8zkr6SuUgxdi_y6qGEoiuGIXoio6wuLjDwI4ONXfe6JugV2UxgsxhFzi_saogdP4sPbFUGgrdXghFh_2O6ZDZ5ZONLakrAjohZVzUxLy1cPYQ1u0Z_2QeZrkgbBsNuAU8J0aFacRmY80aDxnbd2XoYvMdWZkgCmaRYd01f4BQayId3e1aYOzBYgtG0YQbjyEM1rHrFZv6jWCuVGYHkJuLTWT8jIJ2t_D6JTCwgHhz5Y5ylQ-hMj7dN76KDKrC_5k=w959-h510-no"></p><p>만약 빌드에 실패한다면, jdk 이슈일 가능성이 높다. jdk가 설치되어 있지 않거나, 프로젝트에서 사용한 자바 버전과 다르기 때문일 것이다.</p><br><h2 id="jar-파일-실행"><a href="#jar-파일-실행" class="headerlink" title="jar 파일 실행"></a><a name="java-jar"></a>jar 파일 실행</h2><p>위에서 메이븐으로 빌드했다면, jar파일은 <code>/target</code> 디렉토리 안에 생성됬을 것이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar target&#x2F; .jar</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/JM4GiONuVPpi7qrdI025vQjux7q_g3K9FTNRSoyCUss-sNfmAgT6xpIhLy_jtbtWxL75mTFT1gmP0mQivAFs0jWK82nXUfRkNBwpXSPH6Bv0DcrOIw40uSZQ7RAax-cFxRL8uMJXotxDjNg0ffEnBJoAv7pKf1YPvL2Pux_hl6yzURe8A96-lOxSs-ZkNJJcdmAL2mgyxaEHKTUsNqXd4fJdcZzL5NAX9lipfA9v5LQdaYc3agFsxcnTZsxebYfuV0nwwosR-2MDvtMmLBgbdmysTHWft4Eb_1bSiYjmk4a1DZCUhiAxicr9JzigFuvY1SJhHmp3LXmaXwtc8sM29TFqYoaUVc2p0HW3jUbci2YdMUciBKd7Zq5CslGzT5cdEGfzFbpi_TAyrPDjjw3zzH5lkkIOooy-2asVXdEbY2oyCjf3d7LvKfvDQB-gtLPpHKhdRSgEsd86JEAzlXdaxriqCP9XHxf7J_8G2mljiRZYsrvwpbwl9V2VyIy8NNWE99uiEnpEN2lclkEa29a5gUXZJ5-HhIOXS0VWB_QvRqSASw0ECMYJ7CQsZr-jlmjzyQErkdCUD0P_BpK2VCVu8DGB27NzJQ_0-Y09Cj2Oc7fNOg-deiphy4_elX3jXyb_RDA5EONgKS5d4WkeBg2JgADNqkbGTAMwCN6_X8gQaWLv45XBVVwwfxPQ5uYCGNCA-Yb6n442M7pIKW4nAHIEEMQP-UQMrJEoN2G--ctrLgUDwbSsS2qkFLHo=w957-h487-no"></p><p>스프링 로고가 출력되고 마지막에 <code>Started 프로젝트명 in seconds</code> 메세지가 출력된다면 이제 배포가 성공적으로 마친 것이다. 웹 브라우저로 가즈아!</p><p>ec2 인스턴스를 생성할 때 보안그룹설정에서 custom TCP 프로토콜에 설정한 포트로 접속하면 된다. ec2 인스턴스 퍼블릭 ip주소에 위의 포트번호를 입력하면된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[public-dns-ip]:8080</span><br></pre></td></tr></table></figure><p>그럼 브라우저에서 프로젝트를 볼 수 있을 것이다. 혹시 프로젝트가 열리지 않는다면, 포트번호 맵핑이 잘못되었을 확률이 있다. 그렇다면 보안그룹을 다시 살펴보자. </p><p>EC2 대시보드에서 [작업] 버튼을 클릭해서 EC2 인스턴스와 관련된 여러가지 설정을 변경할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/L4WCMTb3h1ay96mRX2N2OnpdLnvixemnc3I_8zSovK5F-YnFSzyQBqMa8502ZNlSRL5IkkASYN1oOFH3Uy8pcX3NPnsGq9fF73IxWBz0OwuhxrcKJSVoIkpW4MrL3MMn5Kie6Iee1NhrjH7g_V1ucoLg0S_wK0u0Xw0BuOWAhtKuqed279nU3wTwM2aEnfPFTcRyQ6uIG4ojwxvw6t9f41iquW_TFyXK49fMDRJ-gXvNXzi0Q4T4ymc5LK1pAHhArgdOQeJiJZGdFXLyOn6fFGwQJBGj50Ak-DvAGYqwjpp6DvbWmHbszQmc6ZY8G4e6Wvu3305bgQSWqKyik8KwmFApBfKFRtWe0V_RclwgcvTCQtI_CoQGgLNpTOOmzQ-2Q_a__r0xj_ulDxXZVfYnnrSW14bXPOks_V6veMKKQFQxzOkoy5sX_v9fug9sPmherz4Rf73EAkEPS_PbHrH58BxNJvBcDbOLMIG_1eyPe2lEiY0teJ-442r69asFidmRCQ4XGW7N_34kwJjZaLTJ82bWDCDc_kJONDCmRNw5HhMFqW-Y6e3y8G7YRvN-EsjTvfQdaE24JK4L0B9C-aP1tNs9dufC1V9CkwYvGiR83nUWwtchgJbS4OBfAzSYPmiE_0d7jvfGovBaviicuJDejF-POA_DPWNj2mSm-lE27eD8Ibhl23upY-VayPNV5KHIRDTynU2-KITRMS1kFOSPmBJtcCyKayyXu47yQEtaPnpvN02xzmGl1deS=w1259-h601-no"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> aws </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS 튜토리얼(1) - Ec2 생성하기</title>
      <link href="2020/03/aws-tutorial-create-ec2/"/>
      <url>2020/03/aws-tutorial-create-ec2/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/qhdDFWnctJLKcX23nrRJ8SPeDluLDJ2T49Qdrd5qUyu0oAeDiJtkjP9IpgMUd1rQneENw9-3aPVXXxob9cvptQexHXxlpEkiV2DEVh7kjTWzLrEZfm33eIcmgCLvn9RabrYkpcRd88bwDHVs1BtKeKLSjdbSAo0TE1LlvQ2KDVb5c1s_mO8KVbeMf60EMfzm3JKFYzJxzp9Z0Rb5-Lx7gBhNlUpttCjHH0B4LN0_qDK9-H3DG0YzD5SExkz7hfGAztWiysUAqfxFIj2x2ykLyLp0XgZW28v19Q0nh9fk0azHj4eUQGnS-F-pA4YYxBtWBOHDOBU0nralDG0kJE8LlzsM4Ug_lQ0dfFSt27Nf3TKbsm5LsvLLcYtti0b4Nmx1Z8xuktbgY-FkthYPGMRuQw8xepxBb-sWV5ZVG6CCb0yuksVbr_nXtolsp7A7IlJM3kxp9mX1t49zIhGbFNBy_J4iRc_0VHBc70uWiJT30E5Uy8SrLzzG3Q9CJo5NQujLz6TPe1ExrqsW0MYYxhVJ6bcwaL13earne2IqoD4g1Dq3eNs9w8phZUZKD2KMySw-FftnVmZJtOF1A9ngR_77n-wU5p5wN47sMtVBHKQY3nA-mde0qoLdp-k86_sr19bzogwxxF1vL_z1RrQIiC6fQx8mq061LiMdYVX3PeJ4xmbcTQq672ttiP7CSDl8Q_d28J9tFtBVK23dQPRyUJZ6HTSziTw7tGkiWWAKsppCpWydZFqNNK7tJ0Gw=w543-h273-no" width="650px" /><ul><li><a href="#create-ec2">EC2 인스턴스 생성</a></li><li><a href="#step1">AMI(amazon Machine Image) 선택</a></li><li><a href="#step2">인스턴스 유형 선택</a></li><li><a href="#step3">인스턴스 세부 정보 구성</a></li><li><a href="#step4">스토리지 추가</a></li><li><a href="#step5">태그 추가</a></li><li><a href="#step6">보안 그룹 구성</a></li><li><a href="#step7">인스턴스 시작 검토</a></li><li><a href="#complete">인스턴스 생성완료</a></li></ul><br><p>지난주쯤에 스프링부트로 개발한 그레이들 프로젝트를 AWS(EC2 인스턴스)에 배포해보면서 AWS 배포를 정리하는 포스트를 정리하고 싶었다. 그래서 이번엔 박재성님의 유튜브 영상 강의를 보면서 하고 있는 스프링부트 메이븐 프로젝트를 EC2 인스턴스에 배포하면서 그 과정을 기록하기로 하였다.</p><p>앞으로 사용하게될 용어 정리부터 하자면, **<u>EC2 인스턴스</u>**는 일반적으로 우리가 사용하는 컴퓨터와 같다. 램과 용량을 선택할 수 있으며, EC2 인스턴스가 인터넷에 연결되서 우리가 배포하는 프로젝트를 인터넷에서 계속 통신하도록 도와주는 역할을 한다. AWS는 이런걸 제공하는 아마존의 서비스이자, 아마존의 계열사이다.</p><p>AWS를 서비스하는 아마존은 미국 시애틀에 본사를 두고 있는 회사이다. 한국에서 시애틀까지 연결하는것보다는 아무래도 한국 내에 위치한 데이터센터에 접근하는 것이 더 안정적이고 빠를 것이다. 따라서 AWS는 지역마다 **<u>리전(Region)</u>**을 설치해서 해당 지역에서 더 빠르게 접근할 수 있도록 지원하고 있다. </p><p><img src="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/images/aws_regions.png" alt="AWS - region"></p><p>서울도 지난 2016년부터 서울 리전이 가동되어 한국의 다양한 스타트업들이 AWS를 이용하고 있다고 한다. </p><p>참고문서 : <a href="https://docs.aws.amazon.com/ko_kr/AWSEC2/latest/UserGuide/using-regions-availability-zones.html">AWS - 리전, 가용 영역 및 로컬 영역</a></p><p>**<u>프리티어(Free tier)</u>**는 AWS에 가입시 1년 동안 무료로 사용가능한 범위를 말한다. 이 범위를 초과하면 비용이 초과되는데, 이 범위 내에서는 무료로 이용이 가능하다. 이 포스트는 프리티어 내에서 진행된다.</p><p>본 글은 AWS에 회원가입에 대해서는 정리하지 않았다.</p><br><h2 id="EC2-인스턴스-생성"><a href="#EC2-인스턴스-생성" class="headerlink" title="EC2 인스턴스 생성"></a><a name="create-ec2"></a>EC2 인스턴스 생성</h2><p><a href="https://aws.amazon.com/console/">AWS 콘솔</a>에 로그인하여 서비스에서 [EC2]를 클릭한다.</p><p><img src="https://lh3.googleusercontent.com/Y_A97FGra576jzelZ0sUcqXHqadrXehSofEN46vMVSk1QIRrc9z_EQm3FJ2nfhAmtWHSTZwB4_rHB7NpH2dZbMf0Ut5JviAEdn_zSANg7kk1gSPtHfNBnjNRP9GQWcqTq_WCyVxGtJRdKsuFGKbh8UBv62dbM50zEnRXNij5sUTmV97PU2SPp3HEpPErYvZI1iLvel6Xj1Zp7Wvvjjth5nNGcug4DbdZQ27yEfZmubQ5pEf7_IfXDogo-5pTfNnLlFrYWgM0c1f7jAldLBkD6ml0IsvrUoZCjEZX0hMoitrTvQmTLDrH5lwH3mv-BnV97hSWMgQgk1rl68Jxb2cbwP9Xb7DO8r97ink7ZsSMGpvqJu_ddgEEUoKFRYPbKqZdjmFpNkFCNsiz5bezDc66msG9os_QpEY-z3G5_-wdfaGdvxuJI-RItip5oNQIejMLkXwsAjla3P8YNdhd8UURu9_c1jIJ084a8ycc2zFZeWoqBlV-nRBVm-ayy02uqmF7eevdmRNjKvQoHNmNvIkbdYaHD9sY9-OYWpL86GTVRJQuWrjLxvWwFuce2rW9m2KFcVuH8Zd5-YgV1YADmCo98OACjGSP-0_dPDc6XRd7JRCKECuyAFzNpmWdIACHQ0MmjIRUxRycXpZvyLHYVeUg15pc7kscWXrbAOp8r645DQ0mEBDKGQCKjxVUVTBkU46Vda97y2kQnwL2kSnCeWQKxr-Y0u3jcx9_9L7REDkS8RbD4WMYahRy-40k=w857-h449-no"></p><p><br>그리고 상단 메뉴에서 리전을 서울 리전으로 선택한다. 아마 위치를 인식하여 자동으로 잡힐 수도 있지만, 그렇지 않다면 서울로 잡아주어야 한다. 속도차이가 발생하기 때문에 자신이 있는 곳에서 물리적으로 가장 가까운 곳의 리전을 선택해서 사용해야 한다.</p><p><img src="https://lh3.googleusercontent.com/837f8ca-RjQKrlVak8D7hSYNA4aA03ECpn--IZTbxhPYluAPISKj3o2nPmq049GgcG5iSUPTdNS4HviUSSumUCNKbQPJoFGua0U18pcwjGGRqr4covf-qkgevdmVVGhkVEC6d0aCvXtXiZwmqVOery7PxxzZckOIeQ_WEAPwVwUDCqWqfD6iKPiA-Bmmrtx4hCbcQqgn2ujYekeUPDey5Xsb-wgEzbQuzTCsTYr9OURECjSFjqz-QObQXv4PA5bqIorX5nnFmOFTvBHn1paNVuNJJC_1M_Ij3ul9omHw_B0wkhHIxz4nUpmiqaCWoVR5nDkeVzq80GVqZD5GI6hZTtyuZRcuKWDAfulRafJiNrNLqlmiVFdsTvA5LBsuWjcTnCJzfQr3TaERaODrUmK-7STmwk0jOBiB0H0naWma9TMhPdMEeltWqPDjAQbICSu5VXKQwNOt5ohtMJB0IV8GGnHpPycbS0FaczuBx7IDczZlTXPLyHdwENlFg5doclOA1fHrR0ZCxPEUIl8GWmG0xfkHtyV9PkPOYPMqJFKX7trJGl-_iPfxPJ9UNbJSGn09OrmWMoAB_kQp-2OILz0KcQULIoWy6FUBdhrkhu9ncLQJGywotK6H93De9ZAPbr0805GO1JwkqOFY10zNDuUs2ih1aqCZ4vFD6RBPO2fyN2dzlgGG4ULy-kSBGS6bkm6_AgrDzCAI68F1pmsrve3f_AginIzmEIZQ9KwNWcWIDbkfTH3_aM3m2oUe=w738-h244-no"></p><p><br>[EC2]에서는 [인스턴스] 메뉴를 클릭한다. </p><p><img src="https://lh3.googleusercontent.com/31eHAmu6vjZ5Xzjt1hcNzrsaxblWVXyZ0wBuuQ_jD3IyEygPHcJDeVy3QRHjS2leUaNyubCLKOP2fFhn9pfnfBMqgL2j56FugBR7sgf5JR4JuazWTvOCsfnidWwRWEtXL64TtyFdYE8zs9fadUX0B4OswqBQ2ehX-CE90b2lo-WitvcCXab6zUy5en3uoEt4tGtcipJ3ZOGRoVbGuKwbWFTo755f87ydkFbdp8W9IPS1ErafvMPz6fYFDzYajo8UeO1GJQd3hC8v6xWo-YSHI2w9ME4eBkhHQHb2Tl6DJZIVOyf9V7UqX3RtaP4iI9leVteWN5ddLxlwEerL3TDng6FjJN4Up8aY8c-vxqxnsHUh9gHJPD0SQl9IVBvikOJFZMmHjC2xC6vVbwEH1hTUoApIJyFGXi1KBVUk4fS1AUAri_MLNWmOFyM4CwkvSFx7ZGTkERm6WiMB0jA6srYj8vsxSj-jo_73owvFzIt4UrinlaYRGZtSXIyt7QogeH5SDdHUcPQ1YRcClp2QjL_6FtwHQV0o1ldFfSvu1oYp38_7CRd8j2SXYCGpnGEiVeWmD2sZ7Ehxmtwjq3GL8eJ-ouSPn6KHD_x_wtTi45VderBGEyLCJhWMvVr1qFeqQIJqRVTOm8rInpoWD4INWw5CQGCvu3VHxTDL09VjS_TriXbLzCFMAdBvLnqCe0GixX0sx5xyDCI6ZknpgoqtMbJXwhKk9hBS1nVgym0cXdAyZnE-CZcPSylNYLWL=w1992-h1041-no"></p><p><br>이제 본격적으로 인스턴스를 생성하게 된다.</p><p><img src="https://lh3.googleusercontent.com/uip0R6Ir2NBq2HY8bkJL1HjhWQY__trxRUyKfayT4iP1k8QYthojT8W0OFrklrSe0AlxSqUgqOBeWjXSWv9wVvR7geIfTXG8DM0FEXhe2MqeRmveYhmIZzxg5B1fybSuVxD6NKuMnS_IJurDdgwr8vii6o2YItfllIgy7LtX23IqEV1sSpZU8su0S65B4maliWW7JTzCFWcWbSRm7eAxZR5E8LafVP-zzoGu-0k2CC87N5yiitJ-7HtFsHHT9iz3U3Hxn93INDO3dbwPmD33CUtBX9Msk3z2r4lqHuMAspSNh1kcr4uH4TBUjROxBDGNNqaGtfp65fwPFemWffj6-aM8FyDMGtE9lfCbBTlwEktU31IAQmjK_8O8b5E7kxIiPlxbPeoBbm4vJOKMN5vhGymM8LWlR6FpgQ6eUCSZs2qZFc-vvC-buVQdp5I9ef1vmQmWu5wyShs0oJGjLzy4YAz1MDraXrOtXtSRZoCA7L12G5MBU6Elcfo_IMY8TRSjalF3YszzSqR_i4DcTKVSbk2HvAKQ3NqHSNhY-cod8XNZFHzopd-jaGg3slYYt0O-4NG7Y6AXgOvzNPPsrNXrJEsVTd1ph75UHzkXW2n-31dlxhKEKQSEWowcUR4jdc01OaPOfmY1Gb3ahK8Dwhn3k9OJRQwyAyIXJqtUGdjh2HgnGsj2inQt3jD0aOgto7h2ofYYTveLT0MbNOAcVzGJ9dO6G0YP1Bbeory6-TnZ3PK9i-atIsx0vuxh=w1992-h1041-no"></p><br><h2 id="AMI-amazon-Machine-Image-선택"><a href="#AMI-amazon-Machine-Image-선택" class="headerlink" title="AMI(amazon Machine Image) 선택"></a><a name="step1"></a>AMI(amazon Machine Image) 선택</h2><p><img src="https://lh3.googleusercontent.com/M4zK_E3uMC5Q5QM3J615hnDt9cVEH0BQOI2vehBeN3YVqx7Ktv2_AEzPIz2vR0iYFh5krw5QfVmfd1JckNGVIZAECFvMTrl5_KtJzXVnKxqkDTO584hkmqtEpUO-iS3w5fbI8CvoMEqWJJkiKrwgW-5uvryhS6xOE4AX2s9qSC72Hu_rtutqMu6HmONUkOJ-mlUW1YMyFrC-XVP01Gh_jPL4VvlIbTzFuzKmdPXfAHtEXLEOii1dX0MaGS_KvtPdgK_DfPQ8JfRMQd_XHgdh6ioKP2z2VFvDryZOXl4LhSnPTSTJJf0C1WaMu9v3aTxmHe_oUKOao1g-u2bMaryDSw0SbGusRS9M9mOPcdZO_-_AIEn_tZakWE8esZADPEfiHbJCgFkB_WxmHpCyq5MYo-byF_ehnGDLXteKYZRqWwuHbWouPT7KNYbe16RqvPOh10pHcmBwdIhfWyT-P8xwDU7TJb7Qd46Jg7xA5H0ndF1m2Q-gM7smTTN5Fqn8W-G2oSTijwPlau9L3ERRI-b5j6UH8br2-P9ii9X8beNnYJJ644UGDW5H3V5iQlQwoFbvnr-xOYK5Gyew3Ars5Mmet2ymFkztmQeTrIjUBF8cowl3qzXVvK9AT4peqS8CSGICFTelUMQDkAWvfQOKXuDCz_rqMLZj7NBjbMKmrnqWWcWG2bbhE-A35-NPnHPdME0lUWa3i29_AhJ9dQK_sv8VatvB_Wy07uMN-N5dh5VNI7JCPvfdOrQBERa-=w2557-h1340-no"></p><p>AMI는 아마존 머신 이미지라고 하는데, EC2를 구성하는 템플릿을 선택하는 창이다. 일반적으로는 개발에 용이하게 소프트웨어가 구성된 Amazon Linux AMI 2018.03.0을 선택해서 사용한다.</p><br><h2 id="인스턴스-유형-선택"><a href="#인스턴스-유형-선택" class="headerlink" title="인스턴스 유형 선택"></a><a name="step2"></a>인스턴스 유형 선택</h2><p><img src="https://lh3.googleusercontent.com/l-tlerV_grTAZyEIMRD1g6E26vgQ9J4OdVQeIp6L8cGx9eRwqtd4n8kDzxUbVvExkgdJR_-Z9ZgS689pM8tD1jElly9Yxgc4ATpU0WlG2ju7FQ8VWXzaNoTQdiixzQbDn1UVJr71SVD9cRKjlDeIGISN3EiqiOGGN1hFJc7OCaguqQTYolKkU7itXzQXAuWNa-fpYmRyREhoObizxzjzQEVg-1UDtxboTwnVSk_mXExdn87FevJDzCeavIBlSI2dYuud2gUB1whTeNxFTrWHuWS0-AzwZJNy95NYtp0ysIb0zmHpabv-pEnYUhvK6TShaZUNDCaxCJtryDuMaN6f0slaThHgbXsdiAnYkzbd6W2uaP6x99cINLlXGhsxASIxMPU1TK2Gku8k9FI2k8vDJBbDtdv1D6TMRQ_uMl-v2WFORIn3eT8Q-eJ_xWPZGhSf6JOZ0DwmMmUTsr4z5yysuqIaJGk1XjYik2h11m1goX4NXmrwOJS7d81JX6qtCJU6LeXRqMJ0StKO-lC6tnL-YjIAHtMEd-GIuhz3StqG9UUPvY4MHUyTNWaTF00IhBlzMGnzCGivylQy3XdLofAehVOEly1jjeWvASWpE3h8MdHHgLUoZeh85vPVbUon0_-jjHXCoUemQyfe6MDppvcnTnuj4v1P1xrbPvHeSFCr5dv43qVjwOJLcGiFrutytpB30DwjKiuwo-PiHyz1NQ-p8rZ_OZ376MVx89kh7DsAL35kR-p1CiaMlmYQ=w2560-h1340-no"></p><p>프리티어 사용이 가능하다고 마킹되어 있는 t2.micro 인스턴스를 생성한다.</p><br><h2 id="인스턴스-세부-정보-구성"><a href="#인스턴스-세부-정보-구성" class="headerlink" title="인스턴스 세부 정보 구성"></a><a name="step3"></a>인스턴스 세부 정보 구성</h2><p><img src="https://lh3.googleusercontent.com/r95yhoS6qRuLokusBdZ9z5V4x0JWOdRliGHozUHn7bUSpOD9c7phPn9lQwtAETgkceYh4I1C5l7G5fxSf5OpKiNepk0QxrSjmbYxMbKlXKQ2yS9-FdlL3fr4g8IXNh0Kdv275oN0rZJL3YZXA7Jnjm0DiKb2pGQWhwjToC8yyI245OyHJMJwgsWq-8DkzYh3UA9rIF1OI9lCzGV0pPdY05_15-JmNlu791bKC_PDPqkKVXXDVBeXeIj1np56sr1zY65WmMbLKlxmXZ-fKzgZwTXGkLV7qgFYEt1_xZaKfbtt5bjGGU9MzrgPVAHuojGvm2NM13loZvfE2e-X0jS0PzkpvXKNRhK28TirF20lCBP57l40NE7ZhqpzGfYCvsFDF5MVv22sA49YTRflezWnU1GW71UcdndYBH44Wplye-BHBOP7HkHTAnoQD-AOa3avWGH6sLhiwhGol1kxuzSgI_vlbT5EA14OLtzFJQIDNyi9Ip3VhlVDLyOmn8tl8ayu-DwrcEO2-y0YwobtxudrhmHQ5ebEiTijnFeyhAGcU3QGqgnCWwl3TR4BNJbqpYoXc5aiTfBxTOrgpiA5jQ_gS6o7WARCYB8m4PoL1N-hX5Bs0AcXiTdvRYXOvb6gnet2ixvZVWadoslypdNwUgHQjOJww2OP1WOwwLY5iO3ws7RZ2UNt_E0gD1QrD5peqNbtE7wCZR2b3nO8uHQgx6O0JY8fsi9yXpojE-x3wThN_yM5TkTWCBB4gF5R=w2560-h1340-no"></p><p>여기부터는 계속 넘어가도 좋다.</p><br><h2 id="스토리지-추가"><a href="#스토리지-추가" class="headerlink" title="스토리지 추가"></a><a name="step4"></a>스토리지 추가</h2><p><img src="https://lh3.googleusercontent.com/-hDlO87VFigjnc15hl7bkQRlX1Ub6e-oXbzHP880P2KOUKFgT7a22zlTx0eS8EIK6DODnb7BIJDR4QGo8JKKh3eKFa3hsSmBkGJqysx0fuWqZfU9GgtawhTBVflIDIgAXuMphGprTWMEfDg6ul6cHtcPBmOXfy63-eYQVGmzZvGNZB-eyCEQBiC_5yFri4GnkD6e0s6mrkIOw4WtHj5r5NJDG58Shbt2LRwhshEUUx0ejQqW-JPsFagP2asJb4V9aL6H_3T6_MgWWW2vKmecV0jtbkdzXSwhaP33Jgg0Fr8znft3xlKrspbLWY1OpqnFBE4usvj-joRrIHIbVxN7Ut61DHLSjDNM-8-CwAy4TUY6WYmSk_0p2UjzveX8pw5oD2_2WICDHqPK1E_VZVLkIqU9FzXTjPjKnk14qd9E9QetuyQ6WyVMBCtkg5T18pYSWbvToHQRUWkouBYcAL6WdP8cIr2MBnAtqQuJA5VMtQfrG_OleeOEY_9VpI9lHyFNQnTOzfrfXyD2wYhV1zw7rAuG_NyWAYkqLnja0x5IJ7PH2Exa5YqPV3VhJNKTGTkgBnW9ztbkhuoEbazWvyEtqY1gM5UiOruENtOvXrZsVKgOS4Z1g71sDUyUZvNtDKHyyKgaYzbdP64M7a5U7OmtcgjmmWoOIfy-T98IeQYYNkwf_X376l-6pTyY7MQVo8O_YkTzpbz8_M9k-x_YYkaQJVTUIZeDSJWGBOmnOXhf_imfjwKB-xQVAjuf=w2560-h1338-no"></p><p>스토리지는 기본으로 8기가가 설정되어 있지만, 프리티어는 최대 30기가까지 사용이 가능하다.</p><br><h2 id="태그-추가"><a href="#태그-추가" class="headerlink" title="태그 추가"></a><a name="step5"></a>태그 추가</h2><p><img src="https://lh3.googleusercontent.com/IjTBrljv4yh3YZCjVc06m3kP2Fjgq8XdwgpxiiESjQBZnsn7L0CxsYnw8kMpZfvKBZ3emqxie9izA5Ml7VxX4O3i2jizwQm1XSL6AfJYz-HCLB5eu5Qi-1nsmznSRd6l8Km51vxIpVOiLKKcBahJLS1pnj38C9NmXD2Iq87NDJcCiaqqhONV6Gy3RqIIpHqQRJ3nbxoom5_7iHgnffjsVasqb0SMtydSGf6NETGyvCQDh7hNAS7qqC_FogKyPdFWYZBgDFmUqNM9KJf8BigZe16CGElRINVc2KBr8sFNzFTVjNrNUaXQosPbKZIb_P9DWM4jI9KIs2hTMEvf4qTS_kb6lU9tV3Dw3Tz5u-gHctnrrDJGgvwfFX5sbqrcATQh5xgKrOU-1n6yz7eS7kUFvEVpgkZ1NVBPaKroFKGo4cwc4Hu9ObstxATcH72rsTSXgizIcoVFiycw6wF1UsecVxkktvJ6AcgYmpa0YkNAonlclWGuE69tXuouk77JOjU253HAJhaecEcDFbp-HzYom-GC92v2UPYpYTyuV4TDT8ZLiIdc7LNogMcni6xXXMunVt3aiUO4cOxN1c8rBua9PKI6NvWFY56HMSRWKTt0H1KsWsOW27EOZhCTVNAr0c11gY41lqoNsMAMUvMMOqTozrIeSB5J2TSJ56pdMB-5qKvNbfXhl7dwgoL6Jw3_VG_KyeGM_d4N1BI1zv-xO3oNrQd5holPvINRapG_Ds_9k3h4kOahHxAwaeiM=w2557-h1340-no"></p><p>기본적으로는 태그가 아무것도 생성되어 있지 않은데, Name 태그를 부과해서 인스턴스의 이름을 지정하도록 하자.</p><br><h2 id="보안-그룹-구성"><a href="#보안-그룹-구성" class="headerlink" title="보안 그룹 구성"></a><a name="step6"></a>보안 그룹 구성</h2><p><img src="https://lh3.googleusercontent.com/zSD1V56Rr3jkljTUTjvwSlB2HjSsxA402dZ6zDe33PD4qy2AicmKz9uKR6q2of-d4iR_lzJIyMHRWHd8_H65u4zn9t34daDgdOt5DaxV8tdqbCIQPOgqGnrAHBu8_OT_ffBCy380gGcXg6CIwlKjymmq5HuSDJQUgkwqYhad-vgy4Ldw5DXFVzWh06kFi53UjxihoIstXjrF3qvPPqRT8khEkGHq530OuOiJg-1-5uD_H0-C4uhQk-xOWxLTaQw5-fFPrS-C-vtjOYZ0rF4PmxJuT6oeIIL92encXQzoiVZ_v9b0XRQSKkwIhCsLgZU5IqaHLccsHJbGiYNmdw6YlAWEmf52cT0edccS5H_u9_hzah8hjV1EF_AHLKBi92r_L9Nv7jigQg9SgTPHXxLWM29CsIAfbTnK3Bl0RrziCkhKC8eII0WSwJnJqh8HZqFIlZIDbGhDn43B3BkiQ_6SZ4ONQYJ6LglzImy9axJjjSlH-CNmSufeqSa3F0O76ztTWTBAamntT6ChMCY2vI4cTVGo_ANEB2ZtbUUNPBTSPssz03QYQIIisMY6JzZ-ZRxFOmqCaq9xhRfArejXPndx7iRoHXgQFzp9eJET_3MPhy0rfuxOJNX4IExJsmJYd2I-P46JnH7gr9T32LIAqG6jyvuxEH-FHPrWQXDcdnFRi8yfvI_yZ-94d2Wn3KUprtoLV_UZAWN60POtvUddinBECPiyr0SXP-yqobYYoIv0LTKCriqZxec9841o=w2560-h1340-no"></p><p>지금까지의 과정중 AMI을 선택하는 것만큼 중요한 과정이다. 보안그룹은 해당 인스턴스를 어떻게 사용할 것인지를 결정하는 과정이다. 지금 빠뜨리고 못한 설정은 나중에 보안그룹 수정을 통해서 추가하거나 제거할 수 있다.</p><br><h3 id="updated"><a href="#updated" class="headerlink" title="updated."></a><span style="color: red;">updated.</span></h3><p>보안 그룹을 위에서처럼 하면 퍼블릭 DNS로 연결이 되지 않는다.</p><p>커스텀IP를 추가해서 8080 포트를 입력해주어야한다.</p><p><img src="https://lh3.googleusercontent.com/TjvweWI6k08jxJ167ZId-7_DC1G5ApmgPyJUDg2VxIaFqwFjDPiVpRfldC5YnVUZ6519254lUQlOZt8ZK5IPWhjZNS1k_REDJDA2jkIehj5DNHFldvN4K6eLPfF3-IvYH_K7vyejKGWnBnqt1-J1Vlo6fukl0okzhr9Amp69rqd6bgxhmWuekvK7H9z4d0QCjD5LHpo9ZbaCck8kxmdvSiGxArgD0Nql86cQ0AHts0csRhbtqTjJ80zCRKZLsr8dR_i1Ns1yYd2-VGZqSYfVqvh4r9b8cCuM4niXfX06hnzMojKvW4OHa57sB81XI_3aXx0uDeF-fbU-auLTl98SLfaYezfcMLUBctlTu1VSqajaWFTH4mJEWg-BO8ITqigINHqEzwidIBk8XsYs1murYCoFoygYOvH4U6C8j8vs92mP9AxLDOLXqPfGL3-5jyY7gn7u0sLGUlmkcAM5TDxVh9RSLpkTptI6cIO3IBVWysrZnZMWIjh63wKEBy2MD-0RVNuACsNb4BG_XSdJtCcjM9M3BViMaIPY9Cw9zovCezyuCowUoqK5pUv3PZAcjfk7VRPbFtlNTrH6qf16VYeDnhurLVlbYv_h-pGIuSEqaFib4Y2QfWkqk2jSyv5CPA5pX9Kx3hT5SL478TL__ro6EMsZWMWcOpCaQCd05LN6nAw0z--lwuLA3Z-W9wFKzVpG6j-20ZH0gusRUrMNfOrb4w_0sPHg-5qPvq3kwWTZ82jIkOeDsD469K3u=w1260-h575-no"></p><br><p>기본으로 SSH만 보안 그룹으로 구성되어 있을텐데, <strong>HTTP와 HTTPS를 [규칙추가]를 통해 추가</strong>하도록 하자. SSH는 터미널에서 사용이 가능하도록 하는 설정이다. 어디서나 <strong>SSH가 개방되어 있으면 보안상 위험할 수 있으므로 [사용자지정]을 클릭하여 [내 IP]로 지정</strong>하도록 하자. 그럼 자동으로 본인의 IP를 가져올 것이다. 그럼 해당 IP에만 접근이 가능하다. 현재 인스턴스를 생성하고 있는 IP가 아닌 다른 IP에서 인스턴스에 접근하려면 보안 그룹을 수정해서 지금과 같은 방법으로 규칙을 추가해서 접근할 수 있다.</p><br><h2 id="인스턴스-시작-검토"><a href="#인스턴스-시작-검토" class="headerlink" title="인스턴스 시작 검토"></a><a name="step7"></a>인스턴스 시작 검토</h2><p><img src="https://lh3.googleusercontent.com/Zvd27_CbpCrKtd43Do3dDOtXMUCVa0TNJdY0MIOJxkh0VfqBQcanWPvM_24hubjXK4nsxJKOjiBgBXW1WQq09I1I_jG9FoXczfGYTj-PoWTfmj4_HyjqMlFWqQ05ao6YHQQD5inBc1iZmL0qk39PzLkJpUhYvzmoUoPBpajUdl60v9vc69FDCP3_IvIQaTD7be-l-QHZ8hWxNT4JdQqlNObpddxWIlYj9Vg6terkbbHKs-lsse9sfku_SbsBZZZeGQa7Oyz1xObXq0488CYBvLYO_8OVVQP2sKAsRWxuZ4w2ISX7YFc-DPy6cBnKCnUkuVCkbmDLhwg7sm05x94cKyL6K-0aoocrK0ZpgFPe6ae9MBw_aDRaMXJbkBersV99GrJN88faASzQW4BTHgkts1DXmD0IPBaHN4k7M_eDwoOrDJ1MgBBdnxE6c8xGigs1dlrm1HPcdsa7s38wNfobpoN7Qk3XFa8W3z5FU8Kc75EtYbnQbql4trl7yzi0hWPDT__AM45amuncevlCKdOsa45kD8wuHRbZlnpZKdx8WFA_eu-AogirmXpM2oEO-jZ8uMIc2ZNOx6I0-dWGXd0EEBSnnPKZTYNKqhJHtwhYKxZ8V1kSMSw-UEreTcizYjhwANxOkX-i3Xys2bLzDjLtaQx5wA5ZCwfVvtixF4bJfRY1d1xxp46UbB-8fzoRgys64pi1r4ExRkh477uup1ERdV1dvZ_B-Tar6U1QoQjS9q9gNOdPFsTl1KSc=w2560-h1340-no"></p><p>지금까지의 과정중 가장 중요한 과정이다! 키 페어가 있다면, 기존의 키페어를 사용해도 좋고 아니면 새로 생성해도 상관없다. 나는 새 키페어를 생성해서 프로젝트 폴더에 다운로드 해두었다. </p><p>여기서 주의해야할 점은 여기서 다운로드받게 될 키페어(.pem)는 절대 어디서도 공개되어서는 안되는 키이다. 재발급이 불가능하고, 유출되면 안되므로 git이 추적되지 못하도록 gitignore를 사용하여 트래킹되지 못하게 해야한다.</p><script id="asciicast-CXcuXRtWZhIQkPCzFAH2Hokn8" src="https://asciinema.org/a/CXcuXRtWZhIQkPCzFAH2Hokn8.js" async></script><br><h2 id="인스턴스-생성완료"><a href="#인스턴스-생성완료" class="headerlink" title="인스턴스 생성완료"></a><a name="complete"></a>인스턴스 생성완료</h2><p><img src="https://lh3.googleusercontent.com/bfZseNdORnsUiiInRuE-4fLEEzFrZXE2rx0U5eyfLxC2cLdOKK2hNIJIvDkmTkFYas0Ydsfvdp2Xe1d7D4Wwayu7B5PGJD2vOHJsjLPB9mPfrmmrL4niRiiQhK0WQRBg8VZbug2oLvzU4Z8M_mYrVKA3ba5vr0sy5h7bX5QQJg9jZBzuBUTXUtgs64Hv545m8qpu28ur29x67O6Rs1Qtnn-nVL2h758FIlMKy65azQaqkLGkkLQYK6TALZeMS8m3NIRSCVfm652_xoivDbRLC23aDevKB-2vZR-RzToSFlOPzURGm1DJIGEcjSdfcLtFPTfSFdkNWM6hbEjzYig5Lule9jfuG_wtnhMJPWi8V8Tbrf_grf01Druwe72kd4AMgePoDmf7OpDOwrPS03AkRUi4HhLS7OdCJU7LZqVCrBpu5VpMSXeazHWnQihZ_g0a7Qn8Qj4T16EuLsq0gdB8Zx2z9gB0PSdQ5ULaqnw1giNJH2tRqRVYO8s3TINNzpugy4wriqw8ndxEkwxyDtSuZXaJ0Tmc0g4ba_CThp9wo7S6GQAdbs3MXJOp1aJYIWIX14A5IpDq7ANPXQ8VWeyXY3ox0ya9d1bETooEMDfcy6q_VUGHNcfMUHnfnPTKKnIYU1_QXxzxhJWjjnDmzr26Nx6PedIzVVjabegVIKzQyATzVBtAtxAu9omZBfHkOo48dZRyv8MbDmvQnz4Aa2boWqMb7DVUBHk2uCXMiMwCmbIKXkl-v0ZrrJyT=w2560-h1340-no"></p><p>이 화면을 보고 있다면 성공적으로 인스턴스를 생성한 것이다.</p><p>다음 글에선 터미널로 EC2 인스턴스에 접속해서 배포에 필요한 EC2 설정하는 법을 알아보겠다.</p><ul><li><a href="https://youngjinmo.github.io/2020/03/aws-tutorial-launch-ec2/">다음글 - AWS 배포하기 - ec2인스턴스에 프로젝트 배포하기</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> aws </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>터미널 녹화기 Asciinema</title>
      <link href="2020/03/asciinema/"/>
      <url>2020/03/asciinema/</url>
      
        <content type="html"><![CDATA[<img src="http://ubuntunext.com/wp-content/uploads/2016/04/asciinema1.jpg" width="650px" /><p>터미널 화면을 녹화하는 <a href="https://asciinema.org/">Asciinema</a> 패키지를 알게되서 정리하게 되었다. Asciinema를 사용해서 녹화한 화면은 아래와 같다.</p><script id="asciicast-170142" src="https://asciinema.org/a/170142.js" async></script><ul><li><a href="#install">설치</a></li><li><a href="#signup">회원 가입</a></li><li><a href="#rec">녹화</a></li></ul><br><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a><a name="install"></a>설치</h2><p><strong>Ubuntu</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-add-repository ppa:zanchey&#x2F;asciinema</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install asciinema</span><br></pre></td></tr></table></figure><p><strong>MacOS (Homebrew)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install asciinema</span><br></pre></td></tr></table></figure><br><h2 id="회원가입"><a href="#회원가입" class="headerlink" title="회원가입"></a><a name="signup"></a>회원가입</h2><p>asciinema를 통해 생성되는 파일(.cast)은 일반적인 미디어 플레이로 재생할 수 없다. 재생하려면 asciinema를 통해서만 가능한데, 이를 asciinema에 업로드하면, embed링크를 통해 어디서나 재생할 수 있게된다. 따라서 회원가입을 하는것을 추천한다.</p><p>웹에서 회원가입이 끝났다면, 터미널로 다시 돌아가서 asciinema 로그인 상태를 전달하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ asciinema auth</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/hdbRY9R91_sYu4aup6TB2KqdfbBbWMvrv_txe_EFeNqQtAT08KQendVrtxZbQhWj1bXzOs4fm7brartKOXoVGW18HgxaALauhpHmZ40b4TN5mgmB_Avo2P2DMPppISwcLHC26tLQpbAp67aPSBVtaYwfBBVDiPADRgGTH1o2iZsFyPuCLlL9mUd2ebrcNb_2rsy3KKnk9B0JcRyiaIc3XzR7VFowtfs3_mVlUTmNTBBBO2SH1qETrPNX5PcLT0xJfU9ymGMBopZONhx9ZUnvOzD3pwO9a31ws5yZVVKtqV4M2AelbvyoNPHAXRU7GmyyWn4Y_pAMspogksfEG0krM4YuePcbQBq7HxWMAg6Gjtgg_cOZkc_mRM6VnyO6g-KeFb4pKSiTAY9XiTqb4DQriZM2pD7a3-znIf2kSEgnJi9FiDYV4en4i2kmlVIaxaCts_NOIsk-h2yj-TrV4R67gCljT9Y3DPxX9VujhGc-30a_ePYBTv7SDpGoux81KvwTjJOLpO1L6-r9zvvrr01ymjlCYDGDWAWYcWrDODH6pebwN67MXXM2ww39JX9DVj2VVAYDtRT2ZrVV2WR0wwpkCV379Fis5XhGRbeaulmvUEnPaafHP-Rb-gNlagLC3jTQeg0yX45NsHndE64be6Dv1MZzUHcyZyvAvKI7MF_C2tT3-fmCkz2P09MknQJjfklkhZdmGKTcwlGS48SfXwWQQLvG1DDgFLjZGjZdj13p0fniiq8KIQ=w807-h264-no"></p><p>그럼 url이 하나 생성되는데, 생성된 url로 웹브라우저로 접속해서 로그인하면, 앞으로 터미널에서 asciinema를 통해 녹화되는 영상을 클라우드(asciinema.org)로 업로드할 수 있게 된다.</p><br><h2 id="녹화"><a href="#녹화" class="headerlink" title="녹화"></a><a name="rec"></a>녹화</h2><p>터미널을 녹화하는 커맨드 명령어를 알아보자.</p><p><img src="https://lh3.googleusercontent.com/q4e5VsIPKE5ZVDF4qXmDRJCtNck9I4-icrkuRGiLceMBNbB_k_E5MWQXEYBHcYWuSU1zxgwgzt4Q2GyBHAyygEYUtgaDSVECS7z4Zd2SaBm3Nm1jsfrZKvFSuwwjrJGLZKqf2299Zmk2UA9AYj66dXPNJ9nGFLf6tKnwvzeM6n57I5tOfsMfzJK0Guy2PLwXffcp9ZjeNkKxlYRETx2-mtBiWkCW34zWLAU5XiHbWICM0JBuMwTekGLdyG0yUcYvWtTwqntFii2FSMqOoSAggXztKXMhABh2-upd4lfKKPhRsY29UUPIGBS-TmVj2T-2Dh_n_yed-B_CtcvwoNCXYFywCmiFucnVMIfzYbEiRREliHOQdjOLid9vmKIuehTuAffabpffVbinrGQHfzZaQKD-xq_fj1FzbT2NQNZu9V7jycYzaHWRsjwVJ3kZI4zrv0QhvUU6SrzxNt_ABz2MIEizOyravTNjEDB_Ww8zkTZ51v1UGKTI20aHxqOfcAW0_r5mhN1v2R1RBaby639CNqqSK_2sFOFOMBZIhUw0hJHzv8H-P9KH6CZ643gyISVzoR014B8cL9V_iuwBqix8g67Be4oOIBc2r144w2xkRJbs7q9laJYTmQN1HrBf-eiq6zOZl6SwrZnZDj62zXL5KfxHsH54UZR7EFy9eZCSIp4p4XW9F8A8mSmWUMHfXbiF0ZpGuhtgDFdDjyDOwSX66cgRQOLs-ZCeTd-Uxiu7Iwrvbul8mgxxy9Rm=w809-h530-no"></p><p>저장할 때 파일의 명령을 지정하면서 저장하는 명령어는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ asciinema rec -t &quot;new-file&quot;</span><br></pre></td></tr></table></figure><p>녹화를 중지하고 싶으면 exit를 입력하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ exit</span><br></pre></td></tr></table></figure><p>그럼 녹화 영상을 asciinema.org로 업로드할지, 로컬에 저장할지를 묻는다. 업로드를 원한다면, Enter 로컬에만 저장을 원한다면 ctrl+c를 입력하면 된다.</p><p><strong>로컬에 저장했을 때.</strong></p><p><img src="https://lh3.googleusercontent.com/ZiqelRnS6wLSQZvYAG2uqSdfdPgxVzNKr3dqG2h1PaQoWBRe-UrAMhAP-YDzVGFiUuEE3r0wbV173inj0OvF2ImfS6v--PKNOqMd5Nwvlm4_t93KpNrozmxiEoZjdDExlw1bzvRHDLtnZlXRYEw9bfmtejxC4W5hvFpxWQMMDJiMKC_r8MHkHGe7Z7E6ujJPRk4vcsGvZwR6mQO6-lHucP0V3pyNQGQpF9QL-d4CzmSi4Hik8nnLuQzANFPnFDStbX_vm8XY13n2ZH1iB648sU4r1olRx-NKX2B_Vbx1csP4oro9e45f7L-8bUfA4U2C4bbKVnpPJdnbu1qHRHFHfD8vZBAiRGu3zIm-riQo7Qc1o5g3fmmsphVTdQEp97xigYZWurf_TfK1uqKI0bsgGmtMQcwOSYx_AA3w_yZZmluyUYt5yRYEeVMFnPaPMYKOrppy8O1HBk_dlyWg76M8DZdNHwOowaOOE99xZ3XCWN_GKh1YjSI7mZDMaOlTqdNId29_zIWblcfb-UMxYtlRNw8yDZzQmpD9AmgptQjN7GIj7pfSluqvkQWvFqdpjjaeim0cnZmCJ1BCh-VMa3sHRUMHCcF40SpQd9YrtZaIvi3u4MCVYiWbpd2LDfZSGCSdtg-boN-Rmc_hHqi1hFEyydeVRbmn2JoQvBk848f1ZUxnCzssHKC-ToIDt3vmcuer4xJ91j3C0qOnMEpUaDhhQPVnW6B3-TWdZLrfVhouSzIHOLZdtiMaTNvb=w739-h143-no"></p><p><strong>업로드했을 때.</strong></p><p><img src="https://lh3.googleusercontent.com/UmAK-Ni3DUpBwxxg_5KpEverW_G4yriZIDT5-UejiPdojSJEQXGd8XWA6c8i25ZrF2FYkD4qGfDdkoobvLitPBcRW0frsNqB32IKbd0l23mIeoouwxQa6PxZO1gSBJoOEyOVjJ_LFRg5SDrt3umvo4Kd4_xT4Ge83MtW2Fz5hnPkmiOjS3drbtop-O4Rw4AwMy9EHUXbWw4Q4ruuULcZCQfG_TDTju3MMwLFatx6H7RfObc22U1ijQhewnj4M0w4pXW2z0y1F00YWtyNoElJnv-re-CD0rR59gPFpgNv9iGE0uGNpfhFqeg7f5XETzZe_fqfsOMYS3sTMuxGoPwBQOcGAv8-7OD1T7T5jKpTt8TId4qe417VpLz54BAJ4-cP3efv6Qf2uvI4K86rQ_EgWMkorfr2f4Ez_Sk_EybRj2N7xeLmxubHRvVmjCkFQ13EnD35L2vZrGMdHWizcKlCyQrK8Twh-nev8mKxRBYLhfTk8OixY7SWSCzTd60lj2ibATrZIQ5IndFk7jw8Os5fC9_WK6wCq26mCxsaOtudgV3h6pkh2Gs2iSu5M_r8OZxWe3oOxqOyDXK9KsbX_Q2p-lObBuxqSyDGgpDXxiZjXRZPpiQ5AOSmVXOL9mUtbK4Hg2ZtiPUEYfpuuV9XGAM6KcCX00FD9GrX9ZbbB5s64kDuTMgi70Bxnu8SyP2Vf0qGK_s7l5kOq1xiIzL2BcY9Wr8EKUPGHTckGfhl_J17bO4U5bXjlw=w810-h218-no"></p><p>위 링크로 접속하면 방금 녹화한 영상을 확인할 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 블로그에 카카오페이 후원버튼 삽입하기</title>
      <link href="2020/03/hexo-donation-card/"/>
      <url>2020/03/hexo-donation-card/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1523540939399-141cbff6a8d7?ixlib=rb-1.2.1&auto=format&fit=crop&w=750&q=80" width="650px" /><p>얼마 전에 도움이 되는 블로그 포스트를 읽고 포스트를 작성해주신 개발자분께 후원하고자 Buymeacoffee를 시도했는데, 결제에 실패해서 후원을 할 수 없었다. 무슨 이유였는지 모르겠지만, 현대카드를 통한 해외결제가 되지 않았다. 다른 후원방법이 없었기에 결국 그 분께 후원을 하지 못했다.</p><p>그래서 더 쉬운 후원이 없을까 고민하다가 내 블로그엔 페이팔 송금하기 기능을 이용해 후원버튼을 달아놓았었다. <span style="color: gray;">(뭐.. 아직까진 어떤걸 달아놓아도 아무일도 발생하지 않는다….)</span></p><p>그러다 최근 친구들과의 저녁식사자리에서 내가 먼저 결제를 하고, 친구들로부터 남은 금액을 송금받는 과정에서 카카오페이를 통해 들어오는 돈이 가장 많았던 경험이 생각났고, 카카오페이에서 iOS앱을 개발하고 있기도 한 <a href="https://ehdrjsdlzzzz.github.io/">콘</a>의 도움으로 카카오페이 송금코드를 활용한 후원버튼을 만들었다.</p><p>카카오페이와 토스를 사용하는 사용자라면 누구나 송금을 받을 수 있는 QR코드를 발급받을 수 있다. 이 QR코드를 통해 다른 사용자들이 스캔해서 쉽게 돈을 송금할 수 있다. 나는 이 QR코드를 블로그를 후원하는 기능으로 활용해보았다.</p><br><h2 id="카카오페이-송금코드-발급받기"><a href="#카카오페이-송금코드-발급받기" class="headerlink" title="카카오페이 송금코드 발급받기"></a>카카오페이 송금코드 발급받기</h2><p>카카오톡 앱 하단의 마지막 탭 [더보기]를 들어가면, 카카오페이를 사용할 수 있는 버튼이 내장되어 있다.</p><p><img src="https://lh3.googleusercontent.com/i-t3QEYUXc1gl3oyMX7RnwtEWzWXpIOuAToW6LXScONiBUqGSkOzSg9HeLuuWLaPUdFcoKjE3FBcuVOQRkR9SzV3nWZEVGZvfVgCXOeNHivFDE1peXOoKqkNL6P7oBZVXApPpgl6H-eSUAVAVbHu76_XMSSPu_wscaCaSdXYohUvuGd630oxYzKt7BTTcLyDKfgqpb5S3nYwwpRPvNMWrzuEJUa5BYV7RBw7GWXxaadcNWYFPwXQUlad2xq8NjjTbui_Jtjr3hoGIS83Fbnn-UcaxE6ONhavj3vxJAt9FilbTSNoPmzdd93oHImdbCu9dBv-Wjg6_EqMZp5hc3II3uHW_WFVdKbkb2zuJge1dL3HFV63W9CDkVxGJ2TaoEru7_uVQruP5HYcUT9Kp5DaoMw6nWzN6T8XVRIt5gF8hAu0UsFACacunGtn9MesfklES3HY_CqioJOxUnocEP1KLORZqNBXjMq0cl8jzstij58OeiZ3dv9EeDbEkhEtUpe0SlOP4n9JlQyaCxHy_WgLEWZVXl45mKZFrZtYYeuvz58tOOp7ykKrPHPTtt44gYiOugTbmRbcdhtn34mvSA-FEexArDsia3hNSTHVePjMn9wPUGOoK-8T7QEJ7bLr7_b97dhcro0CC0e-WXRA92kx23dZIbTSk3a40EsKb2m2O8c8i1wF6p6En-p2kSpXBQlOZV_umOvb3m8vl9E6NqCKOGetPCREk8kDtuXXBLXz7_QOTnHqaw=w738-h500-no"></p><p>여기에서 빨간색 원안의 버튼을 클릭하면 이미지처럼 송금코드를 발급받을 수 있다. 송금받고자하는 금액을 작성하면 최종적으로 이미지로 저장할 수 있는 QR코드 발급이 완료된다. 정말 쉽다!</p><p>그리고 이 QR코드를 사용하여 아티클 페이지에서 보여줄 카드를 만들었다.</p><p><img src="https://lh3.googleusercontent.com/8C4zExPglFXfYoADxPbPWWYCf3R9Mgfp1TJlGOFMna9fGN_Y96sZAh4oQ9vNIK8MWF9IMMVz9aN1itirYdes0jqzahkLx2iikVJfF0Ef0xPePNIeXbIBO668CzVDbmGAURQNpexI-qtOK5prEiqYTDClTjXYAVlxVVlbOwRBv8A5LBm0416AoKYhhlFrZ3N1oQxlU9CHYEIHXEtUM-kBCjT8bs2L22bna_5Su9sqobh3DT_x-sm1Ncm8Sd_y8LDZSMQA-F9M_C6xuvc6c8Q2spbLI0jdmyycoi6SoWUVcU5_ofIW_mEtHMB6yFED65fBAa95UzHVH61pyzq2ZiBNtSUuMOw_3VKOqEJc3rHBpMuJJuKjV1UEQmnaqJSocChWwnnaeNXuq9-M_8zEjsKzuTJAH9SGbsXh-i1R0liz6GFe9QfBm7PISdXlM4Xlz17jqKaAUqS1KTo28D29t9Q1sV56d-mRuc49TaXvh9MbIm09orFkcN-ypqkTedU9zPKveKzS73ih_TkGmTFkjKE64RDnc9i2EcPm4aDTNJhJR3uYXH6UtjMaFlaGJAROh3eljaMW9JNRAXpWqY6SbN0tx46h87eQ-ue48c3txrV5sjlADt06IHUtwEb44ekem2NkHhH3W-2dL81-fE4lPSoQGqqtX-h7neS6WheYa-7oErD6_wgeuzh8cto9y9VaFxLkBLMf0N5ldRBGKm2x-NwZJ443fQvUp0Nml0HvHX1acdNBcDZlbA=w250-h350-no"></p><br><h2 id="후원버튼-이미지-만들기"><a href="#후원버튼-이미지-만들기" class="headerlink" title="후원버튼 이미지 만들기"></a>후원버튼 이미지 만들기</h2><p>내 블로그 글을 읽는 사람 모두에게 QR코드를 보여줄 필요는 없다. 후원을 원하는 사람에게만 보여주려면 위에서 만든 버튼 이미지를 클릭했을때만 QR코드를 보여주면 된다.</p><p>그럼 후원버튼을 클릭했을때 QR코드 이미지를 보여주는 창으로 넘어가도 될 것이다. 그러나 이렇게하면 페이지를 벗어나게되고, 결과적으로 블로그를 이탈하게 된다. 후원 그 자체가 목적인 블로그는 아닌만큼 버튼을 클릭할 때만 QR코드를 보여주고, 또 버튼으로 QR코드를 사라지게 해주는 것이 내가 원하는 구현이다. </p><p>후원을 원하시는 멋지고 아름다우며 감사한 분들이 클릭할 수 있는 버튼 이미지를 만들자.</p><p><img src="https://lh3.googleusercontent.com/HAT4TU9-XEbu16VHXwv4httwvQU8whmO9dN565u71eg29bOY2g7j54XFjJFfs3pjm64LCGRCOekB9MO7cmlSvLoS38ZBr3JLh5UxjNbwpsN_rjQxrCs4Rm8QaSKr5gq_4IOQdpOJu23eO_VMoQTJzZl8VQmxmAzlxv3-GyEcyqiK7ScXDiIPCLY--1EH8Jd_SDGJjOuYCIkhS_C56X-F17r5MuMa1kRKnxzEY-99_iFKFykh-1mrcvwcGXywaRY8YGyTYTJ6XgGKig2m4Cd2m4bv9p6arwRFsfkE3TxkSqL6GNRamdkOUuRIewtu_pE61C3pZeDLm1UQeTn353WyLagBdFBSPQH6eGDcSEPoejlJ957YlPjCfLZTAswkG2lXRBVi08Dzjp6IyqH2pposogFlkifCcKPsZEu3yKbvDvrwXO-RDpdyAA9Q9ZVlC6T5XrUSgEC3X9YvMlJaEaXa2-UxX4V0_qHj9-QkuDoqTgcDJmJzPDveOXw2vPPsgKqbdAUzhjjB7stkkNGOOJtnWhHQCKO9G3-WbVoCOCNUDEpYD0wxSTOFQKDA-x8zyZLZp0CyL9ZY24np-ykQenwHu7REa7B7G8Malw0Ud61LGsAlW8iqGPhB_gPK3ak907ae-uXmBSb-K8cNcl_KGHM6JNiIh6QQD1NnA3mik8oCBwROUUJP4NKOpxu7MPmBiQ67hQ_IoEXUotQVEbMHHCqJlKX3Hy7vGZVYLqprkoCa5O2hPwddvA=w250-h55-no"></p><p>후원버튼은 카카오페이의 분위기(?)가 나는 버튼 이미지를 만들기 위해 카카오의 CI에서 배경색상(<code>fffacd04</code>)과 폰트색상(<code>ff1e1e1e</code>)을 가져와서 만들었다.</p><br><h2 id="후원버튼-송금코드-HTML-작성"><a href="#후원버튼-송금코드-HTML-작성" class="headerlink" title="후원버튼/송금코드 HTML 작성"></a>후원버튼/송금코드 HTML 작성</h2><p>광고배너 코드만을 따로 모아둔 Hexo 폴더(ads)내에 donation.ejs라는 파일을 생성했다.</p><p>버튼을 보여주는 코드를 먼저 작성한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 후원하기 버튼 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;donation-toggle-button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">&quot;showQR_kakaopay()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이미지 태그 바깥을 a 태그로 감싸서 클릭했을때 QR코드를 보여주는 함수가 작동되도록 설계했다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- QR코드 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;donation_card&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;qr_kakaopay&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><p>QR코드는 후원버튼을 클릭할 때만 보여지려면, 버튼을 클릭할 때까진 보이지 않아야 한다. 그러기 위해 <code>display: none;</code> 을 스타일 속성을 부여했다.</p><br><h2 id="js-함수-작성하기"><a href="#js-함수-작성하기" class="headerlink" title="js 함수 작성하기"></a>js 함수 작성하기</h2><p>이제 <code>onclick()</code> 속성에서 명시한 자바스크립트 함수를 작성할 차례이다.</p><p>버튼을 클릭했을때, QR코드가 화면에 출력(<code>style.display=&quot;block&quot;</code>)되어 있으면 닫는 기능을, 출력되어 있지 않으면(<code>style.display=&quot;none&quot;</code>) 출력되도록 할 것이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="keyword">var</span> donationKakaopay = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;qr_kakaopay&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 후원버튼 클릭했을 때 QR코드 불러오는 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showQR_kakaopay</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(donationKakaopay.style.display==<span class="string">&quot;none&quot;</span>)&#123;</span><br><span class="line">    donationKakaopay.style.display=<span class="string">&quot;block&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    donationKakaopay.style.display=<span class="string">&quot;none&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>위의 코드들을 하나의 ejs파일로 만들어서 이를 article.ejs(layout/common/article.ejs)의 footer영역에 삽입하면 완성된다.</p><p><strong>donation.ejs</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;donation-toggle-button&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">onclick</span>=<span class="string">&quot;showQR_kakaopay()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">class</span>=<span class="string">&quot;donation-card&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;qr_kakaopay&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;...&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> donationKakaopay = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;qr_kakaopay&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">showQR_kakaopay</span>(<span class="params"></span>)</span>&#123; </span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span>(donationKakaopay.style.display==<span class="string">&quot;none&quot;</span>)&#123;</span></span><br><span class="line"><span class="javascript">    donationKakaopay.style.display=<span class="string">&quot;block&quot;</span>;</span></span><br><span class="line"><span class="javascript">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">    donationKakaopay.style.display=<span class="string">&quot;none&quot;</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>article.ejs</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">&quot;article-footer&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;donation-button&quot;</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">%-</span> <span class="attr">partial</span>(&#x27;<span class="attr">ads</span>/<span class="attr">donation</span>&#x27;) %&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>암호화폐, 제대로 알고 투자하시는건가요?</title>
      <link href="2020/03/do-you-know-crypto-currency/"/>
      <url>2020/03/do-you-know-crypto-currency/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/MfrFjfM-nNoX9YWKjkSTtRj0LWISVqlOOLmFWhBIA0aH12lEMVTxAWm1RmqICqn7j91I69y4hEjQkypn-1oQsVZPH4Y0cVYsX4ovzWkjxa_fg11hGJdQakVt5A2CKxkp-9-NCtC99PXKNeADGYYirObeMZkOmIpOItGfFsRM_L-Uid72n9aP5i2lKnCYVfEi6OPN2oPYpExbWdgDJgrXCyEepIMEWKUBtPR6btsH0T-YngnWpNZfCldQp871xRR9OnUyDLhAszUAN7qPfAPKBLBMiR2N-Fn-jF7_LWnPpznd0yJHZZirXdraT40OR0Gs6mKL7-2xAwzHrPe-zQb5Nqs5wb_tSsrtpfj3gkDGxo2lXsw7JQrZx51W9JxJHaiL_GWERp_0eniwW-GVuM9bYs_8VQ_0hM3wTQkxTyZdP5fU7rZOHFNzN_gD4YcnFXz56htsAvvAnxBlBRBQ0UROHCK4jYGMzOwZJJOqscz6eSV0LiqtqLYRwi9E1ctsD8lmtF5GeqTsXWUVcqeVV-lxtPHraoPMIfyYUjcDQtpyOhLFOqcarAbWUGk5iAebS3JInnHqSLSuhXnoucT_yKkVnHLreJX5Bh9AnPoxtAu-ogmQ1-je8_ZWCyZqlHYiFbpy37P10660EG7UxoxxOQu6sD7eLZbxctQSV1H52x8hEgrd34LWB-dDvmku0VDLTJDMeZ2juAEC9mYog6jza1niK6YXsj62d_UvKdCWU86eLjUD0WC8uuyKzMYM=w720-h480-no" width="650px" /><p>본 글은 2018년 1월, Ripple을 송금한 이후, <a href="https://brunch.co.kr/@youngjinmo/16">브런치</a>에 작성한 글을 가져온 글이다.</p><hr><br><p>얼마 전, 암호화폐 송수신을 경험했다. 친구로부터 토큰을 전송받는 일이었는데, 그 동안 매매는 몇 차례 해봤지만 정작 송금은 해보지 못했기에 궁금한마음에 해본 일이었다. 꽤 신기했고 재미있었다. 그리고 이 경험을 통해 든 암호화폐에 대한 개인적인 생각을 조금 정리해볼까 한다.<br>(쓰다보니 길어졌다..)</p><p>친구의 거래소 지갑에서 내 거래소 지갑을 통해 토큰을 수신받았다. 송금수수료가 상당히 저렴했고, 은행보다 간편했다. 물론 암호화폐 월렛의 private key를 챙기는 일이 OTP나 공인인증서를 챙기는 일보다 어렵다는 사람에게는 해당되지 않을수도 있다.</p><p><img src="https://lh3.googleusercontent.com/ixj-nPSou0AqZ0amy4nat9wvoOJ-jj0brSwp4zN-TAIKV7YHwmYcYPBZJ-7UN0BCaHMiHfyd-CvUXU6dssTh6-H0i9OZfXQTooGJwdXcmXCU-UsD1TCJtE6qPeKXuYXfdJFt7qEWWFhellD5k0HdKQqXGbzkoLrFfgoYgc8uNJP8LPFxTbrj6akgGhGFL3Sk8mbLx_SRRJYd4tuy4gdnhurtYZ8ojPVGV85oW6IYNRuLo47mdlet5_NSpbBjLqa8lgeIWklH-E2hNlL_cMR9rAWz2VpIeB8yhVggcd8rhCPGouFx7uOZshYmYsNQ8m40H2Lk2UMwwETuLBBzqmqBEy-KC5r0Nl6eyO5quHmeqBh5pX2JIepkhx95AdTmNI6aRqjpMlozrAZ7QWiec-xp3tVG-4mCbvm-Lb72KmPjdejmPqjB3Y4iCsnJiI9P1GouCS_-3AvMF1zzLuBpIaxy5g0QqYdjMiwZ61h7GlAAUKQ3gLhgroVOUtuLICPkRpmAZ0_t4ecWkaW4kdzLE-pEXqBlPPF_WOrAr5WP60MhHazAx0M9srLmSvakHrYbLJnmWLWoIRuKiilyW1vlJ1X4E5KhXT5V52B3fEXRXzIkAKwMDezVzkPDvaWrymsbony3rWjTYoWRR6TFn1HhzGxwQYTqk8kza9bdvFey33kHHlsSvU71OOsda-_jciH5HtEPMjwGh509-JfAuEMj7yK2sm-zgM5AuWY7TgneIYEun8y-NC7E=w1280-h791-no"></p><p>불과 6개월 전까지만 하더라도 비트코인이 무엇인지도 몰랐던 지인들이 수십가지의 암호화폐를 섭렵하며, 너도나도 투자를 하고 있다. 그러나 정작 대부분은 본인들이 거래하는 토큰이 정확히 무엇인지, 그 암호화폐의 네트워크가 무엇이고, 왜 탄생하였고 무엇이 매력있는지에 대해 알고있지않다.</p><p>급상승하는 가격이 모든 것을 잠재우는 느낌이다..</p><p><img src="https://lh3.googleusercontent.com/9j0MT9NKKk5aE_t41t_AfLflrCJfesS7nD8DJ83Hu2jab0SW3SyNCkfDWDsGKiYkBG5UvlyTG_mFKq3tdgDbGAKJ3IxlV9ruH7vFdmF82MZz6NBg3dZg8NY2lBYz3p47K6MqnD8o9nIdGscEp9exHOj9HgwNKk3UmT77G3rtEVI51CggKkD2LCU9JnePpnHdllkh7aE0Qo1pYlkhvSYHLhLy9y8IUmjki5JQeYblheHgkGHPizJCPxTa0PnJ-ucttkZV5pvjtuWFvjSkZMJWNB9Lucw91KtAIqnVeM4o0zHeFCMC7xmmXhdhQ8AIJkgQgFRIoX1vppz9AJ6MFnYARGU0eRJqZwEe6I2rgP6UjqtsCm6fwhdpzQjrVEdoA0bFN5BQ4q2AXq1S9_EQ8y52Zl_8o_5L_t4Q7BMQnvUqApwZK31NfJxRAaL2hv-XP1I0VSSC97giCzSTxZjOIuZsUCMdhUfB8FxzpfwEr9wJuwYXYnyCKy9HZQ3ti4u_QvTD8KVPiSN498YLmmMW_swVQ26F5qNs58LJ-MS5yNY7YZqeTtPT9QO7s_lJLicwpz6EKMEu6450RjOypexr9h40_Wi7vNzXTf3nWqnwFwTlqS2RXSOz7RNwpKcHg68NNRnvdkc_toZaAWZWLDyhOd2GeQ3OdBYICV_onRfajYlprYB0fqLGh0FzGG6HrG4dRTGrMuCNKMF1OZh_THT0cQTv25cV6AuegmUSbmvXPHMMUcmYx3X5=w531-h493-no" alt="15-18년 사이의 BTC/USD 그래프"></p><p>상식적으로는 이해할 수 없으나, 직접 암호화폐 매매도 하고, 송금도 해보는 과정에서 그들의 투기에 대해 어느정도 이해할 수 있게 되었다.</p><p><strong>암호화폐를 거래소에서 매매하는 일은 암호화폐를 경험하는 일이 아니다.</strong></p><p>이 것이 최근 대부분의 사람들의 암호화폐의 블록체인 네트워크에 집중하기보다 가격에 집중하는 이유라고 생각된다. 그들의 경험은 사고파는 매매 행위에 불과하기 때문에 그 본질적 가치보다는 가격상승 여부가 전부일 수 밖에 없다.</p><p>주식을 사고파는 행위만 해서는 그 주식회사가 어떤 사업을 하는지, 그 사업의 가치는 무엇인지 절대 알수 없는 것과 같다.</p><p><img src="https://lh3.googleusercontent.com/Yom-Hc2XcBBau_2rApXpRaeFhexIywfbwc0nq96WJHJCEPBESXOIAkN6tBmOKnISn4w0Rnjx1nYgBKLpv-RKNEYVXMuPAn3gaxckDD2Z6Wee6JRcb9UIfiJVIFAYfe2yMT5MLyUxfLfdhXvo0PtZfdH31u6RkKdd7122co6feS9s9qjB3JDrpSrQj86xbynMEjGh2Vmw4Ibz6zX8Ys1M1SqMberZkODTUo66AAd0xscEfZIVCet3hCMXW8QMsKY47vTM7o9waINMO70uh6QFAVYGbJmuCiGGvaFrIaM8TPemR-6YkJG-7hQy2XySZgypN7hgEsc-ZtMyPmRBn2wqxi20-QeACw6B1nftm50GoUtf6-fs9k5QZm8b7wYykYv2-f_g26oM7-zrwxe5Xpgm50O3Vk5MymjcezwNCMFgVcJQwnIDqU7lf6ykBJ6LUO_NiHkGrFjbDePMvTeiNCA757ayhrlLROmkfI1UOCWeNQdLU9fhV55B0uUQ8bmG3mpGrHCGD3maH5RE7M8qv3TCLEzbKOApC3ZPziglrJZv5jZ2Qpucn6rtfE0rCu8fwZoHt24cha-vMFtqNxhZ7kfw-hKm4-GhDv9yAtJPuZCO230tNY2ttPOnluFBKUfu80-9RPeQzSgohCcBQ59WNfow8OOV_Dnc5u3iM7fMHlwu7KIj-TSYBHJNgotDNdc_wmGS_J8rGPoR2KS9rqO1bFCuyk31j4G9ZG1SG5ThfqmBerJ6HAfZ=w1200-h800-no" alt="Amazon이 운영하는 무인스토어"></p><blockquote><p>아마존 주식($AMZN)의 매력은,<br>주식을 싸게 사서 비싸게 파는<br>매매만으로는 알 수 없다.<br>Amazon.com에 접속하거나<br>아마존 오프라인 스토어에 가봐야한다.</p></blockquote><p>현재 암호화폐를 거래하는 사람들은 어떤 사람들일까. 이 네트워크를 경험해본 사람들일까. 네트워크가 매력적이라서 토큰을 구입하는 것일까? 아마 대부분은 아닐거라고 생각한다.</p><p>네트워크 거래 처리속도가 얼마나 빠른지, 이 네트워크가 왜 존재해야 하는지, 기존 은행과의 관계는 어떻게 되는지, 기관들과의 제휴 소식이 어떤 의미를 갖는지에 대해서 알지도, 심지어 관심마저 없는듯하다.</p><p>그래서 오해할 수 있는 부분에 대해 조금 정리해보았다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">본인은 암호화폐 전문가가 아니다.</span><br><span class="line">약 8개월 동안 책 몇권읽고, 관련 기사 조금 팔로우업한게 전부다 보니 부족할 수 있다.</span><br><span class="line">또 어떤 부분은 잘못된 부분이 있을 수 있는데, 그런 부분은 코멘트로 피드백 주시면 본문에 반영하고, 필자가 스터디하는데에도 도움이 될 것 같다.</span><br></pre></td></tr></table></figure><hr><h3 id="가격-변동성-Variability-이-너무-커서-화폐로서-작동할-수-없다"><a href="#가격-변동성-Variability-이-너무-커서-화폐로서-작동할-수-없다" class="headerlink" title="가격 변동성(Variability)이 너무 커서 화폐로서 작동할 수 없다?"></a><strong>가격 변동성(Variability)이 너무 커서 화폐로서 작동할 수 없다?</strong></h3><p><img src="https://lh3.googleusercontent.com/0JNiKcBMUsCclJgo6Lhw7AjSigzAiCRZeaoav4UKAG-oN7nRzGm0_M2ldtclGOHO_KDv-9CVuDv854XsAn6dZM6inB7WM0CkaWXUbGuuRpbYHqoBFdPDjSy6-t35KhM5KSc8sJVSNLz47S4C3syefx2xpot3Le8XmPSA85fwy3suS8JlyKh4fou0Vz4TNE8-wrl6Yr3tOnsXsD66i9iHhIEAGcw8Qsia5CSNs27xi02d6Ahxb4aTpXcJe5Viyh_MNOTjOEZxkCJ9m_sBN_CiV1k82tE4Z-hmSXQMVlALHQDSqZo2lB3QekeIC9vKLUtHvWGQYQ-Ea3YNCAn7KpOlEXwaSHDsu0fdp210a2SFm5Rc87sW6GZd5Pdadg1ulaW3A5_fOmTIkJktmarKmfjzuuNOD2saWf5GM_TXdSS5ksgCPtHmLdsskYTUZ0LWUy6m0EIayBvarNVs4_lKA1gncxnvEzrJe_0l61EVtzacCG9PCXTulb06xUPn8LpJ9GEm74sJX6QYRvFynF8ZuX0nNNTHme8MX5FuQFnCtATHG4JKoLdZ8XwOnN1Z0QqoHSXx0JoiNDJqir616bHWsb-qPts_khqg7qzvYieyjJRddjPi39wSQrzO5eyRr7QzpR_kEG1XxxwcBtb048bTxpGLjxf2tP41xVCy7Vl67XrMpq420d6_1g0TyCrk0Udf0zKrx8sxdEl8kvfaeriOHDRigiOHpTdQAJVHxNl6boE639fIdW7D=w690-h388-no" alt="BTC를 수신하는 상점"></p><p>변동성(Variability)으로 인해 실제 화폐로 대체될 가능성이 없다는 이야기에 대해선 어느정도 안정적인 가격으로 형성된다면, 그러니까 변동성이 줄어들게 된다면, 그 땐 충분하지 않겠느냐고 되물어볼 수 있다.</p><p>그러나 가격이 언제 안정될지, 또 어느 가격대에서 안정이 될지는 누구도 알 수 없다.</p><p>어쩌면 이런 이유로 비트코인은 화폐(Currency)보다 자산(Asset)으로서 활용될지도 모른다. 실제로 미국은 <a href="http://news.joins.com/article/22190044">비트코인 선물상품이 시카고상품거래소(CME)에 상장</a>하면서 금융자산으로 분류하는듯 하다.<br>(그러나 여전히 논란은 있다.)</p><p><img src="https://lh3.googleusercontent.com/5PaIvMR8roMQ5H2R0qpOn2dUh1KCCR1nyyoCvnX09IVOY7aWK4dRXfxLg3YJhvjDVYdHDWWtg_1Rdi9zJXkuQUWarP3DonpUSE6CzHGOL-b36X9LksnZkAEIe0sm1DeVjyjbwiZhIbhCbmgo-5msPmAc1xYWyyhPbZfWy-lJ6FC30Bfh5fHweSn1GsxIOGRXV8A58ZVlSC401gVQUDCBAKrQuoH-2lwL6K3ZZLEBHpQd59euaBAt3PefIG4K6pvT92B3phBEAOr0uiYvShm01WMC_rRRRQg-iQh88hRu4hNikARNoFY-4KikEXvTCBIPOzl-QfR-ZFd8b9jyDJhijz0It4v_mCFsJQmGLNPuOQRjsJVF_FIjmG-gqXqdPvNzMfGGz4Avk6HVzpd439qTM2fL4uPr0xeU_w79R0RDTE3uLzGRbwOgqpT-035qYE2rRdY04Ama24jsgA3URp6A_tSc2WH6DRqe3KuJlRT430elDlBHyswyAG5Teyn0ouXuxzoiN_XlBKtztF5KzTG2g42JjLnAfEP7v8QJutEVCjyTOENXlW2Ni1njvx9XAe_UqIoh9g69vDWAizzp_A-vCmCDm2c80wyoVoClaJfCjaRMkuaqpDDgbHo2dB2OY43n5z41dfCUDaKNrHeyslxYyraIS5KvWV6wG9dJ9Z83o1ZCfWo9UgNamESs62sJthS_rSAzbttEByrh-FGolZDZUVzawK9VRFcjcqkZPcwX9ebdUU-M=w700-h394-no"></p><p>은행 금리나 주식시장 등 다양한 경제 지표의 영향을 받아 가격이 변동하는 금은 직접적으로 거래하는 화폐보다는 자산으로 이용되고 있다.</p><p>그러나 본질적으로 현 상황에서는 이 질문이 옳은 질문인지 틀린 질문인지, 또 이 질문에 정답이 존재하긴 하는지조차 우린 알 수 없다.</p><iframe src="https://giphy.com/embed/wPkWlsnohtn7a" width="480" height="261" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p>변동성이 이렇게 크게 발생하는 원인(<code>We are still don&#39;t know what this is</code>)도 여기에 있으니까.</p><h3 id="암호화폐의-실제-내재-가치는-없다"><a href="#암호화폐의-실제-내재-가치는-없다" class="headerlink" title="암호화폐의 실제 내재 가치는 없다?"></a><strong>암호화폐의 실제 내재 가치는 없다?</strong></h3><p>암호화폐가 실제 내재가치가 있냐없냐의 이슈는 현재 가격이 버블이냐 아니냐만큼 어려운 이슈인 것 같다. 그러나 이 질문에도 반문하자면,</p><p>“그럼 우리가 현재 사용하고 있는 현금은 어떤 근거로 내재 가치가 있다고 하는가?” 라고 물을 수 있을 것 같다. 우리가 내재 가치가 있다고 생각하는 현금이야말로 사실은 현실에 존재하지 않는 현금일 수 있기 때문이다.</p><p>예를 들고자 2017년 여름 카카오뱅크의 사례를 언급하고자 한다. 카카오뱅크가 출범한지 1년도 안되어 컨소시엄으로부터 추가 자금조달을 받았다. 왜 그럴까?</p><p><img src="https://lh3.googleusercontent.com/FFaHdMu1XCxEe7RsWSC2s8BOXSPiigYp9f8K1u3CxvwtQDYBfcVyk46hptqq4qa7Kc48tsS-LOVtj-yDhVW-ls0VBV3miNuaLteiNDJAwo7-h2_Z-_NgBO85T9HrXKRbMEaeqeCWzgbP-lfvCIzb7qAauUQeLe-6o_LcmjAb_VGvrFmbzL44Lh6vydu8lzr0A38_TOU43Y0rJjrUwquZwnRMs1Fd4Tw9ogXrZ3sNNxSqN0dBxg7qdzOA6Ppmo8NYW-gkDt98SGmb294DvqS0Jdf_uH64BuQkBAqb6o4vPfNKhRenLojlBF2zzqI1m9WMhNGxZv0RzkgR25c2gOb6UQXY4trjhLn4DJnn1VW29U7oAz5fpb-JdEImM4tU7RKXzs4y7pWsEUU_GzM27dHQ50VXqao4Mv8vnVvvdcCwCdMd0iuUAoCMG0HhNy7tKnjznYoPV9xgguNokvI1dl6kxexZkzsAsc-C6boXrSucA99Jc5adLJtb79Eykl4BZFVkmtN5KLaQ4Y75VURKDOchSrDs4CXVllklQfmaKt0Gd9FQJajRRcV_xGrOY07WQtLDMUNfqoXPDp-g4l0CB4IJu23t-DAZfZIYYcyBgECpDi1vi0bAI9W3CBDWKXvdAeR_qbVXf2MpyKOt6aj--sOWZNuBUpI_tqVB0hnpGrwlDcHd3k74ghdchE7ZppxFPce3SPZzuimAgIqEoF3rsJZrLOIv4In_BupItk7VdX3xFo3wjR2X=w1438-h762-no"></p><p>예치금(input) 대비 대출액(output)이 예상범위를 초과했기 때문이라고 한다. 좀 더 자세히 알아보자.</p><p>위 링크 속 <a href="http://m.biz.khan.co.kr/view.html?code=920100&art_id=201708111733001">기사</a>에 의하면, 2017년 8월 11일 기준, 초기자본금 3천억으로 출범한 카카오뱅크는 예적금을 통해 약 1조 2천억원을 유치하고, 대출액은 약 9천억원이라고 한다. 그런데 대출신청이 많아서 이를 위해 추가로 5천억원을 조달한 것이다.</p><p>정리하면, 카카오뱅크의 자본금은 초기자본금 3천억에 추가 자본금을 더해도 5천억인데, 대출액은 이를 <span style="color: red;">1천억 초과하는 9천억원</span>인 것이다. 어떻게 가능한걸까?</p><p>그렇다면 예적금자들의 돈은 어디갔을까? 카카오뱅크 자본금과 수신금을 합쳐 총 1조 5천억중 9천억을 대출해주었으니 이제 카카오뱅크에 남은 돈은 6천억 뿐이다. 그럼 카카오뱅크 예적금자들의 돈도 1조 2천억에서 6천억으로 절반으로 줄어든걸까?</p><p>아니다. 여전히 카카오뱅크 사용자들 통장엔 예,적금한 만큼 정상적으로 찍혀있고, 지금 당장 은행에가서 출금을 시도해도 전액 출금이 가능할 것이다.</p><p><strong>사실 카카오뱅크는 실제 돈을 굴리는 것이 아닌 우리가 ‘돈’이라고 믿는 믿음을 부풀려 장사를 하고 있는 것이다.</strong> 은행을 이용하는 모든 사람은 은행에 돈을 예치하고도 예치금의 대부분을 은행에 계속 보관해둘뿐 전액을 인출하는 일은 거의 없다. 때문에 <u>은행은 이 예치금을 그대로 보관하지 않고, 돈이 필요한 사람에게 이자를 받기로 계약하고 대출해주는 것이다. 그리고 사용자들은 그 예치금에 비례해서 그 이자의 일부를 공유받는 것이다.</u></p><p>일반적으로 은행은 수신금의 90%까지를 대출해줄 수 있다고 한다. 바꿔말하면 사용자들이 평균적으로 100만원을 은행에 입금하면, 실제 사용하는 금액은 10만원 내외라는 이야기이다. 은행은 이를 활용하여 사용하지 않는 90만원을 굴려서 돈을 버는 것이다.</p><p>이 것이 은행의 수익모델이자 금융이 일반인들에게 복잡하고 어려운 이유이다.</p><p><img src="https://lh3.googleusercontent.com/Frj2aRiqGBQnHprfIdhOaQxo4V6LjEoWZ5QlMOkKpNKqx-cd3k_gnDFuMGcuXWrE7RCXy5Kq7Plt3GdGa4aCLoCDvtU5tUT44RZJj0nOAC4C5XdVIrPTKOzrea7B9KtfqKkfyEN8KuQaSqY6oV3wAo916U5RS2cCNFQqMm-BOJzFs5xpYnbegVOX0WVBuOB_izsLiL3HGbTKO3Qr-oH3WKurCDdn-K7KjeMe4LmNQO3Y8BU75Gxs2VXuvVt6zif4hE-dBvhK0ydRv1Xz_VmHcoafMBqupwBv3mkaov1lEZsP_aaikWF7ENJRydRSRmzM4iOwG8rQZwKyEiu2gNYuCBSV76RT3NLvXy9mBCAYNd7xE1dInoLy3yxQhNHgMkI3cETl2yMzTX5ToMtNQqVzoEfiM6eL1h6wbt4b_4adp_pvfFPai1M-YJZ_HmowuvyvTTCQwPj6UAnc9duWu8Tr0DBvo3z1tD6nq9kVnHGSZIse9jdT0sjOK3QtS7FkhTHjv5OoGm6m4r0kpyfUFtGYyhbX6RpbX14d1VNNSlRG8w3cMXepBVfEC7wWs1l4l3M61ihmKg7ePvkf20h1QKMD9vLym9HaKFs6gT_GChD-ImLWtY1Ew3_QhnjP-kJA8L2lFjnnbFw6uT4PMCvnHP9KT1I8_UMAzq3gF3YjPWHox7wOef1nn6XZruxRqCRS9LGuMWRhf0yO8cTTD_qstc_3eovZPHawLqrJmtdlUqFs6hvgXaBB=w500-h333-no"></p><p>금융시장에서 내재 가치란 이용자들의 신뢰라고 생각한다. 우리가 가치있다고 믿으면, 가치가 존재하게 되는 것이다. 따라서 어떤 암호화폐의 토큰이 가치있다고 믿는 커뮤니티에서는 해당 토큰이 거래가 될 수 있을 것이다. 지금 암호화폐가 거래되는 시장 역시 그런 사람들이 모여모여 만들어진 것이다.</p><blockquote><p>예를들어,<br>구내식당이 있는 A라는 회사가 있다고 가정하자. A회사의 구내식당을 이용할 수 있는 식권을 지구 반대편의 B라는 회사에 가져다주면 그 식권은 그저 종이조각에 불과하다.<br>그러나 A사 직원들 사이에선 식권을 가지고 거래가 가능할 것이다. A사 직원들은 이 식권이 점심으로 교환할 수 있다는 신뢰가 형성되어 있기 때문이다.</p></blockquote><p>암호화폐가 모든 사람들에게 내재가치가 있는 상품으로 인식되려면 결국 가격이 아닌 기술적인 부분이 입증되어야 할 것이다.</p><h3 id="블록체인의-탈중앙화-Decentralization-방식은-안전하다"><a href="#블록체인의-탈중앙화-Decentralization-방식은-안전하다" class="headerlink" title="블록체인의 탈중앙화(Decentralization) 방식은 안전하다?"></a><strong>블록체인의 탈중앙화(Decentralization) 방식은 안전하다?</strong></h3><p>다시 이야기하지만 암호화폐의 블록체인 네트워크는 네트워크에 참여하는 모든 사람들이 거래장부를 나눠갖기 때문에 이런 시스템을 해킹하려면, 어느 한 사람의 거래장부를 훔치는 일이 아닌 네트워크 전부를 훔치고 암호화(hashed)처리된 거래장부를 전부 해독해야 가능하다. 사실상 불가능한 일이다.</p><p>따라서 블록체인 네트워크의 이러한 탈중앙화 방식은 거래에 보다 높은 신뢰도를 구축할 수 있고 당연히 해킹 등 외부위협에도 안전할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/cCLDBHtqCrr120lxJrKcdkTZvcz191za_Yl6Lmmx88bdsiGfK-XG28RcQkCbGyvaQh3UkJZiMMChamQ5963H-mSScJZnkEdn1tto7yU6OaC8XqAlf6MuqqwxBBA5Y5KLbmdnCjNV-AJopq6K-v_-RLCJzYauPy92Dx8g1pHdIypErD7PaWFyOq2HQKY3IPaYz_layirVVg3uKNeuVpFaecO9jzQG5jDAuq3ajUjHyBJzCNf-2aOWVC06kEB_IttAXglRxDQBjSExCycJkJFz-543xhZ2rHVodmfRjjNoD2eAJbNz7gglaoisZRhFxtxuRqr8kB4LaS_1c8gUOPPQF7pxo81QqiKfkzK8klXgUAAQ4m7q-2mcc3OEN_yPnOLnxKtn_duqwlUhm4YwWI5WdhCaMQaH2TdMHExRExOHImo06T9vck3l4Y-4VvIldN1XCHc8pbEC1mE5PuUcDe18wGcR4V7b09Ka1WhMJtcycVySBX8tazD9AuGIg7c6YzUnMiumNWADBgJo5TjUI6tK_U7TdLe5OtCo99-Rn9rtHW7yGQKpx-VXBIQWKfcXYoRegkL6PJygKaX9P2xL-fuOvwCyuLUuJ9OhYhmliQpjP6Nl1rHYO1J_ggzW6QB4A0sydAv49dimmgVFmnrUDbrZm3DVLv0MU8y6mLtDAZdVwC6IdaYG-11zHOev9kPF22FW6ppBHeRm5dKt-YmOasrCtedEITmnNXTTTuS4286n371vdxWc=w961-h445-no"></p><p>그러나 정작 대부분의 사람들은 거래소에 암호화폐를 보관하고 있기에 암호화폐 네트워크는 탈중앙화(Decentralization)일지언정, 다수의 이용자들의 암호화폐는 거래소에 중앙화(centralization) 관리되고 있다고 볼 수 있다.</p><p>이렇게 되면 암호화폐의 블록체인 네트워크는 안전할지언정 거래소의 보안은 독립적인 요소이기에 거래소의 보안에 따라 사용자들의 암호화폐의 보안도 결정된다고 볼 수 있다.</p><p><img src="https://lh3.googleusercontent.com/mQjNSYcTMzrUU0EEgS1Utfp3IWgP8iKTbzTQftVz653NejX2LgLOfQmwlHAeWrOhhDbtB2OQRyx5EMjOLWVPaCrR8ZlJUJ1gqaU1ArlbtPkf7hdeEkizDIAdhK0TxkkM7L6j5YfpYkvJy0PIFz5H-luev6GAV7lksF0dtAnj7rwq_QPuHOZZigqLRfyTkwQD1Je1wv2MAGcyEng5xbDG8o1hcrFR64F8CiCC8EJ3Xb33zvCnu2OXEwfYDCy4BToYicJV222D3yeANOkOO-DlGYkJsEJbfRUn4uphJTlLPqFNKO6L5DLL-qEzLB5vEaOQlUF-TPmE2haj0SArSgvRPeGER-8glN-pMOPrnd5feuw4aE6pPzxKN04AMwZ98LVIAnpIxwtSHNi9nMKcPsvk1hem7NrhdTV6MyL2TaRwddo6AEpCo0bffG1DxltIyYAGTVM2pTU3MpgkSf-cFMpQFcw9ppQyEaz5lHGuJs55aoD0CsRPZFSZbpRtWIRtJCC4rGO4gQBhLEL3QHHPZleZosJeCaMcsTTcmE787IcVycVPJLwePV9y8mgBubiEWUmDDCQkTnra-ip81oAut3WyNO6Oupp-zcVNcB2DtN_5GhqHlkF8yL4VLbzB424N1wydc_QxM_UWCj_ZV1Uk-p4Wqb1NF7iBZ-krNNy4Q75-m_VyFwe6G3vA5V6aiU9Vr0PHAw28RXSwsWuUxEtG9Vx2VP6VfS0Uz7jz_bgECMZHEbwrSmjE=w470-h385-no" alt="보안사고로 파산한 거래소 유빗의 마지막 공지사항"></p><p>한창 비트코인 열풍이 뜨겁던 2017년 말, 국내 거래소 한 곳이 해킹으로 인해 암호화폐 자산을 잃고, 파산한 이유도 암호화폐의 네트워크가 안전하지 못해서 발생한 일이 아닌, 대리 보관중인 거래소의 보안에 문제가 생겨 발생한 일이다.</p><p><img src="https://lh3.googleusercontent.com/9ySggpBwSy3pvn9CzVBZ8ad3Eyf4w_Ag6QphKMjpnzdznk24yUwAyugiHa2YgBv8HB93R7BP5mKmRVZ4MNZ2zAyeQLFndH7jwqDnVPcYloBGsHV_0y-U5jd3eJ5nkwmJzYo16yJmynLUdqRTFEZXiv-RDc4VO8I7kU8mY5yTOWCfF7O1O5GvEqNy59MQWpRHSGehA1sli1JpW_NZw2IBxRj1vqB6oxwlctmRbpcIJO0S4qVglG6FWQ0mMkzVPrW_bzcUfm9dxvfjwWPVzy6E1A3qzSBtTzQMkC9VRyn-mSEaaMymjf-cAWpAqkwb4Sa1TWB5lOM9LeTDzYYwkzVbytI5CWvPm52a5pUW5oIXASB8FFRelucZm9gyNu-EP2ujuTmIR30hvZTG0VOgvUNYxee5K4DwGErESCkHpSI8xGZTlHHeX0Z3JjzwP5ERaSBUht8iaTwwzAQw7LxVwBYZGGJAamjvOqBGzMIKN88f7P_tA3jYy0WzjHYi17ltg2nw8Cf0PqtKXezdjUf1InM6v2ZusO99leIlIDdMYIwyfjAcJJuBg2n4m1FDWNsLZN7zW8hIFJFIMZaEW7YkupGbQWumOPtZeItuw_hG9C_UGEBXlRPWr30hxlGGZUXLp8I8Cl5oteqjUENMc2yrayUNKK8wMye0hJi9CBlxX9v0Dlr0r7_sRT27u6W3XXJBE51iXYBC9F3rHpvWV_Dy2V7Xl3CGA2lxDm-5YvGBDZ2jEsGfuKVf=w470-h294-no"></p><p>비트코인은 물론 이하 알트코인 가치도 폭등하며, 전체 암호화폐의 시가총액은 지난 한 달간 큰 폭으로 상승하였다. 곧 세상에서 가장 비싼 기업인 애플의 시가총액마저 따라잡을 기세다. 그러나 거래량에 비해 실제 이 네트워크를 경험하는 사람의 비율은 얼마나 되는지 궁금해진다.</p><p>3년전 비트코인이 전 세계 개발자 및 일부 트렌드에 밝은 사람들에게 주목받았다면, 이번 폭등으로 이제 개발자가 아니더라도 누구나 비트코인에 대해 알 수 있을만큼 대중성을 얻었다고 생각한다. 그러나 가격상승에 시선을 뺏겨 이에 대한 기술적 검증은 또 다시 몇년이 걸릴지 알 수 없다.</p><p><img src="https://lh3.googleusercontent.com/A4RRgtlRPQZfjkVGHSHzm-3CZWW9NylNZYtfVzwhzf3ZQTxjhcb_rzmybC0N9nKldJgwIki-r9hz6Ejd3gcZ0jGIk1j5tAqaVo4xjEXRmWVI5LMkzckyO5u7GAYTDax_OyP0hDbclw4t1_qu_-7a2whjT-cdGD26QcynqJlSFl18dRA75LMMoW9jMDfsrCjRb2XLmm1tYuB4wiLu17UfvIsQNXodDjh88tZ30OF5nBDRGO9tytzJbJw7VKpPJF4QkGpcaRha4A4jyFp5D0pvpnRIBx74fm3n26LSxlUTRXVZR2TkT-DhZIzfNR5ExXhJnqcOIF7vr_g-pSOH8x9wgBcZIaX5LdvNy0E_TtOzlxqcZJ5my2VjPezG8DBJz-KzOS3Dwr5EMqfSHoCYhxLf0pkmjdyOu4LaSqBxFL2k3xImHbIRSGwB3Z2_k-QvaQEGeY0HP73ieybHNihYNfi6peJH6wwexsscwo9rVZQR47NCknSHgnp0z5nGn7cHaBQ6ct2Q1InZLdVy3k5dDRbWpjPt8HJHNfJXWH8sul7douzz_HhzrmGsn3Ckrv5gKbQl5Da9ebATel8SS7PrWoBUUxLWo3gjsvBqQ4-VgsR8I-v25u7dURNAbY0DRA56skQEahtqlFM3b0AgkFK_aMim4lZZErBoadFMBp5YWayarG44VRdc9AHwKKWvFOLgPqp_No-n2DnEowx4TDiZ0U74lC2w_3FcLROQmmp3CjmW83DdHJCE=w650-h433-no"></p><p>현재 비트코인을 포함한 모든 암호화폐는 아직 시장에 출시하지 않은 베타 제품과 같다고 생각한다. 따라서 현재 상황에서 평가하기보다는 이 기술이 어디에 어떻게 적용될 수 있는지, 미래의 가능성에 대해 생각해볼 필요가 있다.</p><p>벌써 수백가지의 암호화폐가 시장에서 거래되고 있다는데, 이들중 상당수는 결국 선택받지 못하고 사라질 수 있고, 또 일부는 기술적 검증에 실패하여 많은 투자자를 실망시킬 수 있다.</p><p>가격 상승을 예측하는 무모한 일 대신 현재 시점에서 암호화폐를 활용해볼 수 있는 상황을 찾아보고 직접 경험해보는 일이 필요할 것 같다. 가격상승이라는 환상에 젖어 기술적 검증이 뒤로 밀리는 일은 안타깝기만하다.</p><hr><p>2020년 03월 14일. </p><p>미국에 있는 친구와 처음으로 Ripple(리플)이라는 블록체인 토큰을 송금한 이후, 느낀걸 작성한 글이다. 다만 토큰을 송금하는 경험에 대한 상세한 리뷰를 작성하지 않은건 조금 아쉽다. </p><p>미국으로 한국에서 외화송금을 하면 최대 일주일 이상이 소요되기도 했는데, 리플 송금은 무려 30-40분만에 송금이 완료되었다. 또한 송금을 보낼때 발생하는 해시주소를 통해 마치 택배 송장주소를 통해 내 택배가 어디쯤 도착했는지 보는것만큼 간편하게 확인할 수 있었다.<br>송금속도도 빨랐고, 내가 보낸 토큰이 어떻게 처리되고 있는지를 볼 수 있는점이 흥미로웠다.</p><p>리플의 전송과정은 다음과 같다. </p><p><img src="https://lh3.googleusercontent.com/AG4jqHRN6RaKaEHQY_dy8lZenXWH0C-__CX8ZDiuotE4_5mZTDs4chJwCA4jqONk1aLzRD6hUKJysS5xRHtIGV8bZSCAZIcHScZyVvqtGjCVneSSFWJVtKxIEKWS7rbzvhVL-bxEqo7amBOMl1s1_BE6LkXrMfmMfyea0r5PeST7hHXkvHu95xWWCjQxL_Y2ZXjHdHKb1-EqlZXzmfvaHUF0C-F3t2-nLYtYjE_DkS5hL8FdOSG4Ac6dX1wZzSWfuwW5-FfMhVfDVyWUViiPe9H0ljiI0ZQ275hlrLguyyMWapkPmWomRBKDvMK73OzF2-S4WAdapMaQWi4GfTQW4lxQ53JLtF06O9vUSMXv5PPDI4PJ7xVVMbJFILc9nkHv5rkPxXMXpwkHnHHpMjYko40yVu3a3t3iO_yr4To29osYPw9dn685RyPBvNqXsWDLU5uZ6NkzXfyH8uZrg1i946zPedzPs4byGXmj1SNB-q5kIEEeR8VNr-0iKwoaQGibXeyRWu7jMrvg06O9heSVIP5JeH99bTGilIWMyq3Dty6A3Uuqx_9lGKxte50Elc6XAWT2l9MrgD0mQR9og_vpKSM5hayKmyUIJaiekPeURhL4-bb4jxahnzn4MlzLn6gSc45XhaAjyZ9vjN5_GU0WzS5GgNOXJmyIYCvgsSE85ihaDDXQDnynocmkgUksiNGo2ZijoLhWMqlSWiHZmOTZ8lU0oGMtaFv2Kd_cH_misfqa4yLD=w469-h220-no"></p><p>내가 보유하고 있는 거래소 A의 지갑에서 친구가 보유하는 해외 거래소 B의 지갑에 보내는 일이었다. 그럼 거래소 A가 보유하고 있는 리플 월렛에서 내가 출금 신청한 만큼의 리플이 친구로부터 받은 지갑 주소로 전송을 시작한다. </p><p>리플 네트워크 안에서의 트랜잭션 속도는 30분이 채 되지 않았다. 그러나 문제는 여기서부터 발생한다.</p><p>리플 네트워크에서 트랜잭션이 끝나도 실질적으로 친구가 리플을 받은건 아니다. 친구가 사용하려면 거래소 지갑으로 송금이 완료되서 입금이 되어야 하는데, 거래소 네트워크 안에서 처리하는 속도가 느리다보니 리플 네트워크에서 트랜잭션이 마쳤다는 이메일을 받고도 1시간이 지나서 친구의 계좌로 송금되기도 했다.</p><p>이런 경험을 하고나니 주변 사람들을 포함하여 우리가 거래하는 방식은 블록체인이 지향하는 탈중앙화 방식이 아니라는걸 깨닫게 되었다. 그래서 이에 대한 위험성이나 블록체인에 대해 조금 더 알릴 수 있는 글을 쓰고 싶다는 생각이 되어 당시 이 글을 작성하게 됬었다.</p><p>이 글을 쓴지 2년이 지났고, 엄청난 태풍이었던 저 당시랑은 180도로 분위기가 달라져서 지금은 대부분의 블록체인 서비스들이 자취를 감추거나 사업을 축소하고 있다. 그럼에도 난 여전히 블록체인 서비스가 필요하다고 생각하고, 언젠간 사용자에게 필요한 기능, 서비스를 제공하는 DApp(Decentralized Application)이 등장할거라고 믿고 있다. 국내에서 <a href="http://www.bloter.net/archives/350090">테라</a>가 그 역할을 잘 수행하고 있다고 생각되는데, 금융/결제 영역을 벗어난 다른 영역에서도 혁신적인 블록체인 서비스를 만나기를 기대한다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>구글 딥마인드 AlphaGo와 이세돌 9단 대국 리뷰(주관적)</title>
      <link href="2020/03/2016-alphago/"/>
      <url>2020/03/2016-alphago/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/7dsIxA_Jr141Y9fGUQAE1DBjd-3Dwxgjp65iltCdhzhKtJ9p4K1TgffzkgeMU8ZVGHwG7eg2sctoL3dCI_TZ6gEvLOXHNG55FBiJcEG3nBHRPO7KKKjOG23vSiFuP_5Q16o_SUMkfQNPUDf9FPXwL41cywJsKs_uRiQRnpJcKVpGhXZYM9Av7_ggUt23KmnbG2KVVHaLtVF8dV0jzi2DXcaPphWKq4osYTB3MOfF2DcLQtbjdGt0BfLr7geYICXI0vu590MUQU81xOPyqYQa-DiLz2zqY6SGFM_C6uTV9A44EfLoi2CbOO4LocRiFjBp3kCRVkHyW4rAR-VDreA0QEThN8Cfan_fNVpiNyfOUWXVsO_szflElERzh_-lqa1AysAorefJGrvkCF5kRIT7bU053gmNNQ_yYvZJeUrveVfWkkaoJlYMMdzvIX1-Q1zTK4jhAWkKfXluuy4PtKtFGvE73Y3KXiVzSg29BI9fiZxpB_al-yEndwN96yR3EaVfUOt2dbTCEWUmRjoECxLiVv21vjmu_neSGgYboRLPVTXO4YKMloMkFAvCkMwWBv_TwYu52CHLJeJH7Wz1gD2bAwRMMBuGqxuZeAikVFErCFU6JaFmqsLJ0yIcLjhUJ0XVA1WdHbA8eE0AbLAKKTkIKf8-v5u7FzCpvWjwC_S-NiFxvQw5iq1384mCl4uJ1M1LXDsH2JbD5jk5jV0in_ZTIWbszvCBXOFjLhe-qojNvuzCGhPCLbK2THok=w800-h533-no" width="650px" /><p>이 글은 2016년 5월 11일, 알파고와 이세돌의 대국을 2국까지 마치고 나서 <a href="https://medium.com/@devandy/%EA%B5%AC%EA%B8%80-%EB%94%A5%EB%A7%88%EC%9D%B8%EB%93%9C-alphago%EC%99%80-%EC%9D%B4%EC%84%B8%EB%8F%8C-9%EB%8B%A8-%EB%8C%80%EA%B5%AD-%EB%A6%AC%EB%B7%B0-%EA%BD%A4-%EA%B9%81%EB%8B%88%EB%8B%A4-aa10ead03f9a">Medium</a>에 작성한 글을 가져온 글이다.</p><hr>15년~16정도 된 것같다. 바둑 대국을 관전한 것이. 중간에 기원에서 아마추어 바둑을 관전한 적은 몇 번 있지만, 프로 대국은 정말 오랜만에 관전하게 되었다. 인간계 최강이라 불리우는 이세돌 9단과 구글 딥마인드팀이 개발한 딥러닝 프로그램, AlphaGo와의 대국이었다.<p>이 대결은 <strong>현존하는 인공지능의 기술이 인간에 대항해 어디까지 진화해왔는지 볼 수 있는 흥미로우면서도 역사적인 매치업</strong>으로 전세계인의 주목을 받고있다. 어릴적 2년간을 바둑에 미치다싶을정도로 몰입을 했었으며, 현재는 인공지능(이하 AI)에 관심이 생기게된 나도 이 경기를 한 달 전부터 기다리며, 오랜만에 프로 바둑 대국을 관전하게 되었다.</p><p><img src="https://lh3.googleusercontent.com/sz2vumT8oHEGNdJOyTvh17cruTD65poVB2DA9vqXBgiUu9f8Nz_kGosV2L07R-Gv1MclkC53kK8qvHq3N5St3TR8sMDyd7845nEr_gT_rFYudTn3Zy4b3UBYYqvP7Mmod9uA0r-A9TALDTJ9TBreNHwf6TKdQUKGwLXPpCWBwhD0y4aWk0ZSZepiWi46736KFH7L_EXhE7bA9sMd2qdXvSnf0OMvyb4YYuc6wQpMLN4G4NYY6KSNM0-SZo3Rgf76GnUVI69-lsx2Xcvk58gdoKBz_fFTvHstRyVnVLISWXdpVK6RHqfzOxyvcowagPgD7Myip-nYfu3PQjfYolNCISpu5HbrvE4QEmAN5PlMJ7g20ts7LhH2gOkrx5BUuSjL9lc4EuAdwMhTd1fw8h4SaI3Wth6FKfdMc0cZ_-5xoeFIJSv8oeSXlxxqK4guN0mlrgzAE4Xl6xEk_zRdNx_q3NRI23SZToH9sUAG71sgHhPbn2YUFvO3jvKf5n7ZKJdLJvK0VnAmr468vSRDi6wLP2GXLR7c_kNagMLq9GMtohRw6fjGZAyZetsimZGdusumtwO42AtITOU4r_Gt1w3DFh2vD8t_tKVqiItMh3vcJxUZgpG-Ls-e1AHzppCRc2mG2GmOLf_xUcXYNRRqH6ialEZ-QLNdeoRoGuVOxjFab1CVZ1BDLezckmz3gulCnJxwY9c6BlHLz-UnY2banetxrWy_8jAplDRunLBJIMb5gXtYpm3c=w707-h161-no"></p><p>대국이 시작하기 전까지 수 많은 언론매체에서 프로바둑인들과 IT업계인들의 서로 다른 예상을 보도하였다. 과거엔 바둑을, 지금은 IT기술에 관심이 많은 나는 두 분야에 대해 비슷한 수준으로 이해하고 있다보니 감히 누가 이길 것 같다고 예상하기 힘들었다. 우선 주위에 계신 IT업계 분들의 의견과는 달리 AlphaGo가 이세돌 9단을 쉽게 이기지 못할거라고 예상한 배경에는 바둑이라는 게임의 룰에 있었다.</p><p>이번 대결을 앞두고 이세돌 9단은 제한시간 2시간, 초읽기 1분 3회로 구글과 계약했다고 밝혔다. 이는 다시 말해 <strong>총 2시간 3분</strong>을 대국에 사용할 수 있다는 이야기이다. 물론 초읽기 시간마저 다 쓴다면 시간패가 선언된다.<br>(<em>그래서 초읽기에서 성급한 판단으로 실수가 나는 경우가 잦다고 한다.)</em></p><p>워낙 오래전 기억이지만, 내 기억에 바둑의 승패를 알 수 있는 정도는 보통 200수를 넘어가면서 부터였다. 대략 200수에서 대국이 종료된다고 가정하면*(이세돌9단과 AlphaGo의 제 1대국도 200수정도에서 마무리되었다.)*, 각 플레이어당 착수하는 수는 100수로 예상 할 수 있다. 이를 제한시간으로 나누면 <strong>돌 하나를 착수하는 데에 평균적으로 72초를 사용해야한다는 계산이 나온다.</strong></p><p>그렇다면 한 수를 두는데는 대체 얼마나 많은 경우의 수를 생각해야할까. 바둑판의 규격은 19x19므로 단순 계산하면 초수를 두는데에 고려해야 할 경우의수는 361가지이다. 그런데 바둑을 둘 때엔, 내가 어디에 돌을 놓을지만 판단하고 두지 않는다. 내가 어디에 착수하면, 상대가 어떻게 대응할 것이며, 그 이후의 전개까지도 고려해야 한다. 이를 <strong>수읽기</strong>라고 한다.<br>아마추어인 나의 경우는 기껏해야 5수 정도를 내다봤지만, 프로바둑기사는 10수~20수까지도 내다본다고 한다. 이번 매치업은 프로 바둑 대국이었으므로 프로수준으로 계산하면, AlphaGo와 이세돌 9단도 최소 10수를 수읽기 할 것으로 예상했다.</p><p>그럼 한 수를 착수하기까지 10수를 수읽기하므로, 이를 바둑판에서의 경우의 수로 다시 계산해보면 361x360x359x358… 너무 길다.. 쉽게 풀어보자..</p><p>대략적으로 한 수를 두는 데 경우의 수를 3x10²로 가정하면, 수읽기(10수)까지 고려한 <strong>착수에 대한 경우의 수는 3¹⁰x10²⁰으로 예상</strong> 할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/g9OS_KP_H3UyWJgrew8r9YO4VJxoUhI4z9utwjbssCA59CdPxPfdsUbeH4kDZ_woWx9XgmaaaVDBjSs_-yQbA5c-5atZ0ZBqXEhmL7-6DMNklyn8PFmgNMeXou5AwY2FwSlF_u8T_k92yWvKjn88IdWcIvdAGLGpKUS6FLsKSZGDcf8KA2Lk1Hzte3vN3eD95aY_J7CFRtzVucbs0yBsOgv_NCKQpCQaldv4TxdZIEPCzocmqqamKOmxAqvKVoJYCqqS-wEYutBi97S2U_YVOA3SjLUl5VZv6oEj8mR-JZhaol2cgHDFdawpm29PO45UmegHmPxDdFXDUgR3aImEnLH-hJg2X60h2_I3XqkkaaMHyClrto3owEk3tXl0AkPtawXf9rFI2BVInX-yaAqItpluCoPYxglfadd2j6h3v4zLj1mOGqQ1aWMF9b_GZvFeZiy6-_iUcyMMdUWZCr21aEoy-r3F7RYk3q3DqpKI9qtvkjqNM0IJgwuZQaGZKGLoWkyGbk_IiTmugG9txSniarkPWyQ0O1cxjoHRbeaOCLda4KdWgJjcjiJJ7abLWddCb1ne4Z1Pu00BOg38uqnanrMUceyH2muH44df5u2ABCkuAwcZhLoiduZU1UT8SldLsBmb5Xj429gjsWvM0DJ3C6bPTqM4zcOxbpVzaF_uJH39PdSqZfAUNtSZKfUuOYt1CNKvydzNIaAApiGtmcPX_2kenDoLSUX-WnE9LxS-tDSBK4Co=w620-h400-no"></p><p>종합해보면, <strong>어떻게 읽어야 할 지도 모르는 이 방대한 양의 수*(3¹⁰x10²⁰)*를 단 72초만에 연산해야 겨우 한 수를 둘 수 있다는 계산이다.</strong></p><p>여기까지만 읽으면, ‘연산속도’가 인간보다 압도적으로 빠른 컴퓨터, 즉 AlphaGo가 이세돌 9단을 쉽게 이길 수 있을 것으로 생각할 수 있다. 그러나 뒤집어보면, 컴퓨터는 그 존재가 탄생한 이래로 단 한 순간도 인간보다 연산속도가 느렸던 적이 없다.<br><em>(당연하게도 그러도록 개발했으니까..)</em></p><p>그렇다면 <strong>왜 기존의 AI 바둑은 프로 바둑기사를 넘어 설 수 없었을까.</strong></p><p>AI는 커녕 컴퓨터에 대해 잘 모르는 내가 감히 예상해보자면, 한 수를 착수하는데 필요한 72초의 시간동안 <strong>컴퓨터의 연산속도가 인간만이 보유한 ‘직관’을 뛰어넘지 못했기 때문으로 예상한다.</strong></p><p>예를 들어 컴퓨터가 1부터 100까지의 모든 경우의 수를 빠르게 계산한다면, 인간은 1부터 100까지 모든 경우를 계산하지 않는다. <strong>본인이 직접 경험하고, 학습하며 생성된 ‘직관’</strong>이라는 능력을 통해 100가지 경우의 수 중 몇가지만 끄집어내서 계산하고 판단한다. 모든 경우의 수를 꼼꼼히 계산하지 않았음에도 인간의 이런 직관은 놀라운 성공률을 보여왔다.<br><em>(대표적인 분야가 ‘바둑’이라고 생각하며, 이때문에 구글 딥마인드가 AlphaGo의 인간에 대항한 첫 번째 종목으로 바둑을 선택한 것 같다.)</em></p><p><img src="https://lh3.googleusercontent.com/OOjAVlT2ldZEuujPPE3UUfcvI89HTRzyLhMUBaT-pnJTxPb6rhVz-V5ng1HYZ1J7hAf8Vqwz9Y8U5l99U88xzi6iRXT5BNUuL7cTI7z8-8syAF8wam06irYQ4uEwPiVAKQ5vvIch-DvGL8cC3XFpDi_KYDUm8IeP147p79C4Wq7SjcT4wz7Doesz-QZ2aUxwwx6C4LvC1fysGf9Cl7isseqYdeN22WKcTrj_W829i5gg0QN16GjkFi8WEGEPktjyK9D3FWk9gLCvRtAoAnE3DjZmjFM0lDNZ0Gj4-UOLLw60UM07oXUz3yPLkNzpg6ywDClZDy9jALQT00eo6G7diith-dhqCV-Lp880--I7u5adEP3kGP53C8rQs7ltt957k8iwRUiCwTDitYX8tjiGYbW1NrSA50cyWrdVWK4bAPlt2YKkIHVQlmvivXsSBRXEofj7uIADigN3Hp_mx4gid1b8hIsaXXxgzNrjzIK_AJYrALcEEuwdJjhCyWZZCeyT3GUClwqGOrnfJIovClDXmvA3YUNt0LdWoa2urO6yEy82RVMP7C2wCJja0MmA6_xSyDSVuJXBYGwyXLju7rMBo6WWYyYs981xpGwV1O5itVVdY_8j4KzJSMzBgJ6ycYUqQWn3EyckHY_6qevMgTTWsFQX92x3DewQ_QDcNoiwu3Lu18mmngIwT8h3JH7isz4FhMED329lGMqMxd4nTiNPtKVDgyhs3AMRnHnqMsXn6RhHokve=w640-h360-no"></p><p>지금까지 컴퓨터는 없고, 인간만이 보유한 이 ‘직관’은 인간조차 설명할 수 없는 놀라운 능력이었다. 그저 천억개가 넘는 뉴런이 보여주는 놀라운 퍼포먼스를 우리는 이유도 모른채 감사하게 사용할 뿐이다.<br><em>(참고로 현존하는 슈퍼컴퓨터는 약 백만개의 뉴런정보를 파악하고 동작할 수 있다고 한다. 하지만 이마저도 아직 완벽한 수준은 아니라고..)</em></p><p>그래서 단순히 연산속도를 빠르게 하는 것만으로는 지금까지 AI가 바둑판에서 인간을 넘어설 수 없었던 것이다. 그러나 <strong>구글 딥마인드 팀이 개발한 AlphaGo는 지금까지의 AI와는 달랐다. 딥러딩<a href="http://slownews.kr/41461">(Deep Learning)</a>을 통해 인간만이 보유한 ‘직관’이라는 능력에 도전장을 던진 것이다.</strong><br><em>(딥러닝은 빅데이터에서 발전한 기술로써, 컴퓨터 프로그램이 사람처럼 스스로 학습하는 것을 의미한다.. 정확한 설명은 위의 링크 참조)</em></p><p><img src="https://lh3.googleusercontent.com/UPBTME2ZxXBQcyXFCCz9f8Vk8o1yITYzlKBi4RgFR-4QBuwyq8ymLyHyZDlHsJyUIG1KL13D5ERcO_nhMINjtqGtbD4DfHJWMKAXGi3iRCDviKUJ93wXXmUWrcVlCFsPvFjoNLwrr89hHe7MjR9Cqtfz_in5wk7kLkweC_hL8PIXYuuMQvhK-OOxSRHUvDcm65oAdnc8npSn_EksdC2N1k4Bjp1Ev-wb25zUMmpB3jBNkxczKp5NFn0VTYUx8FE14wACqdfPZiugnY5GYN3xx1caKfHI5uyAT5V2A2R4liEwKeVEUFs1GpNQsOmnOZaRkJDGdMgv06Z50gzkeQUle2O1U9Q1u5TTfucUWdja95d2t_hUsk2rzCp8jvej4JyzrzBi95IdhU33tkhYak_CEwPi699C1-d29VAYKYq_AJjGhb8Hb-95ykrf2B07TCkH1AyoGE7I-ca1_YJnoiD2lj-FDBvmOPhxT17hBXCLX6sjxUuEa9NPIzx-pRTj9Ntp8SStYeuFFnVvT4JSm5o-Hh_hcxZE_QkE5j4txjPm4ok9qWtm1cGqooRqZc_QWDid0cdybNwbvZm42TzvREagv8OTWuqaPjZqXL-I0h3CG1yVycF5BdQW2w6eimxP8YbMxeaU1rBPXoMEhw1DhQhkoTrOKfT_Np3Hez6aEZHgFU8NRrFs5oYKx5pekrHP-1K0xjNvpRfmRB4y2UMhJxf1ue3XiFy4uH-Mb1sIeJsE0kevoV-q=w1920-h1200-no"></p><p>바둑대국 이후 인간과의 두번째 매치업으로 구글 딥마인드팀이 선정한 종목은 ‘스타 크래프트’이다. 스타 크래프트 역시 엄청난 경우의 수와 전략이 필요하다는 특성을 생각하면, 이 역시 ‘직관’을 활용하는 게임이라고 생각한다. 결국 구글 딥마인드가 보여주고 싶은 것은 <strong>자사가 개발한 AI가 이 만큼 빠른 연산속도를 지녔다는 것이 아닌, 인간만이 보유한 직관을 흉내내는, 혹은 그 이상을 실행하는 진정한 AI를 개발하고 있음을 홍보/테스트하고 싶음을 예상할 수 있다.</strong></p><p>이 때문에 난 이번 구글 딥마인드 이벤트가 승패따위의 결과에 상관없이 인류 역사에 중요한 <a name="memorable"></a>Memorable day가 될 것 같다. <strong>인간이 개발한 인공지능이 드디어 인간만큼의 퍼포먼스를 보여준다는 것을 우리 눈으로 확인한 역사적인 순간이라고 평가한다.</strong></p><p>추가로 경기에 대해서 조금 더 떠들어 보자면..<br>이세돌 9단과의 경기 이후, AlphaGo의 몇 수에 대해 <em>‘실수인가’</em>, <em>‘의도된 실수인가’</em> 혹은 <em>‘상대의 실수를 유발한 고도의 한 수인가’</em> 하는 말이 많다. 당시 경기를 프로기사 해설과 함께 시청하며 AlphaGo의 수를 이해하려 하고*(물론 실패..)*, 생각해봤는데 우선 컴퓨터가 인간과는 다르게 정확한 근거에 실행한다는 점을 고려하면, 그것이 어떤 수이든 실수는 아니었을 것으로 생각한다. 그러나 감정이 주입된 인격체가 아니므로 상대의 실수를 유발하려고 하는 심리전은 펼치지 못했을 것으로 생각한다. 그렇다면 생각해볼 수 있는 것은..<br><strong>Alphago의 바둑능력이 인간의 그것을 초월한 것으로 생각한다.</strong></p><p><img src="https://lh3.googleusercontent.com/b1o-jVarVkvgysHaIpifa6KhCq7YXex4wHae6FVbaocFHneJ_-PpUSYOBwJwnHAgdhfwZ1fjJcnB7WkI3rvhyLs00_KxwVs4vvBKfo67D4vPxAa_2TyePv8GpDn6purD1Yi2sU0bJVgaGXE3Ku5soOfB4Rf8XAYwPm44MUc36Cbe5OSkghbox-79os3aAeckjKmkOOqstubcSxTThDnB4Wdvf-23_EltAvltIvhQrnRX5w3XWH-w-8rFJAhGgf4Lj8ChsoD6gDx00sYMTMlF5fDzgTaLtlnY1PsKT1ngp0FxhzrImfm2wrBb69-2gIOttdsoT7dCUmkd5g2zdKVAgzmRMe5LRs_MnqWTNQ-uNZcgcRYyMTlNgTupwWMG76AjbhehXpLCg71FV9I9uIi5lJnwM1io71ULb9R3NuvYI_s5xR8VNlMPP25EKbYNjahyqqxhPShe0ThwZz_N6WAPs6Dha2L8iO7LF_a_VbpLWW02oP0h9Q8KCRVgpC9MihQQ1oDcfQ5C0Vbm-AruqKjYnUWNpMmD0g2O0G5FHusCycTxLnVZDDslhPrX5bxPlq7VX-AwR46yGxRGTrrKXCN6lmYNwuarsRJ5Igmlkh24lLzTZowPsR6NCz6Wlhutwmz_E-GjaDox4J7aJrEc7nWtHJf9neDSX9u7QfXMYEHE-UxHvDgqWbcYpwuDxEsUcSbxGcPnpNcRVMWnH6bRUVWkUKv7nC2nUvV_oXlFajz4vqzeiyBm=w1024-h480-no" alt="당시 언론의 반응"></p><p>제 2대국이 종료되고 나서는 몇몇 언론에서 패인도 모른채, 이세돌9단이 불계패하였다는 기사를 보도하였다. 실제로 프로바둑기사가 해설하는 방송에서도 AlphaGo의 묘수에 대해 뚜렷히 정의하지 못하고 있었다.<br><em>(참고로 사람간의 바둑대국이 종료되면,승자와 패자가 함께</em> <a href="http://krdic.naver.com/detail.nhn?docid=17142500"><em>복기</em></a><em>하기 때문에 해석 못할 수는 존재하지 않았다.)</em></p><p><em>(추가) 알파고가 이런 플레이를 할 수 있었던건 인간은 가지고 있지만, 컴퓨터는 가지지않은 <b>‘고정관념’</b>이라는 특성도 한 몫하지 않았을까 생각한다. 어쩌면 그래서 복기를해도 AlphaGo의 묘수를 이해하지 못하는 것일지도..</em></p><p><img src="https://lh3.googleusercontent.com/EkSqSo3K74Yd6X5E30-fmIhdRNYqtPgEZsJ-W9lQjGO4P_B33f4CQWxObFJGZT1t3kQjgFLdprIuhCz5OT6v9WDbFwNhu4bTJ6eezMlZiRFBxC5NObkXTjvzA6RkX9ZaJB4S_ZRtQzra2KAKfSNlJ2v4hGEI25cxYGCdIN_MqgP6mEoR7gp4Dyvg0KtQf2ACsjMPDS-otOF-Bh0m2FRTJ2yoO4pSJGwZNAT8kQmHKQBYzZD7KlNTjOmnysaFFvbIqSme2S2IZg-2gL_fTrISm0ABja73oVChVWRPf99PC2MEZjtSv9d-TcjCPWfduijBM_yiukhB-KAC4Chu3vikyPWgT4esWDOKb0vR7wjDyg-7skuO3Bsdbhn8lvc0Oz-hUlBMWJgoG_dy93KmNpaIRqydO3_ipNo3EjlvioryCnHUpMxtM20fzp4DNwBHSFeh95AYUi2bQRovdUS3Pq8RDPGU2IOBmhDsII2PmATgL-mnsWkINaTeEpNZsbU_FvQW0vNzGCgqhVDRfqR61Tl5vUFbLKhSbrneSlLKvGCxdzEZX3uvAO0oRprJtxOEGURN0n0cRR5F9HraieyDrnpbDdA9uyOCEFfY1CbLZCfTbtVjZkcKk7IpRoQy7GcqDMd6mvqz0GRXWq24L7KMIja9GjK3wA5BA6njqw8tWtxHiVa1Qr4L89zXOPoLlQuR9y-Jm1DdWxNIYyG2k1YgSc3h6W_suf22HupfZ0nQcj2OeMZWRKzu=w640-h427-no"></p><p>내가 어렸을 때 바둑학원에서 선생님께 가장 많이 들은 말씀이 있다.<br><strong>바둑에서는 모양이 중요하다는 말씀이다</strong>. 바둑이란, 결국 땅따먹기 싸움이기 때문에 소규모 전투에서부터 전체 형국을 아우르는 바둑알들의 모양이 분위기와 승패에 영향을 미친다고 배웠다.</p><p>바둑을 모르시는 분들은 어떻게 하면 ‘신의 한 수’를 두는건지 궁금해 하시기도 하지만, ‘신의 한 수’란 대국이 종료된 후, 복기하는 과정에서 평가하는 수이지, 대국중에 ‘신의 한 수’로 평가할만한 수를 둘 수는 없다. <strong>인간은 전체결과를 예측하고 두지 못하기 때문에 적어도 인간에게는 대국중에 ‘신의 한 수’를 둘 만한 능력이 없다.</strong> 그렇기 때문에 ‘모양’으로 결과를 만들어나가고자 하는 것이라고 생각한다.</p><p><strong>그런데 AlphaGo가 보여주는 바둑은 이와 정면으로 대치하는듯 보인다.</strong><br>모양이 아닌 오직 ‘정확한 결과’에만 초점을 맞추어 철저히 계산하고, 착수를 하는듯 하였다.<br><em>(제 2대국에서 초반 30수까지 보여준 플레이는 결과적으로 인간이 두는 포석과 같았지만, 그 순서(과정)가 인간과 달랐다고 한다.)</em></p><p>앞서 나는 <strong>한 돌을 착수하는데 있어 3¹⁰x10²⁰의 경우의 수</strong>가 만들어진다고 했다. 그러나 인간은 이 경우의 수를 모두 따지지 않는다고도 했다. 그래서 ‘직관’이라는 능력을 믿고, 추상적인 결과를 그려가며 대국을 진행한다.<br>반면 프로기사들의 의견에 따르면, AlphaGo는 인간처럼 10~20수를 수읽기하는 것에서 그치지 않고, 전체 결과를 예측하고 한 수, 한 수를 둔 것같다고 분석하였다.<br><em>(과거형으로 쓴 이유는 경기중에는 어떤 기사들도 이런 의견을 내놓지 못했기 때문이다. 모두 경기 이후 분석에서 쏟아져 나온 의견이다.)</em></p><p>인간이 지금까지 해왔던 바둑과 전혀 다른 스타일의 바둑을 보여주는 <strong>AlphaGo는 당장 바둑 역사를 획기적으로 바꿀 존재가 된 것은 분명해보인다.</strong><br><em>(대회 종료 이후, 세계 유수의 바둑연구가들이 Alphago를 중심으로 새로운 바둑연구를 많이 진행하지않을까…)</em></p><p>오늘날의 이런 결과에 AI에 대한 공포심을 가질 필요는 없다고 생각한다. <strong>AI를 개발하는 주체가 인간이며, AI는 인간이 입력한 목적대로 실행 할 뿐이다.</strong></p><p>이세돌9단이 2연속 불계패하자 SNS에서는 영화 터미네이터에 나왔던 ‘<a href="https://en.wikipedia.org/wiki/Skynet_(Terminator)">스카이넷</a>‘이 언급되고 있지만, 아직 이를 걱정하거나 논하기에는 너무 이를뿐더러 AlphaGo가 보여준 능력과는 다른 차원이라고 생각한다.</p><p>AI가 스스로 인간의 통제에서 벗어나기 위해서는*(인간이 입력하지 않은 다른 차원의 행동)* 지금 수준의 딥러닝정도가 아니라 ‘감정’ 이 필요할 것으로 생각된다.<br>AI에게 감정을 입히는 것이 가능한건지, 만약 가능하다면 언제쯤 현실이 될지 궁금하다. 또한 그 존재가 인류에게도 도움이 되는 존재가 될지 역시도 궁금하다..</p><p>이제 2국까지 종료하였고, 앞으로 3국이 남았다. 앞으로의 대국 관점 포인트는 무엇이 될까.</p><p>이세돌 9단도 이 같은 사실을 완전히 모르지는 않을 것이다. 그는 인류를 대표하여 AI에 싸우고 있는 것이 아닌, 인류를 대표하여 AI를 바둑이라는 게임으로 테스트중이라고 생각한다. 그 역시 구글 딥마인드 팀만큼 AlphaGo의 능력이 궁금할 것이며, 이기기위해 이 이벤트에 참가하지는 않았을 것 같다. <strong>승패보다는 AlphaGo가 보여주는 퍼포먼스를 더 중요하게 볼 필요가 있지 않을까.</strong></p><p><a href="http://news.jtbc.joins.com/html/144/NB11178144.html">이세돌 9단의 인터뷰</a>를 들어보면, ‘5:0 승리가 아니면 의미없다.’ 라는 인터뷰를 들을 수 있는데, 이는 결코 이세돌 9단의 오만한 생각이 아니라고 생각한다. AI와 바둑, 그리고 이 대국이 갖는 의미를 이해한다면, 충분히 공감할 인터뷰라고 생각한다.<br>남은 대국에서도 이세돌 9단과 AlphaGo가 흥미로운 대국을 보여주길 기대한다.</p><hr>2020년 03월 11일. <p>4년 전의 내가 쓴 글이다. 그땐 개발을 하게 될지도 몰랐는데, 새삼 신기하다. 또 한편으론 중간중간 민망한 글 또는 표현때문에 글을 닫고 싶었다. 그래도 일부러 수정하기 보다 현재의 블로그에 박제를 하기로 했다. </p><p>이 글을 썼던 이유는 <a href="#memorable">중간</a>에서 언급했듯 두고두고 기억할만한 이벤트 직후의 내 생각을 글로 남기고 싶었기 때문이다. 다시 읽으면서 민망하긴 했지만 그래도 ‘이런 이벤트 때에 내가 이런 생각을 했었구나’ 라고 회고할 수 있어서 좋았다. 앞으로도 이런 일이 생기면 글을 공개적으로 남겨야겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> alphago </tag>
            
            <tag> leesedol </tag>
            
            <tag> go </tag>
            
            <tag> ai </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot에서 H2 데이터베이스 사용하기</title>
      <link href="2020/03/h2-database/"/>
      <url>2020/03/h2-database/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1533750204176-3b0d38e9ac1e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80" width="650px" /><p>h2데이터 베이스란 <strong>컴퓨터에 내장된 램(RAM)메모리에 의존하는 데이터베이스</strong> 를 말한다. 램에 의존하기 때문에 테스트 또는 지금의 나처럼 실습을 위해서는 간편하고 빠르기 때문에 좋은 옵션이 될 수 있다.</p><p>다만, <strong>램에 데이터를 저장하다보니 웹서버를 재부팅하면 기존의 데이터가 사라진다는 단점</strong>이 있다. 따라서 이 때엔 테스트에 필요한 데이터를 미리 sql로 작성해두고 웹서버 재부팅시마다 데이터를 인위적으로 주입하여 테스트 해볼 수 있다.</p><p>스프링부트 프로젝트에서 h2 데이터 베이스를 사용하는 방법은 다음과 같다.</p><h3 id="의존성-설정"><a href="#의존성-설정" class="headerlink" title="의존성 설정"></a>의존성 설정</h3><p><strong>Maven</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.200<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>Gradle</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://mvnrepository.com/artifact/com.h2database/h2</span></span><br><span class="line">testCompile <span class="keyword">group</span>: <span class="string">&#x27;com.h2database&#x27;</span>, name: <span class="string">&#x27;h2&#x27;</span>, version: <span class="string">&#x27;1.4.200&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="application-yml-설정"><a href="#application-yml-설정" class="headerlink" title="application.yml 설정"></a>application.yml 설정</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">spring.h2.console.enabled=true</span></span><br><span class="line"><span class="string">spring.h2.console.path=/h2-console</span></span><br><span class="line"></span><br><span class="line"><span class="string">spring.datasource.url=jdbc:h2:mem:devandy;</span></span><br><span class="line"><span class="string">spring.datasource.driverClassName=org.h2.Driver</span></span><br><span class="line"><span class="string">spring.datasource.username=sa</span></span><br><span class="line"><span class="string">spring.datasource.password=</span></span><br><span class="line"><span class="string">spring.jpa.database-platform=org.hibernate.dialect.H2Dialect</span></span><br></pre></td></tr></table></figure><p>이제 데이터베이스가 사용가능하며, <code>localhost:8080/h2-console</code> 에서 대시보드를 이용할 수도 있다.</p><p><img src="https://lh3.googleusercontent.com/VD97biPg5fcx8KwvetWuiwQ9Atr81zPmhwlMntynUvyK7ICh1Qq8Pk34_9Wa6_YgJAd_hDRDvEy14LYYVALxi-E0_Jrv7wBChRywueHMVyuJfOj2fRlIT2H6vxhLv30jklpyrOXDCmMoy6dWncPF0rC3CSvE4_pfkbi4qIWBScKBl_Y69eNoJv-JZAGgxd1RcA-rbk63cEfPFEgrCl3b8_v0_VCV3vTEbIgwV_huEb-7BGIbvZxAtdcaNTkv1LsJaquRis_vkPjkfzsu2LzgPXGfcBTNg8KWqtvNMtq1b3fcrU49tmzX_oIvKYU9IXeA011fG6oI6hsEmpY4BNW91Sn10Q0vgXRtxgsRV1DWySyJD_jW0_aFURz__PqEc5Xn3WVAERTso52Autvn07ejtg21fr84d3lk3qTaKozgbEJgwBJDflpvrV64ODEmjeXquMTQ9FwTsi2-NFSjrazPlak4LNHPXsCP69SdEUZ5STE8JKD99fiD9a96UYeml-EyHyvDzNz6MnRnXmkLjgrnd4Zj7sV8qUad990r6EQNp9JVtY4mGIL-zCXMhvC2SVLO-PEyirrUZ7DEnL5UbnvpHWLfUluFSdk09BupqW9H_Vt35slM0iOKbliBTsxo7MCSzAjVTEP3kXaNkqUiLTLZUpSP79ZA6GBCcUaUiqslpvfdLxMIZoFqOY2sITcDRSKZpTURnKtXbjo5aEURXdaxBDNinAr1oy7rzywUkf1_IjaN3dLKoQ=w509-h402-no"></p><p><img src="https://lh3.googleusercontent.com/7g4emF9IGksv-m0sPpFAR3zI979_RKRss2Ebksu4bCBxCAZ-XOVqS62PyLWFyX4qXQ8VnP7iFhlu2xfqW0XU4AL63SG9uoYtsWY68bUm4P1AqC-0A2nX0JQZnqD5JkwwCcR9yx1fY2QSDeYvnTPJDxf9QntTAX95xGi1iIsdYIKDd9Eg9zkgaRguWEnpksmoUuJTj4FIgeOQjveE1f1YuVRLRgSwOSBU-WMVhvmd6O0KuVFpNra3i934fhG3gUa8RohlhHSdXlKzaleHwZYYnJEHI1m601NBY_h2LQinHkCmx_wNIzSReWKJHHW_wNmTlRBS1WlG1NvUgvUTy8AEbaeMThJmQm3QUbLHxmFK8B3E-XcG-NLRYjyvVppUcMn3_hngSfPcDvzjRT1bkSZ3fWv6k_3o5vyXd5b1amWmAxVS_rZJ_RGZOh6iaLPLarDaD4NQ55D8w-8mjXm7I7ZDJQh3Ta2qWfOlQb0ta0mB2yzvuC3JjoLWsf4V6o9lv07q6kO7IJ2yTNC6YPz3UGJlLHgIbUomuvJsflbuNSOJPIO58WSThBLRUdQQRTuQnKhbXa6_grfdFmQVqrB87rs11LkZVIpSCGELnf5U5kDZUHa643w1HIbPcMKX1x75OThFKUOr-amtqFBPA48mpzsodaW79YqNXSoTHuJvDAEgelED-wKxoXScnGoBWIYWlPbPmJkJtvnnkOe2qwt7duRGAa8SXjA2cNOTZ46IduCRpd76B4pokA=w864-h778-no"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> springboot </tag>
            
            <tag> databse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GetMapping 어노테이션으로 다중맵핑하기</title>
      <link href="2020/03/annotation-getmapping-value/"/>
      <url>2020/03/annotation-getmapping-value/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1546527868-ccb7ee7dfa6a?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw=&ixlib=rb-1.2.1&auto=format&fit=crop&w=1350&q=80" alt="출처 : Unsplash"></p><p><code>@GetMapping</code> 어노테이션은 <strong>HTTP GET 요청을 처리하는 메서드를 맵핑(@RequestMapping)</strong> 하는 어노테이션이다. 메서드(url)에 따라 어떤 페이지를 보여줄지 결정하는 역할을 한다.</p><p>참고로 스프링부트에서는 어떤 HTTP 메서드를 사용할지에 따라 RequestMapping 어노테이션을 아래의 어노테이션으로 구분해서 제공한다.</p><p><i>RequestMapping 어노테이션으로 사용가능하지만, 목적에 따라 아래 어노테이션으로 대체사용이 가능하다는 이야기이다.</i></p><ul><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/GetMapping.html">@GetMapping</a> : GET 요청을 하는 API의 어노테이션.<ul><li>데이터를 가져올 때 사용한다.</li></ul></li><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PostMapping.html">@PostMapping</a> : POST 요청을 하는 API의 어노테이션<ul><li>데이터를 게시할 때 사용한다.</li></ul></li><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PostMapping.html">@PutMapping</a> : PUT 요청을 하는 API의 어노테이션<ul><li>데이터를 수정할 때 사용한다.</li></ul></li><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/DeleteMapping.html">@DeleteMapping</a> : DELETE 요청을 하는 API의 어노테이션<ul><li>데이터를 삭제할 때 사용한다.</li></ul></li><li><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/bind/annotation/PatchMapping.html">@PatchMapping</a> : PATCH 요청을 하는 API의 어노테이션<ul><li>데이터를 수정할 때 사용한다.</li></ul></li></ul><blockquote><p><code>PUT</code>과 <code>PATCH</code>가 데이터를 수정한다는 측면에서는 비슷하나, <code>PUT</code>이 데이터 전체를 갱신하는 HTTP 메서드라면, <code>PATCH</code>는 수정하는 영역만 갱신하는 HTTP 메서드이다.</p></blockquote><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GepMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">homeController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@GetMapping(&quot;/main&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>지금까지는 위의 코드처럼 <code>@GetMapping</code> 어노테이션으로 하나의 메서드만 처리했는데, 다중맵핑이 가능하다는 사실을 처음 알았다. 파라미터안에 <code>value = &#123; , &#125;</code> 형식으로 작성하면 다중맵핑이 가능했다.</p><p>웹 애플리케이션의 메인 페이지로 이동하는 3개의 키워드를 모두 index.html로 넘기고 싶어서 작성한 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">homeController</span> </span>&#123;</span><br><span class="line">   <span class="meta">@GetMapping(value = &#123;&quot;/&quot;, &quot;/index&quot;, &quot;/main&quot;&#125;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>본문 읽는 시간 보여주기</title>
      <link href="2020/03/hexo-reading-time/"/>
      <url>2020/03/hexo-reading-time/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1501139083538-0139583c060f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" width="650px" /><p>Medium을 이용하다보면, 해당 아티클을 읽는데 몇 분이 소요되는지 알려주는 아이콘이 있는데, 이걸 내 블로그에도 적용시켜보고 싶었다. 그러다 우연히 <a href="https://futurecreator.github.io/">Eric Han님의 블로그</a>에서 방법을 찾게되어 허락을 구하고 공유하게 되었다.</p><p>순서는 아래와 같다.</p><ul><li><a href="#npm-install">플러그인 설치</a></li><li><a href="#set-config">_config.yml 설정</a></li><li><a href="#code">코드 작성</a></li></ul><h3 id="플러그인-설치"><a href="#플러그인-설치" class="headerlink" title="플러그인 설치"></a><a name="npm-install"></a>플러그인 설치</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure><h3 id="블로그-메인-디렉토리에-있는-config-yml-설정"><a href="#블로그-메인-디렉토리에-있는-config-yml-설정" class="headerlink" title="블로그 메인 디렉토리에 있는 _config.yml 설정"></a><a name="set-config"></a>블로그 메인 디렉토리에 있는 <code>_config.yml</code> 설정</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="article-ejs에-코드-작성"><a href="#article-ejs에-코드-작성" class="headerlink" title="article.ejs에 코드 작성"></a><a name="code"></a><code>article.ejs</code>에 코드 작성</h3><p>아티클 내 메타 데이터 아래에 아래 코드를 작성한다. <code>date</code>와 <code>tag</code>를 불러오는 코드 아래에 작성하는게 좋다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span class&#x3D;&quot;reading-time&quot;&gt;⏱ &lt;%- symbolsTime(post.content, 4, 300, &#39;분&#39;) %&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>여기서 <code>symbolsTime()</code>안에 들어가는 파라미터들은 다음과 같다.</p><ul><li><p><code>post.content</code> : 현재 포스트</p></li><li><p><code>4</code> : 평균단어길이 (AWL, Average Word Length)</p></li><li><p><code>300</code> : 분당 읽는 단어 (WPM, Word Per Minutes) </p></li><li><p><code>&#39;분&#39;</code> : 시간 단위명</p></li></ul><p>단어길이를 바꿀 수도 있고, WPM(분당 읽는 단어)을 바꿀 수도 있다. 이렇게 해서 각자 읽는 속도 계산을 변경할 수 있다.</p><p>출처 : <a href="https://futurecreator.github.io/2018/06/18/hexo-symbols-count-reading-time-plugin/">Hexo 글자 수와 리딩 타임 추가하기</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>맥에서 파이어폭스를 완전히 삭제하는 법.</title>
      <link href="2020/03/how-to-completely-remove-firefox/"/>
      <url>2020/03/how-to-completely-remove-firefox/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/po-jFGHrFgau8ZVxxgFekJxd48JdgOXAgIElpJhaiYSfbrzIaITntBJBcMb4dU88uapLZkE-2uYtr7pXBQShjcSEbOmxUC4gRY1SMuyO1Q2Q28LAWOuzSD8LLgJK_wULfcXKaroWXgkU7A_PJDOOme7-8xRh6yRszEfKK1AvfrXhR8oCYtSM_WQO5e8NYoGLR7Z8iCxcCqITojHT4kaIJNCBmOot3kHTS8FIWmGzhP8CfncVALOJJvFoBYiQTk6YAyDY9dn3PLKMK6ggSBTxLfnzAwayrNfQEWv3O60SjC_WhMQL0hyyYsBaDQIzwbqJgEev2J59Fx5ASii11TvaNnGgoEWCpAlS3d6m0-eq6J8jVPyEXEnXO7t1h7TU9DTGK-QzDMiq-oTGQid6YU85qFH81tpreeAQdq5W25DiL4tqFLQJbfAnYak9NwR0yTJ-mXewkQsKRZOAlcgdXNrX6z8qEL0Bl4zjU_oGq5w-jD9nofCQpmSozHTkaAA4itFMXsSjY56LWzUBa4CHFjuCt2lv-VH_V9d3XvNe-wjYdIiqJuKfweY5d2hONfpjFEjVNFG68W3dENR5cwugjkZiD9U-zrqkyQCsm5ITkHahC_GFv_og_tm31RvTd3pgBk6liHsHCzKGJ_kWxVpNpgLukctRZGkpnws7SaPVGuJ-_pGVszfm7vH2gzPMRhfuynpnbBmVU5IZiMumcSA5hfBzuBinqTqQuiImJMjcjTCV1yl8pXClhw=w720-h480-no" width="650px" /><p>기사를 읽다가 파이어폭스에서 Brave브라우저로 갈아타야겠다는 생각을 하게되었다. 지난해부터 보안이 가장 강력한 브라우저로 Brave로 알고는 있었지만, 대신 크롬/파이어폭스 대비 편의성이 떨어진다고 생각했었는데 막상 설치해서 이것저것 만져보니 별로 불편하지 않았다. </p><p>특히 Brave는 크롬 익스텐션을 지원하기 때문에 기존에 파이어폭스에서 사용하던 익스텐션을 가져다 올 수 있었다. <em>(파이어폭스는 크롬과 다른 익스텐션 스토어를 운영하지만, 파이어폭스 익스텐션은 대부분 크롬 익스텐션으로도 존재한다.)</em></p><p>아무튼 새로운 브라우저를 사용하게 되었으므로 이제 파이어폭스를 완전히 삭제해야 하는 일이 남았다. 파이어폭스가 브라우저를 재설치해도 식별자정보를 그대로 가져다온다고 하는데 그렇다는 이야기는 컴퓨터에 리소스를 남기기 때문에 가능할 거라고 생각했다. 이것까지 완벽하게 삭제해야 새로운 브라우저로 이주가 끝나는 것이다.</p><p>우선 터미널을 열고 Firefox 앱부터 삭제한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf Application&#x2F;Firefox.app</span><br></pre></td></tr></table></figure><p>다음은 Library에 있는 파일들을 삭제할 것이다.<br><em>(들어간 김에 안쓰는 앱이나 프로그램의 파일들이 남아있다면 이것들도 다 삭제하다.)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;Users&#x2F;User&#x2F;Library&#x2F;Application Support&#x2F;Firefox&#x2F;</span><br><span class="line">sudo rm -rf &#x2F;Users&#x2F;User&#x2F;Library&#x2F;Caches&#x2F;Firefox</span><br><span class="line">sudo rm -rf &#x2F;Users&#x2F;User&#x2F;Library&#x2F;Preferences&#x2F;org.mozilla.firefox.plist</span><br></pre></td></tr></table></figure><p>Preferences에는 이것말고도 다른 파일들이 남아있을 수 있는데 Firefox 또는 Mozila의 파일이나 디렉토리가 있다면 이것도 남김없이 삭제하자.</p><p>그리고 아래의 파일들도 삭제하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf &#x2F;Users&#x2F;admin&#x2F;Library&#x2F;Preferences&#x2F;org.mozilla.firefox.plist</span><br><span class="line">sudo rm -rf &#x2F;Users.bill&#x2F;Library&#x2F;Preferences&#x2F;org.mozilla.firefox.plist </span><br></pre></td></tr></table></figure><p>자 이제 완전히 끝났다!</p><p>이제 Brave 브라우저를 써보고 나중에 또 후기를 남겨보겠다 :)</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>시간에 따라 광고배너 다르게 노출하기</title>
      <link href="2020/03/hexo-conditional-ads/"/>
      <url>2020/03/hexo-conditional-ads/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1488459716781-31db52582fe9?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1650&q=80" width="650px" /><p>광고배너를 삽입(<a href="https://youngjinmo.github.io/2020/03/hexo-coupangads/">포스트: hexo블로그에 쿠팡광고 적용하기</a>)해보면서 Hexo 프레임워크에 대해 훨씬 더 이해를 하게되었다. ejs 파일 형식에 대해 잘 모르지만, ejs 파일들을 보니 자바스크립트 코드로 구성되어 있었다. 짧게 구글링해보니 ejs는 Embedded JavaScript의 약자로 자바스크립트가 내장된 템플릿엔진이라는 설명을 보았다. 그래서 <code>&lt;% %&gt;</code> 안에 자바스크립트를 넣어서 사용할 수 있었다.</p><p>음 자바스크립트를 적용할 수 있다면 광고배너도 여러가지를 넣어두고 조건에 따라 배너를 노출시킬 수 있지않을까? 라는 생각이 들었다. <em><strike>(자본주의 러버)</strike></em></p><p>현재 블로그엔 광고 배너 3개를 노출하고 있다. 두개는 사이드바에, 하나는 아티클 안에서 노출하고 있는데, 시험삼아 <u>사이드 상단에 노출되는 광고</u>를 시간에 따라 다르게 출력해보려고 한다.</p><p>퇴근시간 전에는 책과 사무용품을 보여주는 광고를 출력하고, 퇴근시간 이후에는 뽐뿌를 부르는 애플제품을 노출하기로 했다.</p><p>사이드바 상단의 광고는 <code>layout/common/sidebar.ejs</code>에 작성하면 된다.</p><img src="https://lh3.googleusercontent.com/BWl1EcbKK_cPXiQ0FnxSOvDNFqPm0k11DZYGjOotElIEbtswdJwqzxEb6edxi1zjXnkvORKihrPIbs_YisTqksBP9EOIYo5SqQOWVbbJwyfmLqaLBtlzCP-h9T0sUVnJhXDzKH_K1p3M8QBN4cAYk3rT825ApAtkusqZr7LFxHUbXtnhz4O2Zw7D1jEruBUSw0U4C79vHLcykyPK2IIOLNpo-zhy6jTOyXzU89VuNy4FJZHiX8YJ-nSQ0swDMA1-dhuhwi3LHSG1EukHS5f7mCz-hKL5NZ9Sd5aTGkEc5qLNmo0bGr4OVOIbqO1OCrmicnX2Fg7HQcXD7j95IlVcRjWCrRZjcWkQVpIg5j0tI20cTd79KktWGhWddscqQ65Ba4uyluUbTaYq8I6AY5Ujibb0zZ-JAfla2ARrQmcZGSH7MLeDeu7EtdddC_Jy5IxpsS47IL9oIMe1_vl6mRpQyLQSNXKXq0olDqaI8WVSHTCFrP7YKZ3ls_xTigJMrZ9NkfszL8vyiA7HvI0ayH7n7vM6k18GNRCqBaSWOuYQLUfpYJ4biBvhWFRFhdHOs5J1Y6is1NEfz8swFVd9WOPmhBmem9aUc1_LlZYzTqGBISg9g6kGx7vlF6WzMhlbquiFTjFM0_1q0WduOABtDpzSU0HMMaQaRdFFjjrHGse0Z7gCy47VYxSvAGprUaTE62sH96kh-XkuRgeWdkRK4f1n13oKCpu8EFyCcTGIDcYCiNGqdPmKlg=w1225-h500-no"/><p>각 영역별 코드는 이렇게 된다. 따라서 이 사이(<span style="color:red;">빨간색으로 마크한 영역</span>)에 광고코드를 작성하면 된다.</p><p>자바스크립트에서는 <code>Date()</code> 함수를 통해 현재 시간을 가져올 수 있다. <code>Date()</code> 함수엔 시각(시간/분), 요일 등을 가져올 수 있는 함수를 내장하고 있는데, 시간을 가져올것이므로 여기서는 <code>getHours</code>를 사용하면 현재 시간을 가져올 수 있다. </p><p>localhost에서 테스트해보니 원하는대로 광고가 출력됨을 확인할 수 있었다.</p><p>지난해에 hexo 블로그를 시작하면 처음에 번거로웠던 기억이 나는데, 노출이 쉽지않다는점을 제외하면 혼자 독학하며 운영하기엔 괜찮은 블로그 툴이라고 생각한다. 언젠가 비개발자들도 따라할 수 있는 hexo 프레임워크 강좌를 유튜브에 올려볼까 한다..^^ <em>(언젠가…)</em></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 블로그에 쿠팡광고 적용하기</title>
      <link href="2020/03/hexo-coupangads/"/>
      <url>2020/03/hexo-coupangads/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lh3.googleusercontent.com/n4lJPqTwL2LsdLD8ZuLUq0L4ghAt7eYEx5UBcyOURqLviDZINt6HEuTqvkjCtYO47ARjdaSFmM8d0i4YbL1icd--BCr78CnM1zs2pk-4u8HwoNbNZ_VbA1dgozl14ypRX6BG7Exu1qNaYbnorp-Acow-LjOt5A-9ZfHEjbomm1z5Kok5fKUYdAG3gkLVnIuq_FHYsn2jhINOQ0lGhlX79ygRDaAox9GoxTYvSy8AreV422MEk8JaXxgMTOEOCRF4P2S87MeaHCTg31i2CX8Z82qd120hODGxhKj5GXEfxFPDPO5m20A0mxFBeTJU5YUQA4zhAhaf7QJlwtVlgyFN-KBK-PyKPrpBPNUay_QjuRyz0T6lHVF7EHZpHmupiXa-zQRtXLclg75Ktz_rURyLSiM6pFl6m_IdEyUqfrCV3k1tyGNl98IuQxDfIcbEJjyn6Xb1-jxLvJE4RYlqEG4YcJjByKc4T9NzaI4TYWb_N8ke-JuPiv12FFFlz9R5ZZkZzYDfVC3yvGnWPOsNE0NLtlIV2d5vDEIRDnNiWK0r18AV7m6q8q1TypWDOPti1I4kGdnLRp2HTcAz0tsmfZkTiCPUWGErM16u2dXnv7rpRHIRnH34CgrzQZcaXX3EpfZZwGz-onh4ifxDVcLlRkMVD4msnZex6Dmo_OWbC9Knztf4ZdDmQau2Hp3dOn_uZo_rSrcukzdrG-M7JepfybS2iDK0IyZReqcdj6y2xj8w-4rHZNOEig=w651-h314-no"></p><p>구글 애드센스를 일주일정도 적용해보았는데 클릭당 $ 0.1 이 수익으로 발생하는 것 같았다. 이 정도로는 지나치게 작은 수익을 위해 블로그의 분위기를 해치는(?) 광고를 삽입하는 것 같아서 다른 광고를 찾아보았다. 그래서 찾은게 <a href="https://partners.coupang.com/#affiliate/ws">쿠팡 파트너스</a>이다. </p><p>쿠팡 파트너스는 구글 애드센스와 달리 클릭만으로는 수익을 지급하는 것과 달리 광고배너를 통해 접속한 유저가 실제로 구입하면 구매금액의 3% 정도가 지급된다고 한다. 애드센스 광고를 클릭하는것보다 차라리 쿠팡 광고를 통해 제품 하나 팔리는게 훨씬 이익이라고 생각했다. 또한 일정금액($100)을 초과해야 수익을 출금할 수 있는 애드센스와 달리 쿠팡은 캐시를 지급받아서 바로 쿠팡 쇼핑시에 사용할 수 있다는 장점이 있다. 100원만 수익을 내더라도 당장 다음 쇼핑때 사용할 수 있다는 이야기다.</p><ul><li><a href="#register">쿠팡 파트너스 가입/승인받기</a></li><li><a href="#create">광고 배너 생성하기</a></li><li><a href="#ejs">hexo에 적용하기 위한 ejs 파일 생성하기</a></li><li><a href="#hexo">원하는 위치에 배너 적용하기</a></li></ul><h2 id="쿠팡-파트너스-가입-승인받기"><a href="#쿠팡-파트너스-가입-승인받기" class="headerlink" title="쿠팡 파트너스 가입/승인받기"></a><a name="register"></a>쿠팡 파트너스 가입/승인받기</h2><p>쿠팡 계정이 있어도 파트너스 가입은 따로 필요하다. </p><p>양식대로 기입을 하고, 승인을 기다려야 한다. 쿠팡 광고를 개재할 수 있는 블로그인지 여부를 파악하는 과정이다. 혹시나 불법적인 웹사이트에서 쿠팡 광고가 악용될경우 자사의 평판을 해칠 수 있기 때문에 하는 일련의 과정이라고 생각한다. 하루 이틀정도면 승인이 되었던 것 같다.</p><p>쿠팡 파트너스 가입시 추천인코드를 입력하면 첫 30일동안 1%의 수수료를 더 지급한다고하니 추천인코드를 입력하시길 바란다. <strong>추천인코드 : AF1391980</strong></p><h2 id="광고-배너-생성하기"><a href="#광고-배너-생성하기" class="headerlink" title="광고 배너 생성하기"></a><a name="create"></a>광고 배너 생성하기</h2><p><img src="https://lh3.googleusercontent.com/dMTEINyLL2VWLq0BsXFZB9widfcMNNM1FROqjf4m8oB-1rQLHdt0DwVgQHN16s2FqmswjNluf-AHeuGN2UdxfwCZJVBF1OQXbGr_CtA-EpCrrikhwAhjpNlUtPv5scAV5BVmV4z4syJ5mzHv3kH_2w7Y9PyVu-4JjnlJm63Xp-AppLyawiW-eFcOmZ2kLJ6e-z6kNd9B3OxxfEwmSBj2VPuwGDrhAXG5DluYqPSwnf5HPBmTM1eSWp8MGIXi1BKwVY6Hgpc5MB35x3Ti1IdjvbNIANRaW0o30GGcsgLrItrkBdRVjUoPYoXqdr0-hU3aE9KUWIQeQx70VdEws5QKrrhwihXX8Bke2UfJf0YQo5plszmW724jHI8JBhPe31BtPwaRZcLYx6lFVa9d20FnT-GCd2vl6SAENBVcmRtmFtRtSRY0TA9rhnX6BhkedCIwrI2UPA-T4zEpxOR3BhxMrsBkpx0HB9HO-QV45VwpeU0MjzmqkbMBpYYJ6io5ly2ojW0AnATNmT4Vx8CQefUWPDK3nlO9E-eis0zlLjM8yLWtCZ06A5Py2mtkc47nrSJCKU49oDcBwNoS9DwYYmV0rkjVLpteivvH0OQPQH7SVfW_W8aHPNlsiKGKpYelXYllfDaR27iS0jsyJZ-6Y686X75b2HxtXQtfOmg-_xtU_KyNVZHoQ_hd2ez_FwFKQpB6H2PAJtub55stoU1d5obbklIHMuB0toFzQLRIeZxSaXmtAy12=w460-h328-no"></p><p><strong>[링크 생성하기]</strong> - <strong>[다이내믹 배너]**로 접속한다. **[배너생성]</strong> 버튼을 클릭한다.</p><p>그럼 이런 화면을 볼 수 있다.</p><p><img src="https://lh3.googleusercontent.com/9xBfqiZ8RfTVDvkYsUdqDWjyfLffiK7XstLj3TkmlnTX14ho5wpXEw36Kg4bx9PJcYHDJfKB-VOdMkbwGBkmdvuaOnb1aDh5JwICmqZculVNC_61bU5BKRlU4ZiibpM2EJ_COKCPHlArUNgNTCEp-jn7ba79evzoJ-4_JEL2dvrrCFS5JwzA133zf5KLS4ggv_xCHQTbllX1nq9pVl3wZDcqo4T2UPai3fJ45nnRN2A8SFZuRF5RikMgGug8kR9q2qZPINiHt4PYM_lA6QUxw3RsAU9lJBnUpK1c3tIstnSSX1S5584YJGB9GrgQK62a9E4BV2Fsl2UMc1_S7smBtHt5owXYogNrZHCJXs2inp4WQJVKhFM9PM6xL6B_EEahMSjmo_KdI-YTdWyI_Gn_koLKgjzW089IjYgP3UT8IGPe0uN_OG8jhYq169ixs-SBLebE6gZaHkP3mRa7UkOYTKNbfkPlMqMaR4tWI8WUjeVsJIK19KWsIxvPQT7YljgqwT3A_qWeqkU80sJYQmpXztYhrEkM7Qv6kIHyoUlMsWzzjGZQEj95QY643k4-cno0Ct_ikdp55aYIAfj549VgqYY8ta_xGhvP7qPy4GX5Maj-9owR3Q81YYlQenV1EjaCDCe3Ik-qh0EO2Hb_rg8CJUffighil4_dX6VONfrMed5NJ87l1jzdJXCUgkGpk_90JWmL70KoRPzxzPq2lSkpqC-ufO3KBYvlQ5ctxNGYuzz3D9-S=w583-h384-no"></p><p>이제 여기서부터 광고를 직접 만들수 있다. 필자의 블로그는 개발자들이 접속할 것이므로 생활용품 광고를 보여주기보다는 개발자들의 눈길을 끌만한 제품이 필요하다고 생각했다. 지난해 말 아이폰이 역대급 판매를 기록했으므로 아이폰에 필요한 악세서리들을 노출하는 광고배너를 만들어보자.</p><p>배너타입에서 **[상품 직접 선택]**을 선택하면 배너에 노출시킬 제품을 직접 선택할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/BHEVejM0UpR-2KMgpc_KbOC8SfdM9XdlALQorNNh1e8vxrBn7zXcJLg9NZi06ORLJ-Lnyw2zEcRpO80IOWDfqcgw0HCUmmCYzIFsrUim_neDJsLO8EuUKSZ6urSP4JvLD8ZB53tR1ZQHT5_oUTxVfGaYBJgJCjaZXfsSXYdHaJ_QcrP9hbyErPYChCsOK9jprkRBSmTiPCvoa7YpnJV_54SA6sEAlJJyeQhDrdpE3ozIW8JCRjAbeeedyNFnS2b0Qqrim7747Rov6be-065x_5yNDEhyBG4C7TGmXnKm1iTL80EDWujRpuRptGwak6IVi4xxm37PdT1CB2yQfMPCg8gMO5v2FTNkSae1_uw0Vw3MVOZurGQEFyDxxhzHxANYGbMAAvhSQD2X-7jHn-SQunZ1lMiGdP1iHdG2BGmI_Q_6tswY50FYzfTg0mhKVg8myHmPI9oBvQ-YGtTfI3-MqAFV1hPMvD_H7ykOFVoqzwRluL8toxnCVTP6weRQZeNwFY-DxD6NhkM0RYtXsvgn-qWsKMrZoj2Jk6lKa1RwuH_33KxSjs0NJAqQAlkrDZw5yXShN_BGbTbNjUX7iazjoKQ-kuRZmYSp2xqh0BCOqMsxHNU7ahr4R2m1kffVeQebUSv98DeYCqLlfdXkL1gpQR8CiitcKqn7F-93rWnz2Bycsihf0Ixq-5uKLVZkAGs9Vzmbx9XTY-q4ope256lbR7Ej74sqJfqUeidqXz5Pvbvx2pwc=w1111-h500-no"></p><p>최대 20개까지 상품을 선택할 수 있으므로 카테고리에 맞는 제품을 채우고 <strong>[배너 만들기]</strong> 버튼을 클릭하면 블로그나 웹사이트에 심을 수 있는 코드가 생성된다. 생성된 코드를 복사해두자.</p><p><img src="https://lh3.googleusercontent.com/JFAQx0gMD9Az7YoR2pQnQR7bkSwB7TdWGHichejU3XJJ5vSqNJzbsygyd4jYqNZ0ybPAP6PWWtTYlkbLoGK9xxjAR69alyRwfTvUk-ngU1sd71QHFmoJAwJXEPaiQZ1ygngv8lKLTuaVUH4C3x4VDBCAv3mSik5ewzF4ethmrQ3LaEgRr5fgmOLjh9xm8bntKd2RBOf3JYFAcEjeF22w1nLgRiuP24lQ44WdbXTPjn2LeLvZCrUekHStsch1-QNVM5afNRa6A1JzpUJzclDGH5VhFXTsDXa7kJ7KgNd8A-yMRWcFODGgt-GJTF1BJQsaOgEO6d0vIu1lU_SOtSgu9zkwBqcIJF9k9E0wPH6hMWtqSpj8p-f5IQjBXI2WRivRtpdOsVSS7z3dVXBb5B4dMwMSJ_CmJ6oLu63JMdYzX2zlFOAK735Rdiv7JLeGebBKqN3aBdXFq0YnuBkK5l836uHjKU4v_xFwmrJt3Tq1MBj7vr6ItDlTMj_U1QzqRkNwTrx4y6mDxSSP3URzhTWsYPOKwIMv5Md7sBaESHfCYXrqkhPHVGHPr7t7vsIG39-bPwt_nA9vH4bKGqv65ncqbnBNdEsEcPkcnOgVGLz3RrpR66cHomNng5lprPdzpJRKSFJpb2vrF5kB7xCJbE2gzJKSEXoEGcldADL-KFuz2a-tTyQzcIamSzJFE14m202MU0JXA_YSMvUqlsSOdnlbgs3GyBJ5tFYfKH_AC8wR2m8H3b5x=w571-h389-no"></p><h2 id="hexo에-적용하기-위한-ejs-파일-생성하기"><a href="#hexo에-적용하기-위한-ejs-파일-생성하기" class="headerlink" title="hexo에 적용하기 위한 ejs 파일 생성하기"></a><a name="ejs"></a>hexo에 적용하기 위한 ejs 파일 생성하기</h2><p>이제 hexo 소스코드가 저장된 저장소로 가자. <code>/themes/사용자테마/layout</code> 으로 이동하여 광고 소스코드만 저장할 폴더를 생성한다. 앞으로 쿠팡 배너든 모든 광고관련 소스코드는 해당 폴더에 저장하도록 하자. 그리고 방금 생성한 코드를 저장할 파일을 생성하고, 아까 복사해둔 코드를 붙여넣는다. 이 때 파일의 형식은 <code>.ejs</code>여야 한다. ejs는 자바스크립트가 내장된 html 파일이라고만 알아두자.</p><p><strong>coupang-ad.ejs</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://ads-partners.coupang.com/g.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">new</span> PartnersCoupang.G(&#123;<span class="string">&quot;id&quot;</span>:your_coupang_partners_id,<span class="string">&quot;subId&quot;</span>:<span class="literal">null</span>&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="원하는-위치에-배너-적용하기"><a href="#원하는-위치에-배너-적용하기" class="headerlink" title="원하는 위치에 배너 적용하기"></a><a name="hexo"></a>원하는 위치에 배너 적용하기</h2><p><img src="https://lh3.googleusercontent.com/YpfJ8vZMIv1bpGP_M7NumKYMc9JLghAvngiouEgV79BK-7ZJpRYiNCQCJI9aedQWpqxRfnVuzWFt8TB4nFMCMzDgldXmTrWu5wX49H6RwpOCgN_gmLa0sBJ2Pt-d52yupkuh7MF9J5f6KQpBRoGh10jY73R1oNlXVeaXBqu5OQBt2QFpuXVvbhSgVAJdsX3HanTCF8SDMDiHzAAonTtZwfVI8mh4Kdkv_J7FOBTiU6WWCNb38VBl4TwieyJXNl77rcZHeztW1p8MmWy0ijJ4dQLe_q3_7vyCXVcxBtRHkRD--v02Gc-7JwWF16MFSGyLrtdXRt_A50B1NurF3IObPi2EByZd-HXyq6SC7XBtNyCwttYDhbiu98bPKTcLnRNk0Gg1a4-ZckgwJ6rLnW_6Iv_TkMFf1xt2QV9mqsPsxzuT9fB45UMnozeVZTsQfq-zIze1W485OEj4Kq3dYUbABnF7dJxqAXDGoHZg5ELGg8TmitNBxpl_Kt76Smcu98DEY8giVi1ItjpN-V_8xLrilrTRI5CuZtTHOHSt_8szOIxbr_8RHFbRNH__Z272cg1SfsFhozwB0lbRZ0T5B46esQq6LW-qMhaPeSv_BuVtZO7JuQEc5rLzf-Q45lnUjSy2GRW38rbMtRlvvCS-KgyyC2H-3S0kw-PNe9fpSu1qL9P6YZyr7wiOLRVmMT0tKouF5F45PNscvG5wIS2xxFFs-gd7oWTgNuB7YFn7qWSSHrsNw9KT=w650-h336-no"></p><p>이제 광고배너를 삽입할 위치를 결정할 차례다. 블로그의 index에서 navigation이 있는 하단부에 광고를 설치하고 싶다.  저 곳에 광고코드를 심으려면 어디에 심어야 할까? 파이어폭스의 요소검사(크롬에선 개발자도구)를 통해 포스트 썸네일이 출력되는 부분이 <code>archive</code> 라는 것을 알 수 있었다. 광고 코드는 이 <code>archive</code>의 하단부에 삽입하면 될 것 같다.</p><p><img src="https://lh3.googleusercontent.com/Xbt9lRi_dLerWJJ8ZGbA1Nud_Zx6VBdIP5MD5xcbHa95zUZeL_CDVCFK5T0rjFdA3i_-eA3-UsLioxcyzwU69KUkBPFXw74VDHy3fva4JzJbCOl1jSyo7cqo-iTbi3UAD-d4xDKwBDVS93sBEjrkdiH8ti4tHa_MHvIfF_WqjBRtdqVKEzOfJHIEts2AX5JbOAth5HVlybGcEw7dlqZZ9EZAGfuhXgFDa3SHJGzKHtlZhf4FdIRdFOXXzgvgew1inPRVPkR_FtuyxIyRw8vrx1y1TnEtzOMWKhruIXLSNjHRJYjYfQBo5ohKII3dJj034hVVq-HoFbhcSxdAh3vDgyNb6IW0jMpu4SGtUB3l9rIFNf9Y9safsgviEifmR7rAT5yG7dRsWfB0Z5PIlu4vjLi2g1_jDk31UIgL-ocxYD8H5627GF5n0ofz4I93L3jydLxM3Na7cN4Ckzr9JYK5XAxpdMoKpFDIsQhpATh6ciGY-D5KeKdMDtUOLThtOqMIm90W1Q0vLONFL4FEaziy6fVI9yV9jEN8qwPwxyiDiNioEqKAMULcXSZcZY56bkX9Z3c3jG-jHZxN3tLcUnwN_0fQmR_dlR8ks5AMwU_op20n-5DWTsr3oEQuwGg7D1F4B7s_B9rufRy3gv2jaZlc_tyzPURgOyEmoRCvOyszTG_Ua5UKxa2Ra39xOwIHmNisWBGlTf5Y2voMzfUCf85rt9LqUfrOqLZ5d9WVYfwselTRAJAB=w1174-h474-no"></p><p><code>/layout/common</code> 디렉토리 내에 <code>archive.ejs</code>있다. 여기서 id가 <code>page-nav</code> 인 nav 아래에 광고코드를 심으면 될 것 같다. 광고코드는 이미 <code>/layout/ads/coupang-ad.ejs</code> 에 작성되었으므로 이 파일을 가져오면 될 것 같다.</p><p><img src="https://lh3.googleusercontent.com/UXEXzahRKaYjAEt-eK6wmZnv49jzH4tmpf8ZvNlgZKORfkPw-avNxccGY6SdsWF0tN1xGwp9wGTOUm2e7k8l1u8bb_nVsGZjoOR2dWQKGQBWMeC6EmnkCueZtC65UaJsr426osIc7lEuAd6K5QCuBq1DH7LtUXqTnz8cqjv7cJB2CB_iXFkUdEQYr6hWP_CpiicpL8BwHJrqHm4ib24i3VNQ_USciWg3EwiLKBxvkRPn-wT4KvSsfQqjCjv0uLM5kp72jS74jcdxan2W2ghQ8l_RmazFRYv3XoCTgKC1pJ-BHPn6KD1G_SzsnyIge4EgsxrKf8F_QbiDBhFjddadMLWQWfMprDmVWqB6634Avur7PEn6iGVBqvHtMy5Cqin63joBkoiNxRQMqIp5ghTbkPDC_gAxYP8KaZYSGKZGluhy5wkjxSihZvilHodBixZPX4RuplmPlmYcf-Oze-xW_SI0Glgd4iecSF7IJ_yKNcBXZ-4kugLYvp4jP8sV006lx08PDmVFzz63hVm0VyDoOP19MvrqZi87_WjK77DJ7ZPFyC6dZxUiHsdOD3GSvZqX8IZJjFrhg1AqXvKRbIPDDuuIdLg-n942t0-VPN-NGn1P9TQZAmmezTdjbHZBvSvpqCSS9CvXIZU_3U6IRuZ0ggN4b4AhjcBE78LrAHI2KsjrTNltWWGXioRnVHzMWix6bIKCTNoGfP_pXGVmw1HgXw9Z5nEAuTN8GYTM-Bvca09dLL1l=w992-h244-no"></p><p>위 이미지처럼 <code>&lt;%- partial(&#39;&#39;) %&gt;</code> 코드를 통해 해당 코드를 가져올 수 있다. 여기에 쿠팡 광고코드가 담긴 파일의 경로를 입력하면 된다.</p><p>그리고 로컬호스트(<code>hexo server</code>)로 확인해보자.</p><p><img src="https://lh3.googleusercontent.com/8FZTxE8gTNNf1A3vZ3T_yT3GEfTAjQuaaUVYCObQ8Gq465W8tAddKBxBqxsyhV2BKOt3BviQXF-2FpvYeLPDc-PR_0jp9CqprhYS1rSuBYoIUOOeXecgqbWyog66JrCFGTVPkTZPt1AoLQ9MbILpyMvXKvS2KX1mpKOeSQjF74L3QBhc0bwseok4T8HPWEWozgYnxYGlTsy0hgWE9vj9xpX9m2giRHrLguHfmf5CB6P0q9r9FAT-9JkIvq8DG8ZRtJRGrMjkD1b41y5ab1gLfoSFFfvTTEXbmyjGY_D1CDr-ZSvEZsC0U4SNTKQaO_u16J84VgKFAHpAXKLVvhpXW9nAKzqWu1aGLfIbzQWUpUr7PTfsMgNwpjop9gy6xWkh717LUG_q4pFp0HNgJCoHmF8DN8uGgf0qJf46Pjxaik906NArB3URsPFfx3V1F6d8QsCSVZV3D7ekOUIaCNeGWVLFs06IhBtY_cNG73dP-zn8Cx2wxV_0D-5fwPBiWI7TSxHTsz6Yk5HaBGajGlLcBCz9kz1E1R4JNgEVhFIVegiuIOjHSwgipMV4OWaQqRjPuINsGtotojUsdh727Prxp2bnFSquLs16oA2_h7zSAS_GP4XkFNsytobeLLomyjiKTPAjOrX-EyD5gZ5X-Z74kArzZJT9bgwzspoS0JmLJ06DB8CO1ZFxTTSUz0Ch1sCe1cJA_WYdGIEQ2OTxiqCgOUzQHAN9LnHtStBz1h2hvPtwY2qh=w1030-h558-no"></p><p>광고가 잘 삽입되었음을 알 수 있다. 이제 누군가가 이 배너를 통해서 제품을 구입할 수 있기를 바래보자…^^</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>커밋 메세지 더 잘 작성하기 (A.k.a. Gitmessage)</title>
      <link href="2020/03/gitmessage/"/>
      <url>2020/03/gitmessage/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1529460608-bc455fccd5a4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=500&q=60" width="650px" /><p>최근 몇개월간 진행한 프로젝트 스터디를 마무리했다. 뿌듯함보단 아쉬움이 남는 스터디였다. 프로젝트를 시작하고 나서 부족한 실력때문에 몇번씩 좌절감을 맛보았던게 아직도 기억이 난다. 그래도 포기하지않고, 어찌어찌 마무리한건 다행이다.</p><p>프로젝트를 진행하며 버전관리로 git을 이용했는데, 처음 시작할때 메세지를 잘 작성하자고 약속했지만, 막상 이를 지키지 못했다. 그러다 프로젝트를 끝난 시점에 커밋 메세지 템플릿을 만들수 있다는 것을 알았다. 템플릿을 이용하면 커밋 메세지를 작성할 때마다 템플릿에서 작성할 수 있기 때문에 서로의 약속을 지키기 더 원활할 것으로 기대한다. 나중에 다시 프로젝트를 하게 될 때 유용할 것 같아서 적용해보았다.</p><p>먼저 운영체제의 루트 디렉토리에서 <code>gitmessage</code> 를 만들어야 한다. 이 파일이 곧 커밋 템플릿이 되며, 앞으로 커밋을 작성할 때마다 콘솔에서 출력될 것이다.</p><ul><li><a href="#create">gitmessage.txt 생성</a></li><li><a href="#git-editor">vim을 git editor로 지정</a></li><li><a href="#set-template">위에서 작성한 gitmessage를 템플릿으로 지정</a></li></ul><h2 id="gitmessage-txt-생성"><a href="#gitmessage-txt-생성" class="headerlink" title="gitmessage.txt 생성"></a><a name="create"></a>gitmessage.txt 생성</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~&#x2F;.gitmessage.txt</span><br></pre></td></tr></table></figure><p>vim 에디터가 열리면 여기서 템플릿을 만들면 된다. 필자는 이렇게 작성했다.</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 제목은 최대 50글자까지 아래에 작성: ex) &lt;feat&gt;: Add OAuth2</span><br><span class="line"></span><br><span class="line"># 본문은 아래에 작성</span><br><span class="line"></span><br><span class="line"># 꼬릿말은 아래에 작성: ex) Github issue #23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># --- COMMIT END ---</span><br><span class="line"># &lt;타입&gt; 리스트</span><br><span class="line">#   feat    : 기능 (새로운 기능)</span><br><span class="line">#   fix     : 버그 (버그 수정)</span><br><span class="line">#   refactor: 리팩토링</span><br><span class="line">#   style   : 스타일 (코드 형식, 세미콜론 추가: 비즈니스 로직에 변경 없음)</span><br><span class="line">#   docs    : 문서 (문서 추가, 수정, 삭제)</span><br><span class="line">#   test    : 테스트 (테스트 코드 추가, 수정, 삭제: 비즈니스 로직에 변경 없음)</span><br><span class="line">#   chore   : 기타 변경사항 (빌드 스크립트 수정 등)</span><br><span class="line"># ------------------</span><br><span class="line">#     제목 첫 글자를 대문자로</span><br><span class="line">#     제목은 명령문으로</span><br><span class="line">#     제목 끝에 마침표(.) 금지</span><br><span class="line">#     제목과 본문을 한 줄 띄워 분리하기</span><br><span class="line">#     본문은 &quot;어떻게&quot; 보다 &quot;무엇을&quot;, &quot;왜&quot;를 설명한다.</span><br><span class="line">#     본문에 여러줄의 메시지를 작성할 땐 &quot;-&quot;로 구분</span><br><span class="line"># ------------------</span><br></pre></td></tr></table></figure><p>다시 한 번 언급하지만 이 템플릿이 열리며 커밋 메세지를 작성하기 때문에 커밋 메세지 작성에 대한 규칙을 여기에 명시하면 된다. 내가 아닌 다른 사람들이 보고 쉽게 작성할 수 있도록 최대한 명료하게 작성하는게 중요하다.</p><h2 id="vim을-git-editor로-지정"><a href="#vim을-git-editor로-지정" class="headerlink" title="vim을 git editor로 지정"></a><a name="git-editor"></a>vim을 git editor로 지정</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global core.editor vim</span><br></pre></td></tr></table></figure><p> 다른 에디터(emacs)를 사용하는 사람이라면, 위 커맨드 명령어중 vim을 다른 명령어로 교체하면 된다.</p><h2 id="위에서-작성한-gitmessage를-템플릿으로-지정"><a href="#위에서-작성한-gitmessage를-템플릿으로-지정" class="headerlink" title="위에서 작성한 gitmessage를 템플릿으로 지정"></a><a name="set-template"></a>위에서 작성한 gitmessage를 템플릿으로 지정</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global commit.template ~&#x2F;.gitmessage.txt</span><br></pre></td></tr></table></figure><p>이제 커밋(<code>git commit</code>)을 명령하면, gitmessage 템플릿에서 작성할 수 있게 된다.</p><img src="https://lh3.googleusercontent.com/A9Y_6n1mfhLHn4ztVc7L2zhQDxPECedZm2GHPl9T2CSxIGHo6kWL4lajlNw2V3wFV8h1O45z_g-T6RvnFytmdbdplqK_QANY4KclS0GpCNDmFKVhgs8D6YqGmqT-0gF8ksMfpY_oC_jgSsMqQkGtRaw4sMRxLjCWcPpBBkhZyPFaR4_I7zB4EookrH5vDwdstT1oUoUw91KlLN-tZGTVQEN35A4YSqsZnYcvQXg-FQomn9_y3bBs6-BvBMAh9jTbE7wcwfsZ7Kj3tXQdsFjtyk6ci4N7bS2ydsJCGr20eAuq_Cw30bG8rnVUKWTE3-IAohyxBQkE7_uPOh_5DDoU3vIEmsOkd-AL5STFL3HAJbhq4K82XfLf1GYluYRmsDqb3w4UnMHGP7htZ03o4kPWXt5FR61trD6YCkQTsfFRFtOJa6s4B_bzOtONaDA8vRzEi902uzQBjEfF-RHpzpfnNU_ibdLvlPkHQ3QS2l1BuQr3bASVQ9k76PG4y__73zEU7t8ZhQM-h5_xreQ1my7hNSzNSSrtu2ecNby7Jd7h2Fpk4FqrVKGxZATwSQsGtvRzoRkIn_A8t9GKhCKFibUtHAV0oeAv4t7j1ncECzupEYx6WOCGooE0hBAANqoNOl1tmH13EIExNI2BIrwhMWX1eSKXzV-SMA5qaMuZgBQ1c197ygIqYLAeQqyp7FLa9R2h7XTrrCGFDsIkwbY7sH7J9hGmgGgMbCLEd3OrSsLW0JfLt-rK=w809-h576-no" style="zoom:80%;" /><p><img src="https://lh3.googleusercontent.com/6NE5lo6P5RNQEPI5XZ4iu3cLaHrOkL0ufrYzny6zqYA9W3npq6gJap_a4QvBJABkEPtasps5MR2ugv_ADCrtdEgHD4KOD8S7ifWHM_uGXrS08EYxxSEb3IVgHrFoFGRRYhU07bruP63tTXw5tk9VOqfL4N6rHZEsg_Ju-Smfks2e8fSsAj0Kc3FFSrp9qTVnb_Faqeiji8d8cK4l1VD_8JLHVvCL-VMpomacxNaFOy4XqwUXOVcPfDSui4LKmQ9DPXB6XumOvVPt7VRtZ09gDru6-L2vxFvXj2zgwozATgp-TOiTOOa1b0Ip8YT14ocuuXlJRg7Oe3HxzfZhcgusgc7vMQu7k9hlMTAAL64peB_DTtQ_b8VNwoewS1ewtgGnSdBqWmkXnrw1Dru3IWdnRhy7zR-wKaMG4QGmyUi0EwMqdsTpnZxWzUv_tVKYLLoEkXUdP7HYHyv8u5UIFj6oCQKbs4NfUpImeyppMQMPHHN4vg7RxkoC2cP-0_BoKYJaqbk5a5fYpU05hYlZRFJ83qSVTPTN-NcVey0prcKJ-337caZoziYcpDa7iBoehLXv3pItRDXld911lqbeb_BfVVHfwifJQhnsBj6lTxntJJE9B1NtwTV7NVLA2o6N7izK04-Bpp3oRAY3bJS3cJEbh_d6GbsJVvMUGCLzD0ifZ7q1kXHblNX2pRMWTcJcb4zPV1qUzhDMVq1vJmspdmvicpNn_gB67q6gcvfbQG1B6eiIrHNx=w669-h155-no"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 블로그에 Utterances 적용하기</title>
      <link href="2020/02/hexo-utterances/"/>
      <url>2020/02/hexo-utterances/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/ZPV6ThGID6rOwa_gal1M-QlPM0tSG26WTMGHTyXrJd53WS2625px_qo9Jy7PY0ojA5-du_n2EkbazIpbCWEJ2-M_7OKdFIV6fyOzwu0kYoYgH-Zn4dsISWPHp_fNlUoVEtadBGz-uyaif5YrPSAXA-REnYcpbqnmZmpSyCRhSDIAdQygg1IVIFErP53X-F1cAaw281CA8tCkpWXVLBtEwFPkn4unjiAMhz0lzXWyPdQfimxvbrFoYow2UFMALRKKFro6D2l5ZZbrf-NUazxC-bu2CPuIz8gISM7nEiBhc7TeLtaXow_POU0sSecBlSBOAzlbwQITfYCn7hYIjNUVmKx6pGl71Ji9Tne2wHVUTliwtkYhT7EQ_ln5dx2LpwGU1_8gHYMt0WjiUA8EXw-4wd1b9-k6Izvt5WEK9qbwRjHZevnn68Q303M-8Cmgi36nYSb3ej5uW6WhIZrMMMivyOidI_Kyw5xDCvrQSeshhfVeZJKQcwBL6__RntSk0GqKZZy1yJiLaIhsexUbvK__IRUkaIYTiYCm3THVzOa_e6VmMP7bAKOhIaCTum_J7lTJ-qVuFcDZMwn-euHFOzHliP2EFJ7mvlNo-Eqb-6SAjlCeBsOfgLiy6sb9zWb_luata4KJGyzxZnBHxl0FUrqg8eLbuVtYYMHaALWGJEi_3pcEr6LjZmOn91c2Wx09fKgGAU_s1X56I8RL2Kbc8essADxut2KH9s_oEdGivrVUtgVrX-nt0g=w651-h332-no" width="650px" /><p>Hexo 블로그를 운영하며, 댓글 라이브러리로 Disqus를 사용했었는데, 현재 내 블로그를 접속하는 사람들은 아마도 개발자들일 것이고, 개발자들이라면 Github UI가 익숙할 것 같다는 생각이 들었다. 그래서 Disqus대신 Github UI를 경험할 수 있는 <a href="https://utteranc.es/">Utterances</a> 라이브러리를 블로그 댓글로 사용해보기로 결정하였다.</p><img src="https://lh3.googleusercontent.com/6B7uHAkNB5ITzSuObJmGEfOOBxiDTCb7f8IjI_kaBRZMdMSMoeMb0pArZlV-ly_obqqfh4_2zBeje_JYvZBtqlnDKB7Fz06tsukk8nYiF8JrYillEk7iNYjJyc1cXYlmMR-AY0AvRe2cttk7zET95WEBd9rut4oAJ0JcooCbqdQo4awSTxknuuLHovI41cHofghIMh6L-pP-XYOAuZNe1mH38N_luFJjrrg3WT7rmweshFsblY5gtOe8JW4hRJ9fl9kPPUPeIbrlkp8acuTiSKgx7STnDc06W5e0lxfNiwKxpx0oAVZNpoNdiQT6W_3C__gFX3Apg-B4oz2WyrdhTmCi41GzWWZuUP0Ygegzye_PtG6C4O-vDGdahWHh1iaBlZP1UZzEqzYFttgZk12ResdCNehKaYvFv8CnTFjRAxKF10fcfjnmDTymmXnwPVtIbQcOYehVTHZ9ldmPH6olC2jwMegHMbctYhpWKRjCMzK8AaAjWDXUmKLC3D9z3aQA5MLkQjLw5SR_3SNQ7ZmlwcQ9P7kI6N_c2yyGaUkqGeSPx4kEzj3W0sJPRUkm26PaagUnRwOD5dtQWgO9V23XMwq8kGMeIPp4Lvh9jYK_-GG0980d_TbB964UPKMZtfPOKEbwCBDbb-AFU2bhIXKowSrqAeKyZk0_ypmphXjRXmIwysoQgvcjNtix5e9eycOvWu0fxUkZi1Y6s-TCuEteMDTJcsA5oNrwqcYaLS7QtdyIWOVg=w1060-h448-no" alt="utterances 댓글" style="zoom:40%;" /><p>아웃사이더님의 블로그 글(<a href="https://blog.outsider.ne.kr/1356">페이스북 댓글을 utterances로 교체했습니다</a>)에 의하면 Utterance는 Github의 이슈검색 API를 사용한다고 한다. Utterances를 사용하기 위해서는 Github에 댓글을 위한 repo를 만들어야 하는데, 댓글이 작성되면 이 repo에 이슈로 등록이 된다. </p><p>Github에서 repo를 만들었다면, 아래 Utterances 코드([ENTER REPO HERE])에 해당 저장소 주소를 작성하면 된다.</p><p>그리고 아래 Utterances 코드(<code>[ENTER REPO HERE]</code>)에 해당 저장소 주소(예: <code>youngjinmo/hexo-utterances</code>)를 작성하면 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span><br><span class="line">        repo=<span class="string">&quot;[ENTER REPO HERE]&quot;</span></span><br><span class="line">        issue-term=<span class="string">&quot;pathname&quot;</span></span><br><span class="line">        theme=<span class="string">&quot;github-light&quot;</span></span><br><span class="line">        crossorigin=<span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>hexo는 레이아웃에 따라 코드가 분리되어 있다. utterances는 댓글에 해당하므로 댓글 라이브러리들이 저장되어 있는 디렉토리에 utterances 코드를 저장해야 한다. </p><h3 id="utterances-ejs-생성"><a href="#utterances-ejs-생성" class="headerlink" title="utterances.ejs 생성"></a>utterances.ejs 생성</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- utterance comment --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> (config.utterances.enable == <span class="literal">true</span>) &#123; %&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://utteranc.es/client.js&quot;</span></span><br><span class="line">        repo=<span class="string">&quot;[ENTER REPO HERE]&quot;</span></span><br><span class="line">        issue-term=<span class="string">&quot;pathname&quot;</span></span><br><span class="line">        theme=<span class="string">&quot;github-light&quot;</span></span><br><span class="line">        crossorigin=<span class="string">&quot;anonymous&quot;</span></span><br><span class="line">        <span class="keyword">async</span>&gt;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>이 코드를 hexo 블로그 디렉토리내 <code>/themes/[your theme]/layout/comment/</code> 에 파일을 만들어서 저장하는데, 이 때 파일명은 <code>utterances.ejs</code> 로 저장한다. </p><p><code>_config.yml</code>에서 utterances의 enable 상태가 <code>true</code>로 전환일 때만 utterances가 사용되는 코드이다. </p><h3 id="config-yml에-utterances-설정-추가"><a href="#config-yml에-utterances-설정-추가" class="headerlink" title="_config.yml에 utterances 설정 추가"></a>_config.yml에 utterances 설정 추가</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Utterances for comment</span></span><br><span class="line"><span class="attr">utterances:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">repo:</span> [<span class="string">ENTER</span> <span class="string">REPO</span> <span class="string">HERE</span>]</span><br><span class="line">  <span class="attr">issue-term:</span> <span class="string">title</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">github-light</span></span><br></pre></td></tr></table></figure><p>hexo 블로그가 저장되어 있는 디렉토리에 가면 <code>_config.yml</code> 파일이 있다. 여기서 가장 아래쪽에 utterances 설정을 담은 코드를 작성해주자.</p><h3 id="post-ejs에-utterances-추가"><a href="#post-ejs에-utterances-추가" class="headerlink" title="post.ejs에 utterances 추가"></a>post.ejs에 utterances 추가</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Comment - utterances --&gt;</span><br><span class="line">&lt;%- partial(<span class="string">&#x27;comment/utterances&#x27;</span>) %&gt;</span><br></pre></td></tr></table></figure><p>이제 게시글을 작성할때 utterances가 적용되어야 하므로 <code>/themes/[your theme]/layout/</code> 에 있는 <code>post.ejs</code> 파일에 위의 코드를 추가한다. <code>&lt;%- partial(&#39;&#39;) %&gt;</code>에 넣는 주소는 utterances.ejs가 저장되어 있는 경로를 의미한다.</p><p>여기까지 마무리하고 <code>hexo g</code> 를 통해 블로그에 최종적용하면 된다.  </p><p>테스트로 이 포스트에 댓글을 작성해보았다. 댓글을 작성하면 아래처럼 Github을 통해 알람을 확인할 수 있다.</p><img src="https://lh3.googleusercontent.com/4LRTmS8ONJ92PgsVsIGwHO5LllSyrMD1sE6Ko3G2hXQ81ygO78k52dtb91Kqn4gQ4c9Y16Vnja-uVib0Kt_8RW0JlY7_CiMxQ_uwaJzD6rxTvz6WsqvFb8N1--xvSTAZEGtiaa7I68DqzNpHICVkwyJyEvJZWq95sGiVLIlzToO-8B5m9M5nzlw4HbcDDeYx6ujS1pNY_htSjMbKWORtmESJKH09Gc_ByJ2xjEQgaAEgjFOLMvz8h6iwFGih1YndLP9p_4oX9AYaSrWdOqkw6lovimzFRK_J4Hzs74JfY0Wi2m8ovwnWvpisXlzpOUs-tCJ8b2wsoTM780IUSe06V8wFR6dp6FMCmKJ-Z2hl3yyttE2n3MWqnYy7jxvhBDFIzUkjoRy4uZHTyuQewUzxdLKcYhmBgJboNH93vXiUkW67mlFGAZkDD1BPTFfZ-ZQQraATFkw4FJpoayIIFW8OIYLkomL41a0Fkz6h0S6PUgrHkpxbDt3DH6O68wojooZeKXyw1eqWdd0YBXPd6C9jwSwoqNXL8Z9jSRcuv6m5ovFy8Y8RCUykVizYdkz-TGMcnOB5wqfukhNou88Hiyr7h1QoViPY1hwV31-Sbasq2Xoa8JQfePHV0mJrVU-hN6xr6d8ocOY9eiFsHwcae9yJmyP1XhIThMUAULdMCWgj0pBpJQNRbbytlaaHWgFxhdadAMOhHDBstIm6A8Z2wsm6ldNBsHrgO3T4z8AK9EV5btWlo6gtsA=w972-h390-no" style="zoom:45%;" /><p>그리고 댓글 저장소에는 이 댓글이 이슈로 등록이된다.</p><img src="https://lh3.googleusercontent.com/o2uGj_GsHJAqd7POzAIo5DOUkmy2y1HFZblU9xX7xD_dodI0gUBdLlcKhgwY9ph-bxkoeDClvAnY8QUQoDREA8TrfuPGSDRCP_S-lN_fBD4bTnceb5iBBcWI6Mh7L96rKjFxaafQjWLNyMEmi1MWakNnyv2s7i3RcbaDVw4SmkaJKPWukvy_kRx-2_VcYJn9GN7aPPLHooMbruoynwoz0ZzEtcVoW-dfzfNSl0oEj2gndtgqZ8KXaaOGzWrrRzrumCp7Mkb07iiLfnZL6gI5OR0ljjqNFrM1e02iUMluLWN0XROMjl9S4QWai6zuIpQX6qFR9gIsIM69G6yG-T4QiFJz-WVNx9xHjWe2NO9tneHDhQfvZJyRv4ZeIhUASWyOAEpuTV2DDMZGf8o1vKXPNtiD6h9ncnspgKYVIDjP7gz5GZB1-Iqjvx6in-UwjffjPwwvOi04iZt_R8JZhYviyAcnEYSZGOCqh0N2gAuU5PZGeIMNSmd5Kamk_JyrwhGM-SDZOSG6axfnprRi30oJ8mQItRIxDNcCnL9g856xZKP0xC4B7-LwOgQ1DqH7OfP5geUmVFBBjVuHHIw0pJNQnp8O4dFH8zbPyJPYiWt0q9NEQ2RBBMY1DcEzgXOs-30yuTH15Q-0ckfPF3qdg4pZ7S5w7oXgn_M8glyk5T59hpSMZje2kDAszJLMBXbn7d6seAxTdxbwMvBHtf2bYeu3LOjaVizjiYbYAPGEEfA8k0del6mFMg=w720-h768-no" style="zoom:60%;" /><p>utterances로 댓글 적용 완료!</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu에서 Wget으로 파일 다운로드하기</title>
      <link href="2020/02/wget/"/>
      <url>2020/02/wget/</url>
      
        <content type="html"><![CDATA[<img src="https://e-tinet.com/wp-content/uploads/2018/11/wget-como-utilizar-para-download-arquivos-1024x512.png" width="650px" /><p>우분투를 GUI가 아니라 CLI로 사용다가 파일을 다운받아야 할 상황이 발생하곤 하는데, 이 때 사용하는 패키지가 <code>wget</code> 이다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install wget</span><br></pre></td></tr></table></figure><hr>1. 우분투로 전송받을 파일을 구글 드라이브에 업로드한다.<ol start="3"><li><p>업로드된 파일의 공유가능한 링크를 클립보드로 가져온다(복사)<br><img src="https://lh3.googleusercontent.com/qtDCQlHyq9uZsWldOiOvcsh_TnSWKek5EGefoGCIXXbKXthN9EhN5Y7Yrn1YzCJnq9VzvYAU7PNe5z5Iplvgm36TiIMjGrpk95QdubwlgtKmyrB2RtWtUw3wITdEInI6_hqTn9UGJyy7EB9m3gqSNrWU_FXkq4ySzC29PiUDthEdRSDzPyLD_NseectgCblVCrdDYdml1tzLreRWT9zyhTzO3goDGVx7ho0s9d04mwd0atbaPx5sZya9SJRmmR-5CMBVQ2VIVwY0M6t6F0uufFqQRTHTiNXWrD8Q-aik8ds4rLqIqF3G_31h4nvtb2VOpVNnc57yieHZy7nJA0GEXnaFVeIJLIlnUpnHm2lhwJH8W61zUFDEYGyh4ZvaeIKurWvuu8urhQvths8dJjYSAcpeVP_iJvDEA1Zg4_nof3yTcxwV4EvcWylK63xKIhoXDblVdzpXXPITUfc5xBteAU473DpuryxNGT6RRY54qT5xj547xCMYlA5x-1vKU60gwKPK4ZvSk2g0RjbVd8Oq_dHySCXzlEcDXrja5Jtv6ZiuityWGpDivcuZQANjoYA9AdopdJOf38q_OgBs3ihTGYBorGYOdHtkBO8iFbECYmcAvaZKGc7b9SecSNve9DkxyhAvs0o9URVkagnB1iorBYGcGjCD_BtPSgJLzFYb8vjApnMRp62QT24egBvrvTNf1qVJ3mDOwRDZsjj3vZn3PSkjWtDyRIVgViILTPf-U8ZA04ftzg=w1013-h500-no"><br></p></li><li><p>클립보드에 담긴 url중 **<u>id부분</u>**만 아래의 명령어에 붙여서 명령어를 완성한다.<br><code>wget https://drive.google.com/uc?id=[from-gdrive]</code></p><br></li><li><p>위 명령어로 바로 명령하면, 파일 이름이 id값으로 이상하게 다운받아진다. 파일의 이름을 지정하면서 다운받고자 한다면 <code>-O</code> 키워드를 사용하여 이름을 지정한다.<br><code>wget -O aws-keypair.zip https://drive.google.com/uc?id=[from-gdrive]</code></p><br></li><li><p>다운로드가 완성되면 <code>unzip</code> 키워드로 압축파일을 해제한다.<br><code>unzip aws-keypair.zip</code></p><br><p>만약 <code>unzip</code> 패키지가 설치되지 않았다면, 이것도 설치하면 된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install unzip</span><br></pre></td></tr></table></figure></li></ol><br><img src="https://lh3.googleusercontent.com/-1lVdHOQrK-SgXkpiqOOTeO2KCMZzro6ajSz_EhOpyQAyyy7JBPYjI3RwUR4_4lgqjAOldR9FMgefgFHvSiQ9zb7LocRVmG8vUKQgg_Uv5QlQfstrM0uhjvl839W6rLyNnGzRZS1zmZ8FhDUllqw3UdJwQ4ogECX-_5xNXHTSUOpGeaP6yxbNbYXXo5V4-aoKzbX_AHpDZV3KbbjHll7t2EHSKEmr935zpJNwUq9G5bPtsD8-vpVClAtoRY5NPbwOU4GOozMPVvZLP4-eXaNIrpBBb_nVj1Z6KiMotykdkZhtOVsAxnioS3IEQvl5ThIr554oe8iJzgf05NmzDnQ3f-iWgnhGTRGXS9v0LyD-zk0GVoMbSCzMBtRRh7RbjE7p7V9FizSiQPIRVJX0O9iKFoESnWfIdHYU9YdVKvmdPj-7DDKb9reJ8vss61jg_HdhFW5byVL7MtcnbHXXrdcoOV_mBFTlEV7IysI7yRaXkYr6ZD5w1-4epFvHIXYEjhAez_UhejhKZaDIqscGkCLF2064dLo7FcCMo7NmTtck9dDny3_0RSLntzgAPbdk3xa0CcHQOXJ81g_rHDCrW0Ln6OGXb5YyNF9vhJ8-vqADe0lX4xBqs4Ezunf14-3Mh-axUvCGh6CFnFQykrOJZqNE4yjSXaqPJtiRiU254MWbrbcljopW_LDkS8DYC3rz_lp1GDTTDWF07Fkx9KkoN-O3LXXLINjrZicxrVz54YQNVtGS3V3Bg=w1440-h580-no" style="zoom:80%;" /><p><code>wget</code>로 aws-key 라는 이름의 파일을 성공적으로 가져왔다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github - SSH 등록하기</title>
      <link href="2020/02/github-ssh/"/>
      <url>2020/02/github-ssh/</url>
      
        <content type="html"><![CDATA[<img src="https://www.hostinger.com/tutorials/wp-content/uploads/sites/2/2017/07/asymmetric-encryption.jpg" width="650px" /><p>이전에 작성한 <a href="https://devyoungjin.github.io/2019/12/git-credential/" target="_blank">쉘에서 SSH 키를 생성한 후, 이를 Github에 저장해서 사용하는 방식이다.</p><p><a href="https://ko.wikipedia.org/wiki/%EC%8B%9C%ED%81%90%EC%96%B4_%EC%85%B8" target="_blank">위키백과</a>에 의하면, SSH(Secure Shell)는 네트워크 상의 다른 컴퓨터에 로그인하거나 Github과 같은 원격 시스템에 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있는 프로토콜이라고 한다.</p><p>SSH는 암호화되어 통신하기 때문에 통신이 노출되더라도 안전하다고 한다.</p><hr><p>먼저 쉘에서 SSH 키를 생성해보겠다.</p><p>터미널에서 아래 명령어를 입력한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>그럼 key pair가 생성된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Generating public&#x2F;private rsa key pair.</span><br></pre></td></tr></table></figure><p>이후에 프롬프트(Terminal)에 입력을 요구하는 메세지가 출력된다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter a file in which to save the key (&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa): [Press enter]</span><br></pre></td></tr></table></figure><p>엔터를 입력하고, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]</span><br><span class="line">&gt; Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>기억할 수 있는 문장을 두번 입력한다.</p><p><img src="https://lh3.googleusercontent.com/v63aRqQ4LEVFAmB9KQeiKheT0Q2nk6Ssc3iftUuxt3dUhcCt77v81UCSHH_e2p_SJZPd1XuVfoUT0kgkRHEDPCMmHU2T0MpQxSFNg7gE3Qsbp38ssEIyiAyTmAd4-aInYdbciY7OuekcrVOtA1g3aY8eoykkywJQVfz3J0wGGvzPI11L1UdgxsN1ufHRZ5ZZkrAAr93v0LIh_CcF5aiaxvgIrZEKaUkoGoDL_u61fxQdKihyCoOOBPL_fJCPvT5ayRl_gPLX79iR5GRSdSfDNj15ZohJVe6g2Gt1MkUc6-bQQZ1A_aFq1fBMvQvYmUTUrKmzFugOpSkRQzlhu5Uexk5puSPElSDZh0E9uPN-S0gQ76imL0Iy8ghRVkDJf0hzZR9f1x5dcvbWAAftU-oO2rmf8uCELhsWSKjUispLqoZplM0FahKb7Y-oQa9pR73RrWPYaHEXomc93n_Td4ZdHMv3-dI3ZMwDdRtBq3yoOTJgAXLQxNTYQXc6Yt6hSLHmLWGBTJWUG2cbMP2Uj26AShI6jauybl1Ld6JbS-06i_chUal9YYN8bdznUjvxbx8PNia44kpLoOsCBbcYki1JWqpHdVeI5PHUIPlewkIdb4Q_8DdBx1Xfo-4iI9ODDBpOY5uLPMz96Bx3xGYvAZq9ZJtA0VnDVKaJhlC3bOPtH_4TcB8_kFw0MbcQBDic6uHGP3f0WKPt8d_axxqi3ZyB_HM-ae_rAoz1esIJFeK5J4ephyOqdA=w720-h437-no"></p><p>그리고 터미널에 아래의 명령어를 입력하여 <code>ssh-agent</code> 를 실행한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ eval &quot;$(ssh-agent -s)&quot;</span><br><span class="line">&gt; Agent pid 59566</span><br></pre></td></tr></table></figure><p>pid는 리눅스, 맥 등의 유닉스 관련 대부분의 OS 커널에서 사용하는 Process ID라고 한다. (<a href="https://www.2daygeek.com/check-find-parent-process-id-pid-ppid-linux/" target="_blank">출처</a>)</p><p><img src="https://lh3.googleusercontent.com/Dfsh3V9UQhKtZV9NGO8BToyaYoPrhr-eJmF2x3uOTgopDio7mwu6W3DpntTz7XqTWoNlGeD16tFaidKP1AQsm5uIwYaTqGB3zyP9gq2iZgURQyt932OqtybGOdw9OUocpztle3Ky6EmXHX6Z2OkYdnW04zVIHp47uxWVu1yYDTWUZRFkPBT1MvPE1t7qGei_jJQ2w0ycveL-G9RmDB9PWLRgz2WtiKMUjKztO2INalCbHRngNCccJUWCADkYZg79AjiWoXvJ-lNTwqxIzzHOutpUbGiNA679xMSX7Frm9brWu2fN-ycCl7_rzmJRF50KngwtjbxImE7D8z7z670AA27Y_97gDJLros8Hp-CR6LpFF61fDERP7Bmn4Fh3FZc838pNCt4KoNi-Ey3fJAEdulntVJAaWL0_8gUraY06W89ElEi5Tgx2QZTT65Kqa6uzQlP4nL--jnsKWOgPujkcC0mwbHaXAn3SyoJFLmj0GmEBX3FpQR7_9BOSkUOjLkQwEh7VXpu3vEo59sEITrnanfMJYg899dR1CICqMtXFcM7peU0E15N2019sqF9nvV3OwrQg2ppwUik0vYn-5ijK0x3htgajHbnYZ1oVWhOG6Do0vW1EvQLD80gUWNU0uMWRveD0u-BAWxOj6D8XSAKswjwbykt-Vn5MSorfcuviQlPMrVcVYwvHqAaj8xQd72cFkWlCUFqu_jFQnLN-soj8pA6Xd_aq4yF2XaDI6EXL3P1Yy6bcew=w701-h199-no"></p><p>그리고 시에라 버전 10.12.2 이상의 맥을 사용한다면, <code>~/.ssh/config</code> 를 수정해주어야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">   AddKeysToAgent yes</span><br><span class="line">   UseKeychain yes</span><br><span class="line">   IdentityFile ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure><p>그리고 SSH 키를 <code>ssh-agent</code>에 연결하고 기억할 수 있는 문장(<code>passpharase</code>)를 키체인에 저장한다.</p><p><code>ssh-agent</code>는 리눅스 또는 유닉스 계열의 OS에서 로그인이 필요할 때 자동으로 config 를 도와준다고 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -K ~&#x2F;.ssh&#x2F;id_rsa</span><br></pre></td></tr></table></figure><p>이제 Github 설정에서 방금 생성한 SSH 키를 등록할 것이다. </p><p>생성한 키(<code>~/.ssh/id_rsa.pub</code>)를 복사한다. <em>(클립보드에 저장된다.)</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub</span><br></pre></td></tr></table></figure><p>그리고 <a href="https://github.com/settings/keys" target="_blank">Github 설정</a>의 왼쪽 메뉴바에서 **[SSH and GPG key]**를 클릭한다.</p><p><img src="https://help.github.com/assets/images/help/settings/settings-sidebar-ssh-keys.png"></p><p><strong>[New SSH key]</strong> 를 클릭한다.</p><p><img src="https://help.github.com/assets/images/help/settings/ssh-add-ssh-key.png"></p><p><strong>Title</strong>은 입력하고 싶은 이름을 입력해두고, <strong>Key</strong>에 아까 복사해뒀던 키를 붙여넣기해주면 된다.</p><p><img src="https://lh3.googleusercontent.com/YWlsn_mpoKC7bZollAK0EZQqBJGw5uGcPMB_lVF-xt7ZsDYRbmmdMiyHbNhZTXLkzfRFslXUaHaLIIVfs8Iqd3-VB2k6HXZldkNTnWqy38Vr1XeXGKQDCg35ZhduuVE82w9yeAPqVgHv1lql0Lj3eOSWXM8asS8p2GRVEI2nDfTHl-wLvFOazAEN9ufQYqeZma3uj7S818kltFpDOMKqrlQSeNmg23raoPZau1Xfi1s7oyhmE8sooK6S2SoZcSh62RUJX-bckkA4oq4SBjGAtb0mQGR6iTRTp7BDnSiKeVUs6nVEgMHGy6QmQ_y3hrXrmtGBTJdfqfMNGRcAWTFSgF068TNqzB9a5OROgcKLYPVOI7VAbITM2blPkMJYK-_KWUHfrOKabHKFzIqpkoFWnKZdBzJmxY4lbuDSwOKv_TBMY8KEC5ofLgWjDQxY_8ySQ7RiU-s3L-UonhQULoloMc91T65V8tLTJDH4aA7w6Pqvob-kQ4DpOja0BUsKd3yMTQSMlhgEIImUKc_pBz6a97Lv_vtujuWD4h8v4ou3O_mFFIdtlbS68M9ZUmrDzC3EVoKEWrF47ksJEdmJp507GQitdPWDs2JM8pnkAVlTpFCMHBsiZqPKXlrFu6TkvjGt7TGIGdoD4yMImAtyByEwgqBkdIh83CDlv2Ge2HN8Mt0LWISOiCMBT0UkVm7_982eqil_uwc4lJPzcM7vfGsL4HsPzwlKZlAEQ6xHvZ7vmoP7Q3fytQ=w1024-h541-no"></p><p>출처</p><ul><li><p><a href="https://help.github.com/en/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent" target="_blank">Github Help - Generating a new SSH key and adding it to the ssh-agent</a></p></li><li><p><a href="https://help.github.com/en/github/authenticating-to-github/adding-a-new-ssh-key-to-your-github-account" target="_blank">Github Help - Adding a new SSH key to your Github account</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Github 라이센스 정리</title>
      <link href="2020/02/github-licenses/"/>
      <url>2020/02/github-licenses/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1531206715517-5c0ba140b2b8?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1650&q=80" width="650px" /><p>깃헙에서 오픈소스 레파지토리를 보면 항상 보던게 있다.</p><p><img src="https://lh3.googleusercontent.com/gyhdw4OLgqZO-G4R2ntt6E3SMw4XDwUdG8TUdhhDCY8ApFyD6JhOMyUaJ_A3hYCz4-uQvJWOiHH6VcPwrCwy_jhobHPuWAGI4jvx94KphmXntVGIjdR0kKDdEbwX7js9fKujH4C4dnfRMaeBJzusgkrn42vkBEMD9ESKuK-3z2GaB53vVNke9WoLdNIDE-dCfUCRX8kLkmUjOOOhDdA-cQ2O1onwNReV0FVbwD6JcYamhjnpMq_RJdGzLoI67LuoCANWnHtI3yc-I0nUDfhpaIXkBMBR8rCygE2IeRRkJIX0dlKMJvf4TJgpEMVxiAx3ZWcvVrCyowo5r3G2Qmes1dR06cKVDD8sHIRT0nogcjX6i5IU_X4fU7Qd4b31cmcs3ElxWXaF-Q6XNMCpRfVf2krkBg2q5ljwOPBg2LSOgWG7qfTDIVzxL42uZUJYRZ15oQylZ2OvjJhgIz1w8SjCo0McBoiRf93yCxhTaRdaKz3NwJlYZENYLahsfQ0F62L93nwSqCgDXEpCDo3j4eYk9uyjLCwOFZZUOZ8Pvzzt3nAtcJACCWkNSYVHwnulEP19fO7ZD_EYRVZZ9xgfSUOzPX0V5kIRMiRfMwLP2Ow2wz5Pi6zFuXFdYY25nzUBw1_24qfp22_mO_xchLe0ZRTcnVMiin2UmDwWpE61x0voayZF5xrlk-gIZn7LjVqtsHDU2AlFcKtRghstN_NfbD-iocKD906XPL-UesgfjU3b5vaEDeu9=w640-h234-no"></p><p>오픈소스에 해당하는 라이센스의 최소한의 기준을 정의하기 위해 OSD(Open Source Definition)를 정의해두고 이 정의에 따라 인증, 관리 및 촉진시키고 있다고 한다.</p><h3 id="License-List"><a href="#License-List" class="headerlink" title="License List"></a>License List</h3><ul><li><a href="#gpl">GNU General Public License(GPL) 2.0</a></li><li><a href="#lgpl">GNU Lesser GPL(LGPL) 2.1</a></li><li><a href="#bsd">Berkeley Software Distribution(BSD) License</a></li><li><a href="#apache">Apache license</a></li><li><a href="#mpl">Mozilla Public License(MPL)</a></li><li><a href="#mit">MIT License</a></li></ul><br><h3 id="GNU-General-Public-License-GPL-2-0"><a href="#GNU-General-Public-License-GPL-2-0" class="headerlink" title="GNU General Public License(GPL) 2.0"></a><a name="gpl"></a>GNU General Public License(GPL) 2.0</h3><p>GPL은 현재 가장 많은 오픈소스 소프트웨어가 채택하고 있는 라이센스이다. 오픈소스 라이센스들 중에서 가장 많이 알려져 있고 의무사항들도 타 라이센스에 비해 <strong>엄격한 편</strong>이다.</p><ul><li>소프트웨어를 배포하는 경우 저작권 표시, 보증책임이 없다는 표시 및 GPL에 의해 배포된다는 사실 명시</li><li>소프트웨어를 수정하거나 새로운 소프트웨어를 병합(Dynamic linking 포함)시키는 경우 <strong>GPL에 의해 소스 코드 제공</strong></li><li>GPL 소프트웨어를 배포하는 경우, 소스 코드 그 자체를 함께 배포하거나 또는 소스코드를 제공받을 수 있는 방법에 대한 정보를 함께 제공</li></ul><h3 id="GNU-Lesser-GPL-LGPL-2-1"><a href="#GNU-Lesser-GPL-LGPL-2-1" class="headerlink" title="GNU Lesser GPL(LGPL) 2.1"></a><a name="lgpl"></a>GNU Lesser GPL(LGPL) 2.1</h3><p>GPL 라이센스를 사용하기만 해도 소스코드를 공개해야 한다는 부담 때문에 단순한 라이브러리와 모듈로의  링크를 허용한  라이선스이다. 원래는 한정된 라이브러리에만 적용하려는 의도로 ‘Library GPL’이라는 이름을 붙였으나, 모든 라이브러리에  적용된다는 오해를 사 2.1 버전으로 ‘Lesser GPL’로 변경됐다.</p><ul><li>소프트웨어를 배포하는 경우 저작권 표시, 보증책임이 없다는 표시 및 LGPL에 의해 배포된다는 사실 명시</li><li><strong>LGPL Library</strong>의 일부를 수정하는 경우 수정한 Library를 LGPL에 의해 소스코드 공개</li></ul><h3 id="Berkeley-Software-Distribution-BSD-License"><a href="#Berkeley-Software-Distribution-BSD-License" class="headerlink" title="Berkeley Software Distribution(BSD) License"></a><a name="bsd"></a>Berkeley Software Distribution(BSD) License</h3><p>BSD 라이센스는 GPL/LGPL보다 덜 제한적이기 때문에 허용 범위가 넓다. 가장 큰 차이점은 소스코드를 공개하지 않아도 된다는 점이다.</p><ul><li>소프트웨어를 배포하는 경우 저작권 표시, 보증책임이 없다는 표시</li><li>수정 프로그램에 대한 소스 코드의 공개를 요구하지 않기 때문에 <strong>상용 소프트웨어에 무제한 사용가능</strong></li></ul><h3 id="Apache-License"><a href="#Apache-License" class="headerlink" title="Apache License"></a><a name="apache"></a>Apache License</h3><p>아파치 소프트웨어 재단에서 자체적으로 만든 소프트웨어에 대한 라이센스 규정이다.</p><p>아파치 라이센스는 아파치 재단(ASF: Apache Software Foundation)의 모든 소프트웨어에 적용되며 BSD 라이센스와 비슷하여 <strong>소스코드 공개 등의 의무가 발생하지 않는다.</strong> 다만 <strong>“Apache”라는 이름에 대한 상표권을 침해하지 않아야 한다</strong>는 조항이 명시적으로 들어가 있고, 특허권에 관한 내용이 포함되어 BSD 라이센스보다는 좀더 법적으로 완결된 내용을 담고 있다. 특히 <strong>GPL 2.0으로 배포되는 코드와 결합되는 것이 어렵다</strong>는 문제가 었었는데, GPL 3.0에서는 이 문제를 해결하여 아파치 라이센스로 배포되는 코드가 <strong>GPL 3.0으로 배포되는 코드와 결합하는 것이 가능</strong>해졌다.</p><h3 id="Mozilla-Public-License-MPL"><a href="#Mozilla-Public-License-MPL" class="headerlink" title="Mozilla Public License(MPL)"></a><a name="mpl"></a>Mozilla Public License(MPL)</h3><p>MPL은 Netscape 브라우저의 소스코드를 공개하기 위해 개발된 라이센스이다. MPL에서는 링크 등의 여부에 상관없이 원래의 소스코드가 아닌 <strong>새로운 파일에 작성된 소스코드에 대해서는 공개의 의무가 발생하지 않는다.</strong></p><ul><li>소프트웨어를 배포하는 경우 저작권 표시, 보증책임이 없다는 표시 및 MPL에 의해 배포된다는 사실을 명시</li><li><strong>MPL 코드를 수정한 부분은 다시 MPL에 의해 배포</strong></li><li>MPL 코드와 다른 코드를 결합하여 프로그램을 만들 경우 <strong>MPL 코드를 제외한 결합 프로그램에 대한 소스코드는 공개할 필요가 없음</strong></li><li>소스코드를 적절한 형태로 제공하는 경우, 실행파일에 대한 라이센스는 MPL이 아닌 다른 것으로 선택가능</li><li>특허기술이 구현된 프로그램의 경우 관련 사실을 <strong>‘LEGAL’</strong>파일에 기록하여 배포</li></ul><h3 id="MIT-License"><a href="#MIT-License" class="headerlink" title="MIT License"></a><a name="mit"></a>MIT License</h3><p>MIT 라이센스는 미국 매사추세츠공과대학교(MIT)에서 해당 대학 소프트웨어 공학도들을 돕기 위해 개발한 라이센스이다. 라이센스와 저작권 관련 명시만 지켜주면 되는 라이센스이다.</p><ul><li>이 소프트웨어를 누구라도 무상으로 제한없이 취급해도 좋다.</li><li>저자 또는 저작권자는 소프트웨어에 관해서 아무런 책임을 지지 않는다.</li></ul><p>출처 : <a href="http://guswnsxodlf.github.io/software-license" target="_blank">오픈소스 소프트웨어 라이센스의 종류와 제약</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> license </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git - 원격 저장소(Upstream)의 브랜치, Fork해서 로컬에서 사용하기</title>
      <link href="2020/02/git-pull-upstream-branch/"/>
      <url>2020/02/git-pull-upstream-branch/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn-media-1.freecodecamp.org/images/1*TnsFDs-DEye722CrQXjv8w.png" width="650px" /><p>원격 저장소를 fork해서 사용하다보면, 다른 사람의 브랜치가 필요할 때가 있다. </p><p>이제 그 과정을 따라가보자. 현재 원격 저장소를 fork해두고, fork한 저장소를 로컬로 clone한 상황이다.</p><p><img src="http://www.mediafire.com/convkey/07b3/w43ygsnvvax8y90zg.jpg"></p><p>이 상태에선 원격 저장소의 브랜치 목록을 확인할 수 없다. <code>git remote -v</code> 명령어로 깃 저장소를 확인해보면, 로컬 저장소만 가리키고 있다. 따라서 먼저 원격 Upstream 저장소를 가리킬 수 있도록 해야한다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v add upstream http:&#x2F;&#x2F;github.com&#x2F;devandy&#x2F;lectureSearchOrigin.git</span><br></pre></td></tr></table></figure><p>그럼 이제 원격 저장소의 브랜치 목록을 확인할 수 있다.</p><p><img src="http://www.mediafire.com/convkey/ad01/3gdgpupb7ylqy34zg.jpg"></p><p>현재 <code>*</code> 가 있는 곳이 내가 바라보고 있는 브랜치이다. 초록색깔로 표시되는 브랜치가 로컬에 생성된 브랜치인데, 이제 막 clone한 프로젝트여서 아무런 브랜치를 생성하지 않은 상태이다. 원격 저장소의 브랜치는 빨갛게 표시되는데, 앞에 <code>remotes/</code> 로 시작하므로 구분하기 쉽다.</p><p>이제 저기 원격 저장소에서 <code>remotes/origin/search_giyun</code> 이라는 브랜치를 가져다 사용하려고 한다. 이 때 사용하는 명령어는 <code>git checkout -t origin/branch</code> 이다. 이 명령어는 뒤에 작성한 Upstream의 브랜치와 똑같은 이름의 브랜치를 생성하면서 바로 브랜치를 이동하는 명령어이다.</p><p><img src="http://www.mediafire.com/convkey/85ea/e0q5tc4oanwsypyzg.jpg"></p><p><img src="http://www.mediafire.com/convkey/be7d/oqi3od3goac50c4zg.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo에서 Highlight 변경하기</title>
      <link href="2020/01/hexo-code-highlight/"/>
      <url>2020/01/hexo-code-highlight/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1454165205744-3b78555e5572?ixlib=rb-1.2.1&auto=format&fit=crop&w=2100&q=80" width="650px" /><p>블로그를 사용하다가 코드를 문법에 맞춰 가독성있게 표시해주는 코드 하이라이트 테마가 맘에들지 않았다. 처음 설정때부터 Androidstudio 테마를 사용하고 있었는데, 흰 블로그 배경에 다소 어두운 테마가 들어가다보니 이질감도 있고, 별로 가독성이 좋다고 생각하지 않았다. <em>평소에도 가독성 있는 텍스트는 흰 배경에 어두운 글자여야 한다는 생각을 갖고 있다.</em></p><p>알고보니 변경 방법이 어렵지 않아서 왜 이제야 바꿨나 싶다.</p><p>먼저 하이라이트 파일(.styl)을 다운받아야 한다. 그러나 사실 이미 theme 폴더를 확인해보면 수십개의 하이라이트 파일이 있는걸 확인할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;themes&#x2F;hueman&#x2F;source&#x2F;css&#x2F;_highlight</span><br></pre></td></tr></table></figure><p>hexo 블로그 디렉토리에서 위의 경로로 들어가서 맘에 드는 하이라이트 파일을 찾거나 다운받은 하이라이트 파일을 이곳에 넣어둔다.</p><p>그 다음엔 <strong>[themes]</strong> 디렉토리 바로 하위에 있는 <code>_config.yml</code> 파일을 열어보자.</p><p>여기서 cutomize: highlight: 에서 바꾸고자 하는 테마로 수정만 하면된다.</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Customize</span></span><br><span class="line"><span class="attr">customize:</span></span><br><span class="line">    <span class="attr">logo:</span></span><br><span class="line">        <span class="attr">width:</span> <span class="number">180</span></span><br><span class="line">        <span class="attr">height:</span> <span class="number">70</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">images/logo-3.png</span></span><br><span class="line">    <span class="attr">theme_color:</span> <span class="string">&#x27;#ff7f50&#x27;</span> <span class="comment"># coral</span></span><br><span class="line">    <span class="attr">highlight:</span> <span class="string">github</span> <span class="comment"># 여기를 바꾸면 된다.</span></span><br><span class="line">    <span class="attr">sidebar:</span> <span class="string">left</span> </span><br><span class="line">    <span class="attr">thumbnail:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">favicon:</span> <span class="string">images/favicon.jpg</span></span><br><span class="line">    <span class="attr">social_links:</span> </span><br><span class="line">        <span class="attr">linkedin:</span> <span class="string">https://www.linkedin.com/in/youngjinmo/</span></span><br><span class="line">        <span class="attr">github:</span> <span class="string">https://github.com/devyoungjin</span></span><br></pre></td></tr></table></figure><p>어떤 테마로 바꿔야할지 모르겠다면 <a href="https://highlightjs.org/static/demo/">highlight.js</a> 에 들어가서 구경하고 결정하면된다. 각 하이라이트 스타일별 언어가 어떻게 스타일링(?) 되는지 볼 수 있다.</p><p><img src="https://lh3.googleusercontent.com/8E470pZC2wwB-lUz7rk1ZCd-NUeVgcnHLHMfzI-9fwkjFaee9WEJ3mhMkrpnjatmwI78F-RufW2VIU9R_q-YmTLr7TWsApwe4Qinok8xjYg98zFc-YiWL5ZhZUJjs_YpgF96D3H0S_MTQaNEAF5001BtYIf9wCbQLoP2-V7uou9OZmlLY-38qyKUV-ZlZQQmOUoNLro30sH1GAaBI8fkiEJWntU_lb9i8BiWmYwAIHta93AiTLHZ7IRKP2D1JiRYZhAlO0w8F0_F4hwxgT4ZomgKDvTU8NGtVeJwJvWY_IVgu6FBd0GgMGY8Lub-90sTtUH5SddjKR4mJ21qJTzDFA0kaXLgAIeH5c3cQMORsTgdf6Z-F3uA4_TnO-zIv3UX8JTmkEvp9dBkuCbreJ6j1rkv9umo0RhwoNJwmCG8u337-4m5fZLWhGlbwtl7pKfaWcFTgXhtZ5L5KH5Mbc7FQOrTrj03upZbOczfqLhqXjLhFuDiNznJ5Ig565EoymVuqJJagvdJOvcUpcGX75k4Xltcgha22f0d70jl9LNxSD7s1b4r9rIHpn9cUO2xtFF4buG67oph8ahBQwpgpx6A7D9D4Mt3h8Lm6vFoEtqR8A2Y8j7kR7RuUAs4cknw78vTTW3bIwJ8yzDlNrqRsBB4LG_D2oph2DK3_9vUV8G4vpnvAsIuvMHFTx1puJwHu1pqW7ohNRoCvZts99jFbAeHoMKxyXFCxbCG_NS0APTVM9XZUbbAfQ=w1024-h708-no"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Hexo </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>맥에서 5분만에 윈도우 컴퓨터 만들기 (A.k.a AWS)</title>
      <link href="2020/01/window-server-aws/"/>
      <url>2020/01/window-server-aws/</url>
      
        <content type="html"><![CDATA[<img src="https://a0.awsstatic.com/libra-css/images/logos/aws_logo_smile_1200x630.png" width="650px" /><p>한국에서 맥을 사용하는 사람들이라면 누구나 어떻게 윈도우를 사용할지에 대해 고민해봤을 것이다. 맥을 사용하면서 왜 다른 운영체제를 쓰려고 한단 말인가. 우리가 사는 이곳이 <code>한국</code>이기 때문이다. 더 이상 설명하지 않겠다.</p><p>대부분은 부트캠프나 패러럴즈를 이용하리라 생각된다. 그러나 두가지 방식 모두 비용이 발생하거나 맥의 램 또는 하드웨어 용량을 적지않게 차지하는 활동이다. 그리고 무엇보다 간단하지 않다.</p><p>최근에 AWS를 공부하면서 이를 엄청 간단하게 해결할 수 있음을 배워 기록해둔다.</p><p>이를 실행하기 앞서 필요한 준비물(?)이 있다면, <a href="https://www.coupang.com/np/search?component=&q=%EB%A7%A5%EB%B6%81&channel=user">컴퓨터</a>와 <a href="https://aws.amazon.com/ko/premiumsupport/knowledge-center/create-and-activate-aws-account/">AWS 계정</a> 그리고 <a href="https://apps.apple.com/app/microsoft-remote-desktop/id1295203466?mt=12">Microsoft Remote Desktop</a>이다.</p><h3 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h3><ul><li><a href="#create-instance-windowsserver">AWS에서 윈도우서버 인스턴스 생성하기</a></li><li><a href="#run-windows-msapp">Microsoft Remote Desktop으로 윈도우 접속하기</a></li></ul><br><h2 id="AWS에서-윈도우서버-인스턴스-생성하기"><a href="#AWS에서-윈도우서버-인스턴스-생성하기" class="headerlink" title="AWS에서 윈도우서버 인스턴스 생성하기"></a><a name="create-instance-windowsserver"></a>AWS에서 윈도우서버 인스턴스 생성하기</h2><p><a href="https://console.aws.amazon.com/">AWS 콘솔</a>에서 EC2 생성하기</p><p><img src="https://lh3.googleusercontent.com/pOltYRLt8EMsYd89vFbBYOHFjBjqv_nZZPdOUOAysmg4A0P7WfZCdgF1_EVgfCmlpiKR5Y4PpNPCpG6KDUpufHEy8NsidjJLdOlO8zJU5xFhOX4yO8BSFjjbezQGSNZ0TqoohocK3yoxe9rPPPoEmY9yn3MHJtONGzbkhDuVqSmNnHQZh4yawOFAkFu8puBU4ZBdgn_T00D7jB9uiKl1b9VMAKo2XPRaTAORUay3tXrCXxHRMWtl2UDGjnARbGydmun2KwBNRR2ZojgWI6zJnIl9_V1cSEmguYoiB4IdJKV3BPULtrI7j8Hb1rS8nMEmyIwZUTxLoakYnUX9RLQmRZu7F63yN0l0VyqfzX9fOoHOuArEwypImCZmK3NVFJhRAC6mVzymP-V64HN4u7N1HVi1IKRhwSTVapjA17Dpn_icTesjGgAHRwVqFNQyEY_CcAeYeqzuBtrkEhdBjb2cqWkrL_fPOv-hgeTfDps90h_YEq5aCMe_erKJgBJOc6-4gb_-pLo5qhIMmeVaKjdNm05IeHepR7Vh6EyIahhd0mZc_dGyGgEZu32-C-ft5MIoZZlON5Ung6VR_U3_e6e8dkBw_gVqtx0fr8KtVDNC9-CgR4-xXcxln9-e_d-QuC02_Eea5tpMvO-PQvG-blLDT2t7zWUvrQzO3K9kkbqLy6Dppq1Vbdag8F4xJQHFDT72FVRZzp1i7llDaPsWmKIvkJhR8O83rIM0LpeheQlVxoTCQZLmoA=w720-h352-no"></p><p>보안을 위해 이전에 생성해둔 인스턴스의 이름과 ID는 모두 가렸다.</p><p>그 다음 단계에서 인스턴스를 생성하는 AMI로 Microsoft Windows Server를 찾아서 선택한다.</p><p><img src="https://lh3.googleusercontent.com/GEeMUpawTRxW6w1kHRXBhzVLhcMyqE1sLyDZesCE1Abq5daoBJi7iEytEQoQTrzMx7CvHyHp4mShh3-46SGP-WmCuuKdLf-cFGkbMfoaLQNBN3ojEYQLKGyVT-hw0-mhVMAeobFhU0v7Md3zon5CzL_KwZQJX9FBml7_df4AZoOGQjoFBh0GE87SMH_QE-MpkBwWfW1eg359ZkdYz75qwzBtK-ZAw8guZKel7rkRDVKiZ2dsE15h7jM90eV45H4F2YT5PoN7bCdWkGaAac4o7n6YKDsHCkHoAc3kx3xlTQ8I3x6wsVsAo94l7HooCZeIPSyHoB1XIKEvwK8tfW9X96E-F1tsXrJlezWVmaK0xoTvTlPmKpMjVXQ_sKs9CN3CXiDVugA3zdQYNSessl9IJ4tmjBgxz0V3uz2vt1xR2QlpwLQaOeS9is_Bsjc5LlJVNZT46X6x8V1r4YvGDKnQaTALBAyvUVZNmIS8fR7_TKmYebYkZ9okCP9upspM-u7UIRxRXWDfE_04E4v8PUB-N5SbxHuZ1rpv6qlTeoj8iMdXfVbh3oVyJBLiIu89HGCFCpIAIgmd15sJGSotHWG6F9gGRLAjIW8KTWQwpLU7O4yL7nWbqQPANE--RoIHf1csoKUr_zApm8mrYn57TJlb8nWZTHAX7dGRAoF8zTLD_d3AbQKVznDYsx9ZP9zhA91MHFSUYDda8qWc8P6pYCDeblAe-poQMFwwm8rq8Q-AAAEfEHcaJw=w720-h401-no"></p><p>그리고는 디폴트 설정으로 계속 넘어간다. 단계5에서 태그를 추가할 수 있는데, 인스턴스의 이름을 설정할 수 있다. 안해도되는 선택사항이긴 하지만 그냥 알아는 두자.</p><p><img src="https://lh3.googleusercontent.com/FsTQsLJG3jksR6KayqHA8A1KhRYZDt1vyBmqX7awl1KdlKWyZcmKXHHJ7MhBX6acZCpIEFl-wdnjDAelIQxZfbfIkA4qcLLiLKQJB6wTt9YS_9-ApIfSiQZtxrbx6e3b6AEStH1qzoQdblYxg9qsZz47ZwIXZN65CZT9HzEYLl2haWPr10x4xFWycX_hXbzJsPdYA3ncfSaILIhIgbioFiqI6BDMiPvqZkWTBx42fTZYgmE-_paN18U7t0aiiHnbbSRoCT5qeHR8eCakbX6cxY_17yGdNLSX8WJZTXkpRYeB28WohmBpPfPsXk9qZwJPV0fjYfDfAN6YX84sWcF5CqGcQbV6k7wIxzBng05G3D75p9HdtxCkGlM4iUrv1QUQa7antgU-DamI0y4inXOKK7k-vWAGFMcvjksAuI74HGNZbfKC21_tmBqeHx_a7whdfANEGnQRRey_ECmZZw8VjEOF-F2P7KmLx52VWdQhjgBMFPWTXbKOaPh3lzwUxAn_-FkfBr-jkpQ70fvy4hqHGsY4-9R_ZV5segW4Gp2gMeyDihLspjU0vQBXun6OD_4KdaH7qCAAsaA8sRw-x6perSsY77b8MTcEIGDfptiM52lMJjBGj9ca-4v80vk94jtAaNoZZtkuUThCFA53MhP6C5HkQSI1vzay292K2StoshxpIH_WqNiwBLIXMDf_t5rllpL-NRzEDz9A2IpuK2ecP0I7TIn8kz_TlQ23nBH3v7jos5_ucg=w720-h272-no"></p><p>중요한 부분이다.</p><p>인스턴스에 접속할 때 필요한 비밀번호이다. 이 비밀번호는 암기가 불가능할만큼 어려우며, <code>.pem</code> 포맷으로 파일이 저장된다. 해당 파일을 분실하면 다시는 해당 인스턴스를 사용할 수 없게되므로 관리에 철저히 해야한다. <u><strong>유출되어서도, 분실되어서도 안되는 존재이다.</strong></u></p><p><img src="https://lh3.googleusercontent.com/dTS1B7efVcaZdQWdaGc32-aXeu4s5kdL194pQNAl6SnmB3bWygJQ2Mg8iMPAoO22t5y99c3fjIc1897aUuihwS21sGu84MlDccldKqJ7inkJEGGRHemg0lb3ziHH5TA6XLEZyYAFeFmTikHut-PlOqc4JslIJPGr3FxmkAxyc3hF8igswbH__QMZAgJfUc0q9ko7HJ8tPT704RDbWQaCAv8TTOanq0qzj1_nDZ9E4PaEluKS5Ia0FUdRoRKD-mWucN9JidAuIjbvsc5DtY3AwGpIKiF8N8m7EYTZk7gumL_r2LppTZevbJxvFli7slMYPZIXcbcU9beeCyHtgzxwifcROSVeDtrUjyMjTUwyfCcP0opoOPQ0Yc_ZxDs4CGDBhZQg3yw8kIQ2SmyU-2kKdjyn-luytM0FldhoCBuummhXmuhiamAOtzGyzBiDslTnMb3rcsyrn3BBNcxgq415bcgS-YPMXI8vjENEekmOBOUTeMPslIA6gE_FTcN8aiB5Q5K-L-5UrqdCzY2c69WrcwHjQeAfjPkEMnRw76gd9qp8t57StRF3ybbCN84ktRv836WbyLB4m7w2o4S0IOz_O8TmwbkHf4uaWQW4iWYVjxKm0kbK3V5g5del7uYUE1XkYcI244puggcTQA-JMsvlRbmMr8PS5TPF6tFRphP7IS-qLN5OAtsweHqvsDsf0LjSoc0Yl2lKRyDoct-aV0hjV0sa4UX7Q6V-74J5FFH-NglNQhAxXA=w720-h381-no"></p><p>그럼 이제 모든 과정을 마치고, 인스턴스가 생성되었음을 확인할 수 있다.</p><p><img src="https://lh3.googleusercontent.com/2nIwcmenp9XtT3RRmcRxTSIw4YfU_gZTUvnbTK9ZtEmcG6XYHq34cBSL0cW2hajIvtggqqgkIsqK3rye6OyZ2WvNfd_5Qzsi3_9b0jzm5PYVU2o3aHy4rRX0kvN3IFU2oj1zte-VlyjKpLye8LRDkKmJlEVfvztvZfT0AIuiR6tXdzh57x5Wl6hfyn52NyQ4rrJHpfXIxJ20H_rWsijuQ-qln82jv6fHw9aldrC43X_3zrOPdzgeZLOvcHx7LGAoAAwhJSnzwnI_RGcSXSL_WeMlcM12PnpnZRhlIaoEFSsqD3AGzc6nORsmeOEoAQdKXhcd6JfXaFCr4-I45LMASSBFyEPH_sgGtVqN6yTngQ_a3ntE6JMNJAl83pZBE-gHcFfpMORnDE5zQV5o_mYSTOlfW2xA6i6RIkMeRFiOkWwEzu9zahoQUUnGH7JuhW7fpzz6ubfcJknNm8AqxbP28hCUsdJ_Kin1wigKpl7OgsK4NKGmdK64_Xm-WiCfP94Ub-CQdJs-f9Vfjsl24sGzko0QCT1muxVnqjfVIQ4UKtjqtPRgaE7wn9c7dEU0VEuLZCRHvwil-td7t3xThxZXsBxWpdX8qMqt8GcTc9eKL9CxWWUk_HpjmqMjUM7TE22rqHeUuhffwNh1cFdyC0NH-q5lCffkBentCyIzasA2VpoXemqwNTUtdnYw9pOjj4lA0hyYE_Bo-d0lF0dDoZTev1DaMEcPrMAiPymiCQ9nNBHMcDQcXQ=w720-h404-no"></p><br><h2 id="Microsoft-Remote-Desktop으로-윈도우-접속하기"><a href="#Microsoft-Remote-Desktop으로-윈도우-접속하기" class="headerlink" title="Microsoft Remote Desktop으로 윈도우 접속하기"></a><a name="run-windows-msapp"></a>Microsoft Remote Desktop으로 윈도우 접속하기</h2><p>이제 윈도우에 접속해야할 단계이다. 마지막 단계에서 [인스턴스 보기]를 누르거나 <a href="https://console.aws.amazon.com/">EC2 콘솔</a>에 접속하면 방금 생성한 인스턴스를 확인할 수 있다. 여기서 연결을 클릭하자.</p><p><img src="https://lh3.googleusercontent.com/m7sXvUhbn_qMjwAx_ogvvtpWE1vUz1AV3yV77g2MEBpSwNn7a8Nf3vzz5LjKwTWFlgbSFYkvZpfVR37KbK5kVDv1src5T8L-eGsLT5He_6hPalKNoles7lQulYJNPlZ8qnb1mpdiQJfKPNkacTZQlF95De_iAjlItVeWtWXsp_qmDUjEylzhbgsHD2sqZYO4XFNk-UmOrGHIYO_Gy4FWAVxTuGCCu0wMCqoidceDQew8DMERefMY2O1RfMVAg1qgE_6raD4ahthy5hqCxmXfAm8WrlCI_lSXItKSpAGRCm9jEsVl_Tl94ox06bYIMVbfs6zqEydGYI7CC8Jo3aEBx_MiqAgZluUZnWmTtl9LaFntx0CjJw8zFv04gkmc5mXnqBNgNr2E63SjtvJjKijiUDFlrosKf1QTCqNMrYPd1KgevizhWYl2S9KJMhBCCTDx_QgCVX_O_KX6CAfOtOItbo0HNy5NxTY9nHnSMc5QfMNzBN5I1sR6GvfsosUFHcH9v1EejZyQGEFxFO1mPVM7uaDf6yoY_vjF7EeANSK43ySkhu-9WCGYc9slDG_q58VzweiH_DBusiJLFf46iHyArGypVEPCqLQowP8jmw0yDI9rItmQB3sg1WwPsyBybcAEhQ4NY0-1wGgvnUnGJIC8jOjePStuHlq0e1Q38ZW3E7M3TjP1odQ0EOAol_1V4-sQ49qWIjUsV5CVMih4x4MlsjzieE59VguZ2xQ4fobdXtjX-EBA6Q=w720-h371-no"></p><p>여기서 클릭할 수 있는 버튼이 2개가 있는데, 우선 **[암호 가져오기]**를 먼저 클릭하자.</p><p><img src="https://lh3.googleusercontent.com/o18FzDnSIwCoU8v2G3H-3uJCB2OvpbGvc-KIxuaP0vkRA9MmCf9pXIfaXFsrzTLrPvlNCcF5wRoMYNVOYSJ2GREK5yqAe2PVjb82_Q1icoSzWLu7GFbuqIh8NnAbEM17BFaGMyxWOktvGIe8CeFS5_YmldTOHKXfEkS78W4p2V0g-9h-Xm6-W7sfKP_0HlvhPp3W5w3YVhe6KGcUNq0JwKODfPfwAw2N02i4Nr3ilVs7M8E1BBWua-pJSxMuBbPTzPZi_BFvI2UlOom_WIIBiPjFEildixbI7gUE0yQit1zUB-AXkBKGUpzkTq7Rp7VncQEQgD4I2PmnfIXe-6dcDfbiMv3VjL3i8wvz5jkmB8rmvmIQ8n30NWUD3ubckgSE98E86uTYCaM0yC1qqGmtF66jzrKUInBz6CtjwpON_URfUdfNc3XrZ5c_bQ3nI-ZI_BvaDebl54NQEd_2lCpDHavPnflYUz_a1q4ZKmBSQ51sZRNmorLc2L_gpw46Ap8hDLPHzymiJjAfftIuCi7tj72qtnYqQ0yGB3ol-CVRmDf7w9Fhx3Ivj5hDpIcusgwMYecVHlcQecCEr_5ZMpz2icBzXNDl9513Yt7q0EjNB5HC_DYvgb-lWom7kSt_NVcFiN7iLDtDYb5TGafkuas2RDZr9zveb3PKkta5Z3wVmkxrd_5OX7CJG6jl_voXwGk3Fi5k7DnF35yWIE_7JKISRqYsOgO1-g61lkPqYmitXbu1CXegnA=w720-h477-no"></p><p>그럼 아래처럼 넘어가는 것을 볼 수 있다. </p><p><img src="https://lh3.googleusercontent.com/wsZJWh6sQbT080pg0PeWCw-NL8M9ADX10Qz-eWV_00fgvuO700GQBiU6paYwaILZiYqPPadyK2GPqmR_AH7WqvObOmBIyvaJYPyoXe85qSN86rCu9ZU1kOeydcqpQ1Hn_MOyqaE0RMXxZAZU13YvM64O0He4vFSJpyN084yBJ8TwIPDak6ImbzSRew0G15jfWaJT0u1aHy2GcDOm7T9i8zrIQI4HXdlMjRDAGWxFD64C5d_iWl_7IePnZgJX2mYijvxa4RxTlVI8jLx5nr0DVWxUtyneUwDb9-ofdKZEBHziW5KmqVafmkkkJW7LBhUVXJ6S-ZCvML43E-Q3B8iBSzb_5ezaAd8EKzIxjbi6G_HZb4EWbBT95zUgaZzSouPNFusrNySiCGOOszrNrHhwL2Cjbll07Jf1jW1_gi8k4ovGVm0gqZXp5Fi9QEtF94a2tlEdfJn4POFK09aZXctho_q4yFGPb3e8lgBnLiRsqk2O_wCSG7iBxz4kEGQWA9cqmEjRPnsaCSh0YJqKyzlw3gJuzgdegQ3KIf_my_yNnWwkxDe65L9SOGoukvNmbT-iicU1Qz5ZwTizg-9zn4_9rrhhc5kDKSd65He75FAfItviu-mfSfoaAgSDdSe1BoEGzwgfv8gIkBbqQ_3OXBgNqwCsuDWnN7zPtRC_jk-FPevoXuDSEnSWQIdfXtosGzJANCUlyQwjbU0XRDBwQCTrXY_LZbxEL81xeaXh_ERzKW610hNaYw=w720-h488-no"></p><p>접속하려고 하는 인스턴스가 어떤 키페어(<code>.pem</code>)와 연결되었는지 알려주는데, 해당 키페어를 불러와서 암호를 해독한다.</p><p>그럼 짧게 한 줄로 해독이 되는데 물론 이 암호도 간단한 암호는 아니다. 일단 이 암호를 복사해서 클립보드에 저장해둔다. 그리고 위의 <strong>[원격 데스크톱 파일 다운로드]</strong> 를 클릭한다. 그럼 윈도우서버 인스턴스에 접속할 수 있는 파일이 로컬에 저장된다. </p><p><img src="https://lh3.googleusercontent.com/2lGMOh3bqdURpjXu99XlK_NtE1I0Gb7GGhI-Q5309SY_kjHTH6kCBznliMgRCvzr2kDDAaQ9b-z7Wi1WQHJt3vS8CU0v3UqIkLv_kx00TbwFFBcQjbzY4kmOhW99JVuK8gtF5HRnY74IzLHWRA7rWBM5Ok3sgfuDtctZxsvgLogBveJCNy9yrbZJNA0NaOL400HEDTSRre2SuFYDs9bblD5ilwJZlBMrmMm9QMrVAVhAvo8EahbOGOOv5jozOWA2JQwZkdbDRTJp1FiCRchPAdw14zs5SIW5RB2rBtodvfVvhxkL9FP8_l9bbnOpbjArDlUpz0bRGFGa6rc9c3NJAvlBpt04Z8bY7l44SGmneqGjgwJzRUKs7CAfUCizVHpPlXUQIuECLWm1hLXRwPCgU-vBnOmQxY71r96YTQENX0gHv3elCtFg50E4mvPLrKQm5obBMfeLES2XlfwraoKMTR8STtt837V93UseqQxmcReUFSHLRoSwf_SjyrFDlN6_eB4Mh178RFKeT8i_MMccMo2fh2FSsdTPGC7DeP_BQ_44NdWtZ3QbAc7VZwkdCTFGIbdTSjrHTAVNH9ijxgAMtclifxBpoGyKDdVcz7YF5bEri_5WCm5nvabPRT1Uh7J8agj8rB3E6YlT3UuEIZg0ow2V_elCVLhBswXwM4V8XwIZCOFQUALdLhSPEytLAYVB6QoUD4Y_RYON8Ejm0JC4qGqqvh8h3uvYh3lXHCyfxVp6GB748g=w720-h342-no"> </p><p>그리고 설치된 파일을 실행하면 아까 해독한 암호를 입력하라는 창이 출력된다. 클립보드에 저장해둔 암호를 붙여넣기 한다.</p><p><img src="https://lh3.googleusercontent.com/_n33h3GaFdNKKEa4i9TbrxxD1HEfewj2VFmSrRNH3clE6E-V56Ged-zzTRJLFcy6xY7YG2Ag3Op8oUo6rFlSc3__MrgM1ixSEGzWDe-IbqDI0NnmxB-M4QN9kr7hOSkEiWC-dif7wCgpsHhMimYo0E2gkXmG3WYln0V9jNqkUTkmyrvWyWnbeEXBz3HufAdKf4hAs2qgKrcA5brYvFPkYSSAjlClahuR8lMmJquixDuI18Q6SM1Ay2cPprzk8Bn28Q28_OIlv6MdrqsAfOCQsSrpiNP8DVzIA1pgehH-xnsqTz2_4pnpe38glfqh4znF8sotQ2coahhqKj5QfIU12hKntmKWsSOfcKcX9eHvxEkryttuSrPc3TfSg__FNtF8a6d5f0CmePY9gWyFDSdlij9eqT_z_7H9P6MGzbV1R6Aq0eZXeIHTnCbqIppcH9OFl_3jKu0s5IXkXt6fo2InPfaXyfBpg8cGIUnmg14yjdEJsZY_U6JUT9RArulD7aPCNdA3Zj3CABYLCz2rThWRD0uMsBQ6ZzwObWyZSEm-zsd0TCOxWHtu0aTOYQwfxLvQFTvCWfouKlq0iZOuNB6HfK7BwZyvLk2XhxqWYSRgU5ECFkldv5CdzqySFFJPQxUD2f10I_RAEj0XE_GbdHgcpUj1DGWmp-h90WNFFqAyH47pdkt9ZsaGf8bjlky_LMCvEwPoplKSnghq5y22iKpCQPPi7QyFl-Kqy83ufiIT0Pw23baXVA=w720-h353-no"></p><p>끝! 이걸로 맥에서 순식간에 윈도우 컴퓨터를 생성해냈다. </p><p><img src="https://lh3.googleusercontent.com/4JMe2_KmgY0l0tUtsTlKVVcIS2Nyg_EKZKcXax1OsA5DlUfc5_dKcGC6jd2Jiv8xNS4V-Ctf9aU0Vlemc_ubU3wlUwYge5KQKXYtDkrhAtkyoc-CnGeprQZRIgugwf9i-e36-NAzWspWvb_NQUf5g7OraYdpcH493-ZuKjjaef_a2xMj83q_QJf83h_fT1Gf-Khgf2o5AhqG0_kcVbC95fiyx4XfA7uLQOMxYYilzB7KE4Ee9Ir0gdKH5aQE-xJ_FzvjFo--vS9wmvdrdNx5P35um4B_ILzAMExvTsnFghYM5MF92E8P2iVFp_CPjhTmaNeGOOHSrERMqHZNpRSbD46-05Oe3BTNuP-5_9i_rcs5keDikl5VwjvLdOcGiQ4tIAoQdMwCrmEu-9eCvrY32qQCaiftCJdG2iYTWVO5vNLp4Oe403Jj5A1nZwX6xxNuXD2WibdEjN5ddIvE1G53x8dRQsjLxXs7nceenNCHi_5iZLj5b-oHaofxdcsdTRtgQzcpnZaK603tudDfVDzqyfz-qk93k03mPfT01Yz9dp4tRMaFBPwPiQIk0vh6IDmKeRhnqd9KDLCpQC6NY2j_-JqDV_4_GTCAJ0UmocW1jktLe_Ywz8teKVvfgCQQduLnBNwqzRjRtlTZqrV1Ev5sB5x2s6jNqI7uao9z5T3L0M91mXz8k4VA7LddUixcPlMzqZBEb4zVJkiRa0SxK-Ekc2UqXfhLi-ltyWEf1Eaw-XQxXNVfpg=w720-h381-no"></p><p>맥 사용자가 윈도우가 필요한 순간은 아마도 공인인증서가 필요한 상황이 아닐까 싶다. 이 실습은 AWS라는 클라우드 컴퓨팅환경에서 이뤄졌으므로 여기에서 금융거래를 하는 건 위험한 행동이 아닐까 싶다. 그러므로 필요한 최소한의 활동만 하고, 만약 금융거래를 했다면, 반드시 인스턴스를 종료하고 삭제하도록 하자.</p><br><h3 id="별책-IE-Enhanced-Security-Config-해제하기"><a href="#별책-IE-Enhanced-Security-Config-해제하기" class="headerlink" title="별책. IE Enhanced Security Config 해제하기"></a>별책. IE Enhanced Security Config 해제하기</h3><p>윈도우 메뉴에서 [Server Manager] 에 접속한 뒤, [Local Server]에 들어가서 IE Enhanced Security Configuration을 on에서 off로 바꿔두면, 보안은 위험해지지만 IE 웹서핑시 더 이상 경고문고를 받아보지 않아도 된다. 보안과 편의를 맞바꾸는 딜이지만, 사실 2020년에 아직도 IE를 이용하는 것 자체가 이미 위험한 액션이긴 하다. (<em><a href="https://support.microsoft.com/en-us/help/4488955/support-ending-for-internet-explorer-10">MS는 IE10의 보안 업데이트를 2020년 1월 종료한다고 발표했다.</a></em>)</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> aws </tag>
            
            <tag> cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git에서 변경사항 단위(Hunk)로 스테이징하기</title>
      <link href="2020/01/git-add-p/"/>
      <url>2020/01/git-add-p/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1517650862521-d580d5348145?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2100&q=80" width="650px" /><p>위에서 작성된 스테이징 방식(<code>git add file</code>)이 파일 단위라면, 여기서 언급되는 스테이징 방식은 작업의 변경사항 단위로 스테이징하는 방법이다.</p><p>하나의 파일 안에서도 변경한 부분이 몇 가지가 될 수 있는데, 이 때 <code>git add file</code> 을 사용하면 파일이 통째로 스테이징된다. 그러나 <code>git add -p</code> 를 사용하면 <strong><u>변경사항 단위로만 스테이징</u></strong> 할 수 있다. 더 편하고 더 분명하게 버전관리 할 수 있다고 생각된다.</p><p>이 때의 변경사항 단위를 <strong>Hunk</strong>라고 한다.</p><p>test 폴더를 만들어서 실습을 해보았다.</p><p>생성한 파일(test.html)에 세 줄의 코드를 추가하고, Hunk 명령어를 입력하였다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add -p</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/nOsWLkb4d1cDxvd62YTU_k71_OJRwiiXYgItZ_xQJPXHMPGHUMtXT1TaSMN0DGK_YfnzfPuqLk9n8hCdH9UBY4knvRbldaOh2KiPcg8vCJQH7KzuODPwfKojcR3OABe83KdW9ralyr0EWLmapKfAxib8Y-qRTQxz--VqdNDuCgJpMPf-hD2kCBwzK5YITWEp80LEijQpbUhPqpWZmploBXtcA1tGqebeoFSQwuqkOnyHIh4xvn47BPJWJqIMS0BcOxFFhuP1OrQyvOkqL2FHXRS0gFKMs0of7D7aU00mKPVW8ABPb46TOMzZuHVfNRG2hmndTWzIsCZStEc3z3UTAIAdh2QzzZ4TbEmzOGXRZWKHKwHfkg6Qzsjktn-M7_RGtonRDKAuey_hQi0pW55Pxjq8gv10vFws-oKzEJrC2aA4mebdx3Rdoe6JzZ5sWJSSY50Jh0J2-mYuB4c7qw9ruGL1gRuO-vwrpG3a4QHn7-KqsP9nUaFCYYf1Ejcx_GrJYpuW5smq4vUYssQxsP9zb9pqAteUf5_ob4oCsQgGFhLulzVfFlpmsb1K3AaGKTI5ErZomdsSfhnT3Yqju8mGgn6bVItQT59ACegt-CHeB8Pa6uS0EgdsZXwe-72IgnZYHfQMplcAZ1Kdj-lwckGYItDMaPRRmdBk9iuxRR0PNalivmv0SzYYvfSTJJEolEMAb8jCfbstMaUjGL4uI2dC9KofzqvOpB3S6CFt4rx6Fl9Hkh3P5A=w720-h489-no"></p><p>여기서 <code>s</code> 는 split을 의미한다. 세 줄을 한 꺼번에 스테이징하기 보다 더 세분화해서 스테이징하기 위해 split을 하는거다. split을 한 결과는 다음과 같다. <code>git add -p</code> 에서 응답할 수 있는 명령어는 <a href="#commands">아래</a> 정리해두었다.</p><p><img src="https://lh3.googleusercontent.com/KQzWbcfyFdb7qvH4rUYjmL8s2NNSrph-oPVYIOUiVmkBP1ERRqMPy53w0X1AXzbtcIt79H-uiNHftCrcf6z79Zhi9RqN0jb0Qa8w1rR2wQ76Is9HFMrl0mELyBz-AV2wVPk0yFSvOLuPV5HUyG4-HJmKqLq73yMW6s3hY959DrpkgZCC-BAaW5rU0fVvVWZZcgxBSK-ItoUYTQ_-m8Y1lEKE3q7XfFufwik6sqz2qeGRwg6cwXUVhcmHh6HpqlLwJEqsq4__KcuXgJrCNiev6cm6b45Dz2BBCQFx9sxl4es1vyoerosQEqbn2HDqop03OU_umWdFiU4p_H-hYqKbggr8i_QnMLIgLeKZyvoSf3SN0_fiwMRm79YbYzoimXbc8IXZadfBvRrH_8azJxyQ0UVo9aiVy6dKlOe8YOLUR66Ks7arDS-NrHur-65kbxf7FnG3pGGAa_f8YqYJahGkGjqL88aLHOKWo_OPYUCCJ_H7aAU3P_xYE27AmfTYyhp7Ef5QlGyWxtUr151Uz5paLhRgFokveUFrxIBqbcVW9U5DQsdZwVLlhh7JspUXfsJddcfJUh2fVH25BNizW1D4nogEvd7GU6ayUWn8nE7dTXKYzLodJTdB8glSOIxlKE3kU5yml0UOpolWw-zLKKnwT0z6PX6y2hJwpLtcQTwsB0odO5QDov9fnSiI9PxDo4oFou3rNBme1nkLnrxXQ89rquVp1iiX49M8MO-lVLbnieGVcBRDog=w720-h572-no"></p><p>하나의 hunk가 3개의 hunk로 쪼개져서 각각 스테이징 할 수 있었다. 세 줄의 코드중 마지막 줄 코드만 스테이징 하지 않기로 했다.</p><p><img src="https://lh3.googleusercontent.com/ITFznygeA3KQNMX61PfMxOAAUu5pNO2vnwE_J83_oWu2nxoS80Aqm3JmQbaDCMNhoty_NFfGt88z2R0R05CFBbRsxfG9yLZP-GtvfltkE41BtIaMSOEsBLmrYIrW5Z2HGGcdHyqq2HtL-j53X7Kv7jeTiClJ3-L88oN4Hg17A6iXRSbGhjtm8Dv3CrZg_qOQL1iqadjribOmDlrogB4Tg_UPvQwTciNK29ITjfh5sltU1IkO-GFVmSV8PwuDLpdRmGwJQ4BGQzjGMPhDxnMNOoJLoNbNOqQd0L1QvBGP6xg83tX-PgtADpa0T3T-hzv0HZwEp6oCuyxGjs0QQcqR-fTbCo2wnlhWe1Lyg6JydTMzIi5DJvyrvkuqQ5qERSPzNKhULlLaHMxwUMCsXqPDOZhDm4PS7WSb8sM6tZsY3s_dc8Hvyro884QasSWEdO9HUj1-saiENzDuoiDsKL3npc9kGP2j8-ntzL9DGm4BuWNPAtumN7VPFqrxPpVSnaD_vqD8X9vcs-mAee9zESeDBKmAQ_vKdIApQOGzxTYF_YIti31AkuC9YQH0v74RAoDcU0-J86D4rYyt5DXu54LNA42lTfqUAXLsN1DnBCsqEsTX2wNGlihPELVDexwHckf-qk1iTfhWLAoAmQ_9NrNAmbyjwRDrzJKn4gEE5HfKABQ6TdsU8jRn-fvZrk08hFfGxm7UEGcMCRVorVVndo2X5VkWkv2ovtHrrqxKEIGN3Ki69RYnOg=w720-h337-no"></p><p>다시 <code>git add -p</code> 을 입력해보니 아까 스테이징 하지 않은 한 줄의 코드만 스테이지 여부를 묻고, 나머지 코드는 스테이징 되었음을 확인할 수 있었다. </p><p>이처럼 <code>git add -p</code> 를 사용하면, <mark><b>변경사항 단위</b>로 더 세분화해서 스테이징 하는 것이 가능하다.</mark></p><p><code>git add -p</code> 에서 응답할 수 있는 명령어는 <code>?</code> 을 입력하면 볼 수 있는데, 다음과 같다.</p><p><a name="commands"></a><img src="https://lh3.googleusercontent.com/EZaWDiERwWHC0b9Y26t-iuMtBSjLtEmADt0p_a1950PDQwH17gLUsKtwQ86NrBgg7MZdhcLzMPn62pgebHj1c6zCGpJ2-t2Xn4Oyn8z_7HLCu_COp-bgiMWljOA1MfEetjide4LHMV8TO7f-NSzyT1GVvedWRjbCzSP2rgB80U99QUgcWvKThEYQsRvnR-OgnwWm0mKrdDfoaKSoEGIAPKfKjO0JSnoZshpz9-XWneVad0QzIUJIuvxWp71El8mweBQpk8jaf5YZVtYaVNCm-JmIUehi7V7Oaxpe0qAtHB55TSpkQ_UuQ9D5aqsWSTLhHrwtR42EptGdQ5j7jdf7HtYqAKK5bGB4bBlFhOcMiWhi6wAVkEj16-PZP71szp7bKDLxZgGBTDB75KGGQuK0T7L7sUGXqLz8KRzI5z5MtlVFNx_2w-JuDMCMcKBwc6ko_17Aj_bqjLWesfODFUBwyVX9g7PLfLngt4HUYhjYk67mw0o5GvP9o0_FFFX41Ov1yg3g3JEU6uxGGYcGkb6J0ZYQIzsSQ6VY6Ozw4AT2ylVYpcN9vB9b_mCEJGdIP-h960akfLQb1LIDfh3WvamC3HESsxB3uB8IDTw-XgzaIyiM_IV1m2YcfEjHgareU9GLdDqFLEJ5poysw9EmRZFNbL61vfyJsx_idxBfY8llBhecQdk8lmvppfNLEbKLTjKyD3nHJP58B3qZD4Ub6Nvf0N2ZlkXyxo0mOz2l0KWfx1CUdIkaBg=w1440-h366-no"></p><p>주로 쓰이는 명령어는 <code>y</code>, <code>n</code>, <code>q</code> 이다.</p><p><code>y</code> : 해당 hunk를 스테이징한다.</p><p><code>n</code> : 스테이징하지않고 건너뛴다.</p><p><code>q</code> : add 과정을 종료한다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 상태코드</title>
      <link href="2020/01/http-codes/"/>
      <url>2020/01/http-codes/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/SWgcgkpXv5_VtZumsognz31yfOvIWOzzsCGaT8idHl7fGmAE0rHpuGxaTirmxX0oWNQGj2Dho8F80cVMC9VxVN0KbeT0B-nI8zkDAMkD748kf95mRc2e-e1GYGCAFQaca0IV8daRsYYFpowZu6fVOiGOJGuMKeVWwBXP4H_bvMI0HhEHVlq2tYPIHDi9CNKdt6DlSJ_zTEG2uZqYEJRKTnD4ZLuva4n-NIHlmZVJ_JNCURxCk5u2KqPzknKt9sx2ybZZkIDqbTPhb5s9rZikA8Gl18Kyt4WMQWHy21eBGUTNGr6SFrCb07wnHEzl2LwuCqL6LyXPJ87HIYu6HUw8PDkfcrhQ-TnyZP2PB7X8uE7g5ylcVvgpyNxaSq0qPpOaNfAc2BLnaBIwdBG6U4MKgff0T6yygMSWWcQ5BK-16c_NKrvEMVqqxqHoLkq90HeF9UT_WCBq-v_FieSl2pcOHA3xsM8VT3s-DR1n8EbExDqKTgKuTWZqMdtRV_LyrBXLIspDIp0yD4guzH4mNsuL9sixV4P8NDB9p2OxKNuvVDZ77UKPsxwGQdacuTz_3Ylc6IecfxkY01wx3kz3U8m5exeY4_GgI19BkTk-Z-9HOCqFzUDP7mzN7MGvfS-XD4FIaMrWauYH7ZySjayTVf2VyuvkbeUU7JTgtxrMpniogtWq4WXnuA2rNFg60ZUnT4wryoA_tQcymnTbr7s3XkzeAEQEzz8Z4z3KxfkA5ncn53NDa89ORg=w550-h381-no" width="500px"/><p>현재 진행중인 프로젝트를 하다가 <a href="https://github.com/youngjinmo/TIL/blob/master/server-side/spring/spring-boot.md#error">에러페이지</a>를 다루는 과정에서 한 번 정리해볼 필요가 있을것 같아서 작성하게되었다.</p><h3 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h3><details>  <summary><a href="#information">1xx</a></summary>  <ul>    <li><a href="#100">100</a></li>    <li><a href="#101">101</a></li>    <li><a href="#102">102</a></li>  </ul></details><details>  <summary><a href="#success">2xx</a></summary>  <ul>    <li><a href="#200">200</a></li>    <li><a href="#201">201</a></li>    <li><a href="#202">202</a></li>    <li><a href="#204">204</a></li>  </ul></details><details>  <summary><a href="#redirection">3xx</a></summary>  <ul>    <li><a href="#301">301</a></li>    <li><a href="#302">302</a></li>    <li><a href="#304">304</a></li>  </ul></details><details>  <summary><a href="#client-error">4xx</a></summary>  <ul>    <li><a href="#400">400</a></li>    <li><a href="#401">401</a></li>    <li><a href="#403">403</a></li>    <li><a href="#404">404</a></li>    <li><a href="#405">405</a></li>    <li><a href="#406">406</a></li>    <li><a href="#409">409</a></li>    <li><a href="#429">429</a></li>  </ul></details><details>  <summary><a href="#server-error">5xx</a></summary>  <ul>    <li><a href="#500">500</a></li>    <li><a href="#502">502</a></li>    <li><a href="#503">503</a></li>    <li><a href="#504">504</a></li>  </ul></details><br><hr><br><h2 id="1xx-정보응답-Information-Responses"><a href="#1xx-정보응답-Information-Responses" class="headerlink" title="1xx - 정보응답 (Information Responses)"></a><a name="information"></a>1xx - 정보응답 (Information Responses)</h2><ul><li><h3 id="100-Continue"><a href="#100-Continue" class="headerlink" title="100 : Continue"></a><a name="100"></a>100 : Continue</h3><ul><li>진행중임을 나타내는 응답코드이며, 지금까지 상태가 OK임을 의미.</li><li>클라이언트가 계속 요청하거나 이미 요청을 완료한 경우에 무시해도 되는 것을 알려준다.</li></ul></li><li><h3 id="101-Switching-Protocol"><a href="#101-Switching-Protocol" class="headerlink" title="101 : Switching Protocol"></a><a name="101"></a>101 : Switching Protocol</h3><ul><li>클라이언트가 보낸 업그레이드 요청 헤더에 대한 응답으로 보내진다.</li><li>서버에서 프로토콜을 변경할 것임을 알려준다.</li></ul></li><li><h3 id="102-Processing-WebDAV"><a href="#102-Processing-WebDAV" class="headerlink" title="102 : Processing (WebDAV)"></a><a name="102"></a>102 : Processing (WebDAV)</h3><ul><li>서버가 요청을 수신하였으며 이를 처리하고 있지만, 아직 제대로된 응답을 알려줄 수 없는 상태임을 알려준다.</li></ul></li></ul><br><h2 id="2xx-성공응답-Successful-Responses"><a href="#2xx-성공응답-Successful-Responses" class="headerlink" title="2xx - 성공응답 (Successful Responses)"></a><a name="success"></a>2xx - 성공응답 (Successful Responses)</h2><ul><li><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 : OK"></a><a name="200"></a>200 : OK</h3><ul><li>요청이 성공적으로 되었음을 나타내는 응답코드. HTTP 메서드에 따라 무엇을 성공했는지 의미가 달라진다.<ul><li><code>GET</code> : 리소스를 불러와서 메세지 바디에 전송</li><li><code>HEAD</code> : 개체 헤더가 메세지 바디에 존재</li><li><code>PUT</code> or <code>POST</code> : 수행 결과에 대한 리소스가 메세지 바디에 전송</li><li><code>TRACE</code> : 메세지 바디는 서버에서 수신한 요청 메세지를 포함</li></ul></li></ul></li><li><h3 id="201-Created"><a href="#201-Created" class="headerlink" title="201 : Created"></a><a name="201"></a>201 : Created</h3><ul><li>요청이 성공적이었으며, 그 결과로 새로운 리소스가 생성.</li><li>일반적으로 <code>POST</code> 요청 또는 일부 <code>PUT</code> 요청 이후에 따라온다.</li></ul></li><li><h3 id="202-Accepted"><a href="#202-Accepted" class="headerlink" title="202 : Accepted"></a><a name="202"></a>202 : Accepted</h3><ul><li>요청을 수신하였지만 그에 응하여 행동할 수 없다.</li><li>이 응답은 요청 처리에 대한 결과를 이후에 HTTP로 비동기 응답을 보내는 것에 대해서 명확하게 명시하지 않는다.</li><li>다른 프로세스에서 처리 또는 서버가 요청을 다루고 있거나 배치 프로세스를 하고 있는 경우를 위해 만들어졌다.</li></ul></li><li><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 : No Content"></a><a name="204"></a>204 : No Content</h3><ul><li>요청에 대해서 보내줄 수 있는 <u>컨텐츠가 없지만, 헤더는 의미있을 수 있다.</u></li><li><code>user-agent</code>는 리소스가 캐시된 헤더를 새로운 것으로 업데이트할 수 있다.</li></ul></li></ul><br><h2 id="3xx-리다이렉션-메시지-Redirection-Message"><a href="#3xx-리다이렉션-메시지-Redirection-Message" class="headerlink" title="3xx - 리다이렉션 메시지 (Redirection Message)"></a><a name="redirection"></a>3xx - 리다이렉션 메시지 (Redirection Message)</h2><ul><li><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 : Moved Permanently"></a><a name="301"></a>301 : Moved Permanently</h3><ul><li>이 응답 코드는 요청한 리소스의 <u>URI가 변경</u>되었음을 의미한다.</li><li>새로운 URI가 응답에서 주어질 수 있다.</li></ul></li><li><h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 : Found"></a><a name="302"></a>302 : Found</h3><ul><li>클라이언트가 요청한 리소스가 헤더에 주어진 URL로 일시적으로 이동되었음을 가리키는 상태코드이다.</li><li><a href="#301">301</a>과 다른 점은 302 상태코드는 검색엔진에서 페이지랭킹 또는 링크에 대한 점수를 새로운 URL로 옮기지 않고, 기존의 URL을 그대로 유지한다는 점이다. 즉 기존의 URL로 페이지랭킹 점수를 유지하면서도 컨텐츠만 새로운 URL에서 조회되도록 할 때 302 리다이렉트를 사용할 수 있다.</li><li><a href="https://nsinc.tistory.com/168">참고 포스트</a> </li></ul></li><li><h3 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 : Not Modified"></a><a name="304"></a>304 : Not Modified</h3><ul><li>캐시를 목적으로 사용된다.</li><li>클라이언트에게 응답이 수정되지 않았음을 알려주며, 그래서 클라이언트는 계속해서 응답의 캐시된 버전을 사용할 수 있다.</li></ul></li></ul><br><h2 id="4xx-클라이언트-에러응답-Client-Error-Responses"><a href="#4xx-클라이언트-에러응답-Client-Error-Responses" class="headerlink" title="4xx - 클라이언트 에러응답(Client Error Responses)"></a><a name="client-error"></a>4xx - 클라이언트 에러응답(Client Error Responses)</h2><ul><li><h3 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 : Bad Request"></a><a name="400"></a>400 : Bad Request</h3><ul><li><u>잘못된 문법</u>으로 인하여 서버가 요청을 이해할 수 없음을 의미한다.</li><li>따라서 서버가 클라이언트가 누구인지를 모르는 상태이다.</li></ul></li><li><h3 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 : Unauthorized"></a><a name="401"></a>401 : Unauthorized</h3><ul><li><u>비인증(unauthorized)</u>을 의미한다. 클라이언트는 요청한 응답을 받기 위해서 반드시 스스로를 인증해야한다.</li></ul></li><li><h3 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 : Forbidden"></a><a name="403"></a>403 : Forbidden</h3><ul><li>클라이언트가 컨텐츠에 <u>접근할 권리가 없음</u>을 의미한다.</li><li>401과 다른 점은 서버가 클라이언트가 누구인지는 알고 있다는 점이다.</li></ul></li><li><h3 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 : Not Found"></a><a name="404"></a>404 : Not Found</h3><ul><li>서버는 <u>요청받은 리소스를 찾을 수 없다.</u></li><li>브라우저에서 알려지지 않은 URL을 의미한다.</li><li>서버는 인증받지 않은 클라이언트로부터 리소스를 숨기기위하여 403대신 404을 응답할 수도 있다.</li></ul></li><li><h3 id="405-Method-Not-Allowed"><a href="#405-Method-Not-Allowed" class="headerlink" title="405 : Method Not Allowed"></a><a name="405"></a>405 : Method Not Allowed</h3><ul><li><u>요청한 메서드는 서버에서 알고있지만, 제거되어서 더이상 사용할 수 없음</u>을 의미한다.</li><li>필수적인 메서드인 <code>GET</code>과 <code>HEAD</code>는 제거될 수 없으며 이 에러 코드를 리턴할 수 없다.</li></ul></li><li><h3 id="406-Not-Acceptable"><a href="#406-Not-Acceptable" class="headerlink" title="406 : Not Acceptable"></a><a name="406"></a>406 : Not Acceptable</h3><ul><li>이 응답은 서버가 서버 주도 컨텐츠 협상을 수행한 이후, <u>사용자 에이전트에서 정해준 규격에 따른 어떠한 컨텐츠도 찾지 않았을때</u>, 웹서버가 보낸다.</li></ul></li><li><h3 id="409-Conflict"><a href="#409-Conflict" class="headerlink" title="409 : Conflict"></a><a name="409"></a>409 : Conflict</h3><ul><li><u>요청이 현재 서버의 상태와 충돌</u>될 때 보내진다.</li></ul></li><li><h3 id="429-Too-Many-Requests"><a href="#429-Too-Many-Requests" class="headerlink" title="429 : Too Many Requests"></a><a name="429"></a>429 : Too Many Requests</h3><ul><li>사용자가 지정된 시간에 너무 많은 요청을 보냈을 때 응답된다.</li></ul></li></ul><br><h2 id="5xx-서버-에러응답-Server-Error-Responses"><a href="#5xx-서버-에러응답-Server-Error-Responses" class="headerlink" title="5xx - 서버 에러응답 (Server Error Responses)"></a><a name="server-error"></a>5xx - 서버 에러응답 (Server Error Responses)</h2><ul><li><h3 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 : Internal Server Error"></a><a name="500"></a>500 : Internal Server Error</h3><ul><li><u>서버가 처리방법을 모르는 상황</u>을 의미한다.</li></ul></li><li><h3 id="502-Not-Implemented"><a href="#502-Not-Implemented" class="headerlink" title="502 : Not Implemented"></a><a name="502"></a>502 : Not Implemented</h3><ul><li>서버에서 지원되지 않아서 처리할 수 없는 상태이다.</li><li>서버가 지원해야 하는 유일한 방법은 <code>GET</code>과 <code>HEAD</code>이다. </li><li>이 코드는 반환하면 안된다.</li></ul></li><li><h3 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 : Service Unavailable"></a><a name="503"></a>503 : Service Unavailable</h3><ul><li>서버가 요청을 처리할 준비가 되지 않았을 때 응답된다.</li><li>일반적으로 유지보수를 위해 서버 작동이 중단되거나 과부하가 걸렸을때 응답된다.</li><li>이 때는 사용자 친화적인 페이지를 전송시켜서 어떠한 이유로 <code>503</code> 상태인지를 설명해야한다.</li><li>이 응답은 임시조건에 사용되어야 하며, 일시적인 조건 응답을 캐시하지 않아야 하므로 이 응답과 함께 전송되는 캐싱 관련 헤더에 대해서도 주의해야한다.</li></ul></li><li><h3 id="504-Gateway-Timeout"><a href="#504-Gateway-Timeout" class="headerlink" title="504 : Gateway Timeout"></a><a name="504"></a>504 : Gateway Timeout</h3><ul><li>이 오류 응답은 서버가 게이트웨이 역할을 하고 있으며 적시에 응답을 받을 수 없을때 주어진다.</li></ul></li></ul><br><hr><p>출처 : MDN - HTTP 상태 코드(<a href="https://developer.mozilla.org/ko/docs/Web/HTTP/Status">https://developer.mozilla.org/ko/docs/Web/HTTP/Status</a>)</p><p><a href="https://www.kahena.com/wp-content/uploads/2013/12/seos-guide-to-http-status-codes.gif">https://www.kahena.com/wp-content/uploads/2013/12/seos-guide-to-http-status-codes.gif</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>정규표현식(Reg)</title>
      <link href="2020/01/reg/"/>
      <url>2020/01/reg/</url>
      
        <content type="html"><![CDATA[<img src="https://camo.githubusercontent.com/8cc5696b910ded5d34286c50716cfab36e2ebb0d/687474703a2f2f322e62702e626c6f6773706f742e636f6d2f2d2d7438363079735a4745382f5556725741366e4f334c492f41414141414141414176672f396f61446d596d4434466f2f73313630302f726567756c61722d65787072657373696f6e732d63686561742d73686565742e706e67" width="650px" alt="출처 : https://github.com/aloverso/SoftwareSystems/wiki/Deep-Dive-Haley-Grep,-Sed,-Awk"/><h1 id="정규표현식"><a href="#정규표현식" class="headerlink" title="정규표현식"></a>정규표현식</h1><p><a href="https://programmers.co.kr/learn/courses/11/">프로그래머스 정규표현식</a> 강의를 들으면서 작성한 노트이다. 강의는 파이썬으로 진행되었다.</p><h2 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h2><ul><li><a href="#digit-single">숫자 대표문자 (한 글자만)</a></li><li><a href="#word-single">글자 대표문자 (한 글자만)</a></li><li><a href="#multiple">문자 여러개</a></li><li><a href="#atleast-one">0개 이상</a></li><li><a href="#isExist">x가 있을수도 있고, 없을 수도 있고</a></li><li><a href="#isExist-multiple">x 또는 y가 있을수도 있고, 없을 수도 있고</a></li><li><a href="#select-word-by-specific-number">특정 글자 수의 문자만 조회</a></li><li><a href="#select-word-by-numbers">글자 수 조건 추가하여 문자 조회</a></li><li><a href="#select-specific-word">특정 문자만 조회</a></li><li><a href="#select-all-small-alphabets">소문자 알파벳 전체를 조회하기</a></li><li><a href="#select-korean">한글단어 조회</a></li><li><a href="#select-other-words">기타 대표문자</a></li><li><a href="#java">자바 정규표현식</a></li></ul><hr><h3 id="숫자-대표문자-한-글자만"><a href="#숫자-대표문자-한-글자만" class="headerlink" title="숫자 대표문자 (한 글자만)"></a><a name="digit-single"></a>숫자 대표문자 (한 글자만)</h3><ul><li><code>\d</code> : 숫자를 대표하는 정규표현식 (d:digit)</li></ul><p>강의에서 계속 아래의 예제코드를 사용하게 된다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">regex = <span class="string">r&#x27;\d&#x27;</span></span><br><span class="line"></span><br><span class="line">search_target = <span class="string">&#x27;&#x27;&#x27;Luke Skywarker 02-123-4567 luke@daum.net</span></span><br><span class="line"><span class="string">다스베이더 070-9999-9999 darth_vader@gmail.com</span></span><br><span class="line"><span class="string">princess leia 010 2454 3457 leia@gmail.com&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">result = re.findall(regex, search_target)</span><br><span class="line">print(<span class="string">&quot;\n&quot;</span>.join(result))</span><br></pre></td></tr></table></figure><p><strong>출력결과</strong></p><img src="https://www.mediafire.com/convkey/659e/j9cufdbg9cq9wyczg.jpg" style="zoom:50%;" /><p><code>result</code> 라는 변수가 print 함수에 의해 출력되었는데, <code>result</code> 함수를 뜯어보면, <code>search_target</code> 에서 <code>regex</code> 가 일치하는 부분만 뽑아서 한글자씩 저장이 된거다.</p><p>여기서 내가 작성한건 <code>regex</code> 변수 정의하는 부분에서 <code>\d</code> 를 채워넣었다. 여기서 <code>\d</code> 는 숫자(digit)를 대표하는 정규표현식이라고 한다.</p><hr><h3 id="글자-대표문자-한-글자만"><a href="#글자-대표문자-한-글자만" class="headerlink" title="글자 대표문자 (한 글자만)"></a><a name="word-single"></a>글자 대표문자 (한 글자만)</h3><ul><li><p><code>\w</code> : 글자를 대표하는 정규표현식 (w:word)</p></li><li><p><code>a, b, c</code>와 같은 알파벳 문자와 <code>가,나,다</code> 와 같은 한글문자, <code>1,2,3</code> 같은 숫자까지 포함.</p></li><li><p>특수문자는 포함안되더라도 <code>_</code> 는 포함된다고 한다.</p></li></ul><p><strong>출력결과</strong></p><img src="https://www.mediafire.com/convkey/449d/knqqzjdjoj0ky4gzg.jpg" style="zoom:50%;" /><p>숫자 대표문자 <code>\d</code> 와 마찬가지로 변수 <code>regex</code>에 <code>\w</code> 를 작성하고 실행했다.</p><p><code>search_target</code> 에서 <code>regex</code> 에 일치하는 결과물을 출력하는 코드이다. 스크린샷에서는 다 출력하지 못했지만, 숫자와 한글까지 다 정확히 출력된걸 확인할 수 있었다.</p><hr><h3 id="문자-여러개"><a href="#문자-여러개" class="headerlink" title="문자 여러개"></a><a name="multiple"></a>문자 여러개</h3><ul><li><code>\d</code>는 숫자 한 글자씩만 찾는 한계가 있다. 한 글자로 이루어진 단어뿐 아니라 여러 글자로 이루어진 단어로 찾을땐 <code>\d+</code> 를 이용한다.</li></ul><p><strong>출력결과</strong></p><img src="https://www.mediafire.com/convkey/f04a/2jfvjfj19cenouwzg.jpg" style="zoom:50%;" /><p>숫자로 이루어진 글자를 한글자씩 떼네어 잘 출력이되었다. <code>\w+</code> 로 조회해보면, 마찬가지로 문자를 한 글자가 아닌 한 단어씩 조회가 된다.</p><hr><h3 id="0개-이상"><a href="#0개-이상" class="headerlink" title="0개 이상"></a><a name="atleast-one"></a>0개 이상</h3><ul><li><code>*</code> 은 특정 조건으로 최소한 1개 이상의 수를 조회한다.</li><li><code>[1-9]\d*</code> : 앞자리 숫자가 1과 9중 하나가 반드시 나오는 수를 조회한다. 즉 자연수를 찾는 방법이다.</li><li><code>\d*[9]</code> : 뒤에다 붙이면, 뒷자리 숫자가 9인 숫자를 조회한다.</li></ul><p><strong>출력결과</strong></p><img src="https://www.mediafire.com/convkey/103b/s7otvv0xifq1sy4zg.jpg" style="zoom:50%;" /><hr><h3 id="x가-있을수도-있고-없을-수도-있고"><a href="#x가-있을수도-있고-없을-수도-있고" class="headerlink" title="x가 있을수도 있고, 없을 수도 있고"></a><a name="isExist"></a>x가 있을수도 있고, 없을 수도 있고</h3><ul><li><code>x?</code> : x가 있을수도 있고, 없을수도 있는 조건을 포함시켜 조회할 때 사용한다.</li><li><code>[x]?</code> 로 작성할 수도 있다.</li></ul><p>강의에서 사용한 예제는 전화번호이다. 찾고자 하는 전화번호가 같은번호임에도 <code>-</code> 여부에 따라   <code>021234567</code> 일수도있고, <code>02-123-4567</code> 일수도 있다.<br>이때 <code>-?</code> 를 포함시켜 조회하면, <code>-</code> 가 있거나 없거나 모두 조회하게 된다.</p><p>전화번호 형태의 숫자를 조회해보았다.</p><p>전화번호(<code>xxx-xxx-xxx</code>)는 숫자(<code>\d+</code>) 3개 사이에 각각 <code>-</code> 가 포함될수도있고, 그렇지 않을수도 있기 때문에 정규표현식으로 작성해보면 <code>\d+</code> , <code>-?</code>, <code>\d+</code>, <code>-?</code>, <code>\d+</code> 를 이어붙인걸로 작성될 수 있다. <code>\d+-?\d+-?\d+</code> </p><p><strong>출력 결과</strong></p><img src="https://www.mediafire.com/convkey/a3cd/4oe6qltu2wxg1mtzg.jpg" style="zoom:50%;" /><hr><h3 id="x-또는-y가-있을수도-있고-없을-수도-있고"><a href="#x-또는-y가-있을수도-있고-없을-수도-있고" class="headerlink" title="x 또는 y가 있을수도 있고, 없을 수도 있고"></a><a name="isExist-multiple"></a>x 또는 y가 있을수도 있고, 없을 수도 있고</h3><ul><li><code>[x,y]?</code> : x 또는 y가 있을수도 있고, 없을 수도 있다.</li></ul><p>전화번호 예제를 계속 사용해보면, 사실 <code>-</code> 뿐 아니라 그냥 공백으로 전화번호를 구분하는 표기법도 있다. 그럼 <a href="#isExist">위</a>의 정규표현식 <code>\d+-?\d+-?\d+</code> 로는 공백으로 구분한 전화번호는 조회되지 않는다. </p><p>이땐 <code>?</code> 앞에 <code>-</code> 대신  <code>[- ]</code> 를 작성하면, <code>-</code>또는  이 있을수도 있고, 없을 수도 있는 조건이 추가되어 조회된다.</p><p><strong>출력 결과</strong></p><img src="https://www.mediafire.com/convkey/a1d8/sh72klrp42subd0zg.jpg" style="zoom:50%;" /><hr><h3 id="특정-글자-수의-문자만-조회"><a href="#특정-글자-수의-문자만-조회" class="headerlink" title="특정 글자 수의 문자만 조회"></a><a name="select-word-by-specific-number"></a>특정 글자 수의 문자만 조회</h3><ul><li><code>\d&#123;n&#125;</code> : n개로 이루어진 숫자 단어를 조회할 때 사용</li></ul><p>전화번호 형태가 최근 가장 많이 쓰이는 휴대전화번호인 <code>xxx-xxxx-xxxx</code> 라면 위에서 사용한 정규표현식(<code>\d+[- ]?\d+[- ]?\d+</code>)만으로는 부족할 것이다. <code>\d+</code> 는 글자수와 상관없이 한 단어로 구성된 모든 숫자를 조회하기 때문이다.</p><p>이때 <code>\d&#123;&#125;</code> 를 사용하면, 원하는 글자 갯수로 구성된 단어만을 조회할 수 있다. </p><p>일반적으로 많이 사용하는 휴대전화번호 포맷인 <code>xxx-xxxx-xxxx</code>를 조회하기 위해서는 정규표현식을 <code>\d&#123;3&#125;[- ]?\d&#123;4&#125;[- ]?\d&#123;4&#125;</code> 로 수정해야 한다.</p><p><strong>출력 결과</strong></p><img src="https://www.mediafire.com/convkey/052f/ks4es59h599itv0zg.jpg" style="zoom:50%;" /><hr><h3 id="글자-수-조건-추가하여-문자-조회"><a href="#글자-수-조건-추가하여-문자-조회" class="headerlink" title="글자 수 조건 추가하여 문자 조회"></a><a name="select-word-by-numbers"></a>글자 수 조건 추가하여 문자 조회</h3><ul><li><code>\d&#123;x, y&#125;</code> : x또는 y개로 구성된 숫자 단어 조회</li></ul><p>전화번호 포맷이 <code>xxx-xxxx-xxxx</code> 일 수도 있지만, <code>xx-xxx-xxxx</code> 이거나 <code>xxx-xxx-xxxx</code> 라면 <code>\d&#123;n&#125;</code> 만으로는 전체 전화번호 조회가 불가능하다. 따라서 찾고자 하는 단어의 갯수의 조건을 추가해야 한다.</p><p>앞자리 숫자가 3자리 일수도 있고, 2자리일수도 있으니 <code>\d&#123;2,3&#125;</code><br>중간 숫자는 3자리 일수도 있고, 4자리 일수도 있으니 <code>\d&#123;3,4&#125;</code><br>마지막 숫자는 4자리 수이므로 그냥 <code>\d&#123;4&#125;</code></p><p>중간에 <code>-</code> 또는 공백이 있을수도 있고, 없을수도 있는 정규표현식(<code>[- ]?</code>)까지 채워넣으면 최종적으로 아래의 정규표현식이 완성된다.</p><p><code>\d&#123;2,3&#125;[- ]?\d&#123;3,4&#125;[- ]?\d&#123;4&#125;</code></p><p><strong>출력 결과</strong></p><img src="https://www.mediafire.com/convkey/a32a/isqket3qcmiswgwzg.jpg" style="zoom:50%;" /><hr><h3 id="특정-문자만-조회"><a href="#특정-문자만-조회" class="headerlink" title="특정 문자만 조회"></a><a name="select-specific-word"></a>특정 문자만 조회</h3><ul><li><code>[xyz]</code> : x, y, z만 조회한다.</li></ul><p>소음자 모음(a,e,i,o,u)문자만 조회를 해보았다.</p><p><strong>출력 결과</strong></p><img src="https://www.mediafire.com/convkey/fee4/gt4z8s38fo6721mzg.jpg" style="zoom:50%;" /><hr><h3 id="소문자-알파벳-전체를-조회하기"><a href="#소문자-알파벳-전체를-조회하기" class="headerlink" title="소문자 알파벳 전체를 조회하기"></a><a name="select-all-small-alphabets"></a>소문자 알파벳 전체를 조회하기</h3><ul><li><code>[a-z]</code> : a부터 z에 해당하는 소문자 알파벳 전체를 조회한다.</li><li><code>[a-z]+</code> : 소문자로만 이루어진 단어 조회</li></ul><p><strong>출력결과</strong></p><img src="https://www.mediafire.com/convkey/0a60/33og25h9rw5ux1vzg.jpg" style="zoom:50%;" /><img src="https://www.mediafire.com/convkey/8b12/eik0j7nqzqpz0hzzg.jpg" style="zoom:50%;" /><hr><h3 id="한글단어-조회"><a href="#한글단어-조회" class="headerlink" title="한글단어 조회"></a><a name="select-korean"></a>한글단어 조회</h3><ul><li><code>[가-힣]</code> : 한글의 첫 글자는 <code>가</code>이고, 마지막 글자는 <code>힣</code>라고 한다.</li></ul><p>한글로 구성된 단어를 찾을 땐 <code>[가-힣]+</code> 로 조회할 수 있다.</p><p><strong>출력 결과</strong></p><img src="https://www.mediafire.com/convkey/7b11/r3nqdbjyvy4b6jizg.jpg" style="zoom:50%;" /><hr><h3 id="기타-대표문자"><a href="#기타-대표문자" class="headerlink" title="기타 대표문자"></a><a name="select-other-words"></a>기타 대표문자</h3><ul><li><code>\s</code> : 공백문자 (스페이스, 탭, 뉴라인)</li><li><code>\S</code> : 공백문자를 <strong><u>제외한</u></strong> 문자</li><li><code>\d</code> : 숫자 대표문자</li><li><code>\D</code> : 숫자를 <strong><u>제외한</u></strong> 문자</li><li><code>\w</code> : 글자 대표 문자</li><li><code>\W</code> : 글자 대표 문자를 <strong><u>제외한</u></strong> 문자 (특수문자, 공백)</li></ul><p><strong>출력 결과</strong></p><p>숫자를 제외하고 조회</p><img src="https://www.mediafire.com/convkey/08c3/mt6k13b5u3jyd8nzg.jpg" style="zoom:50%;" /><p>글자 대표문자 제외하고 조회</p><img src="https://www.mediafire.com/convkey/ab11/n5poizai60zj0eazg.jpg" style="zoom:50%;" /><h3 id="자바-정규표현식"><a href="#자바-정규표현식" class="headerlink" title="자바 정규표현식"></a><a name="java"></a>자바 정규표현식</h3><p>자바에서는 정규표현식을 작성할때 앞에 <code>\</code> 을 더 붙여줘야 한다. 자바에선 기본적으로 <code>\</code> 이 escape를 의미하기 때문이다. </p><p>따라서 3글자 숫자로만 구성된 단어를 조회한다면, 작성할 수 있는 정규표현식은 다음과 같을 것이다. <code>\\d&#123;3&#125;</code></p><p>Python에서는 <code>re</code> 를 import하고, <code>re.findall()</code> 로 조회를 했다.</p><p>자바에서는 <code>Pattern</code> 클래스와 <code>Matchers</code> 클래스를 사용한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="keyword">import</span> java.util.regex.Matchers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">study_regex</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      String target = <span class="string">&quot;Luke Skywarker 02-123-4567 luke@daum.net\n다스베이더 070-9999-9999 darth_vader@gmail.com\nprincess leia 010 2454 3457 leia@gmail.com&quot;</span>;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 숫자를 포함한 단어(\w) 조회</span></span><br><span class="line">      Pattern pattern = Pattern.compile(<span class="string">&quot;\\w+&quot;</span>);</span><br><span class="line">      Matcher matcher = pattern.matcher(target);</span><br><span class="line">    </span><br><span class="line">      <span class="keyword">while</span>(matcher.find())&#123;</span><br><span class="line">         System.out.println(matcher.group(<span class="number">0</span>));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>출력 결과</strong></p><img src="https://www.mediafire.com/convkey/cb5a/4u2xrn4yc5joisxzg.jpg" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Js코드로 User-Agent 알아보기</title>
      <link href="2020/01/check-useragent/"/>
      <url>2020/01/check-useragent/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1511376777868-611b54f68947?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" width="650px" /><p>갑자기 접속한 브라우저와 운영체제 등 정보가 담긴 <code>user-agent</code>를 확인이 필요해서 코드를 찾아봤다. </p><p>Javascript의 <code>navigator</code> 객체를 이용하여 user-agent를 출력할 수 있다.</p><p>Navigator에 대해서는 <a href="https://opentutorials.org/course/1363/6650">생활코딩</a>에서 더 알아볼 수 있으며, <code>navigator</code> 객체의 여러가지 프로퍼티에 대해서 설명한 포스트도 있다.</p><p>출처 : <a href="https://ohgyun.com/292">꿀벌개발일지 - User Agent 파헤치기 (navigator.userAgent)</a></p><p>코드는 다음과 같다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Check UserAgent<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">UserAgent <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>확인<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;your-userAgent&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> userAgent = <span class="string">&quot;User-agent header sent: &quot;</span> + navigator.userAgent;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;your-userAgent&quot;</span>).innerHTML = userAgent;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>실제로 동작하는걸 확인해볼 수 있다.</p><p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="youngjinmo" data-slug-hash="WNbXbGa" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="check your user-agent">  <span>See the Pen <a href="https://codepen.io/youngjinmo/pen/WNbXbGa">  check your user-agent</a> by DevAndy (<a href="https://codepen.io/youngjinmo">@youngjinmo</a>)  on <a href="https://codepen.io">CodePen</a>.</span></p><script async src="https://static.codepen.io/assets/embed/ei.js"></script>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA - IO(BufferedReader/BufferedWriter)</title>
      <link href="2019/12/java-buffer-io/"/>
      <url>2019/12/java-buffer-io/</url>
      
        <content type="html"><![CDATA[<img src="https://cdn.mos.cms.futurecdn.net/VcSTBwkWeuLvpwAu6Gp3Z9-1024-80.jpg" width="650px" /><p>코딩테스트? 퀴즈를 풀면서 해결한 이후엔 다른 사람의 코드와 비교해보곤 하는데, 대부분의 사람들이 io에 <code>buffer</code>를 이용한걸 확인했다. 이전에도 코딩테스트에서는 <code>Scanner</code> 객체를 사용하는대신 <code>buffer</code>를 이용해야 효율이 좋다는 이야기를 들었고, 빡빡하게 진행하는 데에서는 아예 <code>Scanner</code>나 <code>print</code>를 사용하면 아예 통과하지 못한다고도 들은바는 있었다.</p><p>그러나 <code>buffer</code>를 잘알지 못하다보니 당장은 문제를 해결하기 위한 로직에만 집중하자며, 미뤄두었는데 이제서야 <code>buffer</code>를 좀 정리해보려고 한다.</p><p>먼저 <code>buffer</code>를 왜 사용해야하는지부터 알아보자.</p><br><h2 id="왜-버퍼-buffer-를-사용해야-할까"><a href="#왜-버퍼-buffer-를-사용해야-할까" class="headerlink" title="왜 버퍼(buffer)를 사용해야 할까?"></a>왜 버퍼(buffer)를 사용해야 할까?</h2><p><code>buffer</code>를 사용하지 않을 경우엔 사용자가 입력하는 키가 곧바로 프로그램에 전달된다. 이렇게 되면 사용자가 길게 입력할수록 키보드에서 프로그램으로 전달되는 횟수가 증가하며 프로그램의 성능저하를 유발할 수 있다.</p><p>반면 <code>buffer</code>를 사용할 경우엔, <b>일단 사용자가 입력을 마칠 때까지 buffer에 임시로 담아뒀다가 입력이 끝나면, 한꺼번에 buffer에 있는 값을 프로그램으로 전달한다. </b></p><p>여기서 버퍼란 데이터를 어떤 지점에서 다른 지점으로 전송하는 동안 일시적으로 데이터를 보관하는 메모리의 영역을 말한다. 버퍼의 또 다른 이름은 큐(Queue)라고 한다.<br>출처 : <a href="https://ko.wikipedia.org/wiki/%EB%B2%84%ED%8D%BC_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">위키</a></p><br><h2 id="StreamReader과-Buffer"><a href="#StreamReader과-Buffer" class="headerlink" title="StreamReader과 Buffer"></a>StreamReader과 Buffer</h2><p> 그동안 사용했던 <code>Scanner</code> 는 사실 원래 존재하지 않던 객체이다. Java 1.5에서 처음 적용되었으며, 좀 더 간편하게 콘솔에 문자를 출력하기 위해 개발되었다고 한다. Stream이 <code>Scanner</code>에 비하면 불편할 수 있지만, 원래 오리지널 방식의 입출력 객체라는 이야기이다.</p><p>Stream을 사용하기 위해서는 <mark>예외처리를 반드시</mark> 해주어야 한다. 출력할 때마다 <code>try catch()</code> 를 사용할 수도 있지만, main 메서드에 <code>IOException</code> 을 처리해두면 편하게 사용할 수 있다. 이 <code>IOException</code> 클래스도 <code>java.io</code> 에 내장되어 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">devandy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">// buffer 사용 준비 완료!</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><p><code>InputStreamReader</code> 로는 한글자씩밖에 입력받지 못한다고 한다. 그래서 몇자를 입력해도 한 글자만 출력한다. <code>InputStreamReader</code>과 <code>OutputStreamWriter</code>만 사용해서 IO를 시도할 경우, 다음과 같은 결과를 확인할 수 있다.</p><p><img src="http://www.mediafire.com/convkey/456a/qm4xi7b8827s2ozzg.jpg"> </p><p>입력으로 “12345” 를 입력했지만 정작 출력되는 1과 왜 출력된지 알 수 없는 %뿐이다. </p><p>이번엔 <code>BufferedReader</code> 와 <code>BufferedWriter</code>를 사용해서 입력과 출력을 해보겠다.</p><p><img src="http://www.mediafire.com/convkey/df00/ogkrplrg98npn90zg.jpg"></p><p>한글자밖에 입력받지 못했던 <code>InputStreamReader</code>를 <code>BufferedReader</code>로 감싸서 객체를 생성하니 문자열 그대로를 가져와서 출력까지 성공했다. <em>(여전히 %는 왜 출력되는지 모르겠다.)</em></p><p>원리는 다음과 같다. </p><iframe src="https://giphy.com/embed/Y0mnzvVa80iVjgiBaR" width="480" height="143" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>`InputStreamReader(System.in)` : 콘솔에서 입력한 문자를 문자 스트림으로 변환, <mark>주의할 점은 InputStreamReader는 정수형 데이터만 입력받는다.</mark><p><img src="http://www.mediafire.com/convkey/7396/62sr2m2i3n59l54zg.jpg"></p><p>위의 경우처럼 다른 데이터타입으로 입력받으려면 <code>InputStreamReader</code> 객체를 다른 형변환해주는 객체로 감싸줘야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">String number = String.valueOf(isr.read());</span><br></pre></td></tr></table></figure><br><p><code>Buffer</code>를 이용하여 입출력을 할 때는 <code>String</code>만 입출력이 되므로 다른 데이터를 입출력하고자 한다면, <a href="https://youngjinmo.github.io/2019/08/Java-casting/">형변환</a>해서 사용해야 한다.</p><br><h2 id="buffer이용한-io-실습"><a href="#buffer이용한-io-실습" class="headerlink" title="buffer이용한 io 실습"></a>buffer이용한 io 실습</h2><p>간단하게 코드를 작성해보자. 백준의 문제중 <a href="https://www.acmicpc.net/problem/2908">2908번 문제</a>를 활용해보겠다.</p><p>문제를 요약하면, 두 수(세자리 수)를 한 줄로 입력받아 각각의 수의 백의자리 숫자와 일의자리 숫자의 위치를 바꾼 후, 두 수의 크기를 비교하여 더 큰 수를 출력하는 문제이다.</p><p>이 문제에 대해 내가 작성한 코드는 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">changeValue</span><span class="params">(String num)</span></span>&#123;</span><br><span class="line">      String[] temp = num.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      String changed = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      changed += temp[<span class="number">2</span>];</span><br><span class="line">      changed += temp[<span class="number">1</span>];</span><br><span class="line">      changed += temp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Integer.parseInt(changed);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      Main m = <span class="keyword">new</span> Main();</span><br><span class="line">      Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">      String nums = sc.nextLine();</span><br><span class="line">      sc.close();</span><br><span class="line">      String[] divide = nums.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(m.changeValue(divide[<span class="number">0</span>])&gt;m.changeValue(divide[<span class="number">1</span>]))&#123;</span><br><span class="line">         System.out.println(m.changeValue(divide[<span class="number">0</span>]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         System.out.println(m.changeValue(divide[<span class="number">1</span>]));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그러나 이 코드는 <code>Scanner</code> 객체를 사용하여 프로그램 성능이 떨어진다. 이 코드에서 io에 해당하는 코드를 buffer를 이용한 io 방식으로 바꿔보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="comment">// StreamReader는 한글자씩밖에 저장을 할 수 없다고 한다.</span></span><br><span class="line"><span class="comment">// 그래서 BufferedReader를 객체로 생성해서 입력받은 문자를 buffer에 저장한다.</span></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">changeValue</span><span class="params">(String num)</span></span>&#123;</span><br><span class="line">      String[] temp = num.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      String changed = <span class="string">&quot;&quot;</span>;</span><br><span class="line">      changed += temp[<span class="number">2</span>];</span><br><span class="line">      changed += temp[<span class="number">1</span>];</span><br><span class="line">      changed += temp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Integer.parseInt(changed);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      Main m = <span class="keyword">new</span> Main();</span><br><span class="line">      BufferedReader br </span><br><span class="line">         = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">      BufferedWriter bw </span><br><span class="line">         = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line"></span><br><span class="line">      String nums = br.readLine().trim();</span><br><span class="line">      br.close(); <span class="comment">// BufferedReader 종료</span></span><br><span class="line">      String[] divide = nums.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(m.changeValue(divide[<span class="number">0</span>])&gt;m.changeValue(divide[<span class="number">1</span>]))&#123;</span><br><span class="line">         bw.write(String.valueOf(m.changeValue(divide[<span class="number">0</span>])));</span><br><span class="line">         bw.flush();  <span class="comment">// buffer에 남아있는것 모두 클라이언트로 전송후, 비운다.</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 출력을 위해서 String으로 변환해서 출력 </span></span><br><span class="line">         bw.write(String.valueOf(m.changeValue(divide[<span class="number">1</span>])));</span><br><span class="line">         bw.flush(); <span class="comment">// 위와 마찬가지</span></span><br><span class="line">      &#125;</span><br><span class="line">      bw.close();  <span class="comment">// BufferedWriter 종료</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>바꾼 코드로 다시 제출해봤다. IDE에서 코딩하지 않고, 마크다운 에디터(<a href="https://www.typora.io/">Typora</a>)에서 코딩하고 확인업싱 바로 제출하느라 두번의 컴파일 에러가 있었다. 정상적으로 제출한 코드의 결과를 보니 시간이 100ms에서 80ms로 <span style="color: red;">20%</span>의 효율이 발생한 것을 확인할 수 있었다.</p><p><img src="http://www.mediafire.com/convkey/82e4/10glq6i6g89dg5rzg.jpg"></p><p>오늘은 조금 간략하게 정리했는데, 더 Stream에 대해 더 공부하고 파일 입출력과 함께 정리해보겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Length와 Length() 그리고 Size()의 차이</title>
      <link href="2019/12/java-length-size/"/>
      <url>2019/12/java-length-size/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1531171673193-06ab3c43e4a5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80" width="650px" /><p>자바에서 길이를 반환할 때 사용하는 메서드 또는 프로퍼티로 <code>length</code>, <code>length()</code> 그리고 <code>size()</code> 가 있다. 이것들의 차이를 제대로 이해하지 못한 상태에서 사용하다보니 Intelli J같은 IDE에서야 실수할 일이 없지만, vi 에디터로 코딩할 때엔 어떤걸 써야할지 헷갈리곤 한다. 그래서 정리하고자 이번 포스트를 작성하게 되었다.</p><p>일단 용도를 구분하면 다음과 같다.</p><table><thead><tr><th>함수</th><th>길이를 반환하는 데이터 타입</th></tr></thead><tbody><tr><td><code>length</code></td><td>배열</td></tr><tr><td><code>length()</code></td><td>문자열 (String Object)</td></tr><tr><td><code>size()</code></td><td>컬렉션 프레임워크 타입 (ArrayList, ..)</td></tr></tbody></table><p>스택오버플로우에서 찾은 답변이 좋을 것 같아서 여기에 정리한다.</p><p><em>배열과 문자열은 immutable한 특징을 갖는다. 그리고 모든 최상위 Collection의 하위 클래스는 mutable한 특징을 갖는다. 그래서 “length” 라는 것을 봤다면, 그건 constant(=immutable) 변수일 것이다. 이와 반대일 때 “size”를 볼 수 있다.</em><br>출처 : <a href="https://stackoverflow.com/questions/20192843/difference-between-size-and-length-methods">Stackoverflow</a></p><p>가장 많이 vote된 답변을 해석했는데, 눈여겨볼 점은 immutable한 특징이 될 것 같다. 영어로 “변경될 수 없다.”라는 뜻인데, 배열이 더 이상 변경되지 않는다는 점은 알겠는데 문자열이 변경되지 않는다고? 그래서 또 구글링을 해봤다..</p><p>Immutable Object란 생성후 변경불가능한 객체를 의미한다고 한다. 대표적인 Immutable 클래스로는 <code>String</code>, <code>Boolean</code>, <code>Integer</code>, <code>Float</code>, <code>Long</code> 등이 있다. </p><p>그런데 여기서 말하는 Immutable에 대해 더 알아보자. 일반적으로 값을 못바꾼다고 표현하는데, 문자열은 변경가능하지 않았나..?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String name = <span class="string">&quot;Andy&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;DevAndy&quot;</span>;</span><br></pre></td></tr></table></figure><p>이렇게보면, 문자열 변수 <code>name</code>의 리터럴이 변경된것처럼 보이지만, 사실 이건 리터럴이 변경된 것이 아니었다. <code>String</code> 은 기본형 타입(Primitive Type가 아니라 참조형 타입(Reference Type)이다. 따라서 값을 메모리에 할당하는게 아니라 값을 참조하는 방식이다. 따라서 값을 변경한게 아니라 <code>name</code>이 가리키는 값을 “Andy”에서 “DevAndy”로 바꿔서 가리킨것일 뿐이다.</p><p>출처 :</p><ul><li> <a href="https://hashcode.co.kr/questions/727/%EC%9E%90%EB%B0%94%EC%97%90%EC%84%9C-immutable%EC%9D%B4-%EB%AD%94%EA%B0%80%EC%9A%94">#ashcode - 자바에서 Immutable이 뭔가요?</a></li><li><a href="https://readystory.tistory.com/139">Java의 String 이야기 - String은 왜 불변일까</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA - String 객체간 비교</title>
      <link href="2019/12/boolean-string/"/>
      <url>2019/12/boolean-string/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1516706332927-bb3a20d62514?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80" width="650px" /><p>Java에서 String형 데이터의 비교방법이 두가지가 있다. 하나는 값만 비교하는 <code>equals()</code>함수이고, 다른 하나는 산술연산자 ==를 이용한 비교이다. 각각의 비교가 서로 어떻게 다른지 비교해보겠다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">String str2 = <span class="string">&quot;string&quot;</span>;</span><br></pre></td></tr></table></figure><p>이렇게 2개의 String형 변수를 선언했고, 이제 이 변수들을 2가지 방법으로 비교할 것이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">String str2 = <span class="string">&quot;string&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(str1.equals(str2));</span><br><span class="line">System.out.println(str1==str2);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 출력 결과</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p><code>equals()</code> 함수를 통한 비교는 예상한대로 true를 반환하여 출력했는데, <code>str1==str2</code>은 false가 반환되어 출력되었다. 이유는 <code>equals()</code> 함수는 값만 비교를 했지만, 산술연산자 == 는 객체 주소값을 비교했기 때문이다.</p><p>str1과 str2의 객체 주소값을 확인하는건 <code>System.identityHashCode()</code>를 통해서 알 수 있다.</p><img src="https://lh3.googleusercontent.com/bAKOE9kOi5joQsKqOXh7s8ifHQAo0J3S_PzEBnegpxUTson5fVGwTCZ8PRgsw7jBYphPcMTFySDcvwjRAOaFXUhQKCchjS_P7edFuNQSXKB1cprtudSynLI5lvEqvlD8Zyemla3HxAbaQalT5znEK2Q5hpwrrNtL6Pcp4tF40jOjiXI6kUNEaNFvhJQp3_Oz72bATRaocohzkxw70JpX2IwmHMT7mt1YM9_txfYKxtD9KolPut2kGV9G5zrz7TqwrkZCTHkkZ9pMbXOthuxsl8qtFPtHndWNeDN5b3sDkGO6HHuc_YeLwnOn7i_5vhwQ_br8AcuHGxcWiYWEmJ4Ec5hhjoV_kgO1Z46PWG246XAkoIXxmRaye3fD9bXq8Yp_NHk8PoOtouj0h_cZSAJwNP36wB8FSi2XrUjnZXvZtA8xiA2iLXbQjydgWcBdFr5nlUzvmtHK3n2GpL_M3OVQwG_S3Vc7TJjzFIW92vAiIpel1z1hhOjC_u0dNu6aF35XqgOvrEw0-cX4oxMXLaIE_wCqkGRn5GROUH5qJFJBXgdkpGsiagz5xyn4hYlS8H1TNUW_80PY7L4Mr-lqFE5WGLCsQgOSPy-Xo8d2ZEqspBShqmLaYWp4kczl4DA10RCeai9WV06fxbKCuGl1dSEpBe8mAU2EQEW3I19A_3ghAfDUf9-5eA-6gRmiRALjXvdKjNd9otrN5lN-ebriqHEUbgn501YBbpP6fQnfU-GHYS_0fUrKEol4YFxh=w1372-h850-no" style="width: 90%;" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github - Credential 저장</title>
      <link href="2019/12/git-credential/"/>
      <url>2019/12/git-credential/</url>
      
        <content type="html"><![CDATA[<img src="https://github.githubassets.com/images/modules/open_graph/github-octocat.png" width="650px" /><p>Github Credential이란 Github의 계정정보를 말한다. </p><p>저장소에 push/pull 하거나 private 저장소를 clone하기 위해서는 해당 저장소를 이용할 수 있는 권한이 필요한데 이 때 credential에 계정 정보를 저장해두면 저장소 이용시마다 로그인할 필요가 없다.</p><p>터미널 명령어는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config credential.helper store</span><br><span class="line">git push https:&#x2F;&#x2F;github.com&#x2F;repo.git</span><br><span class="line">Username : your github email</span><br><span class="line">Password : your github password</span><br></pre></td></tr></table></figure><p>credential과는 무관하게 author와 email을 저장할 수도 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;dev.youngjinmo@gmail.com&quot;</span><br></pre></td></tr></table></figure><p>위의 명령어는 디렉토리 상관없이 전역(global)에서 사용할 수 있는 author와 email을 설정한 것이다. 설정해두면, 해당 운영체제 또는 컨테이너에서 커밋을 생성할 경우 해당 커밋에 author과 email이 기록된다.</p><p>출처 : <a href="https://git-scm.com/docs/git-credential-store">https://git-scm.com/docs/git-credential-store</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>배열에서 사용할 수 있는 Fill()</title>
      <link href="2019/11/java-string-arrays-fill/"/>
      <url>2019/11/java-string-arrays-fill/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1499961024600-ad094db305cc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=900&q=60" width="650px" /><p>백준 알고리즘 <a href="https://github.com/youngjinmo/quiz_archives/blob/master/baekjoon/07/10809.md">문제</a>를 풀다가 알게된 메서드 하나를 <a href="https://devyoungjin.github.io/2019/11/java-string-arrays-indexof/">indexOf()</a>에 이어 또 정리해본다.</p><p><code>fill()</code> 은 두 개의 파라미터를 요구하는 함수이다. 하나는 배열(모든 타입), 다른 하나는 해당 배열을 채울 데이터이다. 이 때 배열을 채울 데이터는 당연하지만, 배열의 데이터타입과 일치해야 한다. <code>String[]</code>이 파라미터로 주어졌다면, 이 배열을 채울 데이터 또한 <code>String</code>이어야 한다는 이야기이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">devandy</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 배열 선언</span></span><br><span class="line">      String[] strArr = <span class="keyword">new</span> String[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">char</span>[] charArr = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">      <span class="keyword">int</span>[] intArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 배열에 값 채우기</span></span><br><span class="line">      Arrays.fill(strArr, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">      Arrays.fill(charArr, <span class="string">&#x27;z&#x27;</span>);</span><br><span class="line">      Arrays.fill(intArr, <span class="number">7</span>);</span><br><span class="line">    </span><br><span class="line">      System.out.println(Arrays.toString(strArr));</span><br><span class="line">      System.out.println(Arrays.toString(charArr));</span><br><span class="line">      System.out.println(Arrays.toString(intArr));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>결과</strong></p><p><img src="http://www.mediafire.com/convkey/6a47/su04fhlnvs7iwnhzg.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> array </tag>
            
            <tag> fill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>문자열에 사용할 수 있는 indexOf()</title>
      <link href="2019/11/java-string-arrays-indexof/"/>
      <url>2019/11/java-string-arrays-indexof/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1546198632-9ef6368bef12?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80" width="650px" /><p>백준 알고리즘 <a href="https://github.com/youngjinmo/quiz_archives/blob/master/baekjoon/07/10809.md">문제</a>를 풀다가 알게되어 정리해본다.</p><p><code>String name = &quot;devandy&quot;;</code> 에서 알파벳 a가 문자열 name에서 몇번째 인덱스에 있는가?</p><p>이 질문에 대해 그냥 풀어보면 이렇게 작성해볼 수 있을 것 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">devAndy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">searchIndexOf</span><span class="params">(String str, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">      String[] arr = str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="keyword">int</span> indesx = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(arr[i].equals(String.valueOf(c)))&#123;</span><br><span class="line">            index = i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> index;</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      devandy d = <span class="keyword">new</span> devandy();</span><br><span class="line">      String name = <span class="string">&quot;devandy&quot;</span>;</span><br><span class="line">      <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      System.out.println(d.searchIndexOf(name, c));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>대략 20줄 내외의 코드가 필요하다. 인덱스를 찾는 메서드만 하더라도 딱 10줄이다. 그런데 <code>indexOf()</code> 를 사용하면 이렇게 길게 작성할 필요가 없어진다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">devandy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">      String name = <span class="string">&quot;devandy&quot;</span>;</span><br><span class="line">      <span class="keyword">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">      System.out.println(name.indexOf(c));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char형 뿐만 아니라 String 데이터도 찾아준다. </p><p><img src="http://www.mediafire.com/convkey/ceda/bm6hzkn9dusl5ouzg.jpg"></p><br><p><a href="https://docs.oracle.com/javase/9/docs/api/java/lang/String.html#indexOf-int-">공식문서</a>를 보면, 문자열 데이터에서 parameter로 받은 문자(specified character)가 <strong>첫번째로 등장</strong>하는 인덱스를 반환하는 함수라는 설명이다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> string </tag>
            
            <tag> indexof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>스프링부트 웹 서버 실행시 자동으로 DB 삽입하기</title>
      <link href="2019/11/springboot-import-sql/"/>
      <url>2019/11/springboot-import-sql/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1548606277-956d44f816cb?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80" width="650px" /><p>유튜브에서 박재성님이 올려놓으신 <a href="https://www.youtube.com/playlist?list=PLqaSEyuwXkSppQAjwjXZgKkjWbFoUdNXC">Spring-Boot, JPA로 질문/답변 게시판 구현과정</a>을 보며 게시판 만드는 연습을 하고 있다. <a href="https://www.youtube.com/watch?v=9xmTAmyv_ic&list=PLqaSEyuwXkSppQAjwjXZgKkjWbFoUdNXC&index=25">4-2 영상</a>에서 import.sql 파일을 생성해서 서버 실행시마다 자동으로 데이터를 주입하는 방법을 알려주셨는데, 처음에 잘 안되서 몇시간 삽질을 하다가 정호영님이 남겨놓으신 댓글을 통해 해결을 해서 여기에 정리해본다.</p><p>우선 현재 이 프로젝트는 H2 데이터베이스를 사용해서 연습을 하고 있다. H2 데이터베이스는 In-Memory 방식이기 때문에 서버가 재실행할 때마다 DB가 초기화되는 특징이 있다. 이렇기 때문에 연습하기에 좋기도 하지만, 단 회원 DB를 다루기 위해서 매번 프로그래머가 임의로 회원 DB를 생성하는 일은 번거로웠다. 그런데 resources 디렉토리에 import.sql 이라는 파일명의 sql 파일을 저장하면 sql파일 안의 쿼리를 읽어들여서 DB에 자동으로 주입해준다고 한다.</p><img src="https://lh3.googleusercontent.com/NBUSbvjwwNmGoNHK7IPO36ipQYfsddVRVSgPWLAJ30b1qQ2MmptniLaKR5dR0PH9N5e-f5WekHQpvm2ybuMbrXKZW1dRtcvjVL9Gk5qHuHNMDfRf3U0PX07dALPFO61KkjvzrJ_PFskZL7Z7QAtBzghVOF97jCa7AsscX1fMKYPi70VUn60O9mbI8VcXg5zwjUFogrjL1FTf54CW4aNC0tniwVdlBUukkPdim9iaQyMOdinSZ05MFXDOxa9cRm1edYS_3Q3GSYrG5pjalHkVLQxIlRu1cFdJo5QIbKO2jT3gr4cKDWnVBdmYSCm0m2jd1RoSvc3qHAvg6jSsJeWiTZUmrzIBCy4jNXKFtGAjDbtsUfBVaWF0lmWIm9b_simeDk90q2Krui8HrB4B6lDKPZGVN1_oPY_OsSaKOlHzxI0gugHkvCxH6VJfzAF4_UqSMtS25Gqe44QNvFhvPwozPiYwL1Tw3SVp-ntP4K4LVmyFL_K1FQYqXBkpmqpt6FsWrt-D_TbNYpO-ZWL-Uha0jV9iIzuDF1nyYr83eMXHdxaGKkGdD5IZqqcNu6P0DVox-k4sNETw-nCqhpv2yXW_Vr1UTpNBU03QmyO5Qyf8tP4_1icYvWADpW9eRB8RYhQ8nBqpqy4RugPC64HhXc9arbe_oG63AQXNaO7TTePJzVrqqDXpp0oKIu9L-DI1wjuuzGJET2rnqIDomPFzv3DDfKlc47lls7-51JVNzHniRpIx0dFDRz5APso=w255-h381-no" style="width: 250px;" /><p>이렇게 resources 디렉토리 바로 하위에 import.sql을 생성하고, 파일 안에 유저정보를 추가하는 쿼리를 추가했다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">USER</span> (USER_EMAIL, USER_NAME, USER_PASSWORD) <span class="keyword">VALUES</span>(<span class="string">&#x27;user1@email.com&#x27;</span>, <span class="string">&#x27;user1&#x27;</span>, <span class="string">&#x27;12345678&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">USER</span> (USER_EMAIL, USER_NAME, USER_PASSWORD) <span class="keyword">VALUES</span>(<span class="string">&#x27;user2@email.com&#x27;</span>, <span class="string">&#x27;user2&#x27;</span>, <span class="string">&#x27;12345&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">USER</span> (USER_EMAIL, USER_NAME, USER_PASSWORD) <span class="keyword">VALUES</span>(<span class="string">&#x27;user3@email.com&#x27;</span>, <span class="string">&#x27;user3&#x27;</span>, <span class="string">&#x27;3456789&#x27;</span>);</span><br></pre></td></tr></table></figure><p>여기서 처음에 삽질했던 포인트 하나.</p><p>sql 쿼리의 테이블 컬럼으로 도메인에 있는 <code>User</code> 객체의 컬럼명으로 입력했는데, 에러가 발생하면서 sql을 정상적으로 긁어오지 못했다. 그래서 아래의 h2-console에 접속해서 테이블 컬럼을 확인하고 다시 입력했다.</p><img src="https://lh3.googleusercontent.com/uUqTBYW7r_ABh3Vb2ElP_uRJXC0rg0ZMQ4Lh_2yLqLLx0NR1BzW4wEIh2RN9Dr8ybj_aHu-wbxDVB07S5rxGeyFqhvZFalQjqgg_366SO5MMhukEM8YWRtRZc3-PdLoNqfPfzVF5-73ngVEKTMVu1_asHdb7Ma5nqMUgZPNsuelTj_6xUQ8pkuQNYUU_5ZLJ-UMoVrE2dLSH8-UsrHiYdlS-JYHtkgMz-uBy2xjGuwd3MSUAXcaExJnyPxEBlYS89xdEAvGoNS6NVaXPfLQbON2Y9-YaADCkzVE-8GR8tNOhacQ1Y2sFj7YnRcFfD0ImWsxcdrf67sE6bE-3FGY3jF4QiaWt02uX0xqbUQfz80WGpuozmdpBuBYVNaPzimCXfz92z6YPWCCU37P6fbONnDbLonNcOBVo_Uj_xM0rPpMh1QZ32FCFalc1Su4q_6l0I7tZ0PotOIvbREpNmlaAhgjGm6vcKi6GjRERIJo9k3Wv7BJKo6QZCE6kl7-9A18mMF0si8_CKPlxT_pyaLVZ3bdf1Ucp6n3GDG369Xu43ASH0WieLEJw_HHiQIXKYdL6Z9_jjHsaqeJ7Hj2tl6yPBVbUE9sg3_GmGaFpNcIP2FceHS4fhT85NO25cKMimphmG07XrtB9Rut2WaUWJ5cyZ-QUH9NHdzjaGLFc3TpUqvrRu4gkVQMN39dPuZoAFlW70-OR6_QnmpeOpSkQCx6qrrSOIXrvrguNsBAHQ0fGDjo_EbVHbqHFsYM=w600-h300-no" style="width: 80%;" /><p>하지만 이렇게까지 해도 에러가 발생한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.hibernate.tool.schema.spi.CommandAcceptanceException: Unable to execute command</span><br></pre></td></tr></table></figure><p>뭐 이런 에러가 발생하는데 실행하려는 명령어를 제대로 인식하지 못한다는 에러로 보여진다. 위에 sql 쿼리에 따로 ID 컬럼을 작성하지 않았는데, 이는 User.java에서 <code>id</code> 필드에 <code>@GeneratedValue</code> 어노테이션을 했기 때문에 입력하지 않아도 자동으로 입력되는줄 알았기 때문이다. 이 때 호영님의 댓글덕분에 해결할 수 있었다. </p><p><code>@GeneratedValue</code> 어노테이션에 속성값으로 <code>(strategy = GenerationType.IDENTITY)</code>를 입력하니까 ID 컬럼을 입력하지 않아도 자동으로 ID를 부여했다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Id</span></span><br><span class="line">   <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">   <span class="keyword">private</span> Long id;</span><br><span class="line">  </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이클립스에서 확인해보니 GenerationType의 IDENTITY는 DB 컬럼에 사용되는 primary key를 명시하는 기능(?)으로 추정된다.</p><img src="https://lh3.googleusercontent.com/2gE8v_blXn3GeNmqbo1s6cTx_bgsrFPAbLE5-8Eh4hENErZx4pHXnIgLrHdfDofgOeOxAAxN6rozi-9xb-p-yrTbinhSI56kX4LVg2oYzzY8GJ2THnmShOpF7uXLGLuqkJm8QZzzvejBHV8tvCZljUKRVrJDgpwfHfLkoxG-RxWVU3K8ybaeZlV5ERN8yaQKPGWJXKN_A6OqZcMZ9XmvEG-avpoh14Fi7fHIziQcmOFHDP4u_sN9XvMPj7XjdYKniYc2WOqa0nxO7SNVBLK1yiGi0UEKU0_ib9FduhUDVo-JS70CCFb30PayPKKfcfTJoNaTieHN6n-R1KQ_o5qerpo2LbwIwGdwRw2teSCSIZq093eSym4jHVOY5iFVGbU587XYQbQxwSzpepmc5e41KSjvzFzAXlUrr8aRmmLc6toAEPXasskGHCjOI2yDgcJW8tN7rXAxnf0kjfwdMuNT7y-SZBYQ-iul3j5I9X5bxTA3vzVSfmQ-Sz6Wh-faszkc1OOo3ryI__RMdd_vXqHDtMKWBBEeEWmfEalPewi4058TNj5sMO_dtg-_KpzxhPlzf--_iwzCDdVd4esvv6FlQAFZmUQ7m3wxeAlpq79Sg4ZoLjMv14C5zM2zqnwbDrtkN90AUxMjZ7i3Zf3VOOo-ob1Wd98E5ESlfMfh69Fm1QY582YD7QoCdNdur7gIMC9jb92jRguYjOrrUHrly1ec6pwHWl3OHJto1SmYm9-_X-ffKpVJl5UQKQY=w691-h398-no" style="width: 80%;" /><p>이제 서버 재실행을 할 때마다 유저정보가 자동으로 입력된다.</p><img src="https://lh3.googleusercontent.com/I5PL6HiyvAkbE2-ER8xTi5vp7VC183pYO9ebDaBmNQ2sRvhmn3GLVlqm6P24sMjFDMxXSkZPJXs0XMlxFzbHeMNDIOqK5AD5liw99sguPOSF_IYoQtJ6rMq6Mku1kqUZ2vGAMsucpSHfmwgBmdMecwu5ITsfUZOJq86TuCeO1duXgzEZQOYrnqHA8vzzKjPEBUtcy9Lg46d2DkQfkaDZrHfqO-wtRMIsXuCAayeqbED6nlyuY1QFzmSJp3XzybK0sy_2gOB6xDPpq4lxFyoX7FEF_kn-u-pFTagnY9TQzZ_JzOph1Nks5aZlCQZfqq4JOQOlgpikiCYWDg5mtLmZghlFiQLo7W0JX55epNKC_q3coen8SQEUVyYOfIn_KNZFReFwC8OQegrdSpZXzMzRe-5TKlrRYIpCy0JeDPj3fBUPUtzq7Qhez5XCXVPE1NDRPd0lzY_343Ia8Xx_EKRutzhDF1QMV3Ugiyw1_hefGnObiB9K2Un3LAvUk-yznRUjGW55Q9ArtVXplJ3S1BHYZfcCq_8Vc3UUMl9FGeuHOjh1M5a8ohrQVdgqdx1tHpJ6mABy-HVO5d4ROg3t_V5_QYssSExFy3B17mrVawiAST0bXAy_z6ryFYX6cGfzH48Gwzk2W_MnvQQXwrDT3CkYxPgV6s3VbH_zpA41RCkU-YcIH_7sOAO_TS-oEDfQ32m2vTUbl7n6MpjFIWeh4SZ95KDT4h_SG66sfgRQH-ZauiqQpm-Vz9heEmk=w540-h332-no" style="width: 80%;" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity에서 패스워드 암호화하기(A.k.a.passwordEncoder)</title>
      <link href="2019/11/springsecurity-passwordencoder/"/>
      <url>2019/11/springsecurity-passwordencoder/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" width="650px" /><p>SpringBoot로 프로젝트를 하면서 비밀번호를 암호화하는 작업을 배웠다. 기록을 위해 남겨둔다.</p><p>사용자는 패스워드를 평문 문자로 회원가입/로그인을 한다. 여기서 평문 문자(Plain text)란 암호화되지 않은 문자열 데이터를 말한다. 사용자의 패스워드는 서버에 저장되는데, 이 때 평문 문자로 저장이 되면, 서버를 관리하는 사람이 임의로 사용자들의 비밀번호에 접근할 수 있을뿐더러 서버가 해킹되었을시 비밀번호가 대량유출되면서 큰 피해를 입을 수 있다. 따라서 이를 방지하기 위해 암호화(encode) 작업이 필요하다.</p><p>비밀번호를 암호화하기 위해서는 스프링 시큐리티의 <code>PasswordEncoder()</code>를 사용한다. 인텔리J에서 <code>PasswordEncoder()</code> 를 사용하면 라이브러리를 불러오면서 라이브러리 경로를 볼 수 있는데, 이 때 <code>PasswordEncoder()</code>의 경로는 <code>org.springframework.security.crypto.password</code> 였다. 스프링 시큐리티의 내장 함수로 추정된다.</p><p>암호화를 위한 작업을 진행할 패키지와 PasswordEncoding이라는 클래스를 생성했다.</p><p>그리고 Spring Security의 <code>PasswordEncoder</code>를 상속(<code>implement</code>)받았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordEncoding</span> <span class="keyword">implements</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PasswordEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.passwordEncoder = <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">PasswordEncoding</span><span class="params">(PasswordEncoder passwordEncoder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.passwordEncoder = passwordEncoder;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence rawPassword)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> passwordEncoder.encode(rawPassword);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence rawPassword, String encodedPassword)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> passwordEncoder.matches(rawPassword, encodedPassword);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BCryptPasswordEncoder()</code>가 실제로 문자를 암호화해주는 메서드이다. 이 메서드는 암호화할 때마다 새로운 값을 생성해서 보안수준을 높혀준다. 이렇게 하면 서버에 저장된 비밀번호(encoded)를 분실해도 복호화(decode)하는 것이 사실상 불가능해진다.</p><p>잠시만, 그럼 로그인할 때 사용자가 비밀번호를 맞게 입력했는지 어떻게 알 수 있을까?</p><p>로그인할 때 사용자는 평문 문자를 입력한다. 그럼 서버에서 사용자가 입력한 평문 문자와 아이디(또는 이메일 주소)에 맞는 암호화된 비밀번호를 비교해서 회원여부를 검증한다. </p><p>정확히는 사용자가 입력한 비밀번호를 암호화해서 아이디에 맞는 암호화된 비밀번호를 서로 비교하는건데, 선뜻 이해가 가지않는다. 앞서 비밀번호는 암호화되서 생성된다고 했기 때문이다. 이 때 사용하는게 위에 PasswordEncoding 클래스에서 오버라이딩하여 작성한 <code>matches()</code>를 사용한다.  <code>matches()</code>는, 아직 암호화되지 않은 평문문자와 암호화된 비밀번호를 서로 비교해준다. 이 비교방식은 복잡한 알고리즘이기 때문에 어떤 원리로 비교하는지는 알 수 없다.</p><p>테스트 코드를 작성해보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testPassword</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">      PasswordEncoding passwordEncoding = <span class="keyword">new</span> PasswordEncoding();</span><br><span class="line"></span><br><span class="line">         String rawPassword1 = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line">         String rawPassword2 = <span class="string">&quot;12345678&quot;</span>;</span><br><span class="line"></span><br><span class="line">         String newPassword1 = passwordEncoding.encode(rawPassword1);</span><br><span class="line">         String newPassword2 = passwordEncoding.encode(rawPassword2);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;newPassword1 : &quot;</span>+newPassword1);</span><br><span class="line">         System.out.println(<span class="string">&quot;newPassword2 : &quot;</span>+newPassword2);</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">&quot;boolean : &quot;</span>+newPassword1==newPassword2);</span><br><span class="line">         System.out.println(<span class="string">&quot;matches : &quot;</span>+passwordEncoding.matches(rawPassword2,newPassword1));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rawPassword1</strong>과 <strong>rawPassword2</strong>는 정확히 같은 문자열을 갖고있다. 이 둘을 암호화해서 <strong>newPassword1</strong>과 <strong>newPassword2</strong>에 각각 저장했다. 그리고 이 둘을 직접 비교하는 코드를 작성했고, 다음줄에는 이 둘의 비교를 <code>PasswordEncoding.java</code>에 있는 <code>matches()</code>를 사용하여 비교해보았다. </p><p><img src="http://www.mediafire.com/convkey/6121/cwtqxq3vk1x2q1uzg.jpg"></p><p><strong>rawPassword1</strong>과 <strong>rawPassword2</strong>가 각각 어떻게 암호화되었는지 확인할 수 있으며, 같은 패스워드를 갖고있었던 두 변수들이 암호화되어 생성된 <strong>newPassword1</strong>과 <strong>newPassword2</strong>의 boolean 비교는 <code>false</code>였고, <code>matches()</code>로 암호화되기 전의 boolean 결과는 <code>true</code>였다. </p><p>이는 임의의 랜덤의 수를 생성해서 암호화하는 것이 아니라 입력받은 값에 따라 정해진 알고리즘에 의해 패스워드가 생성된다고 할 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> spring-security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URI와 URL</title>
      <link href="2019/11/http-uri-url/"/>
      <url>2019/11/http-uri-url/</url>
      
        <content type="html"><![CDATA[<img src="http://www.learn-angular.fr/wp-content/uploads/2017/02/http-1024x680.jpg" width="650px" /><p>그래도 웹 개발로 취업을 준비하면서 HTTP에 대해 지나치게 무지한게 아닐까 생각하여 정리하게 되었다. URI와 URL에 대해 다뤄보았다.</p><p><strong>URI</strong>는 <strong>Uniform Resource Identifier</strong>의 약자이다. <u>인터넷에 있는 자원을 나타내는 고유한 주소</u>를 나타내는 <strong>규약</strong>이다. <strong>URL</strong>은 <strong>Uniform Resource Locator</strong>의 약자이다. <u>네트워크상에서 자원이 어디있는지 정확한 위치</u>를 알려주는 <strong>규약의 형태</strong>이다.</p><img src="https://i.stack.imgur.com/FbaKm.png" alt="출처 : Stackoverflow What is the difference between a URI, a URL and a URN?" style="zoom:50%;" /><p>즉, URI가 보다 넓은 범위의 개념이고, URL은 URI의 하위개념이라 볼 수 있다. URL이 가장 흔한 형태의 URI 규약 형태이기 때문에 일반적으로 URI라고 하면, URL이라고 생각해도 무방한듯하다.</p><p>참고로 이 글의 URL 주소를 뜯어보면(?).</p><ul><li><code>https://</code> : 리소스에 접근하기 위해 사용되는 프로토콜. 스킴이라고 한다.</li><li><code>youngjinmo.github.io</code> : 인터넷 주소 또는 호스트 주소를 의미한다.</li><li><code>/2019/11/http-uri-url</code> : 웹 서버상에서의 리소스 주소를 의미한다.</li></ul><br><p>URL과 같은 규약의 형태로 URN도 존재한다. URN은 Uniform Resources Name의 약자이며, 객체의 절대위치를 가리키는 규약의 형태이다.</p><p>URN은 URL을 보완하기 위해 등장한 것으로 보인다. URL의 경우 가라키는 파일이 이동했을 경우 더 이상 URL이 유효하지 않게 되는데, URN은 객체의 이름을 가리키므로 가리키는 파일의 경로가 이동되도 URN은 유효하다는 특징이 있다고 한다.</p><br><hr><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://velog.io/@honeysuckle/URL-vs-URI">honeysuckle - URL vs URI</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Duet 디스플레이 한 달 사용후기</title>
      <link href="2019/10/review-duet/"/>
      <url>2019/10/review-duet/</url>
      
        <content type="html"><![CDATA[<img src="https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F2564F7425493451502" width="650px" /><p>지난달에 구입하여 한 달 조금 넘게 사용한 <a href="https://ko.duetdisplay.com/">Duet 디스플레이</a>에 대한 후기를 공유한다.</p><br><h3 id="1-Price"><a href="#1-Price" class="headerlink" title="1. Price"></a>1. Price</h3><p><img src="https://lh3.googleusercontent.com/qry_vMOZyJrr3jn4EdZl0DHvHyqp4nI6TJAHt1P7E0Cq9aYTeb4MXlu9GwbHzigWLZK_IIWFjSue2UPEZCHEYEe024qP7cAi2KsEL1bv7iXgNFDd5W2pUQ-qTR-bE-Q5ivOp1vl0dVuiKKEQFwE1aumdMAqlX8gTPfFeH8UAnz4Jg2xS_1NmTemkywT1p2zMQrF2XC6nnEex8aikI1ZVeVKDpCoDDUkCoJSnachIOYtTDwB5Oi4pctKFuguUR55tMf7qp54FsajdwvqlwAM-W4Lps0eue8X7HckOcqZrMhbTVd6u7EUqO8Sum1-QUBYRwtICyTtPTkUFwqKJGiOl0O_As4t6pK0vnHmy94ENEvUrdA4bHlppRABG_lXOi4tHBuiFjgYqTiFH9w3V4bJWYfJ5GFJ2tV4gnL4_nfdByEQ9sizVDl0W7I98puGB_lFWb__yX-8tAYhLVpN-1_vlE5EJ1Z-uOCmW0asPkb84lLGAnOotqA-fhrUQZm97l4AHkepq-3voz9sDd7q8_VKe87PQ3iwVqgHBhNRNkzgCsNkLDyOUdHs0emDm3dLshc04BKTfHR5SZ-SftqVo6IMcV5Jl3gX70iIzK2Zj0vBcUfiI1SZLP95j9WTXShy63GUqV-6zAs5Fet9zrhcW3ai-OzeodlkhpT_7U9IuzjGPOBjbRfFfL4ks5q0FEuhz07VSd6qQRBpLyqfpd9pve6yB4CyOKvdcThYW04K18FBGxO7tgEcY5GmL9VpC=w466-h265-no"></p><p>앱스토에서 12,000원에 구매했다. 앱스토어가 이제 한화결제를 지원하기 때문에 국내 신용카드로 편하게 결제를 했던 기억이 난다. 모바일 앱이 12,000원이 저렴하다고 볼 순 없으나 일반적으로 앱스토어에서 인기있는 유료 아이패드앱들의 평균가격이 $10 달러 선임을 고려하면 비싸다고도 볼 수 없는 가격이다.</p><p>특히 이 제품으로 아이패드를 맥/윈도우의 외장 모니터로 만들 수 있기 때문에 휴대용 외장모니터를 이 가격에 살 수 있다면 오히려 가격 메리트가 있다고 생각한다.</p><br><h3 id="2-Resolution"><a href="#2-Resolution" class="headerlink" title="2. Resolution"></a>2. Resolution</h3><p>사실 이 앱을 알게된지 몇 년이 되었음에도 아직까지 구입하지 않은 이유 중 하나이다. 유명한 앱이긴 하나 직접 본적이 없다보니 혹시나 저화질로 재생이 미러링이 된다면, 12,000원이 아까울 것 같았기 때문이다. 그러나 지금은 후회하고 있다. <strong>처음 이 앱을 알았을 때 바로 질렀어야 한다.</strong> 앱스토어 후기는 구매내역 삭제를 요구하는 리뷰를 제외하곤 믿을만한 곳이었다.</p><p>일반 외장모니터만큼 깨끗하다고 볼 수는 없으나 후회전혀 없을만큼 아주 좋다. </p><br><h3 id="3-Input-Leg"><a href="#3-Input-Leg" class="headerlink" title="3. Input Leg"></a>3. Input Leg</h3><p>화질도 화질이지만 걱정했던건 혹시나 딜레이가 발생하진 않을까 싶었지만, 그런것도 없었다.</p><p>혹시나 Duet 구매를 고민하고 있는 분이라면 아래 녹화영상을 보고 판단바란다. </p><iframe width="560" height="315" src="https://www.youtube.com/embed/iHhs75s0h-I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br><h3 id="4-My-opinion"><a href="#4-My-opinion" class="headerlink" title="4. My opinion"></a>4. My opinion</h3><p>아주 훌륭하지만, 당신이 <strong>맥을 사용하고 있고</strong>, <strong>아이패드가 iOS13을 지원</strong>한다면 <mark>구매할 필요는 없다.</mark> 애플은 2019년 소프트웨어 업데이트를 통해 맥OS의 새로운 버전 Catalina와 아이패드의 새로운 운영체제, iOS13에서 <a href="http://www.itworld.co.kr/howto/125636">사이드카</a> 기능을 추가했다.</p><p>사이드카는 아이패드와 맥을 미러링하는, 그러니까 Duet과 완전히 같은 기능이다. </p><p>역으로 맥 사용자가 아니거나, 아이패드가 iOS13을 지원하는 모델이 아니라면, Duet 구매를 추천한다. 12,000원이 후회되지 않을거다. </p><p>난 지금도 이 글을 작성하면서 Duet으로 유튜브 영상을 보면서 작성하고 있다. ^^</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> ipad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - Date</title>
      <link href="2019/10/Java-Date/"/>
      <url>2019/10/Java-Date/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1484981184820-2e84ea0af397?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1650&q=80" width="650px" /><p>스프링으로 웹 애플리케이션을 개발해보는중 <em>‘매 접속시마다 내가 현재 창을 언제 리프레쉬 한건지 알 수 있었으면 좋겠다’</em> 싶었다. 그래서 인텔리J 콘솔에 웹 서버를 실행한 시점의 시간을 출력하도록 작성해보았는데 이 과정에서 사용한 <code>Date</code> 클래스를 간략하게 공유해본다.</p><h3 id="Date-객체-이용하여-날짜-출력하기"><a href="#Date-객체-이용하여-날짜-출력하기" class="headerlink" title="Date 객체 이용하여 날짜 출력하기"></a>Date 객체 이용하여 날짜 출력하기</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">date_tutorial</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Date date = <span class="keyword">new</span> Date();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 코드는 다음과 같은 날짜를 출력한다.</p><img src="http://www.mediafire.com/convkey/ff9e/ltldv7wa674l88lzg.jpg" /><h3 id="포맷-바꿔서-Date-출력하기"><a href="#포맷-바꿔서-Date-출력하기" class="headerlink" title="포맷 바꿔서 Date 출력하기"></a>포맷 바꿔서 Date 출력하기</h3><p>위의 방식은 <code>Date</code> 객체를 그대로 출력했다. 하지만 포맷을 내가 원하는대로 출력할 수도 있다. <code>java.text.SimpleDateFormat</code> 을 <code>import</code>해서 <code>Date</code> 객체의 인스턴스를 인자로 사용하는 <code>format</code> 객체를 이용하면 포맷을 내가 커스터마이징 할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">date_tutorial</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Date day = <span class="keyword">new</span> Date();</span><br><span class="line">    SimpleDateFormat date = </span><br><span class="line">      <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy년 MM월 dd일&quot;</span>);</span><br><span class="line">    SimpleDateFormat clock = </span><br><span class="line">      <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;a hh시 mm분 ss초&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;서버 실행한 날짜는 &quot;</span>+date.format(day));</span><br><span class="line">    System.out.println(<span class="string">&quot;서버 실행한 시각은 &quot;</span>+clock.format(day));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/78db/kx7v4ezlus1w9xnzg.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>터미널에서 디렉토리 한눈에 보기(feat.Tree)</title>
      <link href="2019/10/package-tree/"/>
      <url>2019/10/package-tree/</url>
      
        <content type="html"><![CDATA[<img src="https://www.ostechnix.com/wp-content/uploads/2017/04/sk@sk_004.png" width="500px" /><p>터미널에서 디렉토리를 보는 방법은 <code>ls -al</code> 또는 똑같은 명령어인 <code>ll</code> 로 보는 방법이 있다. </p><p><img src="http://www.mediafire.com/convkey/d516/lg7hxudekp5kvjuzg.jpg"></p><p>그러나 이 방법으로는 현재 디렉토리가 어떤 계층구조로 디렉토리 트리가 구성되어 있는지 알기어렵다. 한 번에 다른 디렉토리로 이동하기 어렵다는 이야기이다. </p><p>이를 해결할 수 있는 패키지가 Tree 패키지이다.</p><h2 id="패키지-설치"><a href="#패키지-설치" class="headerlink" title="패키지 설치"></a>패키지 설치</h2><p>Tree 패키지를 설치하려면 <a href="https://github.com/youngjinmo/TIL#homebrew">Homebrew</a>를 우선 설치해야 한다. 그리고 Homebrew를 이용해 간단히 설치할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install tree</span><br></pre></td></tr></table></figure><h2 id="Tree-로-디렉토리-확인"><a href="#Tree-로-디렉토리-확인" class="headerlink" title="Tree 로 디렉토리 확인"></a>Tree 로 디렉토리 확인</h2><img src="http://www.mediafire.com/convkey/0813/u5n9x04o217pgqezg.jpg" width="500" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>자바 실행환경 훑어보기(MacOS)</title>
      <link href="2019/10/explore-java-environment/"/>
      <url>2019/10/explore-java-environment/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1483356256511-b48749959172?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" width="650px" /><p>생활코딩의 <a href="http://java.yah.ac/">자바야학</a>을 통해서 알게되어 작성하게되었다. 현재 사용중인 맥OS에서 자바의 실행환경을 훑어보는 방법이다.</p><h3 id="1-jdk-설치-경로-확인"><a href="#1-jdk-설치-경로-확인" class="headerlink" title="1) jdk 설치 경로 확인"></a>1) jdk 설치 경로 확인</h3><p>터미널을 열어서 아래 명령어를 입력하면 jdk가 설치된 경로를 출력해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/libexec/java_home</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/ea08/q0kkesqaz03jse1zg.jpg"></p><h3 id="2-해당-경로로-이동"><a href="#2-해당-경로로-이동" class="headerlink" title="2) 해당 경로로 이동"></a>2) 해당 경로로 이동</h3><p>홈 디렉토리로 이동한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~</span><br></pre></td></tr></table></figure><p>여기서부터 콘솔에 출력된 경로를 붙여넣기해서 이동한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_202.jdk&#x2F;Contents&#x2F;Home&#x2F;bin</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/5cad/8xkh9i1dc6cdpgmzg.jpg"></p><h3 id="3-bin-디렉토리-확인"><a href="#3-bin-디렉토리-확인" class="headerlink" title="3) bin 디렉토리 확인"></a>3) bin 디렉토리 확인</h3><p>그동안 허접했지만 vi에디터로 작성해서 터미널에서 바로 컴파일하며 사용했던 패키지 <code>javac</code> 가 이곳에 있는걸 알 수 있다. 자바를 실행할 수 있는 모든 자원들이 이 디렉토리에 있는 것이다. </p><p><img src="http://www.mediafire.com/convkey/5364/oqlv6qhfj5w63u8zg.jpg"></p><p>자바의 실행환경은 이 jdk의 폴더에서도 bin 폴더를 참조?(환경변수)해서 자바의 실행환경을 구성하게된다. </p><p>윈도우 사용자는 처음 자바를 설치할 때 환경변수 설정을 수동으로 해야하지만, 맥이나 리눅스 계열은 개발자가 특별히 환경변수를 만질 필요가 없다.</p><p>그러나 만약 jdk가 제대로 실행되지 않는다면, 아래의 방법을 따라가면서 환경변수를 설정할 수 있다.</p><h3 id="4-환경변수-설정"><a href="#4-환경변수-설정" class="headerlink" title="4) 환경변수 설정"></a>4) 환경변수 설정</h3><p>홈 디렉토리에 <code>.bash_profile</code> 파일을 생성해서 환경변수를 설정한다.</p><p><strong>.bash_profile 파일 생성</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim ~&#x2F;.bash_profile</span><br></pre></td></tr></table></figure><p><strong>환경변수 설정</strong></p><p><img src="http://www.mediafire.com/convkey/9c47/72rgs6vp6y8iznqzg.jpg"></p><p><mark>그러나 맥에서는 환경설정을 할 필요가 없다는 사실을 다시 한 번 알아두자.</mark></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WeeklyReview - 10월 3주차</title>
      <link href="2019/10/WeeklyReview-2019-Oct-Third/"/>
      <url>2019/10/WeeklyReview-2019-Oct-Third/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/a83f/hvbov0k4b1iwdh9zg.jpg" width="650px" /><ul><li><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#read">무엇을 읽었는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#todo">다음주엔 무엇을 하겠는가</a></li></ul><br></li></ul><h2 id="무엇을-했는가"><a href="#무엇을-했는가" class="headerlink" title="무엇을 했는가"></a><a name="did"></a>무엇을 <span style="color:red">했는가</span></h2><p>TIL을 매일 하는데 실패하고 있다. 주말이 관건이다.. 일주일에 딱 한번 데이트를 하곤 하는데, 아침에 원격으로 스터디를 하고 바로 노원에서 데이트를 하고 집에오니 이 시간동안 TIL을 하기 어려웠다는 불필요한 핑계를 나도 모르게 늘어놓고 있다….</p><p>지난주 TIL까지는 위클리 리뷰에 적어두곤 했는데, 이렇게하니까 내가 언제 무엇을 공부했는지 알기 어려웠다. 그래서 나만의 개발 지식맵(?)을 만들어 나갈겸 깃헙에 레포를 새로 만들어두고 카테고리별로 해두고 커밋단위로 <a href="https://github.com/youngjinmo/TIL">TIL</a>을 진행하는 것으로 바꾸었다. 이렇게 하면 각 영역별로 내가 무엇을 얼마나 아는지도 알 수 있고, 커밋 메세지를 통해 언제 무엇을 공부했는지도 알 수 있기 때문이다. </p><p>지난주 <a href="https://youngjinmo.github.io/2019/10/WeeklyReview-2019-Oct-Second/">위클리 리뷰</a>에서 주말 스터디에 대한 걱정을 했는데, 일단 첫 원격 스터디는 무사히 진행이 되었다. 어처구니 없는 일이 하나 있었는데, 하필 원격 스터디가 예정된 날의 바로 전날 밤(토요일 밤)에 집의 인터넷이 고장나버렸다. 일요일 아침에 원격으로 스터디를 하고, 바로 여자친구에게 가야하는데, 하필 이런 날 집에서 인터넷 사용이 어려워져서 아침부터 부리나케 카페를 가야만했다.</p><p>참고로 4명중 한명은 C# 개발자로 취업하면서 스터디를 나갔다. 그래서 앞으로 3명이서 해야하는데, 나머지 한 명이 회사 사정으로 참석을 못하면서 이번엔 2명이서 원격으로 진행했다. 카페에 도착해서 행아웃을 걸었지만, 이미 예정된 시간보다 15분이 늦었다. 여기에 상대가 마이크 이슈로 인해 셋팅을 이것저것 만져보느라 또 다시 15분이 늦어지며 예정된 시간보다 30분이 지연된채로 원격 스터디는 진행되었다. </p><p>결과적으로 나쁘지는 않았다. 함께 스터디를 한 사람이 용인에 사는 사람인데 그동안 강남쪽으로 부르는게 부담스러웠는데 서로 편하고 좋았다. 또 기취업자기 때문에 회사경험을 사례로 이야기를 해준덕분에 미취업자인 나한텐 도움이 될 것 같다.</p><p>다만 앞으로 2명이서 스터디할 날이 왠지 많아질 것 같은 느낌이 들곤하는데, 2명보다는 자주 참석할 수 있는 한 명이 더 있으면 좋겠다라는 생각은 든다. 행아웃으로 진행하기 때문에 완전히 모르는 사람을 모셔오면 서로 어려울것 같고, 기존 학원 멤버들 중에 스터디에 흥미있는 사람을 더 데려올 수 있으면 좋을 것 같다.</p><p>백준 알고리즘에서 문제를 풀고있는데, 배열에서 좀 막히고 있다. 어려운 문제가 아님에도 시간이 오래걸리거나 충분한 시간을 두었음에도 불구하고 끝내 해결못할 때도 발생하다보니 좀 지치는 것 같다. 다음주에 <a href="https://programmers.co.kr/competitions/109/2019-winter-coding?utm_source=programmers&utm_medium=root_competition109&utm_campaign=competition109">윈터코딩 코딩테스트</a>가 있는데 걱정이다.</p><p>그리고 웹 서버 개발을 위해 도커환경에서 우분투를 개발해봤는데, 재밌었다. <code>apt-get</code> 패키지 매니저로 필요한 패키지들을 설치하고 셋팅했는데, 일단 단순한 정적 페이지를 출력하는데는 실패했다. 포트 번호 때문에 그런것 같다. 이후 같은 과정을 AWS로 해봤는데 개발속도가 훨씬 빨랐다. 생산성이 높았다. 도커는 도커대로 계속 연습을 해보고, AWS도 짬짬히 계속 만져봐야겠다.</p><br><h2 id="무엇을-읽었는가"><a href="#무엇을-읽었는가" class="headerlink" title="무엇을 읽었는가"></a><a name="read"></a>무엇을 <span style="color:red">읽었는가</span></h2><ul><li><a href="http://woowabros.github.io/techcourse/2019/05/02/techcourse.html">박재성 - 목적의식 있는 연습을 통한 효과적인 학습</a></li></ul><p>1기때 지원했다가 떨어졌었던, 평소 유튜브에서 재미있게 보고있는 우아한테크코스의 진행자(?) 박재성님의 블로그 포스팅 글이다. 최근에 유튜브에서 재성님께서 올리신 영상으로 스프링부트를 공부하다가 우연히 보게 된 글이다. 재성님은 익숙해질때까지 반복하라고 말씀하셨다.</p><p>일반적으로 일정 수준에 도달하기 위해서는 *”더 시간이 필요하다”*라고 이야기 하곤 하는데, 사실 시간은 아무것도 해결하지 않는다. 박재성님이 반복적으로 말씀하시는 *”반복”*이야말로 다음 스텝으로 넘어갈 수 있는 결정적인 key라고 생각한다. </p><p>평소 학습량이 부족하다고 느끼지는 않으나 학습속도(?)가 더디다는 생각이 들다보니 조바심이 들곤 하는데, 시간이 조금 더 걸릴지언정 계속 반복하고 최소한 내가 공부한 영역에서는 한 스텝이라도 올라갈 수 있도록 노력해야겠다. </p><br><ul><li><a href="https://starlakim.wordpress.com/2019/06/29/4020-%EC%9E%91%EC%97%85%EB%B2%95/">starla - 40+20 작업법</a></li></ul><p>포모도로 기법으로 시도를 하니까 분명 생산성이 높아지는듯 하나 25분 + 5분은 나에게 좀 애매한 시간분리였다. 그런데 이 글에서 제안한 40분 + 20분은 집중력을 유지하기에도 충분하고, 휴식도 충분한 시간이 주어졌다. 그래서 아침에 이 글을 읽고 오늘 바로 적용해서 해봤는데, 아직 깔끔하게 수행하고 있지는 못하나 이전보다는 40분 + 25분이 더 편했다. 의식적으로 지키기위해 노력해봐야겠다.</p><br><h2 id="무엇을-보았는가"><a href="#무엇을-보았는가" class="headerlink" title="무엇을 보았는가."></a><a name="watched"></a>무엇을 <span style="color:red">보았는가.</span></h2><ul><li><a href="https://www.youtube.com/watch?v=esHqxCKOO4E&list=LLPcDxZC4LcCBcLyA_AB8fJA&index=21&t=77s">개발왕루피 - 우아한테크코스 2기? 지원하세요. 비전공자 크루가 직접 들려주는 이야기 1편</a></li></ul><p>우아한테크코스에 관심이 많은데, 어떤 분이 어떻게 합격해서 공부하고 있을까 궁금하던 차에 발견한 유튜브 채널이다. 루피님은 우아한테크코스에서 우아한형제들의 <a href="https://www.youtube.com/watch?v=PCXlgnYekBg&t=3s">도서관리시스템을 개발</a>하셨다고 한다.</p><p>이 영상을 보니 더 하고싶은 마음이 커지면서도 자신감이 떨어지기도 했다…ㅋ 어쨋든 계속 구직은 미룰수 없는 상황이기 때문에 우아한테크코스에 지원해보고 불합격되면 바로 구직에 나설 생각이다. 합격하면 개발자로서의 가능성, 성장을 할 수 있도록 최선을 다해 볼 생각이다.</p><br><h2 id="다음주엔-무엇을-하겠는가"><a href="#다음주엔-무엇을-하겠는가" class="headerlink" title="다음주엔 무엇을 하겠는가"></a><a name="todo"></a>다음주엔 무엇을 <span style="color:red">하겠는가</span></h2><p>이번주엔 스프링부트 스터디에서 진행하고 있는 프로젝트의 개발을 본격적으로 진행할 생각이다. 그 동안 프로젝트에 필요한 개념/이론 공부를 진행했는데, 이제 개발을 할 때가 된 것 같다.</p><p>이와 함께 도커에서 그리고 AWS EC2 인스턴스에서 우분투 컨테이너 위에서 웹 애플리케이션을 구동시켜보는 것까지 테스트 해보고싶다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vim 에디터 주요 명령어</title>
      <link href="2019/10/commands-of-vim/"/>
      <url>2019/10/commands-of-vim/</url>
      
        <content type="html"><![CDATA[<img src="https://miro.medium.com/max/2220/1*VO98sILElESsQdiq1DLcZQ.png" width="650px" /><p>우분투를 쓸 일이 늘어나면서 vi 에디터를 가끔 사용하게 되는데, 이 때 익힌덕분에 코딩문제 풀 때 무거운 IDE 열지않고 그냥 iTerm 열어서 vim에디터로 코드를 작성하곤 하고 있다. 기왕쓰는거 자주사용하는 유용한 명령어를 정리해두고 사용하면 좋을 것 같아서 이 글을 작성해보았다.</p><br><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#editing">입력 명령어</a></li><li><a href="#cursor-move">커서 이동 명령어</a></li><li><a href="#save-and-quit">파일 상태 변경 명령어</a></li></ul><br><h2 id="입력-명령어"><a href="#입력-명령어" class="headerlink" title="입력 명령어"></a><a name="editing"></a>입력 명령어</h2><table><thead><tr><th>입력키</th><th>작업</th></tr></thead><tbody><tr><td>i</td><td>현재 커서의 위치에서 입력 시작</td></tr><tr><td>a</td><td>현재 커서보다 한 칸 뒤에서 입력 시작</td></tr><tr><td>A</td><td>현재 커서 위치에서 줄의 끝에서 입력 시작</td></tr><tr><td>o</td><td>현재 커서의 다음 줄에서부터 입력 시작</td></tr><tr><td>u</td><td>직전 작업 되돌리기</td></tr><tr><td>U</td><td>전체 변경사항 되돌리기</td></tr><tr><td>ESC</td><td>입력모드 종료</td></tr><tr><td>dd</td><td>커서가 있는 한 줄 삭제</td></tr><tr><td>3dd</td><td>3 줄 삭제</td></tr><tr><td>dw</td><td>커서가 있는 단어 삭제</td></tr><tr><td>4dw</td><td>4 단어 삭제</td></tr><tr><td>D</td><td>현재 커서부터 뒤의 컨텐츠 삭제 (한 줄 단위)</td></tr><tr><td>x</td><td>한 문자형(char) 삭제</td></tr><tr><td>r</td><td>한 문자형 변경</td></tr><tr><td>yw</td><td>현재 커서 위치의 단어 복사</td></tr><tr><td>y$</td><td>현재 커서 위치부터 줄의 끝까지 복사</td></tr><tr><td>yy</td><td>현재 커서가 있는 줄 전체 복사</td></tr><tr><td>yj</td><td>현재 커서의 줄과 다음 줄을 복사</td></tr><tr><td>yk</td><td>현재 커서의 줄과 앞의 줄을 복사</td></tr><tr><td>p</td><td>붙여넣기</td></tr></tbody></table><br><h2 id="커서-이동-명령어"><a href="#커서-이동-명령어" class="headerlink" title="커서 이동 명령어"></a><a name="cursor-move"></a>커서 이동 명령어</h2><table><thead><tr><th>입력키</th><th>작업</th></tr></thead><tbody><tr><td>k</td><td>↑</td></tr><tr><td>j</td><td>↓</td></tr><tr><td>h</td><td>←</td></tr><tr><td>l</td><td>→</td></tr></tbody></table><br><h2 id="파일-상태-변경-명령어"><a href="#파일-상태-변경-명령어" class="headerlink" title="파일 상태 변경 명령어"></a><a name="save-and-quit"></a>파일 상태 변경 명령어</h2><table><thead><tr><th>입력키</th><th>작업</th></tr></thead><tbody><tr><td>:w</td><td>파일 저장</td></tr><tr><td>:q</td><td>종료하기</td></tr><tr><td>:wq</td><td>저장하고 종료하기</td></tr></tbody></table><br><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><hr><ul><li><a href="https://www.guru99.com/the-vi-editor.html">Vim Text Editor with Commands: Linux/Unix Tutorial</a></li><li><a href="https://wiki.kldp.org/KoreanDoc/html/Vim_Guide-KLDP/Vim_Guide-KLDP.html">Vim 에디터 사용법</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WeeklyReview - 10월 2주차</title>
      <link href="2019/10/WeeklyReview-2019-Oct-Second/"/>
      <url>2019/10/WeeklyReview-2019-Oct-Second/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/80e7/89jfgzggjnlka4czg.jpg" width="650px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#til">한 주 간의 TIL</a></li><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#read">무엇을 읽었는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#todo">다음주엔 무엇을 하겠는가</a></li></ul><br><h2 id="한-주-간의-TIL"><a href="#한-주-간의-TIL" class="headerlink" title="한 주 간의 TIL"></a><a name="til"></a>한 주 간의 TIL</h2><details><summary>2019.10.08</summary><ul>    <li>Math 클래스를 안쓰고 반올림하는 방법</li>        <ul>            <li><img src='http://www.mediafire.com/convkey/b87f/hvb7nrdlepnmex0zg.jpg' alt='' referrerPolicy='no-referrer' /></li>      <li>Math클래스를 쓰는것보다 복잡해서 생산성은 떨어지는 방식이지만, 반올림에 대한 메카니즘(?)을 이해할 수 있었다.</li>        </ul>  <li>자바에서 문자열 <code>String</code>은 클래스였다. 원래 <code>String</code>형 변수를 선언할 때에 객체를 생성하듯이 <code>new</code> 키워드(예약어)를 사용해야 하지만 생략이 가능하다.</li>      <ul>      <li><code lang='java'>String str1 = new String(&quot;abc&quot;);</code><br><code lang='java'>String str2 = &quot;abc&quot;;</code><br><code lang='java'>boolean test = str.equals(str2);  // true</code><br></code></li>      </ul>    <li><code>git checkout</code> 은 branch가 아니라 head를 변경한다. 정확히는 head의 방향!</li>    <li><code>git reset</code> 은 head가 가리키는 branch를 변경</li>    <ul>    <li>git에선 아무것도 삭제하지 않다. 모든 기록을 저장할 뿐.</li>    <li><code>git reflog</code>를 통해 모든 활동을 확인할 수 있다. merge, checkout 등.</li>    </ul>    <li>auto-merge 되는 커밋이 많을 수록 버전관리가 잘되고 있는 것이다. 프로그래머가 직접 <code>merge</code>하는 일은 코드의 양이나 파일의 양에 따라 매우 어려운 일.</li>    <li>3-way-merge</li>    <ul>    <li>두 개의 커밋이 동일한 파일을 변경한 상태에서 <code>merge</code> 할 경우 어떤 변경사항을 새로운 커밋에 담을지 git에서 물어보는데, 이 때 두 커밋이 공통으로 바라보는 원래의 커밋 즉 BASE를 기준으로 match하는 코드와 match하지 않는 코드를 비교.</li>    <li><code>git config --global merge.conflictstyle diff3</code></li>    <li><img src="https://i.stack.imgur.com/uZDVo.png" style="zoom:80%;"></li>    </ul>    <li>웹 페이지에서 데이터 긁어오는 법 (a.k.a <code>curl</code>)</li>    <ul>    <li>CLI에서 web browser가 아니어서 데이터를 못 긁어올 경우, 클라이언트 정보를 추가해서 입력할 경우 서버를 속여서 가져올 수 있음.</li>    <li><code>curl -H "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.89 Safari/537.36" <url address></code></li></ul></ul><br></details><details><summary>2019.10.09</summary>  <ul>    <li>자바에서 문자열 비교시엔 <code>==</code> 대신 <code>equals()</code> 를 써야 한다.</li>    <li>자바에서 <code>String</code> 은 단순 데이터 타입이 아니라 클래스인데 여기서 비교 연산자 <code>==</code> 를 사용하면 값을 비교하기 앞서 클래스를 비교하기 때문에 의도한 값이 반환되지 않을 수 있다.</li>        <ul>        <li>그러나 <code>equals()</code> 를 사용하면 클래스 비교없이 값만을 비교할 수 있다.</li>    </ul>    <li>배열도 문자열 처럼 비교할 수 있다. <code>Arrays.equals(arr1, arr2)</code></li>  </ul>  <br></details><details><summary>2019.10.10</summary><ul>    <li><code>git add -f</code></li>        <ul>            <li>강제로 staging area에 올리고 싶은 파일이 있을 때, <code>-f</code> 사용.</li>            <li><code>.gitignore</code> 를 생성했는데 sourceTree에서 파일이 안보이길래 명령어 강제해서 stagaing area에 올림.</li>        </ul></ul><br></details><details><summary>2019.10.11</summary><ul>    <li><b>42 Seoul 설명회 참석</b></li>    <ul>        <li>예전에 NHN Next를 떠올리게 할만큼 매력적인 교육기관이다. 다른 것은 강사가 없고 강의가 없다는 것이다. 매주 과제가 주어지고 이를 학생들 스스로가 해결하는 과정이다. </li>    <li>교육비X, 강사X, 교재X 전통적인 교육방식의 대학과는 완전히 다른 기관이다. 정부지원으로 운영되며, 파리에 있는 <a href="https://news.joins.com/article/21965611">에꼴42</a>의 프로그램을 그대로 가져오는 프로그램이다. 이름에서 알 수 있듯 이들 독립적으로 운영되는게 아니라 이들 네트워크가 활용될 것으로 예상된다. </li>    <li>2년의 교육과정과 내 나이를 고려했을 때, 솔직히 초반만 하더라도 <i>"내가 여기 참여했을 때 충분한 가치를 얻어올 수 있을까?"</i> 라는 질문에 시원하게 YES를 못하고 있었는데 이 과정이 전달하고자 하는 가치가 수료증이 아니라 교육 그 자체에 있으며, 이로인해 열정 있는 학생들과 성장할 수 있다는 점이 내게 엄청 큰 베네핏으로 다가왔다. 현재 실력으로 SI 중소기업에 입사하는 것보다 이 과정을 이수하며 좋은 동료를 얻는 것이 비교할 수 없는 큰 가치라고 생각했다.<br>되든 안되든 무조건 지원해볼 생각이다.</li>    </ul>    <li><code>wget</code></li>        <ul>      <li>도커로 우분투 컨테이너를 생성해서 우분투 환경에서 <a href="https://youtu.be/XmaW6EyY5QI">웹서버를 구축중</a>이다. 이과정에서 알게된 명령어인데, <code>apt-get</code> 과는 좀 다른 명령어이다. <code>apt-get</code> 이 우분투 기본 패키지 매니저라면, <code>wget</code> 은 웹 상에서 파일을 다운받아올 때 쓰는 명령어라고 한다.</li>      <li>참고 문서 : <a href="https://askubuntu.com/questions/277665/apt-get-vs-wget">ask ubuntu - Apt-get vs Wget</a></li>        </ul>  <li><b>Way to install java in ubuntu</b></li>  <ol start="1">    <li>check ubuntu version</li>    <ul>      <li><code>uname -a</code></li>    </ul>    <li>get download link from oracle <a href="https://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html">old version</a></li>    <li>install java via <b>wget</b> from command line</li>    <ol start="1">      <li><code>wget --header "Cookie: oraclelicense=accept-securebackup-cookie" https://download.oracle.com/otn/java/jdk/8u202-b08/1961070e4c9b4e26a04e7f5a083f551e/jdk-8u202-linux-x64.tar.gz</code></li>    </ol>    <li><a href="https://askubuntu.com/questions/536134/install-specific-java-version-for-12-04">ask ubuntu - install specific java version for 12.04</a></li>  </ol></ul><br></details><details><summary>2019.10.12</summary><ul>    <li><b>생활코딩 강의를 통해 배운 리눅스 명령어들</b></li>    <ul>        <li><code>--help</code> & <code>man</code></li>        <ul>            <li><code>--help</code>는 궁금한 커맨드의 뒤에 붙여서 입력하면 현재 입력창에서 간단히 볼 수 있는 설명서</li>            <li><code>man</code>은 궁금한 커맨드의 앞에 붙여서 입력하면 다른 창으로 넘어가서 더 상세한 설명서를 볼 수 있음.</li>        </ul>        <li>문서에서 키워드 검색하기</li>        <ul>            <li><code>/</code>뒤에 찾고 싶은 키워드를 입력하면 현재 보고있는 문서에서 키워드를 검색해서 보여준다. 여기서 <code>N</code>을 입력하면 이동하면서 다음 키워드를 보여준다.</li>        </ul>    <li>디렉토리 계층구조 생성</li>    <ul>      <li><code>mkdir -p [directory1/directory2]</code></li>    </ul>    <li>디렉토리를 이동하지 않고도 디렉토리 내 파일확인하기</li>    <ul>      <li><code>ls -l [directory]</code></li>    </ul>    <li>내가 자주 사용하는 리눅스 명령어 조회</li>    <ul>      <li><code>history | awk '&#123;a[$2]++&#125;END&#123;for(i in a)&#123;print a[i] " "i&#125;&#125;' | sort -rn |head -10</code></li>      <li><img src="http://www.mediafire.com/convkey/3f07/dq91nnbhekt3759zg.jpg" width="450"/></li>    </ul>    </ul></ul>  <li>개발에 필요한 패키지 설치한 도커 이미지 생성하여 배포함</li>  <ul>    <li>도커헙에 있는 우분투 공식 이미지는 거의 패키지가 없다시피한 기본 이미지였다. 즉시 개발하기엔 필요한 apt-get, sudo, git, vi 등이 없어서 개발에 필요한 이들 패키지들을 설치 후, 도커 이미지로 생성하여 도커헙에 <a href="https://cloud.docker.com/repository/registry-1.docker.io/youngjindev/ubuntu-starter" >배포</a>해두었다.앞으로 우분투 웹 서버가 필요할 때 이 <a href="https://cloud.docker.com/repository/registry-1.docker.io/youngjindev/ubuntu-starter" >이미지</a>를 불러와서 개발하면 편할 것 같다.</li>  </ul>  <br></details><br><h2 id="무엇을-했는가"><a href="#무엇을-했는가" class="headerlink" title="무엇을 했는가"></a><a name="did"></a>무엇을 <span style="color:red">했는가</span></h2><ul><li><strong>자바의정석 뽀개기(?) 중</strong></li></ul><p>자바를 좀 제대로 공부하기 위해서 책을 정독…까지는 아니지만 거의 정독에 이를만큼 다시 읽고있다. 이전에는 백과사전처럼 두고 필요한것만 빼서 읽곤 했는데 그러니까 지식이 듬성듬성 채워진것 같아서 예제 코드까지 함께 상세하게 읽고 있는데 아직 챕터 3까지밖에 정리하진 못했지만 이 부분에서도 새로 알게된것들이 있어서 도움이 되고 있다. </p><p>책의 뒷부분에서는 아는 것보다 모르는 부분이 더 많기 때문에 더 도움이 될 것 같다.</p><br><ul><li><strong>이고잉님의 지옥에서 온 Git 오프라인 강의 참여</strong></li></ul><p>이고잉님이 주최하신 지옥에서 온 Git 오프라인 강의를 참석하고 왔다. 그래도 평소에 Git에 어느정도 안다고 자부했지만, 막상 강의를 들으니까 이 또한 작은 오만이었음이 금방 드러났다. <code>3-way-merge를</code> 배웠는데 아직 익숙치 않은 개념이다. 하지만 지금까지 <code>merge</code>할 때 충돌이 발생할 것을 우려해 최대한 충돌을 피하거나 <code>reset</code>을 하곤 했는데, <code>merge</code>가 어떻게 이뤄지는지 다시 배우게 된 것 같다.</p><img src="http://www.mediafire.com/convkey/ac44/3gr6x864ngxnarazg.jpg" style="zoom:50%;" /><br><ul><li><strong>42서울 설명회 참석</strong></li></ul><p><img src="http://www.mediafire.com/convkey/53ae/k0frmxq74yylbj5zg.jpg"></p><p>프랑스의 <a href="https://news.joins.com/article/21965611">에꼴42</a>를 벤치마킹한 프로그램이 한국에서도 진행한다고해서 설명회를 다녀왔다. 강사도, 교재도, 수업비도 없는 프로그램이며, 매주 과제를 수행하며 과제를 수행하기 위해 스스로 또는 협력해서 학습을 해야한다고 했다. 정해진 커리큘럼에 종속되기보다 자주적으로 학습하는 걸 좋아하는 내게 좋은 기회라는 생각이 들었다. </p><p>수능을 마친 학생들도 와서 설명회를 듣는걸보니 조금 더 이른 나이에 이런 기회가 있었으면 좋았겠다라는 생각도 들었다. 그러나 일단 지나간 시간은 어쩔수 없고, 지나간 시간 동안에도 배운게 많으므로 앞으로의 미래를 생각해보면, 1년에서 2년정도를 이 프로그램에 투자하는건 투자대비 아웃풋이 더 큰 프로그램이 될 것 같았다. 무엇보다 문턱이 낮지않기 때문에 열정적인 사람들을 많이 만날 수 있을것 같았다. 이들과 함께 성장하고 네트워크를 형성하는 일은 돈을 주고도 못하는 일이기 때문에 1-2년 투자는 아깝지 않은 투자라는 생각이 든다. 그래서 지원해보려고 한다.</p><br><ul><li><strong>주말 스터디 개편(?)</strong></li></ul><p><a href="https://youngjinmo.github.io/2019/10/WeeklyReview-2019-Oct-First/">지난 주말</a> 스터디가 열리지 않았다. 모든 멤버들로부터 스터디 약속시간의 1시간 전에 일시에 불참 통보를 받으면서 캔슬이 되었다. 솔직히 이 스터디가 유지될것 같지않았고, 여기에 리소스를 투입하는 것이 후회스러울 것 같았다. 그래도 한 번만 더 노력해보자라고 생각을 돌려보았다. </p><p>학원에서 면접 할 때 받을 수 있는 질문 중 하나로 “어려움을 어떻게 극복하였는가” 라는 질문을 받을 수 있다고 알려주셨는데, <em>‘과연 이 스터디도 쉽게 포기한다면 이 질문에 내가 어떻게 답할 수 있을까’</em> 생각해보니 내가 할 수 있는한 최선을 다해보고, 그래도 안되면 결과를 받아들이는 것으로 생각을 바꾸었다.</p><p><strong>현 스터디의 문제 그리고 해결방안.</strong></p><p>❗️우선 우리의 스터디는 테헤란로에서만 진행하고 있는데, 이곳이 접근성이 좋다기보다는 그나마 상충한 지역이 여기밖에 없었기 때문이다. 기취업자 두 사람은 대중교통 기준 테헤란로에서 1시간 거리에 거주하고 있다. 때문에 평일까지 회사일을 마치고 토요일 아침에 1시간 가량의 거리를 오는 것은 쉬운 일이 아닐거라고 판단했다. </p><ul><li>💡 오프라인을 고집하기보다 온라인 미팅을 제안했다. 오프라인만큼 학습 효율이 있을지는 모르지만 오프라인이기 때문에 발생할 수 있는 이동시간, 식사시간 등의 낭비를 절약할 수 있을거라고 생각했다. OS 제약이 없고, 무료이며 N:N 화상미팅 및 스크린 공유가 가능한 서비스가 필요했고, 이 모든 조건을 충족하는 <a href="https://hangouts.google.com/">Hangout</a>을 솔루션으로 결정했다. 다음주 주말 스터디는 Hangout으로 원격으로 진행해보기로 했다.</li></ul><p>❗️또 하나는 시간대였다. 앞서 설명했듯 평일까지 일을 마치고 주말 오전에 일시에 오는 피로감을 모르지 않다. 때문에 기취업자들을 고려하여 토요일 오전 대신 일요일 오전으로 시간대를 변경하기로 했다. 상대적으로 여유가 있을 거라고 생각했다. </p><ul><li>💡 토요일 오전 대신 일요일 오전으로 변경했다. 토요일 오전에 몰려오는 피로감을 피할 수 있고, 오전에 스터디를 마침으로써 오후엔 개인시간을 편하게 쓸 수 있다는 점 때문에 일요일로 결정했다.<br>개인적으로 평일로 제안했지만, 현재 기취업자들의 회사 특성상 랩탑 소지가 불가능하고, 회사에서 집까지의 거리를 고려했을 때 평일 회의참여 시간이 저녁 10시를 넘기는 것이 불가피하고 이는 스터디에도, 다음날 출근에도 영향을 미칠 수 있다고 판단하여 일요일 오전으로 결정했다.</li></ul><p>❗️스터디의 방향이 불명확한 것이 동기부여에 영향을 주었다고 생각했다. 백기선님 영상을 보면서 스터디의 목표를 분명하게 하는 것이 좋겠다는 생각이 들었다. 리더가 없는 스터디를 효과적으로 진행하기 위해서는 각자가 분담해서 공부한걸 리뷰하기 보다는 모두 같은 영역을 공부해서 서로 리뷰하면 토론도 할 수 있고, 이를 통해 더 단단히 배울 수 있을거라고 의견이 모였다. </p><ul><li>💡 그래서 서로 같은 영역을 공부할 수 있는 책을 선정해서 스터디를 하기로 했으며, 책은 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=7006516">토비의 스프링</a>으로 결정했다.</li></ul><p>❗️스터디에 불참하면 다른 스터디원들에게 미안해하고, 스터디에 참석한 사람들은 불참한 사람들 때문에 학습기회를 상실하는 지난 주의 경험이 다시 발생하지 않도록 하기 위해 스터디에 대한 책임을 아예 없애보려고 한다. 스터디에는 자유롭게 참석이 가능하되, 스터디에 참여하는 것이 이익이 되게끔 방향을 바꾸어보려고 한다. </p><ul><li>💡 그래서 책을 읽어보고 각자 추가로 공부를 해와서 이에 대한 리뷰를 공유하고, 한 주간 새로배운 지식을 공유하는 시간도 가져보려고 한다. 이를 통해 스터디에 참석하면 얻어가는 것이 있고, 참석하지 않으면 이를 포기하는 프레임을 갖춰보려고 한다.</li></ul><br><h2 id="무엇을-읽었는가"><a href="#무엇을-읽었는가" class="headerlink" title="무엇을 읽었는가"></a><a name="read"></a>무엇을 <span style="color:red">읽었는가</span></h2><ul><li><a href="https://blog.naver.com/ityoonha/220180863835">IT썸남썸녀 - 자바 예약어/키워드 정리</a></li></ul><p>자바의 정석을 다시 읽어보면서 자바 예약어나 키워드를 정리하면 좋겠다라는 생각이 들었는데, 역시 구글링해보니까 누가 정리해주신 글이 있었다. 일단 이 글을 보면서 책을 읽었는데 나중엔 내가 작성해서 블로그에 정리해볼 생각이다.</p><ul><li><a href="https://www.instapaper.com/read/1242049409">로지스팟 - 코드리뷰의 진짜 목적은 따로있다.</a></li></ul><p>코드리뷰에 대해 쓴 글인데, 코드리뷰를 왜 해야하는가에 대한 고찰에 가까운 글이다. </p><p>코드 리뷰는 모두가 코드를 함께 리뷰함으로써 문제를 일찍 파악하는데에 그치지않고 <mark>코드에 대한 책임을 작성자 한 사람에게만 향하지 않고, 리뷰에 참여한 모두에게 향한다는 문화</mark>를 만들 수 있다고 한다.</p><p>문화뿐 아니라 코드 리뷰를 통해 다른 사람이 작성한 코드와의 중복을 방지할 수 있다고 한다. 또 다른 사람의 코드를 리뷰함으로써 <em>‘이렇게 작성할 수 있구나’</em> 하며 배우는 부분도 크다고 한다.</p><p>코드리뷰를 시작하기 앞서 주의해야 할 점은 <mark>경력이 높은 사람이 경력이 낮은 사람을 일방적으로 알려주려고 하기보다는 모두가 똑같이 다른 사람의 코드를 통해 배울 수 있음을 인지하고 오픈된 시각에서 코드 리뷰를 해야함</mark>을 강조했다.</p><br><h2 id="무엇을-보았는가"><a href="#무엇을-보았는가" class="headerlink" title="무엇을 보았는가."></a><a name="watched"></a>무엇을 <span style="color:red">보았는가.</span></h2><ul><li><a href="https://www.youtube.com/watch?v=orv5ibWzkMg&t=4s">백기선 - 내가 컨퍼런스에 다니는 이유</a></li></ul><p>동기부여에 대한 이야기였다. 백기선님 말씀대로 정말 컨퍼런스에 다니는 사람들은 “코딩안하고 놀러다니는” 사람들이 아니라 새로운 것을 배우고, 사람들을 통해 배우려는 열망이 큰 사람들이다. 아직 큰 컨퍼런스에 참여해본적은 없지만 나도 코엑스에서 열리는 큰 컨퍼런스에 참여해서 사람들을 만나보고 싶다.</p><ul><li><a href="https://www.youtube.com/watch?v=NyhbNtOq0Bc">우아한Tech - [10분 테크토크]희봉의 웹서버 vs WAS</a></li></ul><p>영상 중 <a href="https://youtu.be/NyhbNtOq0Bc?t=411">여기</a>서부터 웹 어플리케이션과 WAS가 어떻게 동작하는지 방법을 알 수 있었다. 항상 우아한Tech로부터 많이 배우는 것 같다. 여기 크루분들도 크루들과 함께, 그리고 유튜브에 올라가는 영상을 위해 준비하면서 정말 많이 배우겠다라는 생각이들었다.</p><br><h2 id="다음주엔-무엇을-하겠는가"><a href="#다음주엔-무엇을-하겠는가" class="headerlink" title="다음주엔 무엇을 하겠는가"></a><a name="todo"></a>다음주엔 무엇을 <span style="color:red">하겠는가</span></h2><p>이번주에 알고리즘 문제를 많이 못풀었다. 이달 말에 프로그래머스에서 주관하는 윈터코딩 테스트에 신청했으니 여기에 맞춰 조금 더 많이 풀어봐야겠다. 문제만 풀기보다는 이번주부터 알고리즘을 같이 공부하면서 풀어보려고 한다. </p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - 10월 1주차</title>
      <link href="2019/10/WeeklyReview-2019-Oct-First/"/>
      <url>2019/10/WeeklyReview-2019-Oct-First/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/336f/nmroj2fu2ni0zlazg.jpg" width="600px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#read">무엇을 읽었는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#todo">다음주엔 무엇을 하겠는가</a></li></ul><hr><h2 id="무엇을-했는가"><a href="#무엇을-했는가" class="headerlink" title="무엇을 했는가"></a><a name="did"></a>무엇을 <span style="color:red">했는가</span></h2><p>평일 스터디를 통해 <a href="https://youngjinmo.github.io/2019/10/docker-image/">도커 이미지를 생성하고 배포하는 방법</a>을 배웠다. 그동안 도커 이미지를 가져와 쓰기만 해보았는데, 우분투 컨테이너에서 개발환경을 셋업하고 이미지를 배포하니까 신기했다. 아직 이를 활용하진 못했는데, 이걸 활용할 수 있는 일이 있을것 같다. 평일 스터디에서 Elastic Search라는 검색관련 기술을 쓰게될 것 같은데 아마 이 때 우리가 직접 이미지를 만들어볼 수 있을것 같다.</p><p>*’자바에 대해 내가 잘아는 것이 맞나’*라는 생각이 들어 <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=76083001">자바의 정석</a> 책을 정독하면서 이를 정리하는 작업을 하고 있다. 잘 안다고 생각했던 부분도 책을 읽어보니 이해가 부족했던 부분들이 있어서 도움이 되고 있다. 자바의 정석을 다 정리하고 나면 <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=19505747">토비의 스프링</a> 책도 읽어볼 예정이다.</p><p>주말 스터디에서 일이 발생했다. 국비지원 교육을 함께하면서 얼굴을 익힌 사람들과 하게된 스터디였는데, 이 때문인지 평일 스터디에 비해선 느슨한 감이 없지 않았다. 그런데 이번 주말 약속시간이 한 시간도 안남은 상황에서 나를 제외한 모든 멤버들로부터 불참을 통보받았다. 스터디는 자기 자신을 위해서 하는 것이므로 불참한다고 해서 누군가에게 미안할 필요는 없으나 스터디 장소에 도착해서 멤버들로부터 불참 통보를 받으니 아쉬웠던게 솔직한 감정이다.</p><p>평일 스터디에 비하면 주말 스터디는 이미 기취업자가 있다는 특징도 있다. 현재 2명이 취업상태이고, 구직을 미룬 나를 제외한 나머지 한 친구도 곧 취업을 하게 될 것 같다. 오직 스터디에만 몰두할 수 없다는건 알지만 현재 우리의 스터디가 회사와 병행 불가능한 정도는 아니라고 판단했기 때문에 난 주말 스터디에 참여하고 있는 멤버들의 동기부여가 3주도 안되어 떨어졌다고 판단했다. 그래서 어떻게 이들에게 동기부여를 할 수 있을지를 잠깐 고민했고, 고민 결과 이를 고민하지 않기로 결정했다.</p><p>스터디는 자기 자신의 목표 달성을 위해 참여하는 액티비티라고 생각한다. 회사의 일정에, 주말의 휴식에 스터디의 우선순위가 밀린다면 그 사람이 게을러서가 아니라 그만큼 이 스터디가 본인에게 가치를 전달하지 못하다고 느끼기 때문이라고 생각한다. 간절했다면 어떤 이유에서건 참여했을거라고 생각한다. 따라서 스터디의 리더도 아닌 내가 이들에게 특별히 동기부여를 제공하기 위해 노력할 필요는 없다라는 결론에 이르렀다. 동기부여에 대한 고민대신 스터디의 존속여부에 대해 다음주에 논의해야 할 것 같다. </p><!--개인적으로는 이미 평일 스터디와 주제도 겹치므로 주말 스터디를 이렇게 병행하는것보다 이 시간에 리눅스를 공부할 계획이 있다--><br><h2 id="무엇을-읽었는가"><a href="#무엇을-읽었는가" class="headerlink" title="무엇을 읽었는가"></a><a name="read"></a>무엇을 <span style="color:red">읽었는가</span></h2><ul><li><a href="https://rinae.dev/posts/how-i-use-stackoverflow-kor">rinae - [번역] 내가 StackOverflow를 사용하는방법</a></li><li><a href="https://jbee.io/essay/how_do_i_study_2/">jbee - 나는 어떻게 개발 공부를 했나, 2편</a></li><li><a href="https://junwoo45.github.io/2019-09-10-til_%ED%9B%84%EA%B8%B0/#comment-4642993656">박준우블로그 - TIL을 1년동안 진행하며</a></li></ul><p>이번주에 읽은 글들은 학습방법에 관한 글들이었다. </p><p><a href="https://rinae.dev/posts/how-i-use-stackoverflow-kor">&lt;내가 StackOverflow를 사용하는 방법&gt;</a>이라는 번역 글은 자신이 알고있는 지식을 공유함으로써, 그러니까 오픈 소스에 기여함으로써 자신을 더 나은 프로그래머로 만들어주고, 이는 커리어 향상에 도움이 된다고 하였다. 구체적으로는 다음과 같은 특징을 언급했다.</p><ul><li>두뇌 훈련</li><li>디버깅 기술 향상</li><li>새로운 언어를 배우고 자신의 진도 확인</li><li>온라인 평판</li><li>온라인 노출도</li><li>영어 공부</li></ul><p>이 글을 읽고부터 StackOverflow에서 답변을 찾지만 말고, 답변을 해야겠다라고 마음먹게 되었다. 답변을 하지 않고, 답변을 해야겠다고 마음 먹은 이유는 이 글을 읽고, StackOverflow에 접속하여 답변할 질문이 있는지 키워드 검색을 해본 결과 내가 답변할만할 질문이 없었기 때문이다…ㅋㅋ 오히려 질문과 답변을 통해 내가 더 학습해야할 것들을 확인했을뿐이다.. </p><p>아무튼 Github처럼 StackOverflow계정을 관리할 필요성을 느끼게 한 글이었다. 아직 부족하지만 앞으로는 답변가능여부와 상관없이 자주 접속해서 질문을 구경해야겠다.</p><br><p>jbee님은 **배출(Output)**에 대한 <a href="https://jbee.io/essay/how_do_i_study_2/">글</a>을 작성하셨다. 배운 것을 토대로 토이 프로젝트라도 만들어서 깃헙 저장소에 업로드하거나 블로그에 정리하는게 학습에 도움이 된다는 조언이었다. 공감이 가는 글이었다. 이런 조언은 나 역시 개발 공부를 시작하면서 가장 많이 받았던 조언이었다. </p><p>올 초까지는 프로젝트를 진행할만한 실력이 되지 않는다고 판단해서 Node.js 기반 블로그 프레임워크인 Hexo를 사용해서 깃헙 블로그를 만들어서 운영하고 있다. SEO(Search Engine optimization)를 어떻게 하는지 몰라서 <a href="https://futurecreator.github.io/2016/06/15/hexo-google-site-search-console-analytics/">이 글</a>을 읽고 플러그인만 설치해두었는데, 반년 넘게 운영했음에도 조회수는 거의 발생하지 않고 있다..ㅋㅋ 그러나 가끔 몇 분이 들어오시시고 하시고, 무엇보다 내가 보고 확인하기 때문에 소홀히 작성하진 않고 있다. ‘누군가 볼 수 있다’ 라는 것만으로 에버노트에 작성하는 것보단 긴장되고 더 시간을 써서 작성하게 되는데 이 과정에서 조금 더 공부하게 된다.</p><p>국비교육과정이 끝나고는 내가 쓸 수 있는 무언가를 만들겠다는 작은 목표로 Fitbit Clock Face를 개발해서 깃헙 저장소에 올려두었다. 날씨와 미세먼지 지수까지 보여주고 싶은데, 빠른 시일(?)내에 만들어보고싶다. 그리고 그 땐 스토어에 등록까지 해보고 싶다. </p><br><p>박준우님은 **TIL(Today I Learned)**에 대해서 작성하신 <a href="https://junwoo45.github.io/2019-09-10-til_%ED%9B%84%EA%B8%B0/#comment-4642993656">글</a>이었다. </p><p>이 글도 jbee님의 글의 연장선상에 있는 글이다. *’학습하고 배출하라.’*가 jbee님 글의 메세지였다면, 박준우님의 글은 *’꾸준히 하라’*가 메세지였다. 개인적으로는 <a href="https://apps.apple.com/kr/app/gitbingo/id1435428800?l=en">GitBingo</a>앱을 활용해서 올 초에 ‘일일커밋’을 시도해본 적이 있다. </p><img src="http://www.mediafire.com/convkey/658a/ixzk3j7z22tiu6rzg.jpg" style="zoom:80%;" /><p>1월 25일부터 시작했는데, 주말에 커밋을 하지못하는 일이 계속 발생했다. 4월부터 느슨해지면서 5월부터는 사실상 일일커밋을 포기하기에 이르렀다. 의도한건 아니었지만 Hexo 프레임워크로 블로그를 관리하는 과정에서 의미없는 커밋이 발생하기도 했다. 일일커밋때엔 색이 짙어지는 잔디밭을 보면서 뿌듯하기도 했지만, ‘매일 어떤걸 커밋해야하나’라는 부담도 있었다. </p><p>준우님의 글을 읽으면서 준우님의 경험뿐 아니라 다른 사례들도 많이 볼 수 있었는데 이 덕분에 다시동기부여를 얻게 된 것 같다. TIL을 곧 시작해보도록 해야겠다. 실패하더라도 우선 시작을 해보아야겠다.</p><br><h2 id="무엇을-보았는가"><a href="#무엇을-보았는가" class="headerlink" title="무엇을 보았는가."></a><a name="watched"></a>무엇을 <span style="color:red">보았는가.</span></h2><ul><li><a href="https://www.youtube.com/watch?v=7llL0shsbf8&list=LLPcDxZC4LcCBcLyA_AB8fJA&index=4&t=0s">백기선 - 걱정보다는 응원을! 열등감을 극복해 온 이야기</a></li></ul><p>개발 공부를 하면서 약간의 열등감이 있었다. 공부할수록 <em>‘과연 내가 할 수 있을까’</em>, <em>‘도대체 무슨 소리지..’</em> 하는 생각을 많이하곤 했다. 최근 지인으로부터 좀 더 자신감을 갖고, 목표를 낮추지 말라는 조언을 듣기도 했다. 이런 조언을 해주는 분이 있다는 게 얼마나 큰 도움이 되는지 모른다.</p><p>백기선님의 영상을 보면서 남도 아닌 나 스스로에게 지나치게 걱정하거나 열등감을 갖는대신 스스로를 응원하고 더 공부하고, 더 노력을 해야겠다. </p><p>백기선님 영상을 보면서 늘 뼈를 맞곤 했는데, 오늘은 cheering을 받은것 같아서 좀 힘이 나는 것 같다. 오늘은 어제보다, 내일은 오늘보다 더 노력하자! 그리고 스스로를 응원하자!</p><br><h2 id="다음주엔-무엇을-하겠는가"><a href="#다음주엔-무엇을-하겠는가" class="headerlink" title="다음주엔 무엇을 하겠는가"></a><a name="todo"></a>다음주엔 무엇을 <span style="color:red">하겠는가</span></h2><p>블로깅할 때 이미지를 사용하곤 하는데 이미지를 따로 로컬에 저장하지 않고 구글포토에 업로드되는 또는 unsplash에서 이미지 주소를 참조해서 쓰곤하는데, 이게 문제임을 최근에서야 알았다…(8개월정도 운영했는데..)</p><p>구글포토가 계속 이미지 주소를 바꾸는 바람에 내가 포스팅한 시점 이후에 블로그를 처음 방문한 사람은 내가 올린 이미지를 볼 수 없었다. 내가 8개월의 시간동안 몰랐던건 보통 블로그를 랩탑 웹 브라우저로 확인하는데, 여기서는 캐시 이미지를 가져왔기 때문에 내 웹브라우저에선 정상적으로 이미지를 불러오는것 같았기 때문이다. </p><p>이미지 주소가 바뀌지 않으면서, 사용료가 무료, 무료로 제공되는 저장소 용량이 충분한 새로운 저장소가 필요했는데, 구글링해서 이 조건에 부합하는 저장소를 찾았다. MediaFire라는 서비스인데, 10GB까지 무료로 사용가능하고, 구글포토처럼 이미지주소가 임의로 바뀌는 시스템이 아닌 것 같다.(써봐야 알겠지만..) 일단 다음주엔 이걸로 이미지를 전부 옮기고 그동안의 포스트에 참조한 이미지 주소를 다 변경해야 할 것 같다..</p><p>스프링 개발을 하기 전, Servlet을 다시 공부하고 정리하고 싶다. 유튜브에서 <a href="https://www.youtube.com/channel/UC5-ixpj8DioZqmrasj6Ihpw">뉴렉처</a>라는 채널을 알게되었다. 이 분이 Servlet에 대해 강의하신 영상이 있길래 이걸 보면서 다시 복습을 하려고 한다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker - 이미지 생성/배포하기</title>
      <link href="2019/10/docker-image/"/>
      <url>2019/10/docker-image/</url>
      
        <content type="html"><![CDATA[<img src="http://www.spkaa.com/wp-content/uploads/2016/03/docker-image.png" width="550px" ><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#commit">배포할 도커 이미지 생성하기</a></li><li><a href="#push">도커 이미지 배포하기</a></li></ul><br><p><a href="https://devyoungjin.github.io/2019/09/docker-intro/">이전 포스트</a>에서 도커 이미지는 컨테이너를 생성하고 실행하기 위해 필요한 요소라고 했습니다.</p><p>이번 포스트에서는 도커 이미지를 직접 생성하고 배포하는 것을 해보겠습니다.</p><br><h2 id="배포할-도커-이미지-생성하기"><a href="#배포할-도커-이미지-생성하기" class="headerlink" title="배포할 도커 이미지 생성하기"></a><a name="commit"></a>배포할 도커 이미지 생성하기</h2><p>아직 도커를 어떻게 쓰면 좋을지 모르기 때문에 <a href="#references">책</a>을 참고하여 이미지를 생성해보았습니다.</p><p>우분투를 설치해서 ubuntu 환경에 변경사항을 만들고 이를 이미지로 생성해보겠습니다.</p><p>적용할 변경사항은 아래와 같습니다.</p><ul><li>apt-get 업데이트</li><li>git 설치하기</li><li>github 프로젝트 clone 하기</li></ul><p>먼저 우분투를 이미지를 설치하겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu</span><br></pre></td></tr></table></figure><br><p>컨테이너를 생성하겠습니다.</p><p>컨테이너와 호스트OS간 82번 포트로 마주보는 “custom_ubuntu”라는 이름의 컨테이너를 생성했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker create -it --name myubuntu -p 82:82 ubuntu </span><br></pre></td></tr></table></figure><br><p>이제 생성한 컨테이너를 실행하고, bash shell 모드로 컨테이너 내부로 들어가겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker start custom_ubuntu</span><br><span class="line">$ docker exec -it custom_ubuntu bash</span><br></pre></td></tr></table></figure><p>혹시 여기서 <code>-it</code> 의 의미가 기억나지 않으신다면 <a href="https://youngjinmo.github.io/2019/09/docker-intro/#port">여기</a>서 다시 확인하실 수 있습니다 ​​🙂</p><br><p>지금부터는 컨테이너 내에 변경사항을 만드는 작업입니다. 이 부분을 건너뛰고 바로 이미지 생성하는 부분이 궁금한 분들은 여기를 <a href="#skip">클릭</a>해주세요.</p><hr><p>현재 컨테이너에서 git을 설치하려면 apt-get을 업데이트 해야합니다. 여기서 <a href="https://help.ubuntu.com/community/AptGet/Howto">apt-get(Advanced Packaging Tool)</a>이란, 우분투에서 사용가능한 패키지 매니저입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;# apt-get update </span><br></pre></td></tr></table></figure><p>패키지 매니저인 apt-get을 최신화 했으니 이제 git을 설치할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;# apt-get install git</span><br></pre></td></tr></table></figure><br><p>이제 마지막으로 Github에서 저장소를 하나 불러오겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;# mkdir project_folder &#x2F;&#x2F; 폴더 생성</span><br><span class="line">&#x2F;# cd mkdir  &#x2F;&#x2F; 디렉토리 이동 </span><br><span class="line">&#x2F;# git clone https:&#x2F;&#x2F;github.com&#x2F;autho&#x2F;project.git &#x2F;&#x2F; git clone</span><br></pre></td></tr></table></figure><br><hr><p><a name="skip"></a>원하는 변경사항을 모두 만들었으므로 현재 상태에서 이미지를 생성하겠습니다. 먼저 컨테이너에서 빠져나와서 아래 명령어를 입력해보겠습니다.</p><p>아래의 명령어는 다음과 같은 구조로 구성되어 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit &lt;option&gt; container &lt;repository&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">-a &quot;devandy&quot; \</span><br><span class="line">-m &quot;created&quot; \</span><br><span class="line">custom_ubuntu \</span><br><span class="line">custom_ubuntu:first</span><br></pre></td></tr></table></figure><p>위의 명령어는 <code>\</code> 를 통해 줄을 띄어써서 작성한 것입니다. 아래의 명령어와 정확히 일치하는 명령어입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit -a &quot;devandy&quot; -m &quot;created&quot; custom_ubuntu custom_ubuntu:first</span><br></pre></td></tr></table></figure><br><p>이제 생성된 도커 이미지를 확인해보겠습니다.</p><p><img src="http://www.mediafire.com/convkey/64b5/u77g395gzftb53ozg.jpg"></p><p>저는 위에서 언급한 변경사항을 두번으로 나눠서 적용하면서 커밋을 두번해서 두번째 TAG를 second로 두었습니다. 어쨋든 원래의 도커 이미지였던 ubuntu와 IMAGE ID도, SIZE도 다른 새로운 이미지가 생성되었음을 확인할 수 있을겁니다.</p><p>두 이미지의 용량이 다른 이유는 저희가 git을 설치하기도 했고, git 저장소를 컨테이너 내부에 설치했기 때문에 차이가 발생하고 있습니다.</p><p>생성한 이미지에서 다시 새로운 이미지를 생성하려면, 또 커밋을 하면 됩니다만 변경사항이 있을 때에만 커밋을 할 수 있습니다. 컨테이너 내부에 파일 하나라도 변경사항이 있을 때에만 커밋을 해서 새로운 이미지를 생성하는 것이 가능합니다. </p><p>저는 현재 상태에서 apt-get으로 vim을 설치하고 다시 커밋을 해보았습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit \</span><br><span class="line">-a &quot;devandy&quot;</span><br><span class="line">-m &quot;updated&quot;</span><br><span class="line">custom_ubuntu</span><br><span class="line">custom_ubuntu:third</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/cd37/h6gvz83gxzi25phzg.jpg"></p><p>vim을 설치하고 새로 생성한 이미지의 용량이 이전의 이미지 대비해서 더 커졌음을 확인하였습니다.</p><br><p>삭제하고 싶은 이미지가 있다면 IMAGE ID를 통해 삭제할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi &lt;IMAGE ID&gt;</span><br></pre></td></tr></table></figure><br><p>이미지를 생성할 때 마다 <code>sha256:</code> 로 시작하는 16진수 해시값이 콘솔창에 출력하는데 <code>docker inspect &lt;IMAGE NAME&gt;</code> 을 통해 “Layers” 를 확인해보면, 각 버전 모두에서 공통되는 해시값이 있고, 각 버전마다 하나씩의 해시값이 생성되었음을 알 수 있습니다.</p><br><h2 id="도커-이미지-배포하기"><a href="#도커-이미지-배포하기" class="headerlink" title="도커 이미지 배포하기"></a><a name="push"></a>도커 이미지 배포하기</h2><p><u>배포는 아니지만</u> 현재의 <strong>이미지를 파일로 추출</strong>하는 방법도 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o myubuntu.tar custom_ubuntu:third</span><br></pre></td></tr></table></figure><p>이렇게 하면 <code>.tar</code> 를 확장자로 갖는 압축파일이 생성됩니다. 디렉토리를 설정하지 않았을 때 저의 경우(Mac OS: Catalina)는 /Documents 에 압축파일이 생성되었습니다.</p><p>이 파일로 도커 이미지를 불러오려면 아래의 명령어로 불러올 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i myubuntu.tar</span><br></pre></td></tr></table></figure><br><p>이제 진짜 **<u>이미지를 배포</u>**해보겠습니다.</p><p>도커 이미지를 배포하는 방법으로는 도커 허브<a href="https://dockerhub.com/">(dockerhub.com)</a>를 이용하는 것과 사설 레지스트리를 이용하는 방법이 있다고 합니다. 사설 레지스트리의 경우 회사 내부망을 의미하는 것 같습니다. 저는 도커 허브를 통해 도커 이미지를 배포해보겠습니다.</p><p>도커허브에 접속해서 <strong>create repository</strong>를 클릭하면 다음과 같은 창을 볼 수 있습니다.</p><p><img src="http://www.mediafire.com/convkey/ad1d/0an2db9u2w8209xzg.jpg"></p><p>저는 위 이미지에서 볼 수 있듯 Github 계정 연동을 다시 해야하는 상황이어서 먼저 Github 계정을 다시 연동하고 도커허브 저장소를 생성했습니다.</p><p>도커허브에 저장소가 생겼다면, 도커 허브에 올릴 이미지를 생성해야 합니다. 형식에 맞춰 명령어를 작성해야 합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag custom_ubuntu:third youngjindev&#x2F;testrepo_ubuntu:0.0</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/9462/115lbhuxzrhk55mzg.jpg"></p><p>IMAGE ID를 보면 완전히 같은 이미지면서 이름만 다른 이미지가 생성되었음을 알 수 있습니다.</p><br><p>이제 도커 허브 서버에 로그인합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker login</span><br></pre></td></tr></table></figure><p>도커 허브에서 가입할 때 사용한 이메일과 비밀번호를 입력하면 로그인에 성공합니다.</p><p>도커 로그인 정보는 <code>/&lt;username&gt;/.docker/config.json</code> 파일에 저장됩니다.</p><br><p>이제 도커허브의 원격 저장소에 이미지를 배포하는 명령어를 입력하겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker push youngjindev&#x2F;testrepo_ubuntu:0.0</span><br></pre></td></tr></table></figure><img src="http://www.mediafire.com/convkey/4f33/7rlhkuv8i4km5przg.jpg" style="zoom:60%;" ><p>도커 허브에서 확인해보면 다음과 같이 변한걸 확인할 수 있습니다.</p><img src="http://www.mediafire.com/convkey/33e3/2pvm4s6ww14yjcazg.jpg" style="zoom:60%;" ><p>성공적으로 이미지가 <a href="https://cloud.docker.com/repository/registry-1.docker.io/youngjindev/testrepo_ubuntu">배포</a>되었습니다. 이제 <code>docker pull</code>  명령어를 통해 이를 설치할 수 있습니다.</p><p>지금까지 생성한 이미지를 모두 지우고, 터미널을 통해 제가 방금 배포한 이미지를 검색해보았습니다.</p><p><img src="http://www.mediafire.com/convkey/803c/rdeexn682osbceezg.jpg"></p><p>반가운 이미지..!! 이제 당겨오겠습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull youngjindev&#x2F;testrepo_ubuntu</span><br></pre></td></tr></table></figure><p>이렇게 하니까 이런 에러 메세지를 출력합니다..</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error response from daemon: manifest for youngjindev&#x2F;testrepo_ubuntu:latest not found: manifest unknown: manifest unknown</span><br></pre></td></tr></table></figure><p>버전을 찾을 수 없다는 내용이므로 버전까지 명확하게 입력해서 다시 시도했습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull youngjindev&#x2F;testrepo_ubuntu:0.0</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/3c3b/w3z16pf0s5incxpzg.jpg"></p><p>제가 생성하고 배포한 이미지를 성공적으로 가져온걸 확인했습니다!</p><p>테스트로 아파치 웹서버를 우분투환경에서 설치해서 이미지를 <a href="https://cloud.docker.com/repository/registry-1.docker.io/youngjindev/devandy_apache">도커 허브</a>에 배포해놓았습니다.</p><img src="https://media.giphy.com/media/4xpB3eE00FfBm/giphy.gif" width="200"><br><p><a name="references"></a><strong>참고 문서 및 도서</strong></p><hr><ul><li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=106596706">&lt;시작하세요! 도커&gt; 위키북스, 용찬호</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - 9월 4주차</title>
      <link href="2019/09/WeeklyReview-2019-Sep-Fourth/"/>
      <url>2019/09/WeeklyReview-2019-Sep-Fourth/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/d807/j7260bv9oyy16kzzg.jpg" width="650px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#learned">다음주엔 무엇을 하겠는가</a></li></ul><hr><h2 id="무엇을-했는가"><a href="#무엇을-했는가" class="headerlink" title="무엇을 했는가"></a><a name="did"></a>무엇을 <span style="color:red">했는가</span></h2><p>지난주 위클리뷰에서 스프링에 집중하기로 했다고 했다. 이렇게 하나만 집중하기로 마음먹으니 오히려 마음이 더 편해진것 같다. </p><p>스프링부트 스터디와 스프링 개념 스터디 두 가지 스터디에 참여하고 있는데, 스프링부트 스터디에서는 프로젝트 개발을 앞두고 개념을 같이 정리하고 있다. 이번주에는 도커의 간략한 사용법과 Git, 그리고 IoC/DI에 대해 각자 준비해서 리뷰했다. 나는 이번주에 <a href="https://youngjinmo.github.io/2019/09/docker/">도커</a>를 준비해갔다. 다음주에는 도커 포트 연결하는 방법과 이미지 생성하는 법을 정리하기로했다. </p><p>Git은 그나마 조금 공부했다고 생각했는데도 깊히 파는 스터디원들과 이것저것 해보고, 의견나누는 과정에서 새로운걸 배웠다. Fork한 레파지토리를 오리지널 저장소와 동기화하는 방법은 몰랐는데, 이번에 알게되어 이것도 <a href="https://youngjinmo.github.io/2019/09/git-sync-forked-repo/">블로그</a>에 정리했다.</p><p>IoC/DI에 대해서는 설명을 들었지만 명확하게 이해하지는 못했다. 제어가 역전되는건 대충 알겠는데, “의존성”에 대해서 아직 정리가 되지 않았다. 다음주에 더 정리해준다고 하셨는데 다음 스터디 전까지 개인적으로도 공부를 해야겠다는 생각이 들었다. </p><p>국비학원 출신으로 구성된 Java/스프링 스터디(이하 주말 스터디)에서는 이번에도 많이 해보진 못했다. 준비가 부족하다는 생각이 들었다. 개인적으로는 스프팅부트 스터디가 좀 빡쌔다보니 이 스터디는 좀 설렁설렁하려고 한게 아니었나하는 반성이 들었다. 그래서 스터디의 방향을 좀 바꿔보기로 했다. 예제 수준의 10분짜리 강의영상을 2-3개 보고와서 리뷰하는 것보다 개념을 하나씩 정해서 한 주동안 공부하고 리뷰하기로 했다. 나는 다음주까지 PSA를 정리해서 리뷰하기로 하였다. </p><p>이외에도 각자 한 주간 공부하면서 알게된 팁들을 10분에서 15분간 리뷰하는 시간도 갖기로 했다. 취업자는 회사에서 배우는게 있고, 미취업자도 취업을 준비하는 과정에서 공부하게 되는게 있으니 이를 공유하면 좋겠다는 취지에서 다음주부터 시행해보기로 했다.</p><p>구직에 대해 조급한 마음이 있었는데, 이번주를 거치면서 구직을 잠시 중단하기로 했다. 급한마음에 아무데나 지원하기보다 조금 더 천천히 준비를 하고, 제대로 준비된 상황에서 자신감을 갖고 다시 구직을 해보려고 한다.</p><br><h2 id="무엇을-읽었는가"><a href="#무엇을-읽었는가" class="headerlink" title="무엇을 읽었는가"></a><a name="read"></a>무엇을 <span style="color:red">읽었는가</span></h2><ul><li><a href="https://www.instapaper.com/read/1224387991">Deep Play - 데이터베이스 정규화 1NF, 2NF, 3NF, BCNF</a><br>주말 스터디에서 다른 스터디원이 데이터베이스의 정규화에 대해 설명해주시면서 공유한 문서(블로그)이다. 중복을 제거한다는 모호한 의미만 이해하고 있었는데, 이 문서에 있는 이미지와 설명을 들으니 보다 명확하게 이해가 되었다.<br>데이터베이스 정규화는 이상현상을 제거하고 유지보수에 유리하도록 테이블을 작게작게 쪼개는 작업이다. 여기서 이상현상은 이전에 <a href="https://youngjinmo.github.io/2019/08/database-normalization/#abnormaly">블로그</a>에 정리한 바 있다.</li></ul><ul><li><p><a href="https://github.com/kazupon/git-commit-message-convention">kazupon/git-commit-message-convention</a></p><p>사실 이 글은 지난주에 읽은 글이었는데, 위클리리뷰에서 정리하지 않아 이번주에 정리해본다.<br>커밋 메세지를 작성할 때의 규칙을 정리한 문서인데, 스프링 부트 스터디에서 이 문서를 함께 읽어보면서 향후 커밋 메세지 작성할 때 우리만의 규칙을 만들기로 하였다.<br>일단 우리는 단순하게 커밋 메세지의 첫 단어는 대문자로 시작하는, 동사로 작성하고 두번째 단어에서 어떤 변경사항을 나타내는지 짧은 단어로 정리하기로 했다. 예를들면, <code>Add readme.md</code> 이렇게.</p></li></ul><br><h2 id="무엇을-보았는가"><a href="#무엇을-보았는가" class="headerlink" title="무엇을 보았는가."></a><a name="watched"></a>무엇을 <span style="color:red">보았는가.</span></h2><ul><li><a href="https://www.youtube.com/watch?v=9sSxdhYGYSM&list=LLPcDxZC4LcCBcLyA_AB8fJA&index=16&t=0s">노마드 코더 - 네, 파이썬은 C언어보다 느립니다. 컴파일 기초개념 잡아드림</a><br>이 영상을 보고 구글링을 더해서 컴파일러와 인터프리터를 <a href="https://youngjinmo.github.io/2019/09/interpreter-vs-compiler/">정리</a>해보았다.<br>정리하면, Java같은 컴파일러 언어는 컴파일러가 소스코드를 통째로 해석하고 실행파일을 생성, 이를 실행하기 때문에 생산속도는 느리지만, 실행속도가 빠르다는 특징 있다.<br>반면에 인터프리터 언어는 실행하면 그 때 실시간으로 해석하고 실행 결과를 출력하기 때문에 컴파일러 언어대비 생산속도는 빠르지만, 실행속도는 느리다는 특징이 있다.</li></ul><br><h2 id="다음주엔-무엇을-하겠는가"><a href="#다음주엔-무엇을-하겠는가" class="headerlink" title="다음주엔 무엇을 하겠는가"></a><a name="next"></a>다음주엔 무엇을 <span style="color:red">하겠는가</span></h2><ul><li>스프링부트 스터디에서 약속한 도커 이미지 생성법과 포트 사용법에 대해 정리할 예정이다.</li><li>Intelli J에서 커밋메세지를 작성하고 Git을 사용할 수 있는데 아직 한 번도 써본적이 없다. 이번주에 이걸 배워서 스터디에서는 터미널대신 인텔리J에서 커밋을 해보려고 한다.</li><li>주말 스터디 과제로 스프링의 주요 개념중 하나인 PSA 정리</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scanner 클래스의 hasNext()</title>
      <link href="2019/09/scanner-hasnext/"/>
      <url>2019/09/scanner-hasnext/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1517148815978-75f6acaaf32c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2100&q=80" width="600px" /><p><a href="https://www.acmicpc.net/problem/10951">10951번 문제</a>를 풀다가<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Scanner.html#hasNextInt--"> <code>hasNextInt()</code></a>라는 메서드를 처음 알게되었다. </p><p>Buffer를 이용해서 해결하려고 했는데, 도저히 해결할 수 없었고, 구글링해서 <code>hasNextInt()</code> 라는 함수를 알게되었다. <code>hasNext()</code>는 <code>Scanner</code>의 내장 함수인데, <strong>스캐너 객체로 데이터가 들어왔는지 여부를 반환하는 함수</strong>이다. </p><br><p><a href="https://www.acmicpc.net/problem/10951">문제</a>에 대한 정답 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(sc.hasNextInt())&#123;</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>스터디에서 코드 리뷰를 해봤는데 아직 <code>sc.nextInt()</code> 에 값이 안들어왔음에도 while문이 어떻게 동작할 수 있었는가 라는 질문이 나왔다. 그래서 인텔리J에서 함수를 클릭하여 어떻게 동작하는지를 살펴보았다.</p><p>먼저 <code>hasNextInt()</code>이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> hasNextInt(defaultRadix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위 함수는 boolean 값을 반환하는데 여기서 반환되는, 파라미터를 갖고있는 <code>hasNextInt()</code>라는 함수를 찾아보면 또 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNextInt</span><span class="params">(<span class="keyword">int</span> radix)</span> </span>&#123;</span><br><span class="line">  setRadix(radix);</span><br><span class="line">  <span class="keyword">boolean</span> result = hasNext(integerPattern());</span><br><span class="line">  <span class="keyword">if</span> (result) &#123; <span class="comment">// Cache it</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      String s = (matcher.group(SIMPLE_GROUP_INDEX) == <span class="keyword">null</span>) ?</span><br><span class="line">        processIntegerToken(hasNextResult) :</span><br><span class="line">      hasNextResult;</span><br><span class="line">      typeCache = Integer.parseInt(s, radix);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">      result = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>어떤 데이터타입이든 일단 데이터가 <code>hasNextInt()</code> 로 들어오게 되면, try catch문을 통해 예외처리를 하는 것 같다.</p><p>다시 처음 위의 <code>hasNextInt()</code> 함수에서 반환되는 boolean값의 파라미터인 defaultRadix를 확인해보면 다음과 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The default radix for this scanner</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> defaultRadix = <span class="number">10</span>;  </span><br></pre></td></tr></table></figure><p><code>Scanner</code> 객체의 기본 정수형 인자(?)인것 같다.</p><p><strong>아직 키보드가 입력받지 않았음에도 스캐너 객체가 생성될 수 있었던 이유가 defaultRadix가 10이었기 때문이었다.</strong></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git - PR하기(local-&gt;Upstream), Fetch&amp;merge하기(upstream-&gt;Local)</title>
      <link href="2019/09/git-sync-forked-repo/"/>
      <url>2019/09/git-sync-forked-repo/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1562184552-11a7e638b6f5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1051&q=80" ><p>Fork한 레파지토리(local)에서 변경사항이 발생해서 이를 오리지널 원격 저장소(upstream)에 pull request하는 방법과 오리지널 원격 저장소의 업데이트를 자신의 레파지토리(local)에 동기화하는 방법 2가지를 정리했다.</p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ol><li><p><code>pull request</code></p><ul><li><a href="#pullrequest">fork한 레파지토리의 변경사항을 원격 저장소에 반영하고 싶을 때</a></li></ul></li></ol><ol start="2"><li><p><code>merge upstream/branch</code></p><ul><li><a href="#mergeupstream">원격 저장소의 최신사항을 fork 저장소에 반영하고 싶을 때.</a></li></ul></li></ol><br><img src="http://www.mediafire.com/convkey/2b06/lqak0086qv8cp6uzg.jpg" ><p>한 가지 상황을 예로 들어보겠다.</p><p>A가 만든 원격 저장소를 B가 Fork하고, 자신의 Local repository에 Clone까지 한 상태이다. 이 상태를 기반으로 2가지 상황에 대해 정리했다.</p><br><h2 id="1-로컬-저장소-forked-➡️-원격-저장소-upstream"><a href="#1-로컬-저장소-forked-➡️-원격-저장소-upstream" class="headerlink" title="1) 로컬 저장소(forked) ➡️ 원격 저장소(upstream)"></a><a name="pullrequest"></a>1) 로컬 저장소(forked) ➡️ 원격 저장소(upstream)</h2><h3 id="로컬에서-변경사항이-발생했고-이를-오리지널-원격-레파지토리에-반영하고-싶다-pull-request"><a href="#로컬에서-변경사항이-발생했고-이를-오리지널-원격-레파지토리에-반영하고-싶다-pull-request" class="headerlink" title="로컬에서 변경사항이 발생했고, 이를 오리지널 원격 레파지토리에 반영하고 싶다 =  pull request"></a>로컬에서 변경사항이 발생했고, 이를 오리지널 원격 레파지토리에 반영하고 싶다 =  <code>pull request</code></h3><p>우선 로컬 레파지토리를 최신화한다. 커밋이 정리되었다면, 이제 원격 저장소에 동기화해야 한다. 이 때 로컬 레파지토리의 커밋 객체들이 동기화되는 대상은 위 사진 속에서 “B Remote Repo”에 해당한다. 즉 B가 A의 레파지토리를 Fork해서 생성된 B의 원격 저장소에 최신 커밋을 동기화(push)하고, 이를 원래의 저장소인 A의 원격 저장소에 pull request 를 해야한다. “A Remote Repo”에 접근권한이 B가 Fork해서 생성한 저장소에 최신 커밋을 발생시켜 이를 원격 저장소에서 받아(pull)달라고 요청(request)하는 것이다.</p><img src="http://www.mediafire.com/convkey/a89a/itwwaifhy92ajz2zg.jpg" ><p>최종적으로 A가 Merge하면 B가 작성한 커밋들이 “A Remote Repo”에도 반영된다.</p><br><h3 id="1-내-저장소에서-PR-요청"><a href="#1-내-저장소에서-PR-요청" class="headerlink" title="1. 내 저장소에서 PR 요청"></a>1. 내 저장소에서 PR 요청</h3><p>Github에 접속하면 Pull Request가 활성화되어있는 걸 확인할 수 있다.</p><p>그 왼쪽의 메세지를 읽어보면, *’이 브랜치에 10개의 커밋이 [Upstream Owner:branch]를 바라보고 있다’*고 알려주고 있다. 이는 Upstream에 PR을 보낼 수 있는 10개의 커밋이 있다는 이야기이다.</p><p><img src="https://camo.githubusercontent.com/78caf2feadb00f46c678b567d67161bec544e30e/687474703a2f2f7777772e6d65646961666972652e636f6d2f636f6e766b65792f366365372f3373776639387072706475346675377a672e6a7067"></p><h3 id="2-Upstream-저장소의-브랜치와-내-저장소의-브랜치를-맞추고-PR"><a href="#2-Upstream-저장소의-브랜치와-내-저장소의-브랜치를-맞추고-PR" class="headerlink" title="2. Upstream 저장소의 브랜치와 내 저장소의 브랜치를 맞추고 PR"></a>2. Upstream 저장소의 브랜치와 내 저장소의 브랜치를 맞추고 PR</h3><p>Upstream 저장소의 어떤 브랜치에 내 커밋을 병합(merge)할 것인지, 또 내가 보낼 커밋은 어떤 브랜치의 커밋인지를 맞춘뒤 Create pull request 버튼을 클릭하면 Merge 커밋메세지를 작성할 수 있다. Upstream의 오너가  이를 수용해서 merge하면 내가 작성한 커밋이 한꺼번에 Upstream의 브랜치에 반영된다.</p><p><img src="https://camo.githubusercontent.com/8f367e64be0d059907faf627c9e1ccd0b916e186/687474703a2f2f7777772e6d65646961666972652e636f6d2f636f6e766b65792f366263302f31766a31396e6a34796e63726c71337a672e6a7067"></p><br><h2 id="2-원격-저장소-upstream-➡️-로컬-저장소-forked"><a href="#2-원격-저장소-upstream-➡️-로컬-저장소-forked" class="headerlink" title="2) 원격 저장소(upstream) ➡️ 로컬 저장소(forked)"></a><a name="mergeupstream"></a>2) 원격 저장소(upstream) ➡️ 로컬 저장소(forked)</h2><h3 id="원래의-저장소-A-Remote-Repo-의-최신사항을-Fork한-저장소에-반영하고-싶을-때-merge-upstream-branch"><a href="#원래의-저장소-A-Remote-Repo-의-최신사항을-Fork한-저장소에-반영하고-싶을-때-merge-upstream-branch" class="headerlink" title="원래의 저장소(A Remote Repo)의 최신사항을 Fork한 저장소에 반영하고 싶을 때 =  merge upstream/branch"></a>원래의 저장소(A Remote Repo)의 최신사항을 Fork한 저장소에 반영하고 싶을 때 =  <code>merge upstream/branch</code></h3><p>이번엔 반대로 A Remote Repo에서 발생한 최신사항을 B가 사용중인 Local Repo로 최신화를 하려고 한다. </p><img src="http://www.mediafire.com/convkey/5d93/4dji2941a4935m4zg.jpg"><p>위의 명령어를 입력해서 현재 로컬 깃 저장소가 가리키는 원격 저장소를 보면 A Remote Repo가 아니라 B Remote Repo만 가리킬 것이다. B Remote Repo에서 Clone해온 저장소이기 때문이다. 따라서 현재 이 저장소의 원래 저장소가 A Remote Repo임을 가리켜야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v add upstream http:&#x2F;&#x2F;github.com&#x2F;GiyunPark&#x2F;lectureSearch.git</span><br></pre></td></tr></table></figure><img src="http://www.mediafire.com/convkey/190c/i33so3rucsy8bhfzg.jpg" ><p>이제 다시 로컬 깃 저장소가 어딜 바라보는지 확인해보자.</p><img src="http://www.mediafire.com/convkey/4db2/44c0a8enrwlfck6zg.jpg" ><p>2개의 원격 저장소를 바라보고있는걸 확인할 수 있다.</p><p>그럼 이제 남은건 로컬 저장소(B Local Repo)에서 원격 저장소(A Remote Repo)의 최신사항을 동기화하는 일만 남았다.</p><p>먼저 <code>upstream</code> 레파지토리(A Remote Repo)에서 최신사항이 있는지 <code>fetch</code> 명령어로 확인한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch upstream</span><br></pre></td></tr></table></figure><img src="http://www.mediafire.com/convkey/abd4/4jm47oq2r5icfxlzg.jpg" ><p>upstream 저장소에 최신사항이 있음을 확인했다. 이제 이를 가져오려면 먼저 최신사항을 가져올 브랜치로 이동해야 한다. 현재 브랜치에서 원격 저장소(A Remote Repo)의 최신사항을 동기화하려면 브랜치 이동을 할 필요가 없다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>본인은 로컬 깃 저장소의 master 브랜치에서 원격 저장소의 최신사항을 동기화하고 싶기 때문에 로컬 깃 저장소의 브랜치를 <code>master</code> 로 이동했다. 이제 진짜 동기화를 시작하겠다.</p><img src="http://www.mediafire.com/convkey/4d59/p7uxj6y5p0d7l0szg.jpg" ><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge upstream&#x2F;master</span><br></pre></td></tr></table></figure><img src="http://www.mediafire.com/convkey/81b7/1zwv7w7yiogtw7tzg.jpg" ><p>이제 <code>git log</code> 로 커밋 히스토리를 출력해보면 원격 저장소(A Remote Repo(의 커밋들이 내 로컬 깃 저장소(B Local Repo)에 반영되어있음을 알 수 있다.</p><br><h3 id="관련-포스트"><a href="#관련-포스트" class="headerlink" title="관련 포스트"></a>관련 포스트</h3><hr><p><a href="https://devyoungjin.github.io/2019/11/git-pull-remote-upstream-branch/">Git - Upstream 원격 저장소의 브랜치, 로컬로 불러오기</a></p><p>참고 문서</p><hr><ul><li><a href="https://help.github.com/en/articles/syncing-a-fork">https://help.github.com/en/articles/syncing-a-fork</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Docker 시작하기</title>
      <link href="2019/09/docker-intro/"/>
      <url>2019/09/docker-intro/</url>
      
        <content type="html"><![CDATA[<p>스터디원들과 공유하기 위해 여러 문서와 책을 참고하여 작성한 도커 입문서. 나도 아직 잘 모르기 때문에 시간이 되는대로 조금씩 공부해볼 생각.</p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#intro">Docker?</a></li><li><a href="#comparison">가상머신 vs 도커</a></li><li><a href="#why">그래서 왜 도커?</a></li><li><a href="#engine">도커 엔진 종류</a></li><li><a href="#install">도커 설치</a></li><li><a href="#create">도커 이미지, 그리고 컨테이너 생성</a></li><li><a href="#entering-container">bash모드로 컨테이너 진입하기</a></li></ul><br><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker?"></a><a name="intro"></a>Docker?</h1><img src="https://logz.io/wp-content/uploads/2016/01/docker-facebook.png" width="500" ><p>도커란, 리눅스 컨테이너에 여러 기능을 추가하여 컨테이너로 애플리케이션을 쉽게 사용할 수 있도록 만들어진 오픈소스 프로젝트. Go 언어로 작성되어 있으며, 2013년 3월 첫 번째 배포가 시작되었습니다.</p><img src="https://futurecreator.github.io/2018/11/16/docker-container-basics/docker-component.png" alt="http://kimstar.kr/7695/" width="500"><p>도커 관련한 프로젝트는 Docker Compose, Docker Machine, Kitematic 등이 있지만 일반적으로 도커라고 하면, Docker Engine 또는 도커 관련 모든 프로젝트를 의미한다고 합니다. 도커의 프로젝트들이 도커 엔진을 더 효율적으로 사용하기 위한 프로젝트이므로 도커 = 도커 엔진이라고 해도 무방할 것 같습니다.</p><br><h1 id="가상머신-vs-도커"><a href="#가상머신-vs-도커" class="headerlink" title="가상머신 vs 도커"></a><a name="comparison"></a>가상머신 vs 도커</h1><img src="https://images.techhive.com/images/article/2016/05/virtualization-vs-containers-100663417-large.idge.png" width="500" alt="left-VM right-Docker" ><h2 id="가상머신"><a href="#가상머신" class="headerlink" title="가상머신"></a>가상머신</h2><p>가상 머신은 Virtual Box, VM Ware 등이 대표적인데, 이런 가상 머신은 Host OS(운영체제) 위의 하이퍼바이저 위에서 독립적이고 완전한 운영체제(Guest OS)를 설치함으로써 Host OS와는 완전히 독립적인 공간과 시스템 자원을 할당받아 사용할 수 있습니다. </p><blockquote><p>여기서 **하이퍼바이저(Hypervisor)**란, 컴퓨터의 운영체제와 애플리케이션을 물리적 HW에서 분리하는 프로세스를 말한다고 합니다. 쉽게 말해 Host 컴퓨터 1대에서 다수의 운영체제를 동시에 실행할 수 있도록 하는 소프트웨어입니다.</p></blockquote><p>따라서 <strong>가상 머신의 이미지는 Guest OS를 완전히 실행가능한 라이브러리, 커널 등을 전부 포함하게 되는데 이 때문에 이미지의 크기가 크다는 단점</strong>이 있습니다.</p><br><h2 id="도커"><a href="#도커" class="headerlink" title="도커"></a>도커</h2><p>이에 반해 도커 컨테이너는 <strong>프로세스 단위의 격리환경을 만들기 때문에 성능 손실이 거의 없다</strong>고 합니다. </p><p>또한 가상 머신처럼 독립적이면서 완전한 OS 구축을 위한 많은 자원을 필요로 하지 않고, <strong>Host OS의 컴퓨팅 리소스를 공유받기 때문에 이미지 용량이 작습니다.</strong> 따라서 이미지를 만들어 배포하는 시간이나 설치 시간이 가상 머신보다 빠르다는 장점이 있습니다.</p> <br><h3 id="⭐️도커의-장점"><a href="#⭐️도커의-장점" class="headerlink" title="⭐️도커의 장점!"></a>⭐️<strong>도커의 장점!</strong></h3><p>도커의 장점을 요약해보면, 컨테이너를 이미지로 만들어 배포하는 시간이 가상머신을 통해 배포하는 것보다 빠르고 간편하며, 완전한 OS를 구축하는 것이 아닌 개발환경만을 구축할 수 있기에 팀 단위의 개발환경에서 사용이 용이하다는 장점이 있습니다. 또한 <strong>가상화 공간을 사용할 때 성능손실이 거의 없다</strong>는 것입니다.</p><br><h3 id="도커의-단점"><a href="#도커의-단점" class="headerlink" title="도커의 단점?"></a><strong>도커의 단점?</strong></h3><p>굳이 찾자면 보안의 약점을 꼽을 수 있습니다. 하이퍼바이저로 구동되는 가상 머신의 경우, 컴퓨팅 리소스를 완벽히 독립하여 사용하기 때문에 게스트 OS중 하나가 취약해지더라도 나머지 Guest OS는 영향을 받지 않습니다. 그러나 도커를 사용할 경우에는 Host OS의 컴퓨팅 리소스를 도커 엔진을 통해 컨테이너들이 공유하기 때문에 Host OS가 취약해지면, 컨테이너들도 위험에 노출되게 됩니다.</p><br><p>가상 머신과 도커를 비교하면 다음 이미지와 같습니다..ㅎ</p><img src="https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2016/10/VM-vs-Docker-What-is-Docker-Container-Edureka-1.png" width="350"><br><h1 id="그래서-왜-도커"><a href="#그래서-왜-도커" class="headerlink" title="그래서 왜 도커?"></a><a name="why"></a>그래서 왜 도커?</h1><p>개발을 하다보면 서로 다른 운영체제 버전, IDE버전, Java 버전 등 각기 다른 개발환경으로 인해 개발환경을 공유하거나 맞추는 일 또한 쉽지 않습니다. <strong>도커는 컨테이너에 필요한 애플리케이션을 설치해서 개발에 필요한 환경을 구축하고, 이 컨테이너를 이미지로 만들어 공유할 수 있습니다.</strong> 여기서 이미지는 버전관리 측면에서 볼 때 Commit과 같은 작업으로 봐도 무방할 것 같습니다. 이미지와 컨테이너에 대한 설명은 <a href="#image">아래</a>에 추가했습니다.</p><p>그리고 이를 도커 헙(Docker Hub)을 통해 공유함으로써 마치 프로젝트를 Github에 올리거나 clone할 수 있는 일을 수행할 수 있습니다.</p><p>위의 내용을 정리하면서 이를 알기 쉽게 요약한 영상이 있어 공유합니다.</p><iframe width="560" height="315" src="https://www.youtube.com/embed/tPjpcsgxgWc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br><h1 id="도커-엔진-종류"><a href="#도커-엔진-종류" class="headerlink" title="도커 엔진 종류"></a><a name="engine"></a>도커 엔진 종류</h1><p>2017년 3월부터 도커 엔진은 Docker EE(Enterprise Edition)과 Docker CE(Community Edition)으로 배포되고 있습니다. Docke EE는 기업용 솔루션이며 각종 기술 지원 및 상용 서비스 개발에 필요한 다양한 부가기능을 도커 엔진과 함께 포함하고 있습니다. Docker CE는 무료로 제공되는 도커 엔진이며 별도의 기술지원 서비스를 지원하지는 않지만 도커 엔진의 핵심 기능을 무료로 사용할 수 있는 장점이 있습니다. Docker EE와 Docker CE 모두 3개월마다 stable 버전이 릴리즈 되며, Docker CE는 edge 버전이 한 달 단위로 릴리즈됩니다.</p><br><h1 id="도커-설치"><a href="#도커-설치" class="headerlink" title="도커 설치"></a><a name="install"></a>도커 설치</h1><img src="http://apachebooster.com/kb/wp-content/uploads/2017/09/docker-container.png" width="400"><p>도커가 리눅스 컨테이너 기반 때문인지 도커의 기능을 완전하게 사용하기 위해서는 리눅스에서 사용하는 것이 가장 좋다고 합니다. 윈도우나 맥에서 사용하기 위해서는 각각의 운영체제에서 지원하는 가상화 기술을 통해 도커를 사용할 수 있습니다. </p><p>이외에도 AWS의 EC2 인스턴스를 사용해서 클라우드 환경(우분투)에서 도커를 구축할 수 있다고 합니다.</p><br><img src="https://image.slidesharecdn.com/introductiontolinuxcontainers1-150710054815-lva1-app6892/95/introduction-to-linux-containers-1-638.jpg?cb=1436507384" style="zoom:50%;" /><p align="center">출처 : <a href="https://es.slideshare.net/sssooraj/introduction-to-linux-containers">Introduction to Linux Containers</a></p>여기서 잠깐, <a name="container"></a>리눅스 컨테이너란 리눅스는 운영체제 레벨에서 가상화를 제공한다고 합니다. 그런데 운영체제를 통째로 가상화하는 방식이 아니라 <a href="https://ko.wikipedia.org/wiki/%EB%A6%AC%EB%88%85%EC%8A%A4_%EC%BB%A4%EB%84%90">리눅스 커널</a> 레벨에서 제공하는 격리된 공간으로 가상화를 제공한다고 합니다. 운영체제를 설치하지 않았기 때문에 커널 레벨에서 제공하는 이 격리된 공간을 컨테이너라고 부르는 것입니다.<p><strong>커널(Kernel)**이란 컴퓨터의 가장 기본적인 각 장치들을 관리하고 제어하기 위한 소프트웨어라고 합니다. 컴퓨터가 부팅되면서 GRUB과 같은 부트로더에 의해서 메모리로 로딩되어 **컴퓨터가 꺼질 때까지 항상 메모리에 상주해서 컴퓨터의 각 장치들을 관리하고 제어하는 역할</strong>을 합니다. (출처 : <a href="https://webdir.tistory.com/110">WEBDIR</a>)</p><p>리눅스 컨테이너는 격리된 공간만 제공할뿐 서버 운영에 필요한 부가기능이 부족했는데, 도커는 리눅스 컨테이너를 기반으로 편리하게 이미지를 관리하고 배포할 수 있도록 도와주는 것입니다.</p><br><p>도커를 실행한 후 터미널에서 <code>docker version</code>을 입력하면 설치한 도커의 클라이언트/서버 버전을 확인할 수 있습니다.</p><p><img src="http://www.mediafire.com/convkey/4ecc/5rptcf7zy3h1j8mzg.jpg"></p><br><h1 id="도커-이미지-그리고-컨테이너-생성"><a href="#도커-이미지-그리고-컨테이너-생성" class="headerlink" title="도커 이미지 그리고 컨테이너 생성"></a><a name="create"></a>도커 이미지 그리고 컨테이너 생성</h1><p><strong>도커 이미지는 컨테이너를 생성하고 실행하기 위해 필요한 요소</strong>입니다.  MySQL에서 배포한 <a href="https://hub.docker.com/_/mysql">도커 이미지</a>가 그 예입니다. 해당 이미지를 통해 컨테이너를 생성하면, MySQL를 사용할 수 있는 환경이 구축되는 것입니다. 도커 이미지 하나로 프로젝트에 따라 여러 개의 컨테이너를 생성하여 운영할 수도 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search &lt;image:tag&gt;</span><br></pre></td></tr></table></figure><p>도커를 실행한 상태에서 터미널에서 위의 명령어를 실행하면 이름에 해당하는 이미지를 찾아서 콘솔에 리스트를 출력합니다. 위의 명령어는 mysql이미지의 최신버전(<code>tag</code>)을 찾는 명령어입니다.</p><p>star가 많은 이미지일수록 신뢰가 높은 이미지라고 생각할 수 있습니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull &lt;image:tag&gt;</span><br></pre></td></tr></table></figure><p>설치하고 싶은 이미지를 찾았다면 내려받으면 됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure><p>내려받은 도커 이미지 리스트를 출력합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi &lt;image&gt;</span><br></pre></td></tr></table></figure><p>이미지를 삭제하고 싶을 때 사용합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -i -t --name &lt;container_name&gt;  -p 80:80 &lt;image:tag&gt;</span><br></pre></td></tr></table></figure><p>내려받은 이미지를 통해 컨테이너를 생성, 실행합니다. 이 때 <code>--name</code> 키워드를 통해 컨테이너의 이름을 지정할 수 있습니다.<a name="keyword"></a></p><ul><li><code>--name</code> : 컨테이너의 이름을 지정합니다.</li><li><code>-i</code> : interactive, 컨테이너의 입력 및 출력 등 <u>상호작용</u>하겠다는 키워드</li><li><code>-t</code> : pseudo-tty로 터미널과 같은 환경을 사용하겠다는 키워드</li><li><code>-p</code> : Host의 포트를 컨테이너의 포트로 오픈합니다. (listen)<ul><li><code>-p &lt;host-port&gt;:&lt;container-port&gt;</code></li><li>Host의 포트를 지정하지 않으면 임의의 포트로 할당됩니다.</li></ul></li></ul><p>도커 컨테이너는 이미지와 독립적이므로 이미지를 통해 생성한 컨테이너 A, B, C가 있다고 가정해보도록 하겠습니다. 이 때, 컨테이너 A에서 변경사항이 발생해도 컨테이너 B와 C에서는 컨테이너 A에서의 변경사항이 적용되지 않습니다. 또한 Host OS에도 영향을 주지 않는다고 합니다.</p><p>데이터베이스와 웹 서버를 구축할 때 하나의 컨테이너에서 구축할 수도 있지만, <strong>도커는 한 컨테이너에 프로세스 하나만 실행하도록 하는 것이 철학</strong>이라고 합니다. 각각의 프로세스 단위로 컨테이너로 구분하는 것이 도커의 방향인 것 같습니다.</p><p>혹시 컨테이너의 개념이 헷갈린다면 <a href="#container">여기</a>를 다시 읽어보시길 바랍니다!</p><p> <strong>현재 실행중인 컨테이너 목록</strong>을 출력합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><p><strong>생성된 모든 컨테이너 목록</strong>을 출력합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure><p>생성한 컨테이너를 시작하고, 종료하는 명령어입니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker start &lt;container_name&gt;</span><br><span class="line">$ docker stop &lt;container_name&gt;</span><br></pre></td></tr></table></figure><p><a name="remove_container"></a>컨테이너를 삭제합니다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm &lt;container_name&gt;</span><br></pre></td></tr></table></figure><br><h2 id="bash모드로-컨테이너-진입하기"><a href="#bash모드로-컨테이너-진입하기" class="headerlink" title="bash모드로 컨테이너 진입하기"></a><a name="entering-container"></a>bash모드로 컨테이너 진입하기</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it &lt;container_name&gt; bash</span><br></pre></td></tr></table></figure><p>컨테이너를 실행(<code>docker start</code>)한 뒤에 위의 명령어를 입력하면, <strong>bash shell 모드</strong>로 컨테이너 내부로 들어갈 수 있습니다. 이제 여기부터는 <a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29">리눅스 쉘 명령어(bash)</a>가 필요합니다.</p><p>여기서 <code>-it</code> 는 <a href="#keyword">여기</a>서 정리한바 있습니다.</p><p>해당 컨테이너의 os 정보를 콘솔에 출력합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;# cat &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure><p><code>exit</code> 를 입력면 컨테이너에서 빠져나올 수 있습니다.</p><p>컨테이너 내부에 들어가지 않고도 컨테이너 외부에서 컨테이너 내부로 명령어를 실행할 수도 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec &lt;container_name&gt; echo &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure><p>콘솔창에 <code>Hello World</code>가 출력됨을 확인할 수 있습니다.</p><br><hr><p><strong>참고 문서 및 도서</strong></p><ul><li><a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=106596706">&lt;시작하세요! 도커&gt; 위키북스, 용찬호</a></li><li><a href="http://pyrasis.com/Docker/Docker-HOWTO#start">pyrasis.com - Docker 기본 사용법</a></li><li><a href="https://futurecreator.github.io/2018/11/16/docker-container-basics/index.html">도커 기초 확실히 다지기, Eric Han</a></li><li><a href="https://ndb796.tistory.com/90?category=1009977">서비스 배포의 끝판왕, 도커의 개요 대해서 알아보자!, 안경잡이 개발자</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WeeklyReview - 9월 3주차</title>
      <link href="2019/09/WeeklyReview-2019-Sep-Third/"/>
      <url>2019/09/WeeklyReview-2019-Sep-Third/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/c0d3/olbuu5misq6ezrjzg.jpg" width="650px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#next">다음주엔 무엇을 하겠는가</a></li></ul><hr><h2 id="무엇을-했는가"><a href="#무엇을-했는가" class="headerlink" title="무엇을 했는가"></a><a name="did"></a>무엇을 <span style="color:red">했는가</span></h2><p>몇 번의 면접을 거치면서 스스로 자신감이 부족하다는 생각이 들었다. 솔직히 말하건대 정말 함께하고 싶은 그런 기업들이 아니었음에도 그런 기업들에서조차 난 면접에서 자신감이 부족했다. 결국 실력때문이라는 생각이 들었다. 실력을 더 키우기 위해 더 열심히 준비해야하는건 당연한데, 혼자하기보다 함께 할 사람들이 필요했다. 서로가 서로에게 동기부여가 될. 그래서 이번주에만 2개의 스터디에 참여를 결정했다. 하나는 직접 스프링 개념및 이론 목적의 스터디이고, 하나는 스프링을 활용해서 포트폴리오용 웹 어플리케이션을 만드는 프로젝트 스터디이다. 일단 한 번씩 모임이 있었기 때문에 더 해봐야 알겠지만, 함께 할 사람들을 찾았다는 것에 만족하는 한 주였다.</p><br><h2 id="무엇을-보았는가"><a href="#무엇을-보았는가" class="headerlink" title="무엇을 보았는가."></a><a name="watched"></a>무엇을 <span style="color:red">보았는가.</span></h2><iframe width="560" height="315" src="https://www.youtube.com/embed/ZMoB1SZ4Ceg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>그동안 Git을 다루면서 불필요한 커밋이 생성되곤 했었는데, 이걸 해결하는 방법을 배웠다. Git CLI에서  `git rebase -i 커밋ID` 를 입력하면, 해당 커밋ID부터 뒤의 커밋 전부의 커밋을 관리할 수 있는 화면으로 접속한다. 해당 화면에서 커밋의 순서를 바꾸거나 커밋을 합병할 수 있다.<br><h2 id="다음주엔-무엇을-하겠는가"><a href="#다음주엔-무엇을-하겠는가" class="headerlink" title="다음주엔 무엇을 하겠는가"></a><a name="next"></a>다음주엔 무엇을 <span style="color:red">하겠는가</span></h2><p>자바와 스프링에 조금 더 집중하려고 한다. 하나에만 온전히 집중해도 어려운데 내 호기심과 조급함이 더해져 이것저것하니 정작 무엇하나 완전하게 학습하는게 어려운 것 같다. 그래서 앞으로는 자바와 스프링에만 집중하고, 그외는 교양수준으로 경험하려고 한다. (예를 들면 Django) 대신 코딩테스트에 대비해서 알고리즘 문제는 매일 한문제라도 풀어보려고 할 것이다. 백준 알고리즘 사이트에서 생기초 단계부터 풀어보며 연습하고 있는데 가끔 풀어보는 실전 문제는 지금 풀어보는 문제와는 수준이 다른 문제다. 결국은 기본적인 논리로 해결하는게 아니라 알고리즘이나 자료구조에 대한 이해가 필요하기 때문에 이것들도 천천히 준비를 해야겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git - 원격저장소 Url 변경하기</title>
      <link href="2019/09/git-change-remote-branch-url/"/>
      <url>2019/09/git-change-remote-branch-url/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1499244571948-7ccddb3583f1?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2089&q=80" width="600px" /><p>이럴 일이 어느 상황에서 발생할 수 있는지 잘 모르겠으나 개인적으로는 원격 저장소와 로컬의 히스토리간의 충돌이 발생했을 때 종종 사용했다. 한 2번..? 정도 사용해본 것 같은데, 일단 알아두면 유용할 것 같아서 남겨본다.</p><p>로컬 저장소가 바라보고 있는 원격 저장소의 url을 보는 방법은 다음의 명령어로 확인가능하다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>그게 현재 로컬 저장소가 바라보는 원격 저장소의 url인데 이걸 바꾸려면 다음의 명령어로 바꿀 수 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin https://github.com/youngjinmo/youngjinmo.github.io.git</span><br></pre></td></tr></table></figure><p>저장소를 처음만들고, 원격 저장소에 지정할 때의 명령어는 아래와 같다. 아직 지정해둔 원격 저장소가 없을 때엔  <code>remote</code>와 <code>origin</code> 사이에 <code>add</code>를, 지정해둔 원격 저장소 주소를 바꾸고 싶을 땐 <code>set-url</code>을 붙이는 차이가 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/youngjinmo/youngjinmo.github.io.git</span><br></pre></td></tr></table></figure><p>그리고 변경사항을 푸쉬하면 제대로 이동되었음을 확인할 수 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>알고리즘 - 문자열 변환 연습</title>
      <link href="2019/09/Algorithms-changeLetter/"/>
      <url>2019/09/Algorithms-changeLetter/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/7754/h9b3211aheu5591zg.jpg" width="650px" /><h3 id="ToC"><a href="#ToC" class="headerlink" title="ToC"></a>ToC</h3><ol><li><a href="#quiz_01">짝수/홀수 인덱스에 따라 대소문자 변환</a></li><li><a href="#quiz_02">대소문자 서로 바꾸기</a></li><li><a href="#quiz_03">문자열 알파벳 순서대로 정렬하기</a></li><li><a href="#quiz_04">문자열 알파벳 역순으로 정렬하기</a></li></ol><br><h2 id="짝수-홀수-인덱스에-따라-대소문자-변환"><a href="#짝수-홀수-인덱스에-따라-대소문자-변환" class="headerlink" title="짝수/홀수 인덱스에 따라 대소문자 변환"></a><a name="quiz_01"></a>짝수/홀수 인덱스에 따라 대소문자 변환</h2><p>문자열을 argument로 받아서 짝수번째 문자는 대문자로, 홀수번째 문자는 소문자로 바꾸어서 다시 문자열로 반환해보았다.  </p><script src="https://gist.github.com/devyoungjin/e75f3aba19df2f686d18e9fb49f7a34f.js"></script><br><h2 id="대소문자-서로-바꾸기"><a href="#대소문자-서로-바꾸기" class="headerlink" title="대소문자 서로 바꾸기"></a><a name="quiz_02"></a>대소문자 서로 바꾸기</h2><p>이번엔 문자열을 받아서 대문자는 소문자로, 소문자는 대문자로 바꾸는 메서드를 작성했다.</p><script src="https://gist.github.com/devyoungjin/2930ada03134eb309b533e7378730031.js"></script><br><h2 id="문자열-알파벳-순서대로-정렬하기"><a href="#문자열-알파벳-순서대로-정렬하기" class="headerlink" title="문자열 알파벳 순서대로 정렬하기"></a><a name="quiz_03"></a>문자열 알파벳 순서대로 정렬하기</h2><p>문자열을 받아서 정렬을 하기 위해서 배열로 변환해야하는데, 문자형 배열(<code>char[]</code>)로 하던, 문자열 배열(<code>String[]</code>)로 하던 상관없다.</p><script src="https://gist.github.com/devyoungjin/bcb44efe4e4bd585334008ddccc2faf3.js"></script><p>위의 출력 결과를 보면 <code>HWdellloor</code>은 10글자인데, <code>length()</code>를 확인해보면 11로 출력되는걸 알 수 있다. 원래 <code>data</code>에 포함되어 있던 5번째 인덱스의 space 값이 가장 앞에 포함되어 있기 때문이다.</p><p>정렬 기준은 <a href="https://www.ascii-code.com/" target="_blank">ASCII코드</a> 테이블에 의해 정렬되는데, space 값은 32번째 ASCII코드로써 위의 문자열 문자중 가장 앞선 순서를 갖는다.</p><br><h2 id="문자열-알파벳-역순으로-정렬하기"><a href="#문자열-알파벳-역순으로-정렬하기" class="headerlink" title="문자열 알파벳 역순으로 정렬하기"></a><a name="quiz_04"></a>문자열 알파벳 역순으로 정렬하기</h2><p>문자열을 배열로 변환해서 역순으로 정렬, 다시 문자열로 반환하는 방법도 위의 문자 순서 정렬과 비슷하다. 다만 <code>Arrays.sort()</code> 에 argument로 <code>Collections.reverseOrder()</code> 를 추가해야 한다.   그럼 자동으로 역순으로 정렬된다. 간편하다!</p><p><code>Collections</code> 객체에 내장되어 있는 <code>reverseOrder()</code>를 열어서 확인해보니 아래와 같이 정리되어 있었다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reverseOrder in Collections.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Comparator&lt;T&gt; <span class="title">reverseOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script src="https://gist.github.com/devyoungjin/0a190818288088dac5ae69e0315f1cf1.js"></script>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> casting </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML - Section, Article, Div..</title>
      <link href="2019/09/HTML-Section-Article-Div/"/>
      <url>2019/09/HTML-Section-Article-Div/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/9dae/nc19g8irg0cdj40zg.jpg" /><p>구름Edu에서 인스타그램 클론 코딩 강의를 구입하여 클론 코딩을 진행중이다. CSS에 대해 깊히 알지못하다보니 CSS 파트를 따라치는 것도 쉽지는 않다. 특히 마크업 구조가 복잡해지면서 <code>&lt;div&gt;</code> 태그만 사용하면, 내가 작성한 코드임에도 불구하고 마크업의 구조를 파악하기 어려워졌다. 그러다 문득 프론트엔드 개발자의 <a href="https://www.youtube.com/watch?v=jOzR83vixsE" target="_blank">유튜브 영상</a>을 보게 되면서 HTML 작성법에 대해 다시 한 번 생각하게 되었다. </p><br><p><img src="http://www.mediafire.com/convkey/464c/4oazpyxy3udx3xyzg.jpg"></p><p>먼저 마크업 랭귀지는 브라우저에서 인식하는 언어라고 한다. 따라서 어떻게 작성하느냐에 따라 브라우저에서 받아들이는(해석) 것이 달라질수 있고, 더 나아가 <strong>검색엔진에서의 검색 결과에 영향</strong>을 미치기까지 하다. 따라서 무분별한 <code>&lt;div&gt;</code> 태그 남발보다는 컨텐츠에 맞춰 <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code>, <code>&lt;nav&gt;</code> 등의 태그를 사용하는 것이 좋다.</p><p>사용하려고보니 각각의 태그 사용법이 모호하여 이를 정리해본다.</p><br><h2>header</h2><div style="display: flex;">      <div style="float: left; width: 30%;">      <img src="http://www.mediafire.com/convkey/4e1e/i8y3hctahnvmqw0zg.jpg" alt="hearder">      </div>    <div style="float: left; flex: 50%; align-items: center; margin-left: 15px;">            문서의 header를 나타낼때 사용한다. <br>해당 웹 페이지가 어떤 웹 페이지인지를 정의하는 문서영역이 이 영역에 해당한다.    </div></div><br><h2 id="nav"><a href="#nav" class="headerlink" title="nav"></a>nav</h2><div style="display: flex;">      <div style="float: left; width: 30%;">      <img src="http://www.mediafire.com/convkey/9580/wk7bzdneme7owidzg.jpg" alt="nav">      </div>    <div style="float: left; flex: 50%; align-items: center; margin-left: 15px;">            현재 문서의 메뉴에 해당하는 영역이다.<br>다른 문서로의 이동이 필요한 링크가 이 영역에 포함될 수 있다.     </div></div><br><h2 id="div"><a href="#div" class="headerlink" title="div"></a>div</h2><p>아무 목적 없이 그냥 영역을 나눌때 사용할 수 있는 태그이다. 그렇기 때문에 편하게 사용가능하지만 되도록 목적을 갖는 영역 또는 컨텐츠 영역은 단순히 <code>&lt;div&gt;</code> 태그로 묶기 보다는 아래의 <code>&lt;section&gt;</code>, <code>&lt;article&gt;</code> 태그를 이용하는 것을 권한다. 그래야 브라우저와 검색엔진이 어떤 컨텐츠인지를 올바르게 인식할 수 있다.</p><br><h2 id="section"><a href="#section" class="headerlink" title="section"></a>section</h2><div style="display: flex;">      <div style="float: left; width: 30%;">      <img src="http://www.mediafire.com/convkey/9580/wk7bzdneme7owidzg.jpg" alt="section">      </div>    <div style="float: left; flex: 50%; align-items: center; margin-left: 15px;">            같은 성격/유형의 컨텐츠를 묶는 태그 방식이다.<br>header와 footer를 제외하면 큰 틀에서 section이 가장 큰 태그가 아닐까 싶다.    </div></div><br><h2 id="article"><a href="#article" class="headerlink" title="article"></a>article</h2><div style="display: flex;">      <div style="float: left; width: 30%;">      <img src="http://www.mediafire.com/convkey/33e8/nflcngrw3ad9q0dzg.jpg" alt="article">      </div>    <div style="float: left; flex: 50%; align-items: center; margin-left: 15px;">            section처럼 같은 성격/유형의 컨텐츠끼리 묶을 떄 사용하는 태그이다. 따라서 section태그와 헷갈릴수 있지만, article만의 특징은 <b>독립성</b>을 이야기할 수 있다.<br>article 태그 안의 컨텐츠만으로 독립이 가능한 영역이면 article 태그로 묶는다.    </div></div><br><h2 id="aside"><a href="#aside" class="headerlink" title="aside"></a>aside</h2><div style="display: flex;">      <div style="float: left; width: 30%;">      <img src="http://www.mediafire.com/convkey/20cd/9qxpk0prjsqzjhqzg.jpg" alt="aside">      </div>    <div style="float: left; flex: 50%; align-items: center; margin-left: 15px;">            한 마디로 사이드바 영역이다.<br>section이나 article보다는 nav와 비슷한 영역이 아닐까 싶다.    </div></div><br><h2>footer</h2><div style="display: flex;">      <div style="float: left; width: 30%;">      <img src="http://www.mediafire.com/convkey/28a7/ynhxqxxf1rddekxzg.jpg" alt="footer">      </div>    <div style="float: left; flex: 50%; align-items: center; margin-left: 15px;">            header가 문서를 정의하는 영역이었다면, footer는 문서 작성자에 대한 정보가 담기는 영역이다.<br>기업 홈페이지라면 이 영역에 사업자번호와 사업자대표, 사업장위치 등이 포함된다.    </div></div>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - 배열 형변환</title>
      <link href="2019/09/java-casting-array/"/>
      <url>2019/09/java-casting-array/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/15fe/ci35sgqq6b7bq9tzg.jpg" width="650px" /><p>알고리즘 문제를 풀다가 찾게되어 정리한다.</p><ol><li><code>String</code> 형을 문자열 배열(<code>String[]</code>)로 변환하는 법.</li><li><code>String</code> 형을 문자 배열(<code>Char[]</code>)로 변환하는 법.</li><li>문자열 배열(<code>String[]</code>)을 다시 <code>String</code> 형으로 변환.</li></ol><br><h2 id="문자열String-➡️-문자열-배열String"><a href="#문자열String-➡️-문자열-배열String" class="headerlink" title="문자열String  ➡️ 문자열 배열String[]"></a>문자열<code>String</code>  ➡️ 문자열 배열<code>String[]</code></h2><p>문자열(<code>String</code>)을 문자열 배열(<code>String[]</code>)로 변환하는 법은 비교적 간단하다. </p><p>내장 메서드인 <code>split(&quot;&quot;)</code> 를 사용하면 파라미터의 <code>&quot;&quot;</code> 안에 넣은 값으로 구분하여 데이터를 쪼개어 배열로 반환된다. 아래 코드에서는 <code>&quot;&quot;</code> 안에 아무것도 넣지않았으므로 문자 하나하나 쪼개어 배열로 반환할 것이다. 만약 다른 기호나 문자를 파라미터 안에 포함시키면 해당 값으로 기준으로 쪼개어 배열로 반환된다.</p><p>확인하기 위해 출력하는 방법은 두가지로 구현해보았다.</p><script src="https://gist.github.com/devyoungjin/8dcf4b120ceed2cafe385935b612f507.js"></script><br><h2 id="deepToString"><a href="#deepToString" class="headerlink" title="deepToString()"></a><code>deepToString()</code></h2><p>배열을 출력하는 방법이 또 하나가 더 있다. 내장 메서드인 <code>deepToString()</code> 메서드인데, <code>toString()</code> 과 비슷하지만 조금 다르다. <code>toString()</code>은 2차배열을 제대로 저장하지 못하지만, <code>deepToString()</code>은 2차배열까지도 저장할 수 있다. 예제 코드를 보자.</p><script src="https://gist.github.com/devyoungjin/a11125d0a0325efbc5212f08f09ea6f3.js"></script><br><h2 id="문자열String-➡️-문자열-배열-String-문자-배열char"><a href="#문자열String-➡️-문자열-배열-String-문자-배열char" class="headerlink" title="문자열String ➡️ 문자열 배열 String[], 문자 배열char[]"></a>문자열<code>String</code> ➡️ 문자열 배열 <code>String[]</code>, 문자 배열<code>char[]</code></h2><script src="https://gist.github.com/devyoungjin/0fbc29b02c8b51856b34beca2b64398e.js"></script><p>문자열을 문자 배열로 변환하는건 <code>toCharArray()</code> 만으로 가능하다. 문자열과 달리 문자 배열은 어차피 문자 단위의 데이터 타입이기 때문에 더 단순한것 같다.</p><br><h2 id="문자열-배열String-➡️-문자열String"><a href="#문자열-배열String-➡️-문자열String" class="headerlink" title="문자열 배열String[] ➡️ 문자열String"></a>문자열 배열<code>String[]</code> ➡️ 문자열<code>String</code></h2><script src="https://gist.github.com/devyoungjin/db84ddc0682a533458f7083f296d2e6a.js"></script><p>문자열 배열을 문자열로 바꾼 것이지만, 같은 방식으로 문자 배열(<code>char[]</code>)또한 문자열로 간단히 바꿀수 있다.</p><p>이걸 활용해서 문자를 바꾸는 기초 알고리즘 연습을 해보았다. <a href="https://youngjinmo.github.io/2019/09/Algorithms-changeLetter/" target="_blank">다음 포스트</a>에서 볼 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> casting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - 8월 4주차</title>
      <link href="2019/08/WeeklyReview-2019-Aug-Fourth/"/>
      <url>2019/08/WeeklyReview-2019-Aug-Fourth/</url>
      
        <content type="html"><![CDATA[<img src="https://lh3.googleusercontent.com/dceo5T01N6ELUPEtKyAChBWpOkPg1P-rEveb4Z-ogR3mGQQwEMzHRCWwNMTpsgHJUWZDRoFvn7nW2u_cT3MREPr8bA4oV1EfA6-drgQ-dTHhoL-zZzLcnfoY-IxUH4Kmv-dSvMQqfhTklsciLQM-MvNu3965FCfFbMHlVM8gP64n-oVc2N9AqxILIX1rZ_bVM5iZlANEx8--l2j-VBTaAYC7IBPAHQYYJh53bcx8r_RYs7oGITYyCANAD7cyoJKWMnnkhHUUovMnyd0F_ZwwsDhR2q7Fjob-x5bAXWyUuLzd8JKXQCzwACmcYfACi6tep6IJ0bU-IyRg8_wh4-vYcFu8IQRr8vlri7hEQqh71UF3ndNNiNJERWG8JzbecdQr09p1_B_zUnBP1GGr_TaGFUMGhcdXNNNfJqeEYIkx6d9pLbeWuRxk7WNLVcU2bqJca7C1qPMJ5kKwdfX9YHSz8e68ZkFbCi4f8zHCcgw5we91RwbE524LIhGOKyFofTWWGqnwcJ4DEuzJRC_0pS2RzUnFMUdu7xWDqsTRjXsCvv30_O8qhzQeGqziJN0zSbf6a_Ei6huehf5gqM6LnuSumeKsco6CQja4zKe-aemeBsRqxRCSlXN_-OW0cJKthUW4viHVWJHQlspNQXe4hqEBB3R_46KBUwL9LCq8zSa8TMPlweMXL1ezUV5Z5OOxIDdNZYL9E03Mx0MRvXroM-X76eM6A6mR9mQqqfe4lzrtO1EFY8hj=w960-h540-no" width="600px" alt="출처 : SpringRunner 페이스북"/><br><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#read">무엇을 읽었는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#learned">그래서 이번 한주동안 무엇을 배웠는가</a></li></ul><hr><h2 id="Things-I-did-in-this-week"><a href="#Things-I-did-in-this-week" class="headerlink" title="Things I did in this week."></a><a name="did"></a><span style="color:red">Things I did</span> in this week.</h2><p>주말 양일간 <a href="https://springrunner.io/training/mastering-spring-web-101-workshop/" target="_blank">스프링러너</a>에서 진행하는 Mastering Spring Web 101 Workshop을 듣고왔다. 처음 알게된 행사였는데, 지인으로부터 추천받아서 듣게되었다. 딱히 자격요건은 없는것 같지만, 스프링이라는 주제 특성상 재직자 대상임을 추측할 수 있었다. ‘아직 구직중인 비전공자 초짜 개발자인 내가 들어도 되나’ 했지만, 10명 모집인원중 5명까지는 EarlyBird 50% 할인이 되길래 일단 질러서 참여하게 되었다.</p><p>결론만 이야기하면 쉽지 않았다. 다른 분들은 재직자시기도 했고, 주말 본인의 시간과 비용을 들이면서까지 이런 세미나에 참석하시는 분들의 특성상(?) 실력있는 분들이 많이 계셨나보다. 쉽지 않았음에도 튜터로 행사를 주도하신 <a href="https://github.com/arawn" target="_blank">용권</a>님의 말씀처럼 스프링의 키워드를 접하고 경험할 수 있었던 좋은 경험이었다고 생각한다.</p><p>나에겐 쉽지 않은 세미나였지만, 스프링러너101은 바닥부터 시작해서 스프링의 주요 컴퍼넌트를 경험하는 세미나라고 하셨다. 이번이 3기였고, 이후 연말쯤 이 다음버전의 스프링러너201을 기획하신다고 하셨다. 혹시나 이 글을 읽으시는 분들 중 관심있는 분들은 스프링러너를 들을 수 있는 기회가 있다면 놓치지 마시라고 하고싶다.</p><p>Fitbit 앱을 개발하고 있다. Fitbit 앱은 자바스크립트로 개발해야 하는데 이것때문에 생활코딩에서 자바스크립트 기초강의를 이동중에 듣고 있다.(유튜브 프리미엄 무료체험 이후 아이패드의 활용도가 훨씬 높아졌다!) 유튜브에서 Fitbit 앱을 만드는 라이브스트림 영상을 보며 따라치고 있는데, 내가 만든 앱이나 클락 페이스를 손목위에서 보게되는 날이 벌써 기다려진다.</p><br><h2 id="Things-I-read-in-this-week"><a href="#Things-I-read-in-this-week" class="headerlink" title="Things I read in this week."></a><a name="read"></a><span style="color:red">Things I read</span> in this week.</h2><p><a href="https://brunch.co.kr/@insuk/5" target="_blank"><img src="http://www.mediafire.com/convkey/157f/8duhdcrrcz83jw0zg.jpg" width="500px" /></a></p><ul><li><a href="https://brunch.co.kr/@insuk/5" target="_blank">조인석 Chris - 애자일이 무엇인가요?</a></li></ul><p>이것 역시 스프링러너를 추천한 지인(<a href="https://ehdrjsdlzzzz.github.io/" target="_blank">블로그</a>)으로부터 추천받아 읽게된 글이다. 애자일(Agile)에 대해서 자주 들어보긴 했지만, 방법론은 그동안 비개발자인 나랑은 상관없다고 해서 그동안 미뤄두고 있던 개념이었는데 이 글 하나로 애자일에 대한 개념을 보다 쉽게 이해하고 정리할 수 있었다.</p><p>글의 본문에서 저자는 애자일에 대해 간략하게 한 문장으로 이렇게 소개한다.</p><blockquote><p>애자일은 기존에 소프트웨어 개발을 할 떄 사용하던 ‘구닥다리 일하는 방식’ 을 오랜 기간에 걸쳐 소프트웨어 제품을 만들어 오던 거장들이 소프트웨어의 소프트 한 면을 살려서 정의 한 일종의 **’유연하게 일하는 방식’**이라고 볼 수 있겠다. 애자일이란 용어 자체가 ‘기만한’, ‘재빠른’, ‘민첩한’ 이라는 뜻을 가지고 있는 것을 보았을 때, 이름 하나는 기가 막힌다.</p></blockquote><br><h2 id="Things-I-watched-in-this-week"><a href="#Things-I-watched-in-this-week" class="headerlink" title="Things I watched in this week."></a><a name="watched"></a><span style="color:red">Things I watched</span> in this week.</h2><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/qJGCmYAoOnc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>- <a href="https://www.youtube.com/watch?v=qJGCmYAoOnc" target="_blank">10만명이 쓰는 앱을 대학생때 만든 썰</a><p>프로그래밍을 빠르게 배우거나 지금보다 더 잘하기 위해서는 어떻게 해야할까? 늘 고민하는 부분인데, 입문자들의 이런 질문에 숙련자들은 “프로젝트를 하세요” 라는 대답을 항상 하곤 한다. 그럼 입문자들은 또 이렇게 질문한다. “모르는데 어떻게 해요?” .</p><p>나도 이런 입문자 중 한 사람이었는데, 영상 속 개발자는 ‘무엇이든 시작하시라’, ‘모르는건 구글이알려준다’ 라고 설득한다(?). 그래서 영상을 보다가 문득 생각했다. ‘뭘 개발해볼까..?’ 그 때 손목 위의 Fitbit이 들어왔고, 유튜브에 “How to make fitbit app” 이라는 키워드로 검색하여 나온 한시간이 넘는 영상을 보며 개발을 시작했다. </p><p>아직까지 개발중이지만, 내가 사용할 클라이언트 서비스를 개발하니 괜히 재밌다. 이제 시작한지 얼마 안되어 아직도 ‘내가 완성할 수 있을까’ 라는 불확실함이 존재하지만 그래도 재밌으니까 계속해보고 싶다. </p><br><h2 id="Things-I-learned-from-this-week"><a href="#Things-I-learned-from-this-week" class="headerlink" title="Things I learned from this week."></a><a name="learned"></a><span style="color:red">Things I learned</span> from this week.</h2><p><a href="https://springrunner.io/training/mastering-spring-web-101-workshop/" target="_blank">스프링러너</a>를 통해 스프링 주요 컴포넌트를 많이 접했다. 대부분 쓴적도없고, 모르는 것 투성이지만 이 때 배운걸 정리하려고 한다. 스프링 컴포넌트뿐 아니라 잘 정리가 되지 않았던 자바 클래스에 대해서도 함께 정리하고자 한다.</p><p>그리고 또 하나.<br>스프링러너에서는 스프링 빌드 시스템으로 Gradle을 사용했는데, 내가 학원에서 배운건 Maven이었다. Gradle은 Maven 보다 최신 빌드 시스템이라고 하는데, 난 이걸 이제서야 경험한거다. </p><p>이뿐만 아니라 스프링러너에서는 JSP가 오래된 기술이어서 실무에서 더 이상 사용하지 않는다고 했다. 내가 그동안 학원에서 배운게 길게는 8년이나 된 오래된 기술들이었고, 해당 기술을 사용하는 기업과 사용하지 않는 기업들이 명확하게 구분되는 순간이었다…</p><br><img src="http://www.mediafire.com/convkey/6cc9/mu16coo66kr3n69zg.jpg" width="400px" /><p>생활코딩 유튜브 채널을 <code>구독</code>과 <code>알림설정</code>을 하고 있는데, 며칠 전 꿀팁이 배달되어 왔다. 평소 터미널을 자주사용하면서 딱 하나 아쉬운점으로 길게 작성한 명령어를 수정하는 일이었다. 길게 작성한 명령어에서 오타가 발견되었는데 그 오타가 중간지점에서 발생하면 여지없이 다시 작성해야했는데 이제 그럴 필요가 없게 되었다. 이고잉님 말씀처럼 인생의 시간을 절약하게 될 것 같다 :)</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - 형변환</title>
      <link href="2019/08/Java-casting/"/>
      <url>2019/08/Java-casting/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/0401/gexkwf48m22b4l0zg.jpg" width="600px" /><p>이것 역시 계산기를 만들어보다가 형변환 일이 있어서 구글링을 했는데, 아예 형변환에 대해 정리해두면 좋을 것 같아 작성해보았다.</p><br><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#toint"><strong>To integer</strong></a><ul><li>Double to integer</li><li>String to integer</li><li>Char to integer</li></ul></li><li><a href="#todouble"><strong>To double</strong></a><ul><li>Integer to double</li></ul></li><li><a href="#tochar"><strong>To char</strong></a><ul><li>Integer to char</li><li>String to char</li><li>String to char Array</li></ul></li><li><a href="#tostring"><strong>To String</strong></a><ul><li>Integer to String</li><li>Double to String</li><li>Char to String</li></ul></li></ul><hr><br><h2 id="➡️-Integer"><a href="#➡️-Integer" class="headerlink" title="➡️ Integer"></a><a name="toint"></a>➡️ Integer</h2><script src="https://gist.github.com/devyoungjin/a4f8666c0c336e885c3c163d24c65e05.js"></script><p>그냥 단순히 <code>(int)b</code> 로 명시적 형변환을 하면, 값이 손실된다. 따라서 <code>Math</code> 클래스 내부함수(<code>ceil()</code>: 반올림)를 이용하여 형변환 해야한다.</p><p>String을 Integer로 바꾸는 형변환은 두 가지를 사용했다. <code>Integer.parseInt(str)</code>와 <code>Integer.valueOf(str).intValue()</code>.</p><p>그런데 위 두함수를 출력함수에 직접 넣어서 출력하면 int형으로 형변환되지 않는것으로 보인다. <code>Integer.parseInt(c)+10</code> 이 <code>100</code>으로 출력되어야 하지만, <code>9010</code>으로 출력됨을 알 수 있다.</p><p>그래서 <code>int</code>형 변수를 만들어서 형변환 함수 결과를 저장하고 이를 출력하면 연산에 사용할 수 있었다.</p><p><code>char</code>형을 <code>int</code>로 형변환하면 <code>char</code>형에 담겨있는 데이터를 <a href="https://www.ascii-code.com/" target="_blank">ASCII 코드</a>테이블에 따라서 decimal(십진법)로 변환해준다.</p><img src="http://www.mediafire.com/convkey/cb20/5rfost6mqg6drtkzg.jpg" /><br><h2 id="➡️-double"><a href="#➡️-double" class="headerlink" title="➡️ double"></a><a name="todouble"></a>➡️ double</h2><script src="https://gist.github.com/devyoungjin/c9498d280529e359fd8dec68342cf055.js"></script><p>이 경우엔 단순히 변수 앞에 <code>(double)</code>을 붙여서 강제 명시적 형변환을 해서 바꿀 수 있다. 그러나 원래 데이터 타입만 바뀌었을 뿐, 원래 데이터와 똑같은 값을 가지는걸 알 수 있다.</p><br><h2 id="➡️-char"><a href="#➡️-char" class="headerlink" title="➡️ char"></a><a name="tochar"></a>➡️ char</h2><script src="https://gist.github.com/devyoungjin/0ba974c2f18d7f7c8baae9d3c4bf1d22.js"></script><p><code>int</code>형을 <code>char</code>형으로 변환하면, <code>int</code>형 값 <a href="https://www.ascii-code.com/" target="_blank">ASCII 코드</a> 테이블에 따라 decimal에 대입하여 symbol을 출력한다.</p><img src="http://www.mediafire.com/convkey/686a/4b54fhy8ee0nkmvzg.jpg" /><p><code>String</code>을 <code>char</code>로 변환할 때엔 문자열을 인덱스마다 나눠서 <code>char</code>형으로 저장한다. <code>c.charAt(index)</code> 를 이용하면 index에 따라 문자열을 문자형으로 바꿔서 가져올 수 있다. </p><p>또 문자열 전체를 문자형(<code>char</code>) 형태로 변환하고자 한다면 문자형 배열을 만들어서 저장하는 방법이다. <code>Arrays.toString(char.toCharArray())</code></p><br><h2 id="➡️-String"><a href="#➡️-String" class="headerlink" title="➡️ String"></a><a name="tostring"></a>➡️ String</h2><script src="https://gist.github.com/devyoungjin/f90df18a4ef7773a8a3301a4e978cd99.js"></script><p>문자열(<code>String</code>)로 형변환할 때엔 <code>String.valueOf()</code> 를 사용한다. 잘 바뀌었는지 확인하기 위해 문자형(<code>char</code>) 데이터와 문자열(<code>String</code>) 데이터와 비교하여 <code>boolean</code> 값을 출력하는 테스트를 해보았다.  문자열로 형변환한 데이터와 <code>&quot;d&quot;</code>와 비교했을때 <code>true</code>, <code>&#39;d&#39;</code>와 비교했을 때 <code>false</code>를 출력한걸로 보아 성공적으로 형변환되었음을 확인하였다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> casting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java - Math Class</title>
      <link href="2019/08/java-math/"/>
      <url>2019/08/java-math/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/2e15/unhit4kki9kokw8zg.jpg" width="550px" /><p> 간단하게 <a href="https://github.com/youngjinmo/CalculatorEx" target="_blank">계산기</a> 만들어보는중에 <code>Math</code> 클래스를 사용할 일이 있어서 여기에 정리해보려고 한다.</p><p>각각의 함수를 오라클 공식 도큐먼트와 링크해두었다. 자주 사용하는 <code>Math</code> 클래스의 내부 함수이다.</p><ul><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#abs-int-" target="_blank">Math.abs( )</a></p><ul><li><code>abs</code> 함수는 모든 숫자 데이터타입을 지원한다. (int, long, float, double)</li><li>절대값을 구하는 함수</li></ul></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#ceil-double-" target="_blank">Math.ceil( )</a></p><ul><li>반올림 함수</li></ul></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#floor-double-" target="_blank">Math.floor( )</a></p><ul><li>내림 함수</li></ul></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#round-double-" target="_blank">Math.round( )</a></p><ul><li>올림 함수</li></ul></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#max-double-double-" target="_blank">max( arg1, arg2 )</a></p><ul><li>두 수중 큰 수 구하는 함수</li></ul></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#min-double-double-" target="_blank"> min( arg1, arg2 )</a></p><ul><li>두 수중 작은 수 구하는 함수</li></ul></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#pow-double-double-" target="_blank">pow( arg1, arg2 )</a></p><ul><li>num1의 num2 제곱</li></ul></li><li><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#random--" target="_blank">random( )</a></p><ul><li>1부터 10까지 수중 랜덤 수 출력하는 함수</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - 8월 3주차</title>
      <link href="2019/08/WeeklyReview-2019-Aug-Third/"/>
      <url>2019/08/WeeklyReview-2019-Aug-Third/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/af0e/8irw30yqwz30hrxzg.jpg" width="500px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#read">무엇을 읽었는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#learned">그래서 이번 한주동안 무엇을 배웠는가</a></li></ul><hr><h2 id="Things-I-did-in-this-week"><a href="#Things-I-did-in-this-week" class="headerlink" title="Things I did in this week."></a><br><a name="did"></a><span style="color:red">Things I did</span> in this week.</h2><p>월요일에 7개월간의 국비지원 교육이 끝이 났다. 처음 시작할 때엔 뭔가 대단하게 많이 배우고 실력이 엄청나게 상승할줄 알았지만, 그러지 못했다. 교육과정이 끝나갈 무렵이 되니까 마음이 다소 무거웠다. 7개월간 이것저것 많이 공부하고 나름 열심히 한다고 했지만 아쉬움이 많이 남았다.</p><p>파이널 프로젝트에서 게시판을 하나 만들었는데 이 또한 아쉬운 결과였다. 게시판 하나만 구축해보았고, 그나마 게시판도 더 하고싶은 기능이 있었지만 기한 내에 다 구현하지 못했다.ㅜㅜ 이미 프로젝트는 끝났지만, 프로젝트 레파지토리를 fork해두고 못다한 기능을 구현해야할 것 같다. </p><p>화요일엔 학원에서 진행했던 실전면접의 결과로 SI업체로부터 2차 면접을 제안받아 처음으로 개발자 면접을 보고왔다. 아직 면접 결과가 나오지 않았기 때문에 상세하게 작성할 순 없기 때문에 나중에 정리하도록 하겠다.</p><br><h2 id="Things-I-read-in-this-week"><a href="#Things-I-read-in-this-week" class="headerlink" title="Things I read in this week."></a><a name="read"></a><span style="color:red">Things I read</span> in this week.</h2><ul><li><a href="https://redgee.tistory.com/entry/asd" target="_blank">부스트 캠프 2019 참여 후기</a></li></ul><p>나도 지원했었던 부스트캠프에 대한 후기였다. 이 분이 작성한 후기를 읽으니까 내가 왜 떨어졌는지, 그리고 앞으로 알고리즘을 정말 정말 준비해야겠다는 생각을 다시 한 번 들게끔 한 글이었다.</p><p>부스트캠프의 합격한 크루들은 알고리즘 실력들이 상당하다고 한다. 참고로 글을 작성한 분의 다른 글을 읽어보니 카페24 코딩테스트에도 통과해서 신입사원 교육 프로그램도 이수중이셨던 것 같은데, 프로그램 이수를 포기하고 부스트캠프에 지원, 합격하셔서 이수한 분이다. 이 분의 글을 보면, 카페24 코딩테스트가 *’굉장히 쉬웠다’*라고 표현할만큼 실력이 있는 분이신 것 같은데, 이 분의 시선에서 실력있는 분들이 많이 계시다고 하니 어느정도 일지 감이 안선다. 후. 알고리즘.. 알고리즘.. </p><p>해야할게 점점 더 쌓이는 느낌이다.</p><br><h2 id="Things-I-watched-in-this-week"><a href="#Things-I-watched-in-this-week" class="headerlink" title="Things I watched in this week."></a><a name="watched"></a><span style="color:red">Things I watched</span> in this week.</h2><ul><li><a href="https://www.youtube.com/watch?v=mCw3PRtfHZ0" target="_blank">David Jung - 정규화</a></li></ul><iframe width="560" height="315" src="https://www.youtube.com/embed/mCw3PRtfHZ0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>학원에서 진행된 실전 면접에서 받았던 데이터베이스 정규화에 대해 알아보고자 유튜브에서 영상을 찾아보았다. 그러다 코드스쿼드의 정호영님이 정리한 영상이 있어 이걸로 <a href="https://youngjinmo.github.io/2019/08/database-normalization/" target="_balnk">공부</a>를 했다.<br><h2 id="Things-I-learned-from-this-week"><a href="#Things-I-learned-from-this-week" class="headerlink" title="Things I learned from this week."></a><a name="learned"></a><span style="color:red">Things I learned</span> from this week.</h2><p>데이터베이스 정규화를 해야하는 이유에 대해 배웠다. </p><p>정규화는 데이터의 중복 발생을 방지하고, 이상현상(abnormaly)을 방지하는 작업이다. 이상현상에는 삽입이상, 삭제이상, 갱신이상이 있다고 한다.</p><p>정규화는 크게 7단계로 구성되는데 일단 4단계까지만 생각하면, 1정규형, 2정규형, 3정규형 그리고 BCNF라고 한다.</p><img src="http://www.mediafire.com/convkey/60c6/8j5tk5ktrvpwhyzzg.jpg" width="500px" /><p>지금은 이정도로만 정리하고, 다음에 정규화에 대해 더 정리해보아야겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - 테이블 복사 및 이름변경</title>
      <link href="2019/08/oracle-rename-table/"/>
      <url>2019/08/oracle-rename-table/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/0e5a/i8npb2mn01xrrtyzg.jpg" /><blockquote><p>본 포스트는 행복안테나님의 <a href="https://blog.okno.co.kr/168JavaRa" target="_blank"> JavaRa 블로그 포스트</a>를 참고 및 인용하여 작성했습니다.</p></blockquote><p>오라클 데이터베이스를 연습해보면서 테이블을 생성할 일이 많은데, 이 때마다 데이터를 <code>insert</code> 하는게 여간 귀찮은일이 아니다. 그래서 알아보니 테이블을 복사하는 방법이 있었다.</p><p>먼저 데이터를 넣을 테이블부터 생성.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test01 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">NUMBER</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR2</span>(<span class="number">100</span>)</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test01(<span class="keyword">id</span>, <span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;DevAndy&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test01(<span class="keyword">id</span>, <span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;JavaProgrammer&#x27;</span>);</span><br></pre></td></tr></table></figure><p>위에서 생성한 <code>test01</code> 테이블과 똑같은 <code>test02</code> 테이블을 생성하겠다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test02</span><br><span class="line"><span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> * </span><br><span class="line">  <span class="keyword">FROM</span> test01</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>이렇게만 하면 <code>test01</code> 의 <a name="putback"></a>스키마 구조<a href="#schema"><sup><code>1</code></sup></a>와 데이터를 <code>test02</code> 테이블이 모두 가져와서 생성된다.</p><p>이외에도 테이블을 복사하는 방법은 몇 가지 더 있다. </p><br><ol><li>테이블의 <strong>스키마 구조</strong>만 복사하고 싶을 때.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test03</span><br><span class="line"><span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> * </span><br><span class="line">  <span class="keyword">FROM</span> test01</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="number">1</span>=<span class="number">0</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>WHERE</code> 조건이 false가 되기때문에 데이터는 못가져오고 스키마 구조만 가져올 수 있다.</p><br><ol start="2"><li>이미 만들어진 테이블에 다른 테이블에서 <strong>데이터</strong>만 가져오고 싶을 때.</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test03</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> test01;</span><br></pre></td></tr></table></figure><br><ol start="3"><li>테이블의 이름을 변경하고자 할 때</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test03</span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TO</span> test03_new;</span><br></pre></td></tr></table></figure><br><hr><a name="schema"></a> <code>1</code> <a href="https://devyoungjin.github.io/2019/08/oracle-rename-table/#putback"><b>스키마(Scheme)</b></a> : 데이터베이스의 구조와 제약조건(Constraint)에 관한 전반적인 명세.]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - 데이터 컬럼명(Attribute) 수정</title>
      <link href="2019/08/oracle-rename-column/"/>
      <url>2019/08/oracle-rename-column/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/a572/uxvuqwk1gw6hxn8zg.jpg" /><p>오라클에서 데이터 컬럼명(Attribute name)을 수정할 땐, 직접 컬럼명을 수정하는게 아니라 <u>새로운 이름의 Attribute를 생성</u>하고, <u>바꾸려고 하는 Attribute의 데이터(turple)를 새로운 Attribute으로 덮어씌우는 방식</u>을 사용한다. 마지막으로 이전의 attribute를 삭제하면된다.</p><ol><li>새로운 이름의 Attribute 생성</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [테이블 이름]</span><br><span class="line"><span class="keyword">ADD</span> [새컬럼명 데이터타입]</span><br></pre></td></tr></table></figure><ol start="2"><li>이전의 튜플을 새로운 Attribute의 튜플로 붙여넣기</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [테이블 이름]</span><br><span class="line"><span class="keyword">SET</span> [새컬럼] = [구컬럼]</span><br></pre></td></tr></table></figure><ol start="3"><li>이전 Attribute 삭제</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [테이블 이름]</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> [구컬럼]</span><br></pre></td></tr></table></figure><ol start="4"><li>조회해서 확인해보기</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC [테이블 이름] </span><br></pre></td></tr></table></figure><br><p>만약 컬럼명이 아니라 컬럼의 데이터 타입을 바꾸려면 어떻게 해야할까?</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> [테이블 이름]</span><br><span class="line"><span class="keyword">MODIFY</span> (</span><br><span class="line">[컬럼] [신규 데이터타입]</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - 기본 CRUD 쿼리</title>
      <link href="2019/08/oracle-crud/"/>
      <url>2019/08/oracle-crud/</url>
      
        <content type="html"><![CDATA[<img src="https://stefanomanfredini.info/wp-content/uploads/2017/06/crudblog.png" width="450px" /><p>테이블을 생성하는 것부터 시작해서 기본적인 데이터 삽입/조회/수정/삭제 등의 쿼리를 정리해보았다.</p><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#1">오라클 계정내 테이블 전체조회</a></li><li><a href="#2">테이블 생성하기</a></li><li><a href="#3">테이블 조회하기</a></li><li><a href="#4">시퀀스 생성하기</a></li><li><a href="#5">데이터 삽입하기</a></li><li><a href="#6">데이터 추가하기</a></li><li><a href="#7">데이터 수정하기</a></li><li><a href="#8">데이터 삭제하기</a></li></ul><br><h3 id="계정-내-테이블-전체-조회"><a href="#계정-내-테이블-전체-조회" class="headerlink" title="계정 내 테이블 전체 조회"></a><a name="1"></a>계정 내 테이블 전체 조회</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    table_name, owner</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    all_tables</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    owner=<span class="string">&#x27;TUTORIALS&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="테이블-생성하기"><a href="#테이블-생성하기" class="headerlink" title="테이블 생성하기"></a><a name="2"></a>테이블 생성하기</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> books_bought(</span><br><span class="line">   <span class="keyword">id</span> <span class="built_in">NUMBER</span>,</span><br><span class="line">   title <span class="built_in">VARCHAR2</span>(<span class="number">100</span>),</span><br><span class="line">   author <span class="built_in">VARCHAR2</span>(<span class="number">100</span>),</span><br><span class="line">   writtenDate <span class="built_in">DATE</span>);</span><br></pre></td></tr></table></figure><h3 id="테이블-조회하기"><a href="#테이블-조회하기" class="headerlink" title="테이블 조회하기"></a><a name="3"></a>테이블 조회하기</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    books_bought;</span><br></pre></td></tr></table></figure><h3 id="시퀀스-생성하기"><a href="#시퀀스-생성하기" class="headerlink" title="시퀀스 생성하기"></a><a name="4"></a>시퀀스 생성하기</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">SEQUENCE</span> books_bought_SEQ;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SEQUENCE</span> books_bought_SEQ</span><br><span class="line"><span class="keyword">START</span> <span class="keyword">WITH</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INCREMENT</span> <span class="keyword">BY</span> <span class="number">1</span></span><br><span class="line">MAXVALUE <span class="number">1000</span></span><br><span class="line"><span class="keyword">MINVALUE</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">NOCYCLE</span>;</span><br></pre></td></tr></table></figure><h3 id="테이블에-데이터-삽입하기"><a href="#테이블에-데이터-삽입하기" class="headerlink" title="테이블에 데이터 삽입하기"></a><a name="5"></a>테이블에 데이터 삽입하기</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books_bought(<span class="keyword">id</span>, title, author, writtenDate)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;Everybody Lies&#x27;</span>, <span class="string">&#x27;Seth Stephens Davidowitz&#x27;</span>, <span class="keyword">TO_DATE</span>(<span class="string">&#x27;2003/05/03 21:02:44&#x27;</span>, <span class="string">&#x27;yyyy/mm/dd hh24:mi:ss&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="시퀀스-사용해서-데이터-추가하기"><a href="#시퀀스-사용해서-데이터-추가하기" class="headerlink" title="시퀀스 사용해서 데이터 추가하기"></a><a name="6"></a>시퀀스 사용해서 데이터 추가하기</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books_bought</span><br><span class="line"><span class="keyword">VALUES</span>(books_bought_SEQ.nextval, <span class="string">&#x27;82년생 김지영&#x27;</span>, <span class="string">&#x27;조남주&#x27;</span>, <span class="string">&#x27;2018/07/30&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> books_bought</span><br><span class="line"><span class="keyword">VALUES</span>(books_bought_SEQ.nextval, <span class="string">&#x27;90년생이 온다&#x27;</span>, <span class="string">&#x27;임홍택&#x27;</span>, <span class="string">&#x27;2019/07/31&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="데이터-수정하기"><a href="#데이터-수정하기" class="headerlink" title="데이터 수정하기"></a><a name="7"></a>데이터 수정하기</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> books_bought</span><br><span class="line"><span class="keyword">SET</span> writtenDate = (<span class="keyword">TO_DATE</span>(<span class="string">&#x27;2019/08/01&#x27;</span>, <span class="string">&#x27;yyyy/mm/dd&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> books_bought</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">id</span>=<span class="number">3</span></span><br><span class="line"><span class="keyword">WHERE</span> author=<span class="string">&#x27;임홍택&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="데이터-삭제하기"><a href="#데이터-삭제하기" class="headerlink" title="데이터 삭제하기"></a><a name="8"></a>데이터 삭제하기</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> books_bought</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>추가로 하나 더.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 마지막으로 insert한 데이터 조회하기</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">max</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">FROM</span> books_bought;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>데이터베이스 - 정규화</title>
      <link href="2019/08/database-normalization/"/>
      <url>2019/08/database-normalization/</url>
      
        <content type="html"><![CDATA[<img src="https://socialads.guru/wp-content/uploads/2016/09/database-normalization-1.jpg" width="650px" /><p>기술 면접을 준비하던 중 데이터베이스 정규화에 대해 알아보다가 유튜브에서 <a href="https://github.com/honux77" target="_blank">정호영</a>님의 <a href="https://www.youtube.com/watch?v=mCw3PRtfHZ0" target="_blank">영상</a>을 보고 정리한 글. </p><p>이것만으로는 명확하게 이해하지 못한 것 같아 일단 이렇게 rough하게 정리하고 계속 공부해야겠다.</p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#abnormaly">이상 현상</a></li><li><a href="#normalization">정규형</a></li></ul><p><br><hr></p><h2 id="이상현상"><a href="#이상현상" class="headerlink" title="이상현상"></a><a name="abnormaly" ></a>이상현상</h2><p>데이터베이스의 설계가 잘못될 경우</p><ul><li>데이터의 중복 발생</li><li>이상현상(anormaly) 발생<ul><li><a href="#abnormaly-insert">삽입 이상</a></li><li><a href="#abnormaly-delete">삭제 이상</a></li><li><a href="#abnormaly-update">갱신 이상</a></li></ul></li></ul><br><h3 id="삽입-이상"><a href="#삽입-이상" class="headerlink" title="삽입 이상"></a><a name="abnormaly-insert"></a>삽입 이상</h3><img src="http://www.mediafire.com/convkey/5c3f/2txn7zjzsit6c0rzg.jpg" /><p><code>DNUMBER</code>, <code>DNAME</code>, <code>DMGRSSN</code> 컬럼에 해당하는 데이터를 삽입하려고 하나 실패한다. 해당 테이블의 primary key인 <code>SSN</code> 의 컬럼의 데이터가 비어져 있기 때문이다.</p><p>데이터를 삽입하는 과정에서 primary key를 추가하지 않아서 발생하는 문제. 데이터베이스 설계를 잘못해서 발생하는 현상.</p><br><h3 id="삭제-이상"><a href="#삭제-이상" class="headerlink" title="삭제 이상"></a><a name="abnormaly-delete" ></a>삭제 이상</h3><img src="http://www.mediafire.com/convkey/cbdd/487sjs9ijfsp9iozg.jpg" /><p><code>EMP_DEPT</code> 에서 사원 데이터 한 명만을 삭제하고 하더라도 위와같이 설계가 잘못이루어졌을 경우, 사원 데이터 한 명만 삭제되지 않고 사원데이터의 외래키(foreign key) 참조하는  <code>EMP_DEPT</code> 까지 삭제되는 정보의 손실이 발생할 수 있다.</p><br><h3 id="갱신-이상"><a href="#갱신-이상" class="headerlink" title="갱신 이상"></a><a name="abnormaly-update" ></a>갱신 이상</h3><img src="http://www.mediafire.com/convkey/432c/ydnloak5drfyorszg.jpg"/><p>위와 같이 설계된 데이터베이스에서 부서이름(<code>DNAME</code>)을 바꾸려면, 커럼 하나만 바꿔서 될게 아니라 전체를 하나하나 일일히 바꿔줘야 한다. 정규화를 제대로 하지 않았기 때문에 발생한 현상. </p><br><h2 id="단계별-데이터베이스-정규화"><a href="#단계별-데이터베이스-정규화" class="headerlink" title="단계별 데이터베이스 정규화"></a><a name="normalization"></a>단계별 데이터베이스 정규화</h2><p>이상현상(abnormaly)이 잘 발생하지 않는 좋은 테이블이 갖추어야할 조건</p><ol><li>1정규형</li><li>2정규형</li><li>3정규형</li><li>BCNF</li></ol><p><br>아직 명확하게 이해하지 못했지만, 데이터 베이스 정규화의 단계별 작업을 설명한 이미지를 첨부한다.</p><img src="http://www.mediafire.com/convkey/60c6/8j5tk5ktrvpwhyzzg.jpg" /><br><p><strong>추가</strong> 트위터에서 발견하고 여기에 남겨본다.</p><blockquote class="twitter-tweet"><p lang="ko" dir="ltr">&quot;정규화는 중복을 없애 디스크 공간을 절약하기 위한 것이었으며, 예전에는 디스크 공간이 비쌌기 때문입니다. 그러나 이제는 상황이 달라졌습니다. 쿼리에 걸리는 시간 최적화가 중요하며, 비정규화가 이를 달성하기 위한 직접적인 방법입니다.&quot;<a href="https://t.co/IPtGQ7mmr0">https://t.co/IPtGQ7mmr0</a></p>&mdash; 씨언 (@if1live) <a href="https://twitter.com/if1live/status/1181155806881841152?ref_src=twsrc%5Etfw">October 7, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> ]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> normalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WeeklyReview - 8월 2주차</title>
      <link href="2019/08/WeeklyReview-2019-Aug-Second/"/>
      <url>2019/08/WeeklyReview-2019-Aug-Second/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/8d21/xfzcwzdu4r23195zg.jpg" width="650px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><p><a href="#did">한 주간 무엇을 했는가</a></p></li><li><p><a href="#read">무엇을 읽었는가</a></p></li><li><p><a href="#watched">무엇을 보았는가</a></p></li><li><p><a href="#learned">그래서 이번 한주동안 무엇을 배웠는가</a></p><hr><h2 id="What-I-did-in-this-week"><a href="#What-I-did-in-this-week" class="headerlink" title="What I did in this week."></a><a name="did"></a><span style="color: red;">What I did</span> in this week.</h2><p>지난주 실전 면접 피드백을 받았다. 자신감있게 대답한 부분은 좋았지만 기술면접에 대해 조금 더 준비하라는 피드백을 받았다. 면접 때 *”static과 void에 대해 설명하시오.”*라는 질문에 어이없게 반만 대답을 했다. 긴장을 안한다고 생각했는데 막상 면접 중반부터 긴장을 해서인지 static에 대해서는 *”static은 자주 사용하는 객체를 메모리에 미리 할당해놓고, 인스턴스 생성없이 사용할수 있도록 할당하는 것”*라고 대답해놓고 void는 모른다고 대답했다. </p><p>첫 인터뷰인걸 감안하고 앞으로 이를 바탕으로 준비를 더 잘해야겠다. 아무튼 생각한것보다는 면접관이 잘봐줘서인지 2차 면접을 제안받았고, 응하기로 결정했다. 실전 면접때 질문을 하지 못해서 2차 면접에서는 질문도 하고 싶다. 결과와 상관없이 이런 면접 경험이 향후 구직에 도움이 될 것으로 기대한다.</p><p>항상 도움을 받고있는 ios개발자 동건님으로부터 스프링러너 <a href="https://springrunner.io/training/mastering-spring-web-101-workshop/" target="_blank">Mastering Spring Web 101 Workshop</a> 라는 워크샵을 추천받았다. 이틀간 스프링 부트를 학습하는 기회인데, 교육비용이 30만원이라 부담스러웠는데 얼리버드는 50%할인이라고 해서 일단 결제했다. 좋은 기회라고 생각했는데 잘 따라갈수 있을지 걱정이 드는것도 사실이다. 과정 마치는대로 부족한 부분을 채우면서 준비해야겠다. </p><br><h2 id="What-I-read-in-this-week"><a href="#What-I-read-in-this-week" class="headerlink" title="What I read in this week."></a><a name="read"></a><span style="color: red;">What I read</span> in this week.</h2><p><a href="https://imasoftwareengineer.tistory.com/56" target="_blank"><img src="http://www.mediafire.com/convkey/6f8f/fxygw3xv0p0zkgczg.jpg" width="550" /></a></p><ul><li><a href="https://imasoftwareengineer.tistory.com/56" target="_blank">삐멜 - 컴퓨터공학에 접근하는 방법</a></li></ul><p>프로젝트가 막바지에 치닫는 가운데 본격적인 구직준비도 해야해서 시간날때마다 기술면접 대비해서 글을 읽곤 하는데 최근에 이를 준비할 수 있는 최고의 글을 알게 되었다. 트위터에서 팔로우하고 있는 <a href="https://twitter.com/fsoftwareengin1" target="_blank">삐멜님</a>이 정리해주신 글인데 나처럼 비전공자들에게 더 없이 좋은 자료라고 생각된다.</p><p>구직하면서 다 학습하지 못하더라도 최소한 자료구조/네트워크/데이터베이스만이라도 이해하고 준비할 수 있도록 해야겠다.</p><br><h2 id="What-I-watched-in-this-week"><a href="#What-I-watched-in-this-week" class="headerlink" title="What I watched in this week."></a><a name="watched"></a><span style="color: red;">What I watched</span> in this week.</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/9sSxdhYGYSM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br></li><li><p><a href="https://www.youtube.com/watch?v=9sSxdhYGYSM&feature=youtu.be" target="_blank">노마드코더 - yes, python is slower than C.</a></p><p>파이썬이 C언어보다 느린 이유라고 제목을 달았지만, 영상의 내용은 **인터프리팅 언어(Interpretation)**와 **컴파일러 언어(Compilation)**의 차이를 설명해주는 영상이다. </p><p>영상만의 내용으로는 정리하기에 부족할 것 같아 삐멜님의 <a href="https://imasoftwareengineer.tistory.com/43" target="_blank">블로그 포스트</a>를 참고하여 정리</p><p>정리하면 다음과 같다.</p><p>번역기란 개발자가 작성한 프로그래밍 언어를 기계어로 번역하는 것을 말하는데 JDK(Java), Python(Python), gcc(C) 등이 여기에 해당한다.</p><p>인터프리팅 방식으로 구동되는 언어를 스크립트 언어라고 하는데, Python, Javascript, Php가 대표적인 스크립트 언어이다. 컴파일러로 구동되는 언어는 Java와 C가 있다.</p><p>기계어로 번역하는 방식에 따라 인터프리터와 컴파일러로 나뉘는데 둘의 차이는 다음과 같다.</p><ol><li><u>인터프리터는 코드를 line by line으로, 실시간으로 기계어로 번역</u>한다. 코드를 실행할때마다 번역하는 특징이 있다.</li><li><u>컴파일러는 최초 번역시에 전체 코드를 번역해서 하나의 바이너리 코드를 만들어낸다. 이후부터는 코드를 번역할 필요없이 생성된 바이너리 코드를 실행</u>한다. </li><li>코드를 실행할때마다 번역을 해야하는 인터프리터와 비교해서 바이너리 코드를 실행하는 <strong>컴파일러의 실행속도가 상대적으로 빠르다는 장점</strong>이 있으며, 인터프리터의 경우 번역시에 에러를 발견하면 실행할 때에도 에러가 발생할 수 있으나 컴파일러 언어는 최초 번역시에 에러가 없다면 에러없는 코드로 바이너리 코드가 생성되기 때문에 실행시에 에러가 발생할 일이 없다는 장점 역시 존재한다.</li></ol><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uoVNJkyXX0I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>- <a href="https://www.youtube.com/watch?v=uoVNJkyXX0I&list=WL&index=58&t=123s" target="_blank">우아한Tech - [10분 테크토크]👩🏻‍💻👨🏻‍💻해리&션의 MVC 패턴</a><p>지난 4월 나도 지원했다가 코딩테스트의 문턱을 넘지 못했던 우아한 테크코스 ㅋㅋㅋ</p><p>어떤 분들이 합격하셔서 어떻게 코스를 진행중인지 궁금했는데, 유튜브 계정으로 학습내용을 공유해줘서 감사한마음으로 구독중이다. 기술 면접을 준비하면서 MVC패턴에 대해서도 정리가 필요했는데 이 영상으로 간단히 준비할 수 있었다.</p><p>영상 속의 발표자들이 정리해주신 내용은 대략 다음과 같다.</p><ul><li>MVC 패턴의 정의</li><li>모델1과 모델2(MVC)의 정의와 차이</li><li>MVC 흐름<ul><li>클라이언트 -&gt; 웹 어플리케이션 -&gt; 컨트롤러 -&gt; 뷰 -&gt; 컨트롤러 -&gt; 모델 -&gt; DB -&gt; 모델 -&gt; 컨트롤러 -&gt; 뷰 -&gt; 클라이언트</li></ul></li><li>MVC 패턴에서 Model, View, Controller의 역할<ul><li>Model은 값과 기능을 갖는 객체이며, 비즈니스 로직를 수행하는 역할을 한다.</li><li>View은 모델에 포함된 데이터를 시각적으로 보여주는 역할을 한다.</li><li>Controller는 모델 객체로의 데이터 흐름을 제어하며 뷰와 모델의 역할을 분리한다.</li></ul></li><li>MVC 패턴을 사용할 때의 이점<ul><li>컴포넌트의 코드 결합도를 낮추기 위해</li><li>코드의 재사용성을 위함</li><li>구현자들 간의 효율성을 높이기 위함</li></ul></li></ul></li></ul><h2 id="What-I-learned-from-this-week"><a href="#What-I-learned-from-this-week" class="headerlink" title="What I learned from this week."></a><a name="learned"></a><span style="color: red;">What I learned</span> from this week.</h2><p>  노마드코더의 영상덕분에 컴파일러와 인터프리터의 차이를 다시 한 번 정리할 수 있었다.</p><p>  이외엔 프로젝트 수행시에 하나 배운 것이 있다. sql문을 제어하는 DaoImpl 파일에서 공통적으로 사용하는 sql 제어문을 <code>&lt;sql&gt;</code>로 캡슐화할 수 있다. 이렇게 캡슐화한 제어문은 <code>&lt;include refid=&quot;&quot;/&gt;</code> 명령어를 통해 사용할 수 있다.</p><p>  내가 프로젝트에서 사용한 코드이다.</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectBoard&quot;</span>&gt;</span></span><br><span class="line">SELECT  </span><br><span class="line">    boardno, tag, title, product, </span><br><span class="line">    content, writer, hit, </span><br><span class="line">    price, writtendate, </span><br><span class="line">   (SELECT COUNT(*) </span><br><span class="line">    FROM UsedComment_KG WHERE boardno = UsedBoard_KG.boardno) commentCnt,</span><br><span class="line">   (SELECT min(usedimgno) FROM UsedImg_KG WHERE boardno = UsedBoard_KG.boardno ) AS fileno</span><br><span class="line">FROM </span><br><span class="line">    UsedBoard_KG</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;selectSearch&quot;</span>&gt;</span></span><br><span class="line">SELECT rownum rnum, B.* FROM (</span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectBoard&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectPageSearch&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">parameterType</span>=<span class="string">&quot;web.util.Paging4used&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">resultType</span>=<span class="string">&quot;web.dto.UsedBoard&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">SELECT * FROM (</span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;selectSearch&quot;</span> /&gt;</span></span><br><span class="line">) R</span><br><span class="line">WHERE rnum BETWEEN #&#123;startNo &#125; AND #&#123;endNo &#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>  기본 게시판을 조회하는 sql제어문을 <code>selectBoard</code> 라는 id값으로 sql문을 만들었고, 이를 사용하는 코드에서 <code>&lt;include refid=&quot;&quot; /&gt;</code> 문으로 사용했다. </p><p>  이렇게 코드를 작성하니 xml에서 sql제어문도 객체지향적으로 정리할 수 있겠다라는 생각이 들었다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - 8월 1주차</title>
      <link href="2019/08/WeeklyReview-2019-Aug-First/"/>
      <url>2019/08/WeeklyReview-2019-Aug-First/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/ba30/joz22iserdgscuezg.jpg" width="650px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#read">무엇을 읽었는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#learned">그래서 이번 한주동안 무엇을 배웠는가</a></li></ul><hr><h2 id="What-I-did-in-this-week"><a href="#What-I-did-in-this-week" class="headerlink" title="What I did in this week."></a><a name="did"></a><span style="color:red">What I did</span> in this week.</h2><p>SQL강의를 들으면서 프로젝트를 동시에 하다보니 조금씩 SQL이 익숙해지고 있다. </p><p>실전 모의 인터뷰가 있어서 기술 인터뷰 대비하여 이론관련한 부분을 정리를 조금했다. 실전 모의 인터뷰를 했는데 긴장하지 않고 들어갔는데 막상 들어가서 생각하지 못했던 질문을 받으니까 긴장이 되고 대답이 잘안되었다. 잘하진 못했지만 면접관에서 배려해주시고 피드백해주신 덕분에 면접경험을 좋았다고 평가하고 싶다. 개발자로서 처음 해본 면접이었는데 덕분에 어떻게 인터뷰를 준비해야하는지를 가늠할 수 있었다.</p><br><h2 id="What-I-read-in-this-week"><a href="#What-I-read-in-this-week" class="headerlink" title="What I read in this week."></a><a name="read"></a><span style="color:red">What I read</span> in this week.</h2><ul><li><a href="https://twitter.com/HyunSeob_/status/1155327097541234689?s=20" target="_blank">컴퓨터공학 정원 증대에 대한 트윗 타래</a></li></ul><p><a href="http://m.mk.co.kr/news/opinion/2019/562292#mkmain" target="_blank">매일 경제 컴퓨터공학 정원 5배로 늘려야 한다.</a> 기사에 대한 트윗 타래를 읽었다. 학원 출신의 비전공 개발자로써 아마도 저연봉의 SI 업계에서의 첫 출발이 점쳐지는 가능성이 높은 상황에서 이런 글을 읽으니 기분이 남다르다.</p><p>이 업계에는 이상한 모순이 존재한다. 처우에 대한 불만이 있는 노동자가 많음에도 업계에선 사람이 부족하다는 말이 오래전부터 끊임없이 나오고 있다. 사람은 있지만, 사람이 부족하다? 피라미드와 같은 구조에서 하위 구조엔 사람이 많지만, 상위구조엔 수요에 비해 공급이 부족하다는게 내 생각이다. 그리고 위 트윗 타래를 작성한 트위터리안이자 개발자님도 같은 생각이신 것 같다. 개발자는 많지만, 고급인력은 부족한 현실.</p><p>구직을 앞둔 상태에서 이런 글을 읽으니 기분이 남달랐다. 내 커리어의 시작은 아마도 이 바닥의 피라미드 구조에서 하위 계층에서 시작할 가능성이 높다. 여기에만 계속 있는다면 업계에 도움이 되지 못할 것이다. 언젠간 피라미드 상위로 올라가서 개발자가 부족하다는 업계에 도움이 되는 개발자로 성장하고 싶다. 커리어 내내 이 부분을 계속 생각하면서 일을 하고 싶다.</p><br><h2 id="What-I-watched-in-this-week"><a href="#What-I-watched-in-this-week" class="headerlink" title="What I watched in this week."></a><a name="watched"></a><span style="color:red">What I watched</span> in this week.</h2><iframe width="560" height="315" src="https://www.youtube.com/embed/a3VV46wUKto" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>요즘 프로젝트 하면서 드는 생각이었는데, 딱 나처럼 고민을 하는 사람이 있었나보다. 덕분에 조언을 들을 수 있었다. <p>프로젝트 막바지인 지금, 이제 곧 구직을 해야하는 시기가 오는데 <em>‘내가 과연 일을 잘 할 수 있을까?’</em> 라는 고민이 계속 들었는데, 회사들어가서 어떻게 업무에 적응해야 하는지를 생각해볼 수 있었다. </p><h2 id="What-I-learned-from-this-week"><a href="#What-I-learned-from-this-week" class="headerlink" title="What I learned from this week."></a><a name="learned"></a><span style="color:red">What I learned</span> from this week.</h2><p>면접을 앞두고 객체지향의 특징에 대해 다시 정리했다.</p><h3 id="객체지향-언어의-4대-특징"><a href="#객체지향-언어의-4대-특징" class="headerlink" title="객체지향 언어의 4대 특징"></a>객체지향 언어의 4대 특징</h3><ul><li><strong>추상화_Abstraction</strong><ul><li>우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다. </li></ul></li><li><strong>캡슐화_Encapsulation</strong><ul><li>동일한 기능, 속성을 묶어서 유지보수에 용이하게 만드는 기법이다.</li><li>객체지향에서 캡슐화하는 데이터 구조와 데이터를 다루는 방법을 결합시켜 묶는 것을 말한다.</li></ul></li><li><strong>상속성_Inheritance</strong><ul><li>상위 객체의 속성을 하위 객체가 물려받는 것을 말한다.</li><li>상속이 있기 때문에 객체지향이 가능해진다.</li></ul></li><li><strong>다형성_Polymorphism</strong><ul><li>객체의 동일한 이름이지만 parameter를 다르게 함으로써 완전히 다른 객체로 사용할 수 있는 특징을 말한다.</li></ul></li></ul><br><p>마찬가지로 기초적인 질문일 수 있으나 프레임워크와 라이브러리의 차이이다. 이 개념의 핵심은 제어의 흐름, 제어권이 누구에게 있느냐에 있는 것 같다. </p><h3 id="Framework-vs-Library"><a href="#Framework-vs-Library" class="headerlink" title="Framework vs Library"></a>Framework vs Library</h3><ul><li>Framework<ul><li>프레임워크는 컨테이너같은 개념이다. 개발자는 해당 컨테이너에서 필요한 부품만 개발해서 컨테이너에 장착해서 사용하면 된다.</li><li>Java를 사용하는 <a href="https://spring.io/" target="_blank">Spring Framework</a>, Python을 사용하는 <a href="https://www.djangoproject.com/" target="_blank">Django</a> 등이 이에 해당한다.</li><li>라이브러리와 다른 특징으로는 해당 어플리케이션의 흐름의 제어권이 어디에 있느냐로 구분할 수 있다. 라이브러리는 주도권이 개발자에 있지만, 프레임워크는 개발자가 부품을 채워넣을뿐 개발의 주도권은 프레임워크에 있다. 이를 **제어의 역전(IoC, Inversion Of Control)**이라고한다. <u>프레임워크의 함수(메서드)가 사용자 코드를 호출한다는 이야기</u>이다.</li></ul></li><li>Library <ul><li>라이브러리는 부품이다. 필요한 부품을 개발자가 가져와서 사용하면 된다.</li><li>현재 프로젝트에서 사용하고 있는 스마트 에디터 라이브러리, <a href="https://github.com/summernote/summernote" target="_blank">SummerNote</a>가 여기에 해당한다.</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - GROUP BY, HAVING</title>
      <link href="2019/08/oracle-groupby/"/>
      <url>2019/08/oracle-groupby/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1511632765486-a01980e01a18?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2550&q=80" width="600px" /><p>select문 통해 조회한 결과를 <strong><u>정해준 기준(GROUP BY)</u></strong> 에 따라 그룹으로 분류하는 쿼리이다.</p><p><code>EMP</code> 테이블에서 부서별 평균 급여를 조회하고자 한다면, 다음과 같은 쿼리로 조회할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">round</span>(<span class="keyword">avg</span>(sal))</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/sagQGmnASztHTKip64-NM7yuIUYJnslWZQI7j8GMjWAEcXJAw8StUsD7uvamevmBOE4cWMQjV_NrRGNhpTH9WZ0HrfuKSS6UflmD1Xut0ejIXasXrbkd0RfXgAiOHfR85BS_lioxsyXWfpCTfGRt4TOILLu7-x6oRKA86wCf_4swO4qAnWbCDkQS0R4eC94MmCUDI91E6M7LkKhqIc6n5hPnTUwQYqqMrcBHuM-023smEz0iBc-_avbqHTc_vQrSi2bh5nQHixMUXhomVI5f5NSpoxF3hY1i9nmer9VJr3lMrPrvNRO2vQx6GrsAUoR7YwEMQNS70mdlNTo3njr5mDqv_DPA66oPCrqHBDQNvS3vY-d_uv5DbFCaJ6TpDPYEPF6PTZBfejSAtPnNZnoyKYs6CQZ1No2pGkixlgMJYJnBzKDxWR9MCSFbj5SccZwC7oYPJ0Sa2fNOaxF31e7FGXaPgCAXTGauG_Qll9Xedsw4anqPlbFpamFb253HkZ4NFNnL5yel2tAtbPrl2hSWW15xUFSUNY170VHNXJF1qZMU0SDkJV4HqyqNG58HdoLdqNM9JZK6PDtLJdk8s2LQP51pjKK6J7Uzko1e0IatT_piKNmovbHkWK9WCMP8C6eJSC8hudeNPmLZExDT9qrPgHpyymfkPtfzqkgfunKF-fZcRQKVGqfNAG_-y1qeiLoKyY1_cSGdS7HdXqpcToiItNuVG1_FAorYckcTesOjoLE_JAuylqQPviO2=w840-h502-no" style="width: 70%;" /><p>부서별 평균 급여가 2,000 이상인 부서의 평균 급여를 조회하려면 어떻게 해야할까? </p><p>이 경우엔 <code>WHERE</code> 절을 이용할 수 없다. 부서별 평균급여가 2,000 이상이라는 조건이  <code>GROUP BY</code> 에 조건을 걸어서 조회해야 하기 때문이다. 이 경우 사용하는 키워드가 <code>HAVING</code> 이다. 위의 퀴즈에 대한 sql 코드는 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="keyword">round</span>(<span class="keyword">avg</span>(sal))</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">avg</span>(sal)&gt;=<span class="number">2000</span>;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/R_sXnJis_BRDBjsXKdzpOGjf5kjvKPxvwgJT1Sz55_bDXDyNthLoNNEBv64ik-0zBNVuyB4wb-YHHalnNs30WMJquvdCKaLLQXIUs6-wUTZ6sXyfZK3J051fB2pps4yyB7XZ-mLjhly8y2gpatuWT40LdThm5PeiVNTNZRjr9NILmpJQUiVVnyh0bBkgwFWg4TBBaGVQrhYNqkwHvGK4k9lb3dY-j-KQKfBbBfIrNrU0TSiLvsLCpS__68nJ3HdQL-CSGsCD4DaPyU9R85-I6u6sy6GY4AJhDOzCg0wnO5_gr208isxyS4EM-wHjcCuvEGH2IbT6DKsouELH0yR7wuUOutiBGI8NRV94IuzG-LTIUBEOs9tAM2ITIbkPPBdwl7op8JhTnx97qeiHYDt3kQXC-oEV_A0BJTaiMdk6Y7KBjl0yAHBhgvPXoYRCxVzUHiWwGu6Uv0mujnqWrAlxss_89JqORRyJHrpeMipUvkSs2lbG1Ay83CYHM42hJKIQUilknvuvS0BThgikdxYL-iOIEU8S3cauzaLdiC5Rn3gT-g06WcGNDF6dw5cUxW5QAs8syq2qeAk_r-C3jscsbE-SVOorGAalrsMp9Yk17PhlraF2CRyx1xGX4RcFN0YErkdRvOHiqS2uyj4pB1YiXohR6LufSZEoK1SQWjVHY-VVqYuo2wjgWgzVnd-oX2mvRasUOUPn6FZfyB7O3y9VKDFqdy1dNqrZNMLVKdj0i-E1QkERzRKdnogm=w842-h496-no" style="width: 70%;" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - 7월 3,4주차</title>
      <link href="2019/07/WeeklyReview-2019-Jul-Fourth/"/>
      <url>2019/07/WeeklyReview-2019-Jul-Fourth/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/3a06/agshztnmyhonuoyzg.jpg" width="650px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#read">무엇을 읽었는가</a></li><li><a href="#learned">그래서 이번 한주동안 무엇을 배웠는가</a></li></ul><hr><h2 id="What-I-did-in-this-week"><a href="#What-I-did-in-this-week" class="headerlink" title="What I did in this week."></a><a name="did"></a><span style="color:red">What I did</span> in this week.</h2><p>지난주에 3주차 Weekly Review를 작성하지 못했다 ㅠㅠ 그래서 3주차와 4주차를 한번에 작성한다…</p><p>현재 이수중인 국비지원 학원에서 취업지원을 위해 이력서 작성을 요구받았다. 정말 오랜만에 이력서를 그것도 다른 포지션으로 작성해보니 <em>‘6개월정도 공부했는데 이정도 밖에 안되나.’</em> 싶어서 살짝 자괴감도 들었다..ㅎ</p><p>그런데 학원에서 제공한 이력서 양식이 오래된 양식이어서 좀 놀랐다. <em>‘아직도 이런 양식으로 이력서를 작성하는구나’</em> 싶으면서도 이 양식으로 나라는 사람을 매력적으로 포장할 수 있을지 자신이 없었다. 그래서 내가 생각하는 이상적인 이력서를 새로 만들어보려고 한다. 그러면서 동시에 블로그에도 About 페이지를 만들어서 간단한 resume(프로필 수준?)를 올려보려고 한다.</p><p>지난주부터 스프링으로 게시판을 만들고 있는데, 생각한만큼 잘 되지 않는다. 현재 게시판에서 이미지를 첨부하고, 첨부한 이미지를 게시글에서 보여주고, 수정/삭제에서 이미지를 DB에서 삭제하는 부분을 하고 있는데, 이 중에서 DB에서 이미지를 처리하고 있지 못해서 수정/삭제를 구현하지 못하고 있다. ㅠㅠ<br><a href="https://github.com/dahyezz/UniTime/blob/master/UniTime/src/main/java/web/controller/UsedBoardController.java" target="_blank">Controller</a>와 DB에서 이미지를 일반 컨텐츠와 구분해서 관리하고 있는데, 다른 수강생분께 도움을 받아서 이렇게 시작했지만 아직 명확하게 이해하고 있지 못하고 있다ㅠㅠ</p><p>프로젝트를 하면서 Ajax에 대한 이해가 부족하다고 느껴서 Udacity에서 다시 <a href="https://www.udacity.com/course/intro-to-ajax--ud110" target="_blank">Ajax 강의</a>를 듣고 있다.</p><br><hr><h2 id="What-I-read-in-this-week"><a href="#What-I-read-in-this-week" class="headerlink" title="What I read in this week."></a><a name="read"></a><span style="color:red">What I read</span> in this week.</h2><p>지난주에 오랜만에 이력서를 작성하고, 또 다음주로 예정되어 있는 실전면접을 앞두고, 이력서 작성하는 법과 인터뷰 관련한 자료를 조금 읽어봤다. 아직 얕게만 찾아봐서 코딩을 하다 짬짬히 봐야할 것 같다.</p><ul><li><a href="https://gmlwjd9405.github.io/2018/05/04/how-to-write-a-resume-for-a-developer.html" taget="_blank">개발자의 포트폴리오, 이력서 작성법, 면접을 잘보는 법</a></li><li><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner" taget="_blank">Interview_Question_for_Beginner</a><ul><li><a href="https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Development_common_sense" taget="_blank">Development Common Sense</a></li></ul></li></ul><br><hr><h2 id="What-I-learned-from-this-week"><a href="#What-I-learned-from-this-week" class="headerlink" title="What I learned from this week."></a><a name="learned"></a><span style="color:red">What I learned</span> from this week.</h2><p>국비지원 학원이 막바지에 이르고 있다. 이제 수료까지 한 2주 정도 남은 것 같은데, 매일 접하는 에러에 숨이 막힐 지경이다… 후..ㅋㅋ</p><p>처음 스프링 프로젝트를 시작할땐 금방 할 수 있을 것 같았다. 게시판 하나쯤이야 뚝딱하고, 다른 조원들을 돕고 싶었는데, 현실은 내 임무 하나 해결하기도 힘이든다.. </p><p>스프링 개발시에 모르는 컴포넌트가 있을때마다 Declaration을 열어서 인터페이스 내용을 파악하고 있는데 이게 도움이 되는 것 같다. 내가 작성하는 코드가 스프링 프레임워크에 의해서 어떻게 개발되는지를 알 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>리눅스에서 권한 변경하기 (A.k.a. Chmod)</title>
      <link href="2019/07/linux-permission/"/>
      <url>2019/07/linux-permission/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1549605659-32d82da3a059?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1500&q=80" /><ul><li><a href="#permission">각 권한별 명령어</a></li><li><a href="#dirfile">디렉토리/파일 별 명령어</a></li></ul><p>도커를 사용하다가 DB 때문에 리눅스를 만질일이 잠깐 있었다.</p><p><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14237/statviews_4157.htm#REFRN23287">TABLESPACE</a>를 사용하기 위해서 오라클 11g가 설치된 도커 컨테이너의 Ubuntu에서 임의의 폴더를 생성후 DATAFILE의 경로로 설정했는데, 다음과 같은 에러(<code>ORA-01119</code>)가 발생했다.</p><p><img src="http://www.mediafire.com/convkey/ee38/n1abqqefoho02uazg.jpg"></p><p><code>ORA-01119</code> 는 DB TABLESPACE 에러라고 한다. 그리고 아래 <code>Permission denied</code> 라는 메세지가 출력된걸로 보아 해당 경로의 접근권한이 차단되어 TABLESPACE 에러가 발생했음을 유추하였다.</p><p>파일 디렉토리를 확인해보니 이런게 있었다.</p><p><a name="image-permission"></a><img src="http://www.mediafire.com/convkey/2453/xqwdfjfcjlcjt58zg.jpg"></p><p>빨간색 체크박스 안에 있는게 <u>리눅스에서 권한(Permission)을 의미</u>하는 <strong>퍼미션 정보</strong>라고 한다. <code>/finalProject</code> 폴더의 권한은 원래 아래 위의 다른 디렉토리와 같은 상태였다. 그럼 그 상태 메세지를 뜯어보자(?)</p><p><code>drwxrwxrwx</code></p><p>앞에서부터 <code>d</code> 는 해당 파일 또는 디렉토 리의 파일형태를 의미한다.</p><p> <code>d</code>는 directory를 의미, <code>-</code>는 일반파일을 의미한다. </p><p>멘 앞의 문자가 파일형태를 의미했다면 뒤의 문자 형태는 모두 권한을 의미한다. <strong>문자의 위치에 따라 세글자씩 끊어서</strong> <code>파일형태</code> <code>소유자</code>-<code>그룹</code>-<code>공개</code> 로 구분하며 각 사용자에 따라 정의되어 있는 권한은 다음으로 해석할 수 있다.</p><h3 id="각-권한별-명령어"><a href="#각-권한별-명령어" class="headerlink" title="각 권한별 명령어"></a><a name="permission"></a>각 권한별 명령어</h3><ul><li>사용자<ul><li><code>owner</code> : 소유자에 대한 퍼미션 지정</li><li><code>group</code> : 소유그룹에 대한 퍼미션 지정</li><li><code>public</code> : 모든 사용자들에 대한 퍼미션 지정</li></ul></li><li><a name="permission"></a>권한<ul><li><code>r</code> : 파일/디렉토리의 <strong>읽기(read)</strong> 권한 <span style="color:red">(4)</span></li><li><code>w</code> : 파일/디렉토리의 <strong>쓰기(write)</strong> 권한 <span style="color:red">(2)</span></li><li><code>x</code> : 파일/디렉토리의 <strong>실행(execute)</strong> 권한 <span style="color:red">(1)</span></li></ul></li></ul><p><img src="http://www.mediafire.com/convkey/2453/xqwdfjfcjlcjt58zg.jpg"></p><p>위의 정보를 바탕으로 다시 빨가체크박스 속 권한을 해석하면 다음과 같다.</p><p>파일형태와 권한을 분리하고 각각의 사용자에 따라 <code>-</code>로 구분하면 다음과 같다.</p><p><code>d rwx-rwx-rwx</code></p><p>즉 <code>/finalProject</code> 는 디렉토리 즉 폴더이며, 소유자와 그룹, 공개 모두 <code>rwx</code>로 퍼미션이 정의되어있는걸로 보아 접근권한으로 읽기, 쓰기, 실행 모두 허용되어있음을 알 수 있다.</p><p>그럼 마지막으로 접근권한은 어떻게 바꿀수 있을까?</p><iframe src="https://giphy.com/embed/BJmTtZL4hova8" width="480" height="235" frameBorder="0" class="giphy-embed" allowFullScreen></iframe>위의 [권한](#permission)에서 권한에 따라 숫자가 정의되어있음을 알 수 있다.<p>리눅스 명령어를 입력할땐 영어문자 대신 저 숫자를 입력하여 권한을 변경해야 한다. 접근권한을 모두 공개하려면 각각의 사용자에 따라 읽고(<code>r:4</code>), 쓰고(<code>w:2</code>), 실행(<code>x:1</code>)하는 권한을 모두 허용해야 한다.</p><p>각각의 사용자에 맞춰 권한을 숫자로 바꿔 더해서 입력하면된다.</p><p><code>rwx-rwx-rwx</code>는 <code>(4+2+1) + (4+2+1) + (4+2+1)</code>로 변환할 수 있으며, 최종적으로 명령어로 바꾸면 <code>chmod 777</code> 이 된다. </p><p>정리하면 다음과 같다.</p><h3 id="디렉토리-파일-별-명령어"><a href="#디렉토리-파일-별-명령어" class="headerlink" title="디렉토리/파일 별 명령어"></a><a name="dirfile"></a>디렉토리/파일 별 명령어</h3><ul><li>디렉토리일 경우. <em>(하위 디렉토리 전체 파일의 권한 지정)</em><ul><li><code>chmod -R [권한지정] [디렉토리이름]</code></li></ul></li><li>파일일 경우.<ul><li><code>chmod [권한지정] [디렉토리이름]</code></li></ul></li></ul><p>그럼 일반 디렉토리를 위의 <a href="#image-permission">빨간 체크박스</a> 속 권한처럼 바꾸려면 다음과 같은 명령어가 필요함을 알 수 있다.</p><p><code>chmod -R 777 finalProject</code></p><img src="https://media.giphy.com/media/9Jcw5pUQlgQLe5NonJ/giphy.gif" width="300px"/>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git - CLI에서 커밋 그래프 확인하기</title>
      <link href="2019/07/git-graph-log/"/>
      <url>2019/07/git-graph-log/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1453791052107-5c843da62d97?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80" width="650px" /><p>Sourcetree같은 git 전용 클라이언트를 사용하면 쉽게 커밋 그래프를 확인할 수 있다. CLI 환경에서 이와같은 그래프를 확인하려면 어떻게 해야할까?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log --oneline --graph --all --decorate</span><br></pre></td></tr></table></figure><img src="http://www.mediafire.com/convkey/b89a/l4enm9n65pxf00ozg.jpg" width="550px" /><p>커밋 객체가 타임라인 순으로 보여진다. 브랜치명을 이름으로 구분해놓고 작업중이어서 개인정보 보호차원에서 가려놨지만 브랜치까지도 구분해서 확인할 수 있음을 알 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - 7월 2주차</title>
      <link href="2019/07/WeeklyReview-2019-Jul-Second/"/>
      <url>2019/07/WeeklyReview-2019-Jul-Second/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/80a5/ha37a1153f1yy4izg.jpg" width="650px" /><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#did">한 주간 무엇을 했는가</a></li><li><a href="#read">무엇을 읽었는가</a></li><li><a href="#watched">무엇을 보았는가</a></li><li><a href="#learned">그래서 이번 한주동안 무엇을 배웠는가</a></li></ul><hr><h2 id="What-I-did-in-this-week"><a href="#What-I-did-in-this-week" class="headerlink" title="What I did in this week."></a><a name="did"></a><span style="color:red">What I did</span> in this week.</h2><p>한 주간 오라클 강의를 들으며 강의 속 문제를 SQL 쿼리로 바꾸는 연습을 했는데, 이 덕분에 SQL 쿼리가 익숙해지기 시작했다. 다음주까지 계속 강의도 듣고, 책을 찾아보면서 관계형 데이터베이스까지 익히고 싶다.</p><p><a href="https://youngjinmo.github.io/2019/07/weeklyReview_190701/" target="_blank">지난주</a>에 강의를 들으면서 동시에 블로그에 정리를 하려니 학습이 느리다고 판단해서 이번 한 주간은 강의를 일단 빠르게 듣고 다시 기억하고 싶거나 중요한 부분을 정리하는 방식으로 바꿨더니 학습이 확실히 빨라졌다. 빠르게 강의를 듣고 무엇을 정리할지 판단하니 이전보다 정리노트의 퀄리티도 더 나아지는것도 같다.</p><p>국비지원 학원에선 스프링으로 게시판 만드는 작업을 하고 있는데, 다른 수강생들보다 조금 느리게 작업을 하고 있다. 확실히 익히고자 코드 복붙없이 내가 직접 타이핑하면서 한 줄, 한 줄 의미를 이해하고 넘어가려고 하고 있다. 목요일이 지나면서 조급함이 들기 시작했다. 빠르게 하려면, 작동되는 코드를 복붙하고 작동하는걸 보며 이해해도 되겠지만, 그게 정말 좋은 학습법인지 회의적이기에 조금 늦더라도 직접 코드를 타이핑하려고 한다. </p><p>곧 이어서 파이널 프로젝트가 시작하기 때문에 스프링을 익히기에 더 없이 좋은 시기라는 생각이 든다. 3월에 강의들은 DB를 지금 다시 공부하는 것처럼 다시 스프링을 공부하지 않으려면 지금 확실히 해보려고 한다. 물론 고작 게시판 하나 만든다고 해서 스프링을 완전히 이해할 수는 절대 없다. 그러나 이미 했던 부분을 공부하는게 아니라 스프링에 대해 더 깊히 공부하려면 지금하는 부분을 확실히 이해하고 넘어가고싶다. 뭐 그렇다..ㅋㅋ</p><p>파이널 프로젝트를 앞두고 Slack과 Github 셋팅을 했다. Slack을 하는덕분에 자료 관리나 커뮤니케이션이 더 용이해졌다. 사실 Slack을 적용하는게 쉽지않다. 대부분의 조원들이 이제 막 졸업한 분들인데 대학생들은 Slack은 물론 이런 비즈니스 툴에 익숙하지 않다보니 필요성조차 못느끼고 있었다. 필요성을 못느끼는 사람들에게 Slack을 가입시키는게 어렵다보니 내 나름대로 Notion으로 <a href="https://www.notion.so/yjdevslackmanual/fb099048e16649d3aa6e8152d1cc9c1b" target="_blank">메뉴얼</a>을 만들어서 배포도 해봤는데 가입만 하고 실제 사용하는 사람의 비율은 반이 안되는것 같다. 지금도 프로젝트 조원들중 Slack을 매일 접속하는 사람은 6명중 나를 포함한 2명..? 밖에 안되는것 같다. 앞으로 어떻게 될지 궁금하다..ㅎ</p><p>Github에서는 내가 가장 익숙하게 다루는 사람이다보니 브랜치 관리와 github 사용에 대해서 조장과 함께 리드를 하고 있다. Git에 대해서 나도 더 공부가 필요하지만 조원들 모두 Git의 원리를 모른채 add/commit을 하고있다보니 프로젝트 과정에서 함께 정리할 시간이 필요할 것으로 보인다.</p><br><hr><h2 id="What-I-read-in-this-week"><a href="#What-I-read-in-this-week" class="headerlink" title="What I read in this week."></a><a name="read"></a><span style="color:red">What I read</span> in this week.</h2><p>이번 주엔 두 개의 글을 리뷰하려고 한다.</p><ul><li><a href="https://doublesprogramming.tistory.com/144" target="_blank">학원출신 취업, 면접 그리고 미래.. 초보 프로그래머에게 (남궁성의 초보코드스터디)</a></li></ul><p>지금 딱 나와 같은 상황의, 국비지원 수료중인 비전공자 들을 위한 조언이다.</p><p>글에서 언급한대로 이제 6개월 정도를 공부한 지금, 정말 평생을 할 수 있는 일인지 생각해보았다. 올 초 제주도에서 참여한 카카오 코딩캠프 참여하면서 자신감이 붙은 상태에서 육지에 오자마자 바로 국비지원 교육을 이수하게 되었다. 수료가 끝나갈즈음엔 이 과정의 수료자중에서 내가 가장 실력자가 되고 개발자로서 보다 큰 자신감을 얻을 수 있을줄 알았다. 그러나 딱 6개월이 지난 지금은 기대와 달라졌다.</p><p>지금의 나는 현재 수료생중에서도 중간이 될까 싶을만큼 실력자와는 거리가 멀다. 강의 직후 곧바로 이해하고 프로젝트에 적용하는 전공자와 달리 난 몇 번은 더 코드도 봐야하고, 관련 블로그 포스트나 책, 강의를 한 번 더 봐야한다. 그것도 부족해서 코딩할때엔 강사나 다른 수강생들에게 질문을 하지 않으면 혼자서 게시판 하나 짜기도 힘든 상태이다. </p><p>6개월을 했음에도 왜 이것밖에 안될까 싶고 그래서 스스로에게 아쉽고 부끄럽지만 그래도 지난 6개월간 많은 것을 공부할 수 있었고, 실력은 부족하지만 공부하는게 힘들거나 지겹게 느껴지지 않는다. 오히려 새로운걸 계속 학습하고 싶고 함께 배우고자 하는 의지는 수료 초반과 크게 달라지지 않았다. 글에서 마지막에 언급한 것처럼 누구나 알만한 네임드 기업에서 높은 보수를 받는 나이스한 엔지니어가 되지 못하더라도 이 바닥에서 불행히 일하지 않을 자신은 있다. 그래서 포기할 마음이 없다. 계속 항해해보고 싶다.</p><p>이 글을 읽고나니 스스로 실력이 부족하다고 느끼는건 어쩌면 조급함의 결과가 아닐까도 싶었다. 4년을 공부한 사람들과 고작 6개월 공부한 나를 직접 비교하는건 애초부터 무리였을지도 모른다. 그러나 국비교육과정이 끝나면, 이들과 동등하게 구직을 준비하게 된다. 준비 기간이 부족해서 실력이 이정도라는건 충분한 변명일지 모르나 필드에서는 내 준비 기간이 어쩐지는 궁금해하지 않는다. 3개월을 했든, 3년을 했든 회사가 요구하는 수준의 실력을 갖추어야만 한다. </p><p>부족하다는 사실은 인정하되, 자괴감에 빠지기보다 계속 부족함을 채워나아가야겠다. 이 글 덕분에 다시 작게나마 용기도 얻고, 동기부여도 얻게 되었다.</p><ul><li><a href="http://economychosun.com/client/news/view.php?boardName=C00&t_num=13607320" target="_blank">“평생직장은 없다, 최고가 돼 떠나라”.. 新기업의 탄생</a></li></ul><p>평소 좋아하는 회사인 우아한형제들에 대한 이야기인데, 회사에 대한 이야기보다는 창업자들에 대한 이야기이다. 난 평생직장이 없다고 믿는 사람이다. 결국 언젠간 회사와 구성원이 이별하는 순간이 올텐데 웃으면서 하는 유일한 이별은 창업을 하기위해 퇴사하는 방법이다. </p><p>창업은 누구나 할 수 있는 커리어 선택지가 아니다. 회사생활도 어려운데, 조직을 신설해서 운영하는건 훨씬 더 어려운 일이다. 이렇게 어려운 일을 하기위해서는 남다른 노력을 해야하며 준비도 철저히 해야한다. 창업을 하기위한 준비가 되었다는건 그 조직에서 남다른 성장을 했다는 증거이다. 창업 후 실패할 수도 있으나 처음 회사에 조인했을때보다 성장했기 때문에 창업이라는 더 큰 도전에 나설 수 있는거라고 생각한다. </p><p>우아한형제들의 경영진처럼 구성원들의 더 나은 커리어를 응원하고 장려하는 조직에서 커리어를 시작하고 싶다. 창업을 할 수 있든 없든 상관없이 직원들의 커리어를 이렇게 생각하는 회사라면 개인의 성장도 기대해볼 수 있을 것이며, 그렇게 성장하는 개인들로 구성된 조직의 수준도 기대가 된다.</p><br><hr><h2 id="What-I-watched-in-this-week"><a href="#What-I-watched-in-this-week" class="headerlink" title="What I watched in this week."></a><a name="watched"></a><span style="color:red">What I watched</span> in this week.</h2><p><a ref="https://youtu.be/JmWhnuxLV1o" target="_blank">백기선 - 개발자 고민 상담, “개발자는 기술이 핵심인 회사가 아니면 가면 안되나요?”</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/JmWhnuxLV1o" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>이번에도 백기선님의 유튜브 영상이다…ㅋㅋ<p>스프링을 학습하고 있는 사람으로 백기선님 영상은 요즘 내가 가장 관심있는 채널이면서 또 유익한 채널이기도 하다. 알람 설정을 해두고 빠지지 않고 대부분의 영상을 시청하고 있는데, 이제 다음달부터 본격적인 구직을 앞두고 기존에 내가 갖고있던 생각을 허물어뜨리는(?) 영상이었다.</p><p>이 영상을 보기 전까지는 나도 기술이 중심이 회사에서 커리어를 시작해야 한다고 생각했다. 그러나 개발은 어디서나 필요한 영역이고, <strong>사업이 어떻느냐보다 결국 내가 그 회사에서 무엇을 하는지, 그리고 누구와 일하는지가 중요</strong>하다고 생각이 바뀌었다. 영상 속에서 백기선님이 언급하셨듯이 백기선님이 아시는 훌륭한 개발자분들이 우아한형제들에 많다고 하시는데, 해당 회사에 개발자분들이 많은게 우아한형제들이 개발이 주된 회사이기 때문에 조인하셨는지는 확신할 수 없다. 그러나 우아한형제들에 훌륭한 개발자분들이 많기 때문에 이들과 함께 일하기 위해 조인했다고 한다면 납득이 간다. </p><p>개발이 주된 회사이지만 내가 함께 일하고 싶어하는 개발자가 없고, 또 거기서 내가 하는 일이 내 커리어 발전에 도움이 안되는 일이라면 그 회사는 나에게 좋은 회사라고 할 수 없을 것이다. 반면 개발이 주된 회사가 아니어도 그러니까 영상 속 사연의 주이공처럼 교육이 업인 학원에서 개발자로 일하게 된다하더라도 내가 거기서 웹 백엔드를 계속 할 수 있고, 곁에서 많이 배울수 있는 좋은 사수 분들이 계시다면 지금의 나에게 좋은 옵션이 될 수 있다고 생각이 든다. </p><p>운좋게도 구직 전에 이 영상을 본 덕분에 앞으로 구직에 도움이 될 것 같다.</p><br><hr><h2 id="What-I-learned-from-this-week"><a href="#What-I-learned-from-this-week" class="headerlink" title="What I learned from this week."></a><a name="learned"></a><span style="color:red">What I learned</span> from this week.</h2><p>위클리 리뷰를 작성하기 시작한지 3주가 되었다. 처음엔 주말에 공부를 하거나 코딩을 하는것도 아닌 이렇게 리뷰하는게 귀찮기도 했고, 뭐가 달라질까 회의적이었던것도 사실이었다. 그런데 이렇게라도 내가 한 주간 무엇을 했는지 정리를 하니 그 다음주엔 무엇을 할지, 더 나은 방법은 없는지 고민도 할 수 있고, 이를 통해 더 나아졌는지 아닌지도 생각해볼 수 있어서 좋았다.</p><p>계속 꾸준하게 작성해서 연말즈음에 내가 얼마나 성장했는지를 파악해보고 싶다. 또 그때가서 실망하거나 부끄럽지 않도록 이 위클리 리뷰를 통해 계속 채찍질해서 계속 배우고 성장해야겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - 새 DB계정 생성하고 접속하기</title>
      <link href="2019/07/oracle-create-new-account/"/>
      <url>2019/07/oracle-create-new-account/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1490111718993-d98654ce6cf7?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80" width="650px" /><p>데이터베이스 계정을 새로 만들어서 접속하는 법을 정리하고자 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- DB 계정 생성</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> [<span class="keyword">new</span> <span class="keyword">user</span>] <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> [<span class="keyword">password</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 접근 권한 허용</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>, <span class="keyword">resource</span>, dba <span class="keyword">to</span> [<span class="keyword">new</span> <span class="keyword">user</span>];</span><br></pre></td></tr></table></figure><p>이렇게 하면 DB 계정이 생성된다. 새로 생성한 계정에 접속하는 방법으로는 2가지가 있다. 기존에 접속한 DB를 로그아웃하고 접속하는 방법과 로그아웃하지않고 추가로 DB계정에 접속하는 방법이다.</p><p>먼저 로그아웃없이 새 계정에 접속하는 방법이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 기존 접속한 DB 로그아웃없이</span></span><br><span class="line"><span class="comment">-- 생성한 계정으로 DB 전환</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">USER</span> [<span class="keyword">new</span> <span class="keyword">user</span>] </span><br><span class="line"><span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> [<span class="keyword">password</span>] <span class="keyword">account</span> <span class="keyword">unlock</span>;</span><br></pre></td></tr></table></figure><p>기존 접속을 해제하고 다른 계정에만 접속하고자 한다면 아래의 방식대로 입력하면된다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 현재 접속된 계정 비활성화(disconnect)</span></span><br><span class="line">disc;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 계정 접속</span></span><br><span class="line">CONN [new user]/[password];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - SET</title>
      <link href="2019/07/oracle-set/"/>
      <url>2019/07/oracle-set/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/6a1d/1nh2hii9orqjfhjzg.jpg" /><h3 id="목록"><a href="#목록" class="headerlink" title="목록"></a>목록</h3><ul><li><a href="#set">SET</a></li><li><a href="#union">UNION</a></li><li><a href="#union-all">UNION ALL</a></li><li><a href="#intersect">INTERSECT</a></li><li><a href="#minus">MINUS</a></li></ul><br><hr><h1 id="SET"><a href="#SET" class="headerlink" title="SET"></a><a name="set"></a>SET</h1><p>두 가지 select문을 통해 얻어온 결과에 대해 <strong>집합 연산</strong>을 하는 명령문이다.</p><p>두 select문의 각 컬럼의 개수, 순서가 완전히 같아야만 한다.</p><br><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a><a name="union"></a>UNION</h2><p>중복을 허용하지 않는 합집합.</p><p>중복이 있다면 하나의 row(데이터)만 가져온다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno=<span class="number">10</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> job=<span class="string">&#x27;CLERK&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>쿼리 A</li></ul><img src="http://www.mediafire.com/convkey/bef9/2bpf3mri3w943mrzg.jpg"/><p>3개의 row가 조회된 것을 알 수 있다.</p><ul><li>쿼리 B</li></ul><img src="http://www.mediafire.com/convkey/c14d/algfzf8gz4fl3mgzg.jpg"/><p>4개의 row가 조회된 것을 알 수 있다.</p><ul><li>쿼리 A, B를 UNION을 통해 조회</li></ul><img src="http://www.mediafire.com/convkey/6f1a/38oi318ymssggctzg.jpg"/><p>앞서 조회된 두 개의 쿼리 결과에서 중복된 결과인 <code>ename=&#39;MILLER&#39;</code>를 제외한 나머지 7개의 row가 조회된 것을 알 수 있다.</p><br><h2 id="UNION-ALL"><a href="#UNION-ALL" class="headerlink" title="UNION ALL"></a><a name="union-all"></a>UNION ALL</h2><p>UNION과 달리 중복되더라도 모든 row의 데이터를 조회하는 합집합</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno=<span class="number">10</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> job=<span class="string">&#x27;CLERK&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>쿼리 A</li></ul><img src="http://www.mediafire.com/convkey/c31f/mvryezjzvuyuhxgzg.jpg"/><ul><li>쿼리 B</li></ul><img src="http://www.mediafire.com/convkey/e24c/t0oh9kdgzd0r93qzg.jpg"/><ul><li>쿼리 A, B를 UNION ALL로 조회</li></ul><img src="http://www.mediafire.com/convkey/c9fd/jzziwwludpemj12zg.jpg"/><p>각각의 쿼리에 따른 결과가 중복을 포함하여 7개의 row로 조회된 것을 알 수 있다. (MILLER가 두 번 조회되었다.)</p><br><h2 id="INTERSECT"><a href="#INTERSECT" class="headerlink" title="INTERSECT"></a><a name="intersect"></a>INTERSECT</h2><p>두 가지 쿼리의 <strong>교집합</strong>을 구하는 쿼리이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno=<span class="number">10</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> job=<span class="string">&#x27;CLERK&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>쿼리 A</li></ul><img src="http://www.mediafire.com/convkey/cc6e/ir68lxf64uqmr7izg.jpg"/><ul><li>쿼리 B</li></ul><img src="http://www.mediafire.com/convkey/64ad/3be5nvz35jsqt4hzg.jpg"/><ul><li>쿼리 A, B를 INTERSECT로 조회</li></ul><img src="http://www.mediafire.com/convkey/63da/rrj1gmtnk9armo0zg.jpg"/><br><h2 id="MINUS"><a href="#MINUS" class="headerlink" title="MINUS"></a><a name="minus"></a>MINUS</h2><p>두 가지 쿼리의 <strong>차집합</strong>을 구하는 쿼리이다. 정확히는 A 조회문에서 B조회문의 결과를 제외한 조회를 의미한다.</p><p>INTERSECT에서 사용한 쿼리를 재사용해보겠다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno=<span class="number">10</span></span><br><span class="line"><span class="keyword">MINUS</span></span><br><span class="line"><span class="keyword">SELECT</span> empno, ename, job, deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> job=<span class="string">&#x27;CLERK&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>쿼리 A</li></ul><img src="http://www.mediafire.com/convkey/cc6e/ir68lxf64uqmr7izg.jpg"/><ul><li>쿼리 B</li></ul><img src="http://www.mediafire.com/convkey/64ad/3be5nvz35jsqt4hzg.jpg"/><ul><li>쿼리 A,B를 MINUS를 이용한 조회</li></ul><img src="http://www.mediafire.com/convkey/96a6/hp8fcwquy3wc3zuzg.jpg"/><p>쿼리 A의 조회 결과에서 쿼리 B와 중복되는 결과, 즉 INTERSECT 결과만 빠진 나머지 쿼리 A의 조회 결과만 조회된 것을 알 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - JOIN</title>
      <link href="2019/07/oracle-join/"/>
      <url>2019/07/oracle-join/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/6a1d/1nh2hii9orqjfhjzg.jpg" /><h3 id="목록"><a href="#목록" class="headerlink" title="목록"></a>목록</h3><ul><li><a href="#join">JOIN</a></li><li><a href="#self-join">SELF JOIN</a></li><li><a href="#outer-join">OUTER JOIN</a></li></ul><br><hr><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a><a name="join"></a>JOIN</h2><p>두 개 이상의 테이블에 있는 컬럼의 값을 한 번에 가져오기 위해 사용하는 쿼리이다. 조회하는 컬럼 중 어떤 컬럼은 A테이블에, 어떤 컬럼은 B테이블에 있다면, FROM 절에 A테이블, B테이블을 join해야 원하는 데이터를 조회할 수 있다.</p><img src="https://lh3.googleusercontent.com/n0W4cRiFybuKEk_vYxLGvhEby49KURf8VYGk1w3LrhldykoGA40erYLjpBsDDGdpUmsie9KX7_1Amsy20f3PkmlzlJO_0QM2QMAyINMyiIt2gSyNMS2v1siuVdz7e-Kql1WoOEP1iExnZHjdicCgd5SyMVPiW3yN4wZz9qpNJKLwHH3TPlxPRhJVJCVJ7BhpRozM1Y2MfClzyQm0N4Ehi0QYmB7FjhgOQKfpDFcsJ7sU-Rmgaa7MW03j6GLFThw2_BZbIxheAZ28338dlgVeIvL19iVzp1b-2YBM_5spD3knINeKAFkldQV7ZzUPE1V020azpv100uTYPRtA3JJhgsfRF4q-2Dw4NWZH_5Ih8Ug_ymSYoiWYBFFoxGg4YPHBJa7tKwfuMMkfGtLWykfefyRDhM4S0zVtflCfN-AXvL9q8ewU3P7_vdrsTkk_sjDEwQn9ZiMc32iouP5It6Rv19TSpw63usuu8t205Z-ajZ0CF8djLAjpGrbTwjcS1SU28rbc5h44CmzR6sWZxV_yoFwWgjiklM95JRey20tLjJq5DWwSpvt3_hvpzIO3IdSPPhWnwINWGvre6v7jZ5HHiLMcVbd6CJ4OpJnnNGelAjFBGDEJsu4iP3mq6OYw_ttRX86NMcbnZ4jrMh0oH-rjUBxownsS7qXG7qxdi1a_r69X8kW8EbNOgkTw79sGoruM8dpouIjV8fBozus8P6NQLQkfDLTBXho241zbtJG9ptjP2M6m318VyGWm=w540-h359-no" style="width: 80%;" /><p>위 쿼리에 대한 조회를 보면, emp 테이블에 대한 전체 조회를 했을 경우, 출력되는 컬럼 수는 14개이다. 그리고 dept 테이블에 대한 전체 조회를 했을 경우, 출력되는 컬럼 수는 5개이다. </p><p>join을 해서 조회하면 두 테이블에 대한 데이터를 중복검사 없이 조회를 하기 때문에 emp 테이블의 14개와 dept 테이블의 5개를 결합한 총 70개의 데이터가 조회되는 것을 확인할 수 있다.</p><p>SQL Developer 통해서 join한 전체 데이터를 다시 조회해보면, 중복되는 컬럼을 확인할 수 있다.</p><img src="https://lh3.googleusercontent.com/BUNJGbZ74c_LGVIhazNg5oXDgwvsEOCwYw88-um3ei-QHfI8fWTAG7ssvWqBCZqVVh4CUqxoVrtACLF27ND416bCUhO_SV14M-BdN6plXB9FW8e3hQZ8lcqOedHRlKNKOKePqoctCl6h0rsgUY1NI0wMm1lZdn5o3IxYpi-ZitV8isJQYvnm3FAYVj1oVJFGsSFOdfj_2CQhMHic9uU0W1YtMRo2zOWohQt_YFX7SW2wHBVbFRjciRu1o8BwZxHo0nalqMncIh-31AecfIUvV7ewFfCF-n5vsDopv5_jt_eXq19daw7p98_ew4x68SQo_Ml1ETx8MAIIEV8CSPLpMpLfxm6FUCuPT2cKw4GloJPkIEOm47bOo5QA-pc34ODmo-HWcjVKgQXTbKhjjIwpHnHYmfWOqumIkaICF1HTmUbc1z7xjTpBcNUQjsUKcuW5oLELkZcOZqUPf8kSCtrIDrOfE9JTljwOxiwBMtuzSL3QmRHB0cZA7-xvbI2XA-BAMx7qHfTej47In0DjarK8AuBD0Q429BR-_WlaOOduCcdBdLt9HFo4I8sXj6HDwzXLLA26lZdWxnyKSA1iOVoObMsmR94RQNNvZHNqdiZTMj1ea7XK6aWfM00L0HQxkI6ACv8wMnYESoHYxT_1lF_ZOtTLMZUT0OvlQU9nLiqtw4s93lf2ujqv7p6GKHH_FThBtK2NLiCo9Qy-IsOCE6GaTktIcufy61ybDKcwhJ8qY4co555mYmP3W6o3=w1010-h574-no" style="width: 75%;" /><p>이 중복된 데이터를 제거하고 조회하고 싶다면, emp 테이블의 deptno 컬럼과 dept 테이블의 deptno 컬럼이 같다는 것을 명시하면 될 것이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> emp, dept</span><br><span class="line"><span class="keyword">WHERE</span> emp.deptno = dept.deptno;</span><br></pre></td></tr></table></figure><p>이렇게 하면 잘못된 데이터는 제외되고 14개의 데이터만 조회된다.</p><br><h2 id="SELF-JOIN"><a href="#SELF-JOIN" class="headerlink" title="SELF JOIN"></a><a name="self-join"></a>SELF JOIN</h2><p>같은 테이블을 두 번 이상 조인하는 것을 <strong>Self Join</strong>이라고 한다.</p><p>아래의 데이터를 조회해보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;SMITH&#39; 사원의 사원번호(empno), 이름(ename), 직속상관의 이름(ename)을 가져온다.</span><br></pre></td></tr></table></figure><p>ename을 두 번 조회해야 하는 문제이다. 당연히 같은 이름이 아니며, ename 중 하나는 ‘SMITH’ 이름에 해당하며, 다른 하나는 ‘SMITH’ 사원의 직속상관(mgr)과 같은 사원번호를 갖는 사원의 이름이 될 것이다. 쿼리를 작성해보면 다음과 같다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.empno, e1.ename, e2.ename <span class="keyword">as</span> <span class="string">&quot;직속상관&quot;</span></span><br><span class="line"><span class="keyword">FROM</span> emp e1, emp e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.ename = <span class="string">&#x27;SMITH&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> e1.mgr = e2.empno; <span class="comment">-- e1 테이블의 mgr과 일치하는 empno를 갖는 테이블 조회</span></span><br></pre></td></tr></table></figure><p>emp 테이블을 두 개 가져와서 하나는 ‘SMITH’ 사원에 대한 테이블로, 다른 하나는 ‘SMITH’ 사원의 직속상관에 대한 데이터를 찾는 테이블로 사용했다.</p><br><h2 id="OUTER-JOIN"><a href="#OUTER-JOIN" class="headerlink" title="OUTER JOIN"></a><a name="outer-join"></a>OUTER JOIN</h2><p>조인 조건에 만족하지 못해 제거되는 row까지 모두 가져오는 것을 Outer Join이라고 한다.</p><p>아래의 퀴즈를 해결하며 알아보자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">각 사원의 이름(ename), 사원번호(empno), 직속상관(mgr) 이름(ename)을 가져온다. </span><br><span class="line">단 직속상관이 없는 사원도 가져온다.</span><br></pre></td></tr></table></figure><p>일반 사원에 대한 테이블과 각 사원에 대한 직속상관에 해당하는 테이블 2개를 조회해야 함을 알 수 있다.</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.ename, e1.empno, e2.ename</span><br><span class="line"><span class="keyword">FROM</span> emp e1, emp e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.mgr = e2.empno; <span class="comment">-- e1 테이블의 mgr과 일치하는 empno를 갖는 테이블 조회</span></span><br></pre></td></tr></table></figure><p>이렇게만 하면, 아래처럼 조회할 수 있다. </p><img src="https://lh3.googleusercontent.com/XIyG-WVAZngp2HoodgyPnBHPzUyvWEvvzNYpkiD2437iLBtpY2WQxzZ6vApyyABovFDaK6Ka-bEMdnUvGt44rc78assVoji9r8zVAZN8x5JcrMjKXGSAea7Fesw1-Ulvo0hDJ881ThIcJzlWZD1-fMFx5WZT0tUMEIJQVdlQY-ocgbg5d2hqGTFv9uhqnD3kJrAudwu6cLTrmuNAEHq57Ph8oKct3y3G7CMLpDq8BCeYGacHidAk0wSw89-ejsdVzQsTkhnV4Mgp5r_PSG9pl2qNqs_JDmo1XIf-P3IF7VTfGr9ODCjI6fq1AuHj_9zWacmcYCYne4ahQ2ipfspBfVjVP6W5Ulk56C-A584JeTh_sfqHnXkSGbRja-t2okFPHHG_TpJAwu9ighQJfof0FcWbqU4eCzNiSDuBalD20GlAJklrRr_aqfFBTXMZuk3f6u8ucqpGaG6MCLjepSzW9VmLc29hEWqtOmUlSBX40p4qE1bwCeaAt59LhHXO8547MswwJAa7tWLB3k93DteFjb_Ox3M6j6IOub2wk4JMhBtg_-heudgi-k7YocT8R5vDcmuZgDHFQ7lQKC49a2nr3TOrnHzL8RQUCXtw3vZ-pi30LaPerX_fUzXkwOjc2zT0YXkGA1YJAlXHKeM5TXX-w_MtJbw3rNky1St6VA8ZR0CmCLOiypP7ljKXx4VgXk-limhShCPSw5BSjKCjjSsRepT2r-ZfBX7k8vutl7Z-MzMEDf3fTlRYUqg=w1010-h884-no" style="width: 75%;" /><p>퀴즈의 조건 중 직속상관이 없는 직원은 조회되지 않은걸 알 수 있다. 이 때 사용되는게 <strong>Outer Join</strong>이다.  Join을 하는 테이블중 where 조건에 해당안하더라도 모든 데이터를 조회하고자 한다면, (+)를 붙여서 조회하면 된다. </p><p><img src="https://lh3.googleusercontent.com/vGErvArq7b90o2hb4Gik7FpY62KXvPhEGVkg7124VsvHq5L-YZ2jzek9rHcgJqTI5T96cw3FUeiLwdW8QOjC1z4R9lNoAJZOeOeYK6xMLmum0Bm8gRsWUQJY92BsgwszxlCSo8NpDsII4SjzlXAFAPNHMXRbX8_FEI9uXvwc4JkeSNDeUq86RT3v_vljNB3VVgw2FqswxgPAuPSvHsju9ozuzQnuFMPoNW8wYrPZZlVj9RLhqjNtHN9wBIRHOD5AvPQpZROjUP86mtphwhQBNXOcEYP9211msqSwf70tQveW1tgvwW_Mn8D1h8nnMoj1Y6viOk3i9Ys_Zuik-Rl3im7f45gcKE5beggf8ixuuQexBjubHETKBBpxucjG7p1oP8jctqQ9cyc7Mn0NQo98T5q6wz1fKGb3-iFomN8G92kvdTtXqFZbnQZYdOnPrpOlp1eE8frF0g2YVYopM8pgx3mUvJg8n2TwXMC0TwGSJE29XFHQtwQtI_B-4iWpPh0sxlcLkUN6GLYaL4Kuds8ENfz4DOfEPcXOiOiEQ_yqfuIJt3Snkgt7V6XMYUq66EPsFZM-QWJZW_Yad62RBNicV_vx7_6dYC5nP10-q0YBJKuog6qUHp3w6GtuN42xPr1GHe5AVITBhZ1JiNL-e7JWoLxW9qJUupLpf6f4Sz8bakrtqxUErZegazAcsbBGvUbljuEsXd5XruZZX6lMSazOWLcxrjzNu07fJ3kRsVhjcEiACzHlv-ndV_4=w500-h234-no"></p><p>쿼리를 수정해서 다시 조회해보았다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.ename, e1.empno, e2.ename</span><br><span class="line"><span class="keyword">FROM</span> emp e1, emp e2</span><br><span class="line"><span class="keyword">WHERE</span> e1.mgr = e2.empno(+); <span class="comment">-- where조건에 부합하지 않더라도 e2 테이블 전체조회</span></span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/Px34TJrEkHB-9xpgFF_Zrw39JA8azlF2m6Qq-XAsw-gMS_HcHs6TI33gofHvrAbuVkUGIQcvWdgwzAewRudFf6vUMkntxDrTpK9i25-JMQt2BBqGTN1_rSwK0wh_brr0OPrxZTCiOT6cqVrhT_S-uGrCQEJmeNe_q89ZBmlQZhvRjITIFC6HI4VAHm-Kwb__kI4Pu8fbbSHqUr6W8fyk7kq5ZEX6nTpYOsDwJ9zXwC2n9O-C8sI6k_BpIA2CAZI6mr4YmsT5MvNsJOfiUb3ktlRv3muECn1JZic7cvqK_yNqNp2wpiNjRyfqongfmSki1D_SMiSxyDdWcu442d6FNU0hYLxs1ZDrZno8GAtqEMNwwD-xlnwFFoCTU8LWLqx4S6W9K5KUZOeE9rWx5jWRpfGQUtrnSNlaVuHbmC0sUknKCj3G1u46g536KT5ot8UNXl5-0Pdk3T8m5laS1Arco8BWT_IPjIXx22fJ-6HM1IqXaJMlNrqBfVx4_OFNGYcmbCn07HD9rMvEsL1Fun0EvFj-2JMD0sqfYy-iMqd_XMF-ObMV_t_MCP5jzJhO3PA8rvurtR2fS8EPz2cXqBGuBMCX3yyoRoOIVHrBeOpwd3Azkv3XPRvusERkWJ1pW8UzLIVELLqO5MZJknb-S3ffckn3-Y5MeOc5S6ozhpigaQMyvgCfsMzW4tiL-IqLLNX-NpbvAn3DJrotGtslUtcKUSS0wh6nNrmOLqui3pzk_q6ZYSULvqdL0ic=w996-h892-no" style="width:75%;" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>오라클에서 전체 테이블 조회하기</title>
      <link href="2019/07/oracle-show-all-tables/"/>
      <url>2019/07/oracle-show-all-tables/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1544023341-95f23c83cafe?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1651&q=80" width="600px" /><p>오라클을 하면서 몰랐던 쿼리가 있다. MySQL에서는 <code>show tables;</code> 라는 간단한 쿼리로 테이블 전체 조회를 할 수 있었는데 오라클에선 어떻게 모든 테이블을 조회할 수 있는지 알지 못했다.</p><p> 내가 찾은 답은 이렇다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    table_name, owner</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    all_tables</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    owner=<span class="string">&#x27;ACCOUNT&#x27;</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    owner, table_name;</span><br></pre></td></tr></table></figure><p>위의 쿼리에서 조건절에서 <code>&#39;ACCOUNT&#39;</code> 대신 테이블 조회를 원하는 계정을 입력해서 해당 계정에 생성된 모든 테이블을 조회할 수 있다.</p><img src="https://www.mediafire.com/convkey/ece9/kzn11kgcb2wsd2pzg.jpg" width="400px" /><p>‘SCOTT’ 계정내 테이블 조회를 한 결과이다.</p><p>이렇게 전체 테이블을 조회하다 보면 더 이상 사용않는 쓸모없는/불필요한 테이블이 발견될 수 있는데, 이 때  <code>DROP TABLE &#39;table&#39;</code> 쿼리를 이용하여 테이블을 삭제할 수 있다.</p><img src="https://www.mediafire.com/convkey/8a2c/y8t22sw3j02ib1jzg.jpg" width="400px" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> tip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>한글 깨진 파일 UTF-8 변환하기 (Iconv)</title>
      <link href="2019/07/iconv/"/>
      <url>2019/07/iconv/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1555424681-b0ecf4fe19a5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1867&q=80" width="650px" /><p>맥을 사용하면서 불편한 점 중 하나는 UTF-8으로 인코딩되지 않은 파일을 타 운영체제 사용자로부터 파일을 받을 때이다. 지금까지는 양해를 구하고 UTF-8 인코딩을 부탁하곤 했는데, 이제 그럴 필요가 없어졌다.</p><p>php 코드 한 줄만으로 한글이 깨져서 전송된 파일을 UTF-8으로 인코딩해서 복구할 수 있기 때문이다.<br></p><h2 id="iconv"><a href="#iconv" class="headerlink" title="iconv"></a>iconv</h2><p>php엔 파일의 character encoding을 바꿀 수 있는 <a href="https://www.php.net/manual/en/function.iconv.php" target="_blank">iconv</a> 라는 함수가 존재한다. 이 함수를 사용해서 간단히 문제를 해결할 수 있다.</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iconv -f euc-kr -t utf<span class="number">-8</span> [file] &gt; [<span class="keyword">new</span> file]</span><br></pre></td></tr></table></figure><p><code>-f</code> : 원 문서의 인코딩 방식</p><p><code>-t</code> : 새로 출력되는 파일의 인코딩 방식</p><p><strong>인코딩 전</strong></p><img src="http://www.mediafire.com/convkey/8d6c/eu9kzcicc80xofdzg.jpg" /><p><strong>인코딩 후</strong></p><img src="http://www.mediafire.com/convkey/c90f/tlln4gcjwkk8uujzg.jpg" />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tutorial </tag>
            
            <tag> terminal </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - 7월 1주차</title>
      <link href="2019/07/WeeklyReview-2019-Jul-First/"/>
      <url>2019/07/WeeklyReview-2019-Jul-First/</url>
      
        <content type="html"><![CDATA[<img src="http://www.mediafire.com/convkey/d4a9/z779uen1xiw26sbzg.jpg" width="650px" /><h2 id="What-I-did-in-this-week"><a href="#What-I-did-in-this-week" class="headerlink" title="What I did in this week."></a><span style="color:red">What I did</span> in this week.</h2><p>이번주는 부족하다고 지난번부터 부족하다고 느낀 오라클을 공부했다. 오라클 뿐만 아니라 관계형 데이터베이스에 대한 학습이 궁극적 목표이다. 인프런에서 구입한 강의를 들으며 학습노트를 만들어서 아카이브 하고 있는데 이렇게 하니까 효율이 떨어지는 것 같다. 시간을 너무 잡아먹는 다랄까? 앞으로는 강의만 빠르게 듣고 나중에 중요하다고 생각하는 부분만 노트로 만들어야겠다.</p><p>그리고 토요일인 어제 부스트캠프 코딩테스트를 봤는데 결과가 좋지 않을 것 같다. 120분간 2문제를 푸는 테스트였는데, 알고리즘은 제대로 공부한적 없기 때문에 당연히 어려울거라 생각했지만 Java라는 언어에 대해 내가 정말 알고 있는지 의심들만큼 Java가 낯설게 느껴졌다. 최근 프로젝트 한답시고 JSP와 스프링을 하면서 Java의 기초적인 부분과 배열에 대한 부분이 너무 낯설게 느껴졌다. 배열을 공부하던 2월이나 자료구조를 공부한다고 스터디를 시도했던 4월에 끝내지 않고 지금까지 조금이라도 계속 유지했으면 어땠을까 후회가 들었다. 어쨋거나 작은 쇼크가 와서 코딩테스트를 마치고 급하게 다시 Java의 정석을 읽었다..</p><br><h2 id="What-I-read-in-this-week"><a href="#What-I-read-in-this-week" class="headerlink" title="What I read in this week."></a><span style="color:red">What I read</span> in this week.</h2><p>리디북스에서 <a href="https://ridibooks.com/v2/Detail?id=443000315&_s=instant&_q=%ED%9B%8C%EB%A5%AD%ED%95%9C%20%ED%94%84%EB%A1%9C" target="_blank">훌륭한 프로그래머가 되는 법</a> 이라는 책을 구입했다. 언어에 대한 책이 아닌 순수 프로그래밍에 대한 책은 첫 구매였는데, 이 책을 읽을 때마다 뭔가 ‘좋은 개발자’가 되는듯한 착각을 주어서 기분좋게 읽고 있다..ㅋㅋ 아직 20% 정도 밖에 읽지 못했지만 한 번 읽고 끝내기보다는 2-3년차가 될 때까지 종종 꺼내 읽어보면 좋을 책 같다. </p><p>지인으로부터 코드스쿼드를 이수하다 그만둔 사람의 글(<a href="https://aftersnowing.tistory.com/m/30" target="_blank">코드스쿼드 3달째(feat. 마지막 달)</a>)을 공유받아서 읽었다. 프로그래밍을 처음 시작한 사람이었지만, 프로그래밍에 흥미가 있어서 시작한게 아니었기 때문에 슬럼프가 왔을때 이를 극복못하고 포기한 이야기였다. 나도 올 초 한 두달간의 슬럼프를 겪었기 때문에 남일 같지가 않았다. 당시에 나 역시 <em>‘정말 내가 이 길을 걸어도 되는걸까’*라는 고민을 한 적이 있다. 그 질문에 *’응 걸어도 돼’</em> 라는 대답을 스스로 내놓지는 못했지만, 프로그래밍이 싫지는 않았다. 계속 하고 싶었고, 문제 해결이 안되는 것에 지쳤을뿐 문제를 해결했을때의 희열은 그 모든 고통을 한 번에 날려버릴만큼 통괘했다. 그렇게 하나가 해결되면 그 다음 문제를 어떻게 해결할지를 고민하는 것이 즐거웠다. </p><p>가장 힘들땐 타인과의 비교였다. 그 누구도 나를 다른 사람과 비교하지 않음에도 혼자서 다른 사람과 비교하여 <em>‘왜 저 사람만큼 퍼포먼스가 나오지 않을까’</em>, <em>‘적성에 안맞는걸까?’</em> 라는 생각을 자주 하곤 한다. 그럴때마다 사람들의 성장속도는 다 다르다고 스스로를 이해시키고 있지만 그래도 이런 생각이 들때마다 자존감이 떨어지는건 어쩔 수 없다.</p><p>위에서 <a href="https://aftersnowing.tistory.com/m/30" target="_blank">코드스쿼드 3달째(feat. 마지막 달)</a>라는 글을 쓴 사람이 실패했다고는 생각하지 않는다. 프로그래머로서의 커리어가 시작해보기도 전에 종료되었을뿐 결국 이 분은 어떻게든 자신만의 길을 찾을 것이다. 실패없이 성공한다라는 달콤한 시나리오는 나는 믿지 않는다. 많은 실패는 점점 더 정교하게 성공의 길로 인도한다고 항상 생각한다. 그렇기에 이 분의 선택은 존중받아 마땅하다고 생각하며, 동시에 포기하지 않고 계속 이 길 위에 있는 내가 올바른 선택을 한 것인지 미래에 후회하지 않을 선택이 될지 매 순간 스스로에게 검증받아야 할 것 같다. 이번주에 학습법이 효율성이 떨어진다고 느꼈는데, 다른 방식으로 학습법을 바꿔보고 이게 안되면 또 바꿔보고 하는 방식으로 작은 실패를 끊임없이 경험해보며 조금씩 전진하고 싶다.</p><br><h2 id="What-I-watched-in-this-week"><a href="#What-I-watched-in-this-week" class="headerlink" title="What I watched in this week."></a><span style="color:red">What I watched</span> in this week.</h2><p>요즘 구독하고 자주 보고있는 백기선님의 유튜브 고민상담 영상.<br><a href="https://www.youtube.com/watch?v=4kYNC-QNg1w&amp=&feature=share" target="_blank">개발자 고민 상담, 신입 개발자는 어떤 업무를 하냐구요? 정말 중요한 업무가 있습니다.</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/4kYNC-QNg1w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br>이제 구직 준비를 한달 여 앞두고 요즘 가장 큰 관심사이다. *'내가 정말 개발자로 취업 할 수 있을까'*가 궁금하면서도 만약 정말 구직이 된다면, *그래서 내가 회사에서 어떤 일을, 어떻게 해야하는걸까?* 가 궁금한데, 이 질문자도 그런 걱정과 호기심 때문에 질문한 것 같다. 개발자를 준비하는 입장에서 굉장히 현실적인 조언이었다고 느꼈다. 영상을 요약하면 다음과 같다.<ul><li>회사에 사수를 지정해달라고 부탁한다.</li><li>필요할 때마다 가서 귀찮게 하기보다 질문 목록을 만들고 미팅을 잡아서 한 번에 몰아서 물어본다.</li><li>물어본 내용은 메뉴열로 만든다거나 노트에 정리해서 아카이브한다.</li></ul><br><h2 id="What-I-learned-from-this-week"><a href="#What-I-learned-from-this-week" class="headerlink" title="What I learned from this week"></a><span style="color:red">What I learned</span> from this week</h2><p>부스트캠프 코딩테스트를 통해 다시 큰 동기부여를 받았다. ‘’그냥 이 정도로만해도 취업은 할 수 있겠지?’ 라는 생각이 없지 않았었던 것 같다. 육체적으로 나태하진 않았지만 정신적으로 나태했다고 해야하나? 아무튼 내가 얼마나 부족한지 다시금 알 수 있었다. 이제 계속 필요하다는 이유로 주먹구구식으로 이것저것을 동시다발적으로 공부하기보다는 우선순위를 정하고 철저하게 지키면서 공부해야겠다. 일단은 데이터베이스가 당장 최우선이라고 생각한다.그래서 관계형 데이터베이스까지 한 번 훓고 가볍게라도 정리하는걸 목표로 끝내고 그 뒤에 또 다시 정말 중요하고 필요하다고 생각하는 공부를 해야겠다. 일단 지금으로는 DB 공부를 마치면 자바, 스프링 공부를 할 생각이다. </p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weekly Review - June 4th</title>
      <link href="2019/07/WeeklyReview-2019-Jun-Fourth/"/>
      <url>2019/07/WeeklyReview-2019-Jun-Fourth/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1505238680356-667803448bb6?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" width="650px" /><h2 id="What-I-did-in-this-week"><a href="#What-I-did-in-this-week" class="headerlink" title="What I did in this week."></a><span style="color:red">What I did</span> in this week.</h2><p>국비지원 학원의 마지막 커리큘럼인 Spring에 대한 강의를 듣고있다.</p><p>이 전에 자바 강의를 들을때 명확하게 이해하고 넘어오지 못해서 사실 Spring이 얼마나 편한지 아직까지 명확하게 느껴지지 않고 있다. 다만 지금 이 글을 작성하고 배포하고 있는 Hexo 프레임워크와 마찬가지로 Spring 역시 구조에 맞춰서 파일을 생성하고 코딩하면 프레임워크가 구조에 맞춰서 소스코드를 컴파일하고 작동하는듯하다. </p><p>log4j와 root-context의 파일에 현재 작업중인 패키지를 넣어주면 프레임워크가 컴파일해주고 웹서버에서 실행할 수 있다.</p><p>SQL쿼리가 아직 익숙치 않아서 오라클을 다시 공부하고 있다. 인프런에서 <a href="https://www.inflearn.com/course/oracle/dashboard" target="_blank">오라클 강의</a>를 구입해서 시청하고 있는데 며칠 동안 정리하면서 강의를 동시에 들으려니 시간대비 효율이 떨어지는것 같다. 먼저 강의를 다 들은 후 내가 익숙치 않은 부분을 다시 들으면서 정리하는 방식으로 바꿔야겠다.</p><br><h2 id="What-I-read-in-this-week"><a href="#What-I-read-in-this-week" class="headerlink" title="What I read in this week."></a><span style="color:red">What I read</span> in this week.</h2><p>Slack에서 공유받은 글이다. <a href="" target="_blank">프레임워크와 라이브러리의 차이점</a><br>Spring 강의가 시작하면서 기존에 배운 jQuery와 같은 라이브러리와 프레임워크가 어떻게 다른건지 알아보기 위해 찾고, 공유해준 것 같다. </p><p>위 글에선 <strong>라이브러리가 단순 활용가능한 도구들의 집합</strong>이라면, <strong>프레임워크는 뼈대나 기반구조</strong>를 뜻하고, <u>제어의 역전</u> 개념이 적용된 대표적인 기술이라고 언급했다.</p><p><img src="https://t1.daumcdn.net/cfile/tistory/2344774D577B359522"></p><p>또한 라이브러리와 프레임워크의 큰 차이는 **<u>제어의 흐름이 누구에게 주도되어 있는가</u>**라고 요약했다. 라이브러리는 개발자가 전체적인 흐름을 제어하며 라이브러리를 클라이언트 코드에 더하는 것이라면, 프레임워크는 해당 구조 속에서 개발자가 코딩하는 것이기 때문에 저 표현이 명료하게 요약한 표현이라는 생각이든다.</p><p>그리고 **<u>제어의 역전</u>**이란 프레임워크에 제어의 권한을 넘김으로써 클라이언트 코드가 신경써야 할 것을 줄이는 전략이라고 글쓴이는 설명하였다.</p><br><h2 id="What-I-watched-in-this-week"><a href="#What-I-watched-in-this-week" class="headerlink" title="What I watched in this week."></a><span style="color:red">What I watched</span> in this week.</h2><p>스프링 강의가 시작하면서 인프런에서 또 강의를 찾아 보았다. 백기선 님이 공유중이신 <a href="https://www.inflearn.com/course/spring_revised_edition/dashboard" target="_blank">스프링 입문 강의</a>가 있어서 시청중이다. 아니 사실 셋팅하는 것까지만 시청하고 아직 본 강의는 듣지 못했다…ㅎㅎ </p><p>아무튼 이 강의를 통해 알게된 강의의 지식공유자이신 백기선님 <a href="https://www.youtube.com/user/whiteship2000" target="_blank">유튜브 채널</a>을 구독중인데, 여기서 올라오는 QnA 영상을 이동중 또는 혼밥할 때 보곤 한다.</p><p>한 주 동안 여러 영상을 시청했지만 그 중 유익했던 두 개를 남겨본다.</p><ol><li><a href="https://www.youtube.com/watch?v=pAS84ZJF-Fg&t=88s">깃헙 더 잘쓰는 팁 세 가지</a></li></ol><p>올해 초부터 Git을 배워서 요긴하게 쓰고 있다. 현재 이수중인 국비지원 학원에서 git을 잘다루는 수강생이 없어서 2월 정도부터 혼자 생활코딩을 통해 독학해두었더니 팀 프로젝트 시에 적어도 협업 부분에서만큼은 내가 주도할 수 있었다. 조원들이 충돌만 발생하면 찾아준 덕분에 많은 종류의 충돌을 경험할 수 있었는데 덕분에 프로젝트 한 달동안 git을 더 많이 알 수 있었다.</p><p>아무튼 그래서 타이틀만 보고 시청했는데 이 영상을 통해 Octotree를 알게되어 파이어폭스에 설치해서 요긴하게 잘쓰고 있다. 기존에 Github에서 코드를 구경할 때, 디렉토리 이동할 때마다 페이지를 reload해야 해서 불편했는데 Octotree를 이용하면 한 번에 원하는 디렉토리를 갈 수도 있고, 사이드바처럼 옆에 두고 프로젝트의 구조를 파악하기에도 용이하다.</p><div align="center">  <img src="http://www.mediafire.com/convkey/fda0/vnofwcw4yj60kknzg.jpg" width="600px" /></div><ul><li><p><a href="https://addons.mozilla.org/en-US/firefox/addon/octotree/" target="_blank">파이어폭스 애드온즈 설치하기</a></p></li><li><p><a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank">크롬 익스텐션 설치하기</a></p></li></ul><ol start="2"><li><a href="https://www.youtube.com/watch?v=iua0nrfh4_Q" target="_blank">[개발자 고민] 긴 시간을 소비하고 남은 허물뿐인 경력</a></li></ol><p>경력자는 아니지만 보게 된 영상이다. 남의 일이 아닐수도 있으니까..?</p><p>사연을 보내신 분은 3년-4년을 일하셨음에도 아직 자바를 모르는 것 같다고 고백하셨다. </p><h2 id="What-I-learned-from-this-week"><a href="#What-I-learned-from-this-week" class="headerlink" title="What I learned from this week"></a><span style="color:red">What I learned</span> from this week</h2><p>처음으로 리뷰를 썼다. 이 글을 배포하는 날짜가 7월 4일일만큼 많이 늦었지만 어쨌거나 첫 번째 리뷰를 작성했다.</p><p>이렇게 한 주간 어떤걸 보았고, 어떤 걸 공부했는지 남기니까 해당 주를 완전히 소화하는 기분이 든다. 공부가 부족했든 아쉬웠든 꾸준히 남기는 습관을 들여봐야겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
        <tags>
            
            <tag> weekly-review </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - 문자열 함수</title>
      <link href="2019/07/oracle-function-string/"/>
      <url>2019/07/oracle-function-string/</url>
      
        <content type="html"><![CDATA[<img src="https://www.mediafire.com/convkey/0c82/qlsbk6ga9hpvj6ezg.jpg" width="600px"><p>오라클에서 자주 사용하는 문자열 함수를 정리했다.</p><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#lower">lower : 소문자 반환 함수</a></li><li><a href="#upper">upper : 대문자 반환 함수</a></li><li><a href="#initcap">initcap : 첫글자만 대문자, 나머지는 소문자로 반환 함수</a></li><li><a href="#concat">concat : 문자열 결합 함수</a></li><li><a href="#length">length : 문자열 길이 반환 함수</a></li><li><a href="#substr">substr : 문자열 잘라서 반환하는 함수</a></li><li><a href="#instr">instr : 지정한 문자열의 인덱스 반환 함수</a></li><li><a href="#trim">trim : 공백삭제후 문자열 반환 함수</a></li><li><a href="#replace">replace : 다른문자열로 바꿔서 반환하는 함수</a></li></ul><hr><h2 id="lower"><a href="#lower" class="headerlink" title="lower"></a><a name="lower"></a>lower</h2><p>대문자를 소문자로 변환하는 문자열 함수이다.</p><p>emp 테이블에 있는 사원이름을 전부 소문자화하는 쿼리이다.</p><img src="https://www.mediafire.com/convkey/2f3a/wbsgub7tijweunizg.jpg" width=300px /><br><h2 id="upper"><a href="#upper" class="headerlink" title="upper"></a><a name="upper"></a>upper</h2><p>소문자를 대문자로 변환하는 문자열 함수이다.</p><p>대문자와 소문자를 각각 소문자와 대문자로 역 변환해서 조회하는 쿼리이다.</p><img src="https://www.mediafire.com/convkey/1cd4/1u3jgdt2r4565hvzg.jpg" width=400px /><br><h2 id="initcap"><a href="#initcap" class="headerlink" title="initcap"></a><a name="initcap"></a>initcap</h2><p>첫 글자만 대문자하고 나머지는 소문자하는 문자열 함수이다.</p><p>사원이름의 첫글자는 대문자로, 나머지 글자를 소문자로 조회하는 쿼리이다.</p><img src="https://www.mediafire.com/convkey/b334/loq7xord8loaeh4zg.jpg" width=300px /><br><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a><a name="concat"></a>concat</h2><p>문자열을 서로 더해주는 문자열 함수이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">concat</span>(<span class="string">&#x27;CEO is&#x27;</span>, <span class="string">&#x27;King&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> dual</span><br></pre></td></tr></table></figure><p>concat 함수의 파라미터는 2개로 제한되기 때문에 더 많은 문자열을 더하기 위해서는 아래처럼 작성해야 한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, job, <span class="keyword">concat</span>(<span class="keyword">concat</span>(<span class="keyword">concat</span>(ename,<span class="string">&#x27;의 직무는 &#x27;</span>), job), <span class="string">&#x27;입니다.&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/5bSsN2YS3VgVdd29zLf7vRlex9DX5x0FqbTNp1NhLhdpuxQVj3B5imN5_Ee9eEGj4bfM2i_dQbeufu91QWOS6ROkka4h7XvrzdKG5PA2w6ly0Jkyh0Qse6G6SsWT-aNYzpq6CKXsf1I1WZgRQH6JZwNBHkvm98cmAyag71sdEazK7L598tIYoCSeZYLhd0VgY_nILYKCeRdbonYP1NUg0xcfkG_IZwW2UEsdyWHRpAG-R_J6dHuvSQIUhpDK1nWK7xsgoKkWl21XuBtB0P7PrqbKtQVimDdAoqJGnGwOSRSYSWaSMAk8yKbIdOoB5q0GrOu6Hd8Hb2lG-zeUttNX5X6D5ifZWjvPeuvtmxTR61rHnavjV3b-9-PIWSmL4XuYmxy31JkxsBQb5rD5D8DM-fi7Q1bX06Xe9XhZcMNmVPGamBUAqxL4vPVsdXXVw0xMN2ALE8p8vU6KtMCSe5qkRIh_HDwKhcZk-ZZjoCYAKKCexM3LK_Zwdygtw81sKYUzcAzRLIOZSnmO6opCx5BAPLUePuBj0JGdHF10oP_b1DvrU6Gczmd87-SU3WvABJJzTYeupoSYrvB25w3N8BWhKpzZNqoVU69f9ddJ6aQv-z9XYPv_oFCd6RqpLj2NMPBTzQdkT-s4ZLTVzPG9CrdvTMW1Sch9ZMCk3A9I1ear5tRSVLdSFyhZsCjSWHyApEpk9b-wpPLDQj7Ld5BBDlUw6a7KXk6xHAtviviowTDYJM75sCiEu2gwt0Le=w1440-h630-no" style="width:90%;" /><p>문자열을 더하는 함수는 <a href="https://youngjinmo.github.io/2019/06/oracle-dml/#concat" target="_blank">||</a>도 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, job, ename||<span class="string">&#x27;의 직무는&#x27;</span>||job||<span class="string">&#x27;입니다.&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><img src="https://lh3.googleusercontent.com/e5d1wN1Lmwlul3skEx_Fv0WlDIqseANbMU2xmpaXX_jcmwbkYLsQC6NbUp3O8Nq-htDJNtsvv08taBbEXxmyJymqMsHm9qdHbBwHpRKRWTg4oIaPxglCTNullZiW7JHNqYoAAy2w_qrGfkjRluDY6aI9QCmQTRtGmHGwMggpuHLzr9TNDn43NNxw_rgAUkikYD8FKxXo94j7rolwFmGc2JYQBpAJCPUv3SssRas4QG1FM6QNe5Y-m-McFCIvDwPNRw_Os5f3ySPIj8panIZtm9t8fXyWaZ7sdFe-5I3L2NBtrLNjOsu1UqComYE4_6rvRG8NJ8J-M_08KsxY9wp2ZsaGpsEAN2hx2KIe1EhrhkEI1cD9wjl-jfEC0UpBDFL9uoNVdV_R9VP6CXhVsLXjaaI3xfLhi3OT1dNmIAnvitUKrECni1-3jxGGrRnRi0A2pd0cVQ06JRKOeJ4rmzxnQFKVhjppjWxvZ45JSSbdBgtNNIRIa7oV2fFsrCTaxu4ZmK_V5Nex4qP8hdwgda0ljfGu-hcvkuifRRzUyUDIEynHr94ZP3vk_6uD0NoBPjINcda_hpqWL5SZbgvCjr-UaNKcMjI9F_-Lz3Pz_4vbtSb6sdUYU5iH0zpJ8bMBQrRamqs_Pa5phAoI4vkZ5hSedDqVRb7cqhkX4NOIB4_hD6tKegUsN1RnzaT0lfSgxgBv7gapxn8Vi2ZTNiTArpLtkMPEqnvXdkqw2eyQJy7YwHeGjAGD01K0iuO0=w1084-h634-no" style="width:90%;" /><br><h2 id="length"><a href="#length" class="headerlink" title="length"></a><a name="length"></a>length</h2><p>문자열의 길이를 출력하는 문자열 함수이다.</p><p><strong>legnthb</strong> 함수는 바이트 단위로 문자열의 길이를 출력하는 문자열 함수이다.</p><p>SQL Plus에서 한글 문자열을 입력하니 에러가 발생해서 SQL Developer에서 조회해보았다.</p><img src="https://www.mediafire.com/convkey/d9b7/w5osm7umjv4xqbszg.jpg" style="width: 80%;" /><br><h2 id="substr"><a href="#substr" class="headerlink" title="substr"></a><a name="substr"></a>substr</h2><p>문자열을 잘라내는 함수이다.</p><p>잘라내길 원하는 문자열의 범위를 지정할 수 있다.<br>0번째 인덱스부터 5번째 인덱스의 데이터까지 잘라서 조회하고, 뒤에서 3번째 인덱스까지를 조회하는 쿼리이다.</p><img src="https://www.mediafire.com/convkey/d3b7/qbxhex7pcmftymfzg.jpg" width=400px /><br><h2 id="instr"><a href="#instr" class="headerlink" title="instr"></a><a name="instr"></a>instr</h2><p>찾고자하는 문자열의 인덱스를 조회하는 함수이다.</p><img src="https://www.mediafire.com/convkey/55a3/rgxvwrqex5kzjvezg.jpg" width=400px /><br><p>몇번째 인덱스부터 몇번째로 등장하는 문자를 찾을수도 있다.<br><em>참고로 아래의 문자열에서 인덱스 1의 문자는 ‘H’이다.</em></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">instr</span>(<span class="string">&#x27;HELLO BRO&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="number">6</span>, <span class="number">1</span>) <span class="keyword">FROM</span> dual;</span><br></pre></td></tr></table></figure><p>‘HELLO BRO’ 문자열에서 6번째 인덱스부터 문자열 ‘O’가 1번째로 등장하는 문자열의 인덱스를 조회하는 쿼리이다. 해당 문자열에서 O는 두번 등장하는데, 6번째 인덱스 뒤로는 마지막 O 하나밖에 없기 때문에 조회되는 인덱스는 9가 될 것이다.</p><img src="https://www.mediafire.com/convkey/029a/g6acumz3z5p5fr3zg.jpg" width=400px /><br><h2 id="ltrim-rtrim"><a href="#ltrim-rtrim" class="headerlink" title="ltrim, rtrim"></a><a name="trim"></a>ltrim, rtrim</h2><p>왼쪽 공백, 오른쪽 공백을 삭제하고 문자열을 조회하는 함수.</p><img src="https://www.mediafire.com/convkey/ccbd/11borvlru27fulrzg.jpg" style="width: 600px" /><p><br>공백을 삭제할 수도 있지만, 아래의 경우처럼 특정 문자열을 제거할 수도 있다. 이때 입력할 수 있는 인자값(Argument)은 한 개로 제한된다. <em>(=2개의 문자열을 제거할 수 없다.)</em></p><img src="https://www.mediafire.com/convkey/3f58/nc3f0vplrukzwdyzg.jpg" style="width: 600px" /><br><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a><a name="replace"></a>replace</h2><p>문자열을 다른 문자열로 대체해서 조회하는 함수.</p><p><img src="https://www.mediafire.com/convkey/cab7/sp6mlpwl6kel143zg.jpg"></p><p><code>&#39;Jack and Jue&#39;</code> 라는 문자열에서 <code>J</code> 를 <code>Bl</code> 로 바꿈으로서 <code>Black and Blue</code> 라는 문자열로 변경했다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - 숫자 함수</title>
      <link href="2019/07/oracle-function-number/"/>
      <url>2019/07/oracle-function-number/</url>
      
        <content type="html"><![CDATA[<div align="center">  <img src="https://images.unsplash.com/photo-1513267048331-5611cad62e41?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=800&q=60" width="600px" /></div><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#dual">dual : 임시 테이블</a></li><li><a href="#abs">abs : 절대값 조회 함수</a></li><li><a href="#floor">floor : 소숫점 이하 내림 함수</a></li><li><a href="#round">round : 반올림 함수</a></li><li><a href="#trunc">trunc : 버림 함수</a></li><li><a href="#mod">mod : 나머지 반환 함수</a></li></ul><br><h2 id="dual"><a href="#dual" class="headerlink" title="dual"></a><a name="dual"></a>dual</h2><p>어떠한 테이블 내의 데이터를 조회함이 목적이 아니라 단순 연산 정도의 값을 조회하고자 할 때 사용하는 임시 테이블</p><img src="https://www.mediafire.com/convkey/4b71/fb7h6g0gupf59vbzg.jpg" width=450px /><br><h2 id="abs"><a href="#abs" class="headerlink" title="abs"></a><a name="abs"></a>abs</h2><p>절대값을 구하는 함수이다.</p><img src="https://www.mediafire.com/convkey/248b/ipz6dgnyirmvjthzg.jpg" width=600px /><br><h2 id="floor"><a href="#floor" class="headerlink" title="floor"></a><a name="floor"></a>floor</h2><p>소숫점 이하의 수를 버리는 함수</p><img src="https://www.mediafire.com/convkey/aac5/0g20gthymggqrgkzg.jpg" width=600px /><p>급여가 1500 이상인 사원들의 급여를 15% 삭감해서 조회하는 쿼리</p><img src="https://www.mediafire.com/convkey/021b/z9qmk88ac7npabczg.jpg" width=600px /><br><h2 id="round"><a href="#round" class="headerlink" title="round"></a><a name="round"></a>round</h2><p>정수자리까지 반올림하는 함수</p><img src="https://www.mediafire.com/convkey/c751/5pvrtwawqsk6m0ezg.jpg" width=600px /><br><p>이번엔 자릿수를 정해서 반올림을 해보았다.</p><p>round 함수 사용시 <strong><code>,</code> 옆에 양수를 입력하면 소숫점 이하 자릿수를 지정</strong>할 수 있고, <strong>음수를 입력하면 십의자릿수를 지정</strong>하여 데이터를 조회(SELECT)할 수 있다.</p><img src="https://www.mediafire.com/convkey/6423/l0ea5i1huozddc3zg.jpg" width=600px /><br><p>emp 테이블에서 급여가 2천 이하인 사원들의 급여를 20%씩 인상하는데, 십의 자릿수를 기준으로 반올림해서 데이터를 조회하는 쿼리이다.</p><img src="https://www.mediafire.com/convkey/e1ee/mtdpazm4ikt0t14zg.jpg" width=600px /><br><h2 id="trunc"><a href="#trunc" class="headerlink" title="trunc"></a><a name="trunc"></a>trunc</h2><p>이번엔 버림을 하는 함수이다.</p><p>왼쪽부터 입력한 수 그대로를 출력하였고, trunc 함수를 사용하여 소수점 둘째자리까지 버림, 백의자릿수까지 버림하여 조회(SELECT)하였다.</p><img src="https://www.mediafire.com/convkey/935c/8e1sy00vj2zqbp4zg.jpg" width=600px /><br><h2 id="mod"><a href="#mod" class="headerlink" title="mod"></a><a name="mod"></a>mod</h2><p>나머지를 구하는 함수.</p><img src="https://www.mediafire.com/convkey/ef55/lrtzcgmyp68afoozg.jpg" width=600px />]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle -  Order By</title>
      <link href="2019/07/oracle-orderby/"/>
      <url>2019/07/oracle-orderby/</url>
      
        <content type="html"><![CDATA[<div align="center">  <img src="https://images.unsplash.com/photo-1542044211-723ee4dada2d?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=900&q=60" width="600px" /></div><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><p><a href="#asc">오름차순</a></p></li><li><p><a href="#desc">내림차순</a></p></li></ul><br><hr><h2 id="ASC"><a href="#ASC" class="headerlink" title="ASC"></a>ASC</h2><p>Column의 데이터를 <strong>오름차순</strong>으로 정렬해서 조회(SELECT)하는 쿼리</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> empno <span class="keyword">BETWEEN</span> <span class="number">7900</span> <span class="keyword">and</span> <span class="number">7950</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> empno <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/98e4/sohdn1ii9389q44zg.jpg"></p><p>사원번호가 7900과 7950 사이의 사원의 사원번호, 사원이름, 직업을 조회한 쿼리.</p><br><h2 id="DESC"><a href="#DESC" class="headerlink" title="DESC"></a>DESC</h2><p>Column의 데이터를 <strong>내림차순</strong>으로 정렬해서 조회(SELECT)하는 쿼리</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> empno <span class="keyword">BETWEEN</span> <span class="number">7900</span> <span class="keyword">and</span> <span class="number">7950</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> empno <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/452c/xn67oi974cbw8vdzg.jpg"></p><p>위의 <a href="#asc">ASC</a> 의 쿼리에서 ORDER BY 조건을 DESC로 바꿔서 조회(SELECT)한 결과.</p><br><h3 id="Bonus"><a href="#Bonus" class="headerlink" title="Bonus"></a>Bonus</h3><p><code>ORDER BY</code>에 <code>WHERE</code> 조건을 결합해서 활용하면, 상위 n개 등의 데이터 조회도 응용할 수 있다.</p><p><img src="http://www.mediafire.com/convkey/2de2/s0h2viwup5736hczg.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - SELECT 조건절</title>
      <link href="2019/07/oracle-select/"/>
      <url>2019/07/oracle-select/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1470305585628-a7d2cb18efa2?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2250&q=80"></p><br><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#operator">산술연산자</a><ul><li><a href="#=">=</a></li><li><a href="#%3C%3E">&lt;&gt;</a></li><li><a href="#not">NOT</a></li></ul></li><li><a href="#condition">논리조건 &lt;, &gt;, &lt;=, &gt;=</a></li><li><a href="#between">BETWEEN</a></li><li><a href="#in">IN</a></li><li><a href="#like">LIKE</a></li><li><a href="#null">NULL</a></li></ul><br><hr><h2 id="산술연산자"><a href="#산술연산자" class="headerlink" title="산술연산자"></a><a name="operator"></a>산술연산자</h2><h3 id=""><a href="#" class="headerlink" title="="></a><a name="="></a>=</h3><p>조회하려는 column에 조건을 부여해서 선택적으로 column을 조회(SELECT) 할 수 있는 기능이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>위의 쿼리를 입력하면 아래처럼 데이터가 분류되서 출력됨을 알 수 있다.</p><p><img src="http://www.mediafire.com/convkey/ce1a/1kwqgt38y7f4sq0zg.jpg"></p><br><h3 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;&gt;"></a><a name="<>"></a>&lt;&gt;</h3><p>조건에 반하는 결과만 조회(SELECT) 할 수도 있다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> deptno &lt;&gt; <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>deptno가 10이 안되는 데이터만 출력됨을 알 수 있다.</p><p><img src="http://www.mediafire.com/convkey/dc62/96qpcys572awyuhzg.jpg"></p><br><h3 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a><a name="not"></a>NOT</h3><p><code>NOT</code> 키워드를 사용하여 작성할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> <span class="keyword">NOT</span> deptno = <span class="number">10</span> <span class="keyword">AND</span> <span class="keyword">NOT</span> deptno=<span class="number">20</span>; </span><br></pre></td></tr></table></figure><p><code>WHERE</code> 절 조건으로 <code>deptno=10</code>이 <u><strong>아니거나</strong></u> <code>deptno=20</code> <u><strong>이 아닌 조건</strong></u>으로 조회를 해보았다. deptno=30인 데이터만 조회된 것을 확인할 수 있다.</p><p><img src="http://www.mediafire.com/convkey/ece2/4thhrc5qf6mv8t9zg.jpg"></p><br><h2 id="논리조건-lt-gt-lt-gt"><a href="#논리조건-lt-gt-lt-gt" class="headerlink" title="논리조건 &lt;, &gt;, &lt;=, &gt;="></a><a name="condition"></a>논리조건 &lt;, &gt;, &lt;=, &gt;=</h2><p>int형 또는 ASCII코드의 순서에 따라 데이터를 조회(SELECT)할 수도 있다.    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, hiredate, sal </span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal &gt; <span class="number">2000</span>;</span><br></pre></td></tr></table></figure><p>emp 테이블에서 empno, ename, job, hiredate, sal 컬럼을 조회(SELECT)하면서 sal 컬럼의 데이터가 2000을 초과할 경우를 조건으로 설정하면 아래의 결과처럼 sal의 데이터가 2000이 넘는 데이터만 조회된다.</p><p><img src="http://www.mediafire.com/convkey/259b/632ffeykj1f53mlzg.jpg"></p><br><h2 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a><a name="between"></a>BETWEEN</h2><ul><li><p>범위를 지정하여 조회할 경우에는 <code>between</code> 을 사용하여 조회할 수 있다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job, hiredate, sal </span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> sal &gt; <span class="number">3000</span> <span class="keyword">and</span> sal &lt; <span class="number">4000</span>;</span><br><span class="line"></span><br><span class="line">// 위의 쿼리를 BETWEEN 키워드를 사용하여 바꿔보았다.</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> empno, ename, job, hiredate, sal</span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> (sal <span class="keyword">between</span> <span class="number">3000</span> <span class="keyword">and</span> <span class="number">4000</span>);</span><br></pre></td></tr></table></figure></li></ul><br><h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a><a name="in"></a>IN</h2><ul><li><p>조건 중 공통 column일 경우, 사용할 수 있는 sql 키워드</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> empno, ename, job</span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> job = <span class="string">&#x27;salesman&#x27;</span> <span class="keyword">or</span> job = <span class="string">&#x27;analyst&#x27;</span>;</span><br><span class="line"></span><br><span class="line">// 위의 쿼리를 in 키워드를 사용하여 바꿔보았다.</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> empno, ename, job</span><br><span class="line"><span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> job <span class="keyword">in</span> (<span class="string">&#x27;salesman&#x27;</span>, <span class="string">&#x27;analyst&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul><br><h2 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a><a name="like"></a>LIKE</h2><ul><li><p>문자열에 대한 연산을 할 수 있다.</p></li><li><p>ename 컬럼 데이터가 A로 시작하는 데이터 조회</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, empno <span class="keyword">FROM</span> emp </span><br><span class="line"><span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;A%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/69e0/3f5qni58n02vdnwzg.jpg"></p><ul><li>ename 컬럼 데이터에 A가 포함되는 데이터 조회</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, empno  <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;%A%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/c3bb/a879gplry0u2gszzg.jpg"></p><ul><li>ename 컬럼의 데이터의 두번째 알파벳이 A인 데이터조회</li><li>언더바(_) 갯수만큼 조회하려는 알파벳의 해당 단어에서의 순위를 뒤로 미룰수 있다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, empno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;_A%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/69e0/3f5qni58n02vdnwzg.jpg"></p><ul><li>ename의 데이터가 세글자인 데이터 조회</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, empno <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> ename <span class="keyword">LIKE</span> <span class="string">&#x27;___&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/2651/vnjeg6t7hlfitvbzg.jpg"></p><br><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a><a name="null"></a>NULL</h2><ul><li>NULL은 연산처리할 수 없으므로 <code>is NULL</code>, <code>is NOT NULL</code> 을 통해 조회(SELECT)할 수 있다.</li><li>보너스(comm)가 없는 직원들의 사원번호, 이름, 임금, 임금과 보너스의 합 조회.</li></ul><p><img src="http://www.mediafire.com/convkey/bbc4/pbmtw2r0lb5y4upzg.jpg"></p><ul><li>상관이 없는 사람, 즉 회사 대표를 조회하는 쿼리</li></ul><p><img src="http://www.mediafire.com/convkey/47fb/kwvyejpb64sb5owzg.jpg"></p><ul><li>null을 0으로 환산해서 연산하고 싶을 경우<ul><li>Oracle 내부 함수인 <code>nvl</code> 함수를 통해 null에 해당하는 컬럼 데이터를 0으로 바꿔서 조회하고 연산할 수 있다. 실제 테이블 내 데이터를 변경하는게 아닌 조회시에만 변경해서 조회할 뿐이다.</li><li><a href="https://devyoungjin.github.io/2019/06/oracle-dml/#nvl">NVL함수</a></li><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions105.htm" target="_blank">Oracle Document - nvl</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle - DML</title>
      <link href="2019/06/oracle-dml/"/>
      <url>2019/06/oracle-dml/</url>
      
        <content type="html"><![CDATA[<div align="center">  <img src="http://appstech.com/wp-content/uploads/2013/06/oraclelogo-red-1228x750.jpg" width="600px" /></div><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><p><a href="#select">SELECT</a></p></li><li><p><a href="#insert">INSERT</a></p></li><li><p><a href="#update">UPDATE</a></p></li><li><p><a href="#delete">DELETE</a></p></li><li><p><a href="#arithmetic">산술 연산자</a></p></li><li><p><a href="#nvl">NVL함수</a></p></li><li><p><a href="#concat">Concat ( || )</a></p></li><li><p><a href="#distinct">Distinct ( distinct )</a></p></li></ul><br><h2 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a><a name="select"></a>SELECT</h2><p>SQL 쿼리는 일반적으로 아래와 같은 구성으로 작성한다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename, sal</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> sal &gt;= <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><p>DML은 여기서 <code>SELECT</code> 에 해당하는 언어이며, 데이터를 조작하는 <a href="https://youngjinmo.github.io/2019/06/oracle-intro/#dml">의미</a>를 갖는다. </p><p>SELECT는 데이터를 조회할 때 사용하는 DML 쿼리이다.</p><br><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a><a name="insert"></a>INSERT</h2><p>INSERT는 데이터를 추가할 때 사용하는 DML 쿼리이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> [테이블명](column1, column2, column3)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;property1&#x27;</span>,<span class="string">&#x27;property2&#x27;</span>,<span class="string">&#x27;property3&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/6a1d/p0mqi1rt158dfm2zg.jpg"></p><br><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a><a name="update"></a>UPDATE</h2><p>추가된 데이터를 수정할 때 사용하는 쿼리이다. 추가할 때 HIREDATE에 데이터를 입력하지 않았는데, 현재 날짜(<code>SYSDATE</code>)를 HIREDATE로 수정해서 넣어봤다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> [테이블명]</span><br><span class="line"><span class="keyword">SET</span> [column1] = <span class="string">&#x27;property11&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> [column2] = <span class="string">&#x27;property2&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/bb42/m9hy7nlmlkxfig4zg.jpg"></p><br><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a><a name="delete"></a>DELETE</h2><p>데이터를 삭제할 때 사용한다. </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> [테이블명]</span><br><span class="line"><span class="keyword">WHERE</span> [column1] = <span class="string">&#x27;property11&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/3ca5/re88dnvcnjg7g9zzg.jpg"></p><br><h2 id="산술-연산자"><a href="#산술-연산자" class="headerlink" title="산술 연산자"></a><a name="arithmetic"></a>산술 연산자</h2><ul><li>산술 연산자(+, -, /, *) 를 이용하여 column의 데이터에 대한 연산결과를 출력할 수 있다.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// emp 테이블에서 sal(임금)과 comm(보너스)를 추가한 실수령액을 조회하는 sql 쿼리</span><br><span class="line"><span class="keyword">SELECT</span> ename, sal, nvl(comm, <span class="number">0</span>), sal+nvl(comm, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><img src="http://www.mediafire.com/convkey/4b0d/7r5src4hvccngctzg.jpg" /><br><h2 id="NVL-함수"><a href="#NVL-함수" class="headerlink" title="NVL 함수"></a><a name="nvl"></a>NVL 함수</h2><ul><li><code>NULL</code> 을 처리하는 함수이다.<br>만약 연산에 사용하는 column의 <strong>데이터가 <code>null</code>을 포함하고 있을 경우, <u><code>null</code> 대신에 특정 값</u>으로 바꿔서 출력</strong>을 도와준다.</li><li>값이 없는 column의 경우 <code>null</code> 값을 출력하는데, 이렇게되면 연산시<code>int + null</code>의 연산에 의해 제대로된 데이터를 출력하지 않는다. 따라서 <code>null</code> 일 경우 특정 값(0)으로 바꾸도록 할 때 사용하는 함수이다.</li><li><a href="https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions105.htm" target="_blank">오라클 공식문서 링크</a></li></ul><h3 id="NVL-함수-미적용"><a href="#NVL-함수-미적용" class="headerlink" title="NVL 함수 미적용"></a>NVL 함수 미적용</h3><p><img src="http://www.mediafire.com/convkey/02f0/n4maf5fwx58kaukzg.jpg"></p><h3 id="NVL함수-적용"><a href="#NVL함수-적용" class="headerlink" title="NVL함수 적용"></a>NVL함수 적용</h3><p><img src="http://www.mediafire.com/convkey/3bee/2i50ayol1p38qbmzg.jpg"></p><br><h2 id="Concat-연산자"><a href="#Concat-연산자" class="headerlink" title="Concat 연산자 ( || )"></a><a name="concat"></a>Concat 연산자 ( || )</h2><ul><li><p>문자열을 합치는 연산자이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename || <span class="string">&#x27;s job is &#x27;</span> || job</span><br><span class="line"><span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><div><img src="http://www.mediafire.com/convkey/c2cd/upq0a0axxl2dk52zg.jpg" /></div></li></ul><br><h2 id="Distinct-키워드-distinct"><a href="#Distinct-키워드-distinct" class="headerlink" title="Distinct 키워드 ( distinct)"></a><a name="distinct"></a>Distinct 키워드 ( distinct)</h2><ul><li><p>select 문을 통해 가져온 모든 row 중에서 중복된 row를 제거하는 키워드이다.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">distinct</span> deptno <span class="keyword">FROM</span> emp;</span><br></pre></td></tr></table></figure><div>  <img src="http://www.mediafire.com/convkey/25f9/60qlqb6a2vhqm7bzg.jpg" /></div></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MacOS에서 오라클 사용하기 (a.k.a.Docker)</title>
      <link href="2019/06/docker-for-oracle/"/>
      <url>2019/06/docker-for-oracle/</url>
      
        <content type="html"><![CDATA[<div align="center">  <img src="http://www.mediafire.com/convkey/f249/e5nlxtg8twy0cq5zg.jpg" width="700px" /></div><p>맥OS를 사용중인 사람이 오라클을 다운받으려고 공식사이트에 접속해도 할 수 있는게 없을 것이다. 오라클은 윈도우와 리눅스용으로만 제공하고 있기 때문이다. 그렇다면 맥을 사용하는 개발자는 오라클을 사용할 수 없는걸까?</p><p>당연히 아니다. 가상OS를 사용해서 오라클을 사용할 수 있다.</p><p>가상 OS를 사용하는 방법으로는 Virtual Machine과 Docker 두 가지로 나뉠 수 있다.</p><p>Docker를 처음들어본 사람은 이 유튜브 영상<a href="https://www.youtube.com/watch?v=tPjpcsgxgWc" target="_blank">[얄팍한 코딩사전 - Docker가 뭐고 왜 쓰는건가요?]</a>을 시청해보길 바란다. 개인적으로 구독하고 재미있게 시청하는 채널인데 4-5분 가량의 영상이며 개발을 처음 시작하는 사람들에게 쉽고 재미있게 설명하는 영상들을 올려주는 채널이다. 좋아요와 구독을 추천한다.</p><p>Virtual Machine과 Docker의 차이는 여기서 설명하기보다는 공부할 때 참고한 링크<a href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd" target="_blank">[서강혁 - Docker와 VM]</a>를 첨부하겠다. 사실 나도 계속 공부중이어서 해당 글을 작성한 작성자만큼 잘 정리해서 전달할 정도가 되지못한다..</p><p>시간이 조금 더 쓰더라도 제대로 알고 배우고 싶다면 이 <a href="https://lessipe.com/lesson/589" target="_blank">강의</a>를 추천한다. 도커의 개념부터 명령어, 오라클, MySQL 설치하는 것까지 설명해주시며, 강의는 4개 영상, 러닝타임은 약 100분이 조금 넘는다.</p><br><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#install-docker">Docker 설치하고 실행하기</a></li><li><a href="#pull-image">오라클 image 가져오기</a></li><li><a href="#create-container">Container 생성하고 포트 연결하기</a></li><li><a href="#run-container">Container 실행하기</a></li><li><a href="#connect-container">Container 접속하기</a></li><li><a href="#connect-oracle">오라클 접속하기</a></li></ul><div align="center">  <img src="http://www.mediafire.com/convkey/f9bb/ci5vqdlz4v8srgpzg.jpg" width="740px" /></div><p>지금부터는 Docker를 이용하여 오라클을 사용하는 초간단 메뉴얼(?)을 정리해서 소개한다. 솔직히 Docker를 모르고 이해하지 못했어도 아래 방식대로 그대로 따라하기만 해도 간단하게 오라클을 시작할 수 있다.</p><h3 id="1-Docker-설치하고-실행하기"><a href="#1-Docker-설치하고-실행하기" class="headerlink" title="1. Docker 설치하고 실행하기"></a>1. <a name="install-docker"></a>Docker 설치하고 실행하기</h3><p><a href="https://docs.docker.com/docker-for-mac/install/" target="_blank">Docker 공식 사이트</a>에서 Docker Desktop for Mac을 설치한다.</p><div align="center">  <img src="https://docs.docker.com/docker-for-mac/images/docker-app-drag.png" width="450px"/></div><p>설치하고 나면 실행하면 상태바에 Docker가 실행되는걸 확인할 수 있다.</p><div align="center">  <img src="https://docs.docker.com/docker-for-mac/images/whale-in-menu-bar.png" /></div><p>Docker를 부팅하는데에는 몇 초간의 시간이 소요된다. 완전히 실행되면 클릭해서 열어본다.</p><div align="center">  <img src="https://docs.docker.com/docker-for-mac/images/mac-install-success.png" height="460px"/></div><p>회원가입을 하고, 회원가입된 이메일과 패스워드로 로그인한다.</p><h3 id="2-오라클-image-가져오기"><a href="#2-오라클-image-가져오기" class="headerlink" title="2. 오라클 image 가져오기"></a>2. <a name="pull-image"></a>오라클 image 가져오기</h3><p>오라클이 설치된 이미지를 가져온다. Docker에서 말하는 image란 개발환경(?)을 의미하는 것으로 보인다. 기관이나 기업에서 공식적으로 Docker 이미지를 배포하기도 하지만, 개발자들이 자신의 개발환경에 맞는 컨테이너 이미지를 구축해서 DocketHub에 배포할 수 있다. 나는 개발자가 만들어놓은 이미지를 가져와서 사용했다.</p><p>Docker 이미지를 가져오는 방법은 두 가지이다. </p><p>브라우저로 접속해서 DockerHub에서 이미지를 찾아와서 가져오는 방법, 터미널에서 명령어로 검색해서 가져오는 방법. </p><p>우린 터미널에서 명령어를 검색해서 가져오겠다. Docker를 사용하려면 결국 터미널을 이용해야하는데, 굳이 브라우저로 넘어가서 이미지를 찾기보다 터미널에서 이미지를 검색하고 가져오는 것까지 모두 마무리하겠다.</p><p>Docker가 실행중인 상태에서 터미널을 실행한다. </p><p><code>docker search [keyword]</code> 형태로 입력을 해주면 된다.</p><p>우린 오라클을 사용할 수 있는 이미지를 찾고 있으므로 <code>docker search oracle-xe</code> 로 입력하면 된다. 그럼 아래와 같은 검색결과가 터미널 콘솔에 출력될 거다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search oracle-xe</span><br></pre></td></tr></table></figure><div align="center">  <img src="http://www.mediafire.com/convkey/2801/a3kpv7wxo1dpfugzg.jpg" width="800px" /></div><p>왼쪽의 NAME이 해당 이미지의 이름이고, DESCRIPTION은 해당 이미지를 배포한 개발자가 작성한 이미지의 설명이다. 오라클의 버전이나 이미지에 대한 짧은 설명이 첨부되었으니 읽어보고 가져오면 된다. 위에 검색결과는 STARS 순으로 정렬되는데 가장 위에 노출되는 이미지가 가장 많은 STARS를 받은 이미지이다. 신뢰도가 높다고 할 수 있다. 공교롭게도 가장 위에 검색결과로 출력된 이미지 oracleinanutshell/oracle-xe-11g 가 description이 없지만 stars가 높으므로 이걸 가져와보자.</p><p>Gitub에서 repository를 가져오는 방식처럼 <code>docker pull [image name]</code> 을 입력하면 이미지를 가져온다.</p><p>우리가 입력해야할 명령어는 다음과 같다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull oracleinanutshell&#x2F;oracle-xe-11g</span><br></pre></td></tr></table></figure><p>이미지가 잘 설치한지 확인하고 싶다면, <code>docker images</code> 라는 Docker 명령어를 입력해보자. 설치한 이미지들을 볼 수 있다.</p><div align="center">  <img src="http://www.mediafire.com/convkey/5f61/brwd4vystibuw2zzg.jpg" width="750px" /></div><p>이 글을 작성한 시점은 2019년 6월이다. 이후에 이 글을 보시는 분들은 우리가 사용한 오라클 이미지를 찾지 못할 수 있다. 꼭 똑같은걸 쓸 필요는 없으니 위의 방식대로 또 검색해서 찾아서 가져오면 된다.</p><h3 id="3-Container-생성하고-포트-연결하기"><a href="#3-Container-생성하고-포트-연결하기" class="headerlink" title="3. Container 생성하고 포트 연결하기"></a>3. <a name="create-container"></a>Container 생성하고 포트 연결하기</h3><p>오라클 사용에 필요한 이미지를 설치했으나 이미지만으로는 오라클을 사용할 수 없다. dmg 포맷의 파일을 설치했다고 해서 즉시 어플리케이션을  실행할 수는 없지않은가. 이제 우리가 사용할 수 있는 형태로 만들어야 한다. <strong>설치한 이미지로 컨테이너를 생성하는 것이다.</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 1521:1521 [docker image]</span><br></pre></td></tr></table></figure><p>오라클 Docker 컨테이너의 1521 포트를 로컬호스트의 1521 포트로 포워딩한다는 의미의 명령어이다.</p><p>위의 명령어를 터미널에서 입력하면 컨테이너가 생성될 것이다. 이제 이 컨테이너를 실행함으로써 오라클을 실행할 수 있다. 그럼 이제 오라클을 잘 실행되는지 확인해보자.</p><h3 id="4-Container-실행하기"><a href="#4-Container-실행하기" class="headerlink" title="4. Container 실행하기"></a>4. <a name="run-container"></a>Container 실행하기</h3><p>현재 어떤 컨테이너가 실행중인지 확인하려면 <code>docker ps</code> 를 입력하면 알 수 있다. 실행중인 컨테이너의 목록을 보여주는 Docker 명령어인데, 아래처럼 보인다면 컨테이너가 실행중인 것이다. </p><div align="center">  <img src="http://www.mediafire.com/convkey/c5e8/4thu8pic2fiv22fzg.jpg" width="800px" /></div><p>위 이미지는 아까 설치한 이미지로 생성한 컨테이너가 실행중임을 알 수 있다. 생성시기는 2주 전이고 현재 실행된지는 1시간이 넘었다는 것까지 알려준다.</p><p>만약 아무것도 보이지 않는다면, 실행중인 컨테이너가 없다는건데 실행여부와 상관없이 모든 컨테이너를 볼 수 있는 명령어는 <code>docker ps -a</code> 이다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps -a</span><br></pre></td></tr></table></figure><div align="center">  <img src="http://www.mediafire.com/convkey/54f3/wba6pxgr2uj6itzzg.jpg" width="800px" /></div><p>컨테이너가 언제 생성되었고, 언제 종료되었는지 알 수 있다. 실행중인 컨테이너는 어디 포트에 연결되어 실행되고 있음도 <code>docker ps</code> 명령어와 마찬가지로 알 수 있다.</p><p>실행되고 있는 컨테이너가 없다면, 이제 컨테이너를 실행해야한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start [container ID]</span><br></pre></td></tr></table></figure><p>위의 Docker 명령어를 입력하면 해당 컨테이너를 실행한다. 잘 실행되고 있는지 알고 싶다면 <code>docker ps</code> 를 입력하여 확인해보면 된다.</p><p><a name="stop-container"></a>만약 컨테이너를 종료하고 싶다면, 아래 Docker 명령어로 컨테이너를 종료할 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stop [Container ID]</span><br></pre></td></tr></table></figure><h3 id="5-Container-접속하기"><a href="#5-Container-접속하기" class="headerlink" title="5. Container 접속하기"></a>5. <a name="connect-container"></a>Container 접속하기</h3><div align="center">  <img src="https://media.giphy.com/media/B0RuiNwNKYP1qYqyhu/giphy.gif" width="400px" /></div><p>글에서 언급하지 않았지만 우리가 설치한 오라클 Docker 이미지는 우분투 기반으로 생성된 이미지이다. 그렇다면 해당 컨테이너가 정말 우분투 환경으로 만들어진건지 어떻게 알 수 있을까? </p><p>컨테이너에 직접 접속해보면 알 수 있다. 컨테이너가 실행중인 상황에서 아래 명령어를 입력하면 컨테이너에 접속할 수 있다. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it [Container ID] bash</span><br></pre></td></tr></table></figure><p>접속한 컨테이너의 운영체제 버전을 확인하려면 아래의 리눅스 명령어를 입력해야 한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;issue</span><br></pre></td></tr></table></figure><div align="center">  <img src="http://www.mediafire.com/convkey/c429/iilvgpci36sfo47zg.jpg" width="450px" /></div><p>우분투의 버전을 알 수 있다. 새로운 터미널 창(cmd+n)을 열어서 같은 명령어를 입력하면 아무 결과도 보이지 않을 것이다. <code>cat /etc/issue</code> 는 리눅스에서만 작동되는 명령어이기 때문이다.</p><h2 align="center">  Docker를 사용하게 된걸 환영한다!<br><img src="https://media.giphy.com/media/sp685iuIEGuys/giphy.gif" width="450px" /></h2><h3 id="6-오라클-접속하기"><a href="#6-오라클-접속하기" class="headerlink" title="6. 오라클 접속하기"></a>6. <a name="connect-oracle"></a>오라클 접속하기</h3><p>우리의 본 목적이었던 오라클을 접속해보자. 오라클을 접속하기 위한 방법도 두 가지가 있다. CLI방식의 SQLPlus와 SQLDeveloper. 첫 시작부에 언급했듯 본 포스트는 처음부터 끝까지 터미널로 하기로 했으므로 SQLPlus를 실행하여 오라클에 접속하겠다.</p><p>간단하다.</p><p>컨테이너에 접속한 상태에서 터미널 입력창에 <code>sqlplus</code> 만 입력하면 된다. </p><div align="center">  <img src="http://www.mediafire.com/convkey/7e5a/zv5oooyvwqtqe4gzg.jpg" width-"300px" /></div><p>접속할 계정의 user-name와 password를 입력하면 오라클 데이터베이스에 접속했음을 알 수 있다. </p><p>학습용도로 사용할 수 있는 임의의 데이터베이스가 있다. user-name으로 scott, password로 tiger를 입력하면 따로 데이터베이스를 만들지 않아도 쿼리를 작성해볼 수 있다.</p><p>만약 오라클 사용을 중단하고 싶다면 <code>exit</code> 명령어로 SQLPlus를 종료할 수 있다. </p><p>마찬가지로 접속한 컨테이너에서 빠져나오고 싶을 때에도<code>exit</code> 명령어로 컨테이너를 빠져나올 수 있다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> DevOps </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> tutorial </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>데이터베이스 - Oracle</title>
      <link href="2019/06/oracle-intro/"/>
      <url>2019/06/oracle-intro/</url>
      
        <content type="html"><![CDATA[<img src="https://www.techdonut.co.uk/sites/default/files/managed-server-hosting-your-server-in-the-cloud-523968604.jpg" width="650px" /><p>이번엔 데이터베이스를 정리하고자 한다. 사실 정리라기보다는 이제 막 발을 떼고 공부를 시작했다는 표현이 더 맞을 것 같다. 데이터를 어떻게 관리하는지를 어느정도 머릿속에 정리하기위해 작성해본다.</p><p>본 포스트는 <a href="https://www.inflearn.com/course/oracle/dashboard" target="_blank">인프런 - Oracle SQL Database 11g PL/SQL Developer</a>를 수강하고 작성했다.</p><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#intro">Intro</a></li><li><a href="#features">Features</a><ul><li><a href="#db-pros">Advantage</a></li><li><a href="#db-cons">Disadventage</a></li></ul></li><li><a href="#ddl">DDL</a></li><li><a href="#dml">DML</a></li><li><a href="#dcl">DCL</a></li><li><a href="#dbms">DBMS</a></li><li><a href="#rdbms">RDBMS</a></li></ul><br><hr><h1 id="Database"><a href="#Database" class="headerlink" title="Database"></a><a name="intro"></a>Database</h1><p>데이터베이스는 여러 사람이 공유하고 사용할 목적으로 통합 관리되는 정보의 집합이다. 복수의 데이터를 조직적으로 통합하여 중복을 없애고 데이터를 구조화하여 기억시켜 놓은 자료의 집합체이다.</p><p>일반적으로 응용 프로그램과는 별개의 미들웨어를 통해서 관리된다. 데이터베이스 자체만으로는 아무것도 할 수 없기 때문에 소프트웨어 관리 시스템과 통합돼 제공된다. 정확한 명칭은 데이터베이스 관리 시스템(DBMS, DataBase Management System)이다.</p><p><a href="https://namu.wiki/w/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4" target="_blank">나무위키</a>에 작성된 내용을 첨부하면 아래와 같다.</p><blockquote><p>데이터베이스 자체는 화물(데이터)을 저장할 수 있는 창고 그 자체의 역할만 수행하고, 화물을 적재하거나 적재된 화물을 처리할 수 있는 능력은 없다. 이 때문에 DBMS라는 관리자들을 고용하여 화물을 적재하거나 이동시키는 등 여러가지 업무를 수행하도록 하는 것이다.</p></blockquote><p>관계형 데이터베이스(Relational Database)를 이용하기 위해 만들어진 언어로 <strong>SQL(Structured Query Language)</strong> 이 있는데, SQL을 통해 데이터 추가/탐색/수정/삭제 등의 작업을 할 수 있다.</p><h2 id="특징"><a href="#특징" class="headerlink" title="특징"></a><a name="features"></a>특징</h2><ul><li>실시간 접근성</li><li>지속적인 변화</li><li>동시 공유</li><li>내용에 대한 참조</li><li>데이터 논리적 독립성</li></ul><h3 id="장점"><a href="#장점" class="headerlink" title="장점"></a><a name="db-pros"></a>장점</h3><ul><li>데이터 중복 최소화</li><li>데이터 공유</li><li>일관성, 무결성, 보안성 유지</li><li>최신의 데이터 유지</li><li>데이터의 표준화 기능</li><li>데이터의 논리적, 물리적 독립성</li><li>데이터 저장 공간 절약</li></ul><h3 id="단점"><a href="#단점" class="headerlink" title="단점"></a><a name="db-cons"></a>단점</h3><ul><li>데이터베이스 전문가 필요</li><li>비용 부담</li><li>데이터 백업과 복구가 어렵다 그러나 최근엔 많이 개선됨</li><li>시스템의 복잡함</li><li>대용량 디스크로 액세스가 집중되면 과부화 발생</li></ul><br><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a><a name="ddl"></a>DDL</h2><p>Data Definition Language</p><p>데이터를 정의하는 언어이다.</p><p>테이블을 생성하거나 삭제 등 <strong>데이터베이스 스키마(Scheme)를 정의또는 관리</strong> 하는 언어이다.</p><ul><li><strong>CREATE</strong> : 정의</li><li><strong>ALTER</strong> : 수정</li><li><strong>DROP</strong> : 삭제</li><li><strong>TRUNCATE</strong> : DROP 후, CREATE</li></ul><br><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a><a name="dml"></a>DML</h2><p>Data Manipulation Language</p><p>테이블 등의 <strong>데이터를 조작(추가/조회/수정/삭제)</strong> 하는 언어이다. 응용 프로그램과 데이터베이스 사이에서 실질적인 데이터 처리를 위해 사용된다.</p><ul><li><strong>INSERT</strong> : 추가</li><li><strong>SELECT</strong> : 조회</li><li><strong>UPDATE</strong> : 수정</li><li><strong>DELETE</strong> : 삭제</li></ul><hr><p>연관 포스트 : <a href="https://youngjinmo.github.io/2019/06/oracle-dml/">Oracle - DML 명령어</a></p><br><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a><a name="dcl"></a>DCL</h2><p>Data Control Language</p><p><strong><u>데이터를 제어</u></strong> 하는 언어이다.</p><p>사용자 권한, 작업의 취소 등 DML과 비교하여 상위 개념(?)의 언어라고 생각한다.</p><ul><li><strong>COMMIT</strong> : 작업 결과 반영</li><li><strong>ROLLBACK</strong> : 트랜잭션의 작업을 취소 / 복구(undo)</li><li><strong>GRANT</strong> : 사용자에게 권한 부여</li><li><strong>REVOKE</strong> : 권한 취소</li></ul><br><h2 id="DBMS"><a href="#DBMS" class="headerlink" title="DBMS"></a><a name="dbms"></a>DBMS</h2><p>데이터베이스 그 자체로는 아무것도 할 수 없다. 데이터베이스를 사용하기 위해서는 관리 시스템이 필요하다고 했는데, 그 역할을 하는 소프트웨어를 DBMS라 한다. Oracle, MySQL, MS-SQL등이 여기에 속한다.</p><ul><li>DataBase Management System</li><li>데이터베이스를 관리하는 소프트웨어</li><li>Oracle, MS-SQL,MySQL 등이 DBMS에 속한다.</li></ul><br><h2 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a><a name="rdbms"></a>RDBMS</h2><p>가장 많이 사용되는 데이터베이스 모델이다. 관계형 데이터베이스(Relational Database Management System)라고 해서 RDBMS라고 줄여서 말한다.</p><p>강의에서 강사님이 든 예를 인용하겠다.</p><div align="center">  <img src="http://www.mediafire.com/convkey/6642/w6yet8v1ozydrmxzg.jpg" width="450px"/></div><table><thead><tr><th>SQL</th><th>RDBMS</th><th>Description</th></tr></thead><tbody><tr><td>Row</td><td>Tuplr, Record</td><td>하나의 항목을 대표하는 데이터</td></tr><tr><td>Column</td><td>Attribute</td><td>튜플의 이름 요소</td></tr><tr><td>Table</td><td>Relation</td><td>같은 속성을 공유하는 튜플의 모임</td></tr></tbody></table><p>중간고사를 마치고 학생들의 성적을 분류하기 위해서 정렬한 학생 데이터가 있다고 가정하자. </p><p>연관된 학생들 즉, <strong>같은 반 학생들끼리만 모아둔 형태</strong> 를 데이터베이스에서는 **<u>테이블, 또는 Relation</u>**이라고 한다.</p><p>그리고 그 반을 구성하는 <strong>학생들</strong> 은 데이터베이스에서 <strong><u>Tuple</u></strong> 로 비유할 수 있다. 그리고 해당 학생들이 각각 갖는 이름, 성적 등의 <strong>속성</strong> 은 <strong><u>Attribute</u></strong> 가 될 수 있다.</p><div align="center">  <img src="http://www.mediafire.com/convkey/73de/oxq10pm13uzpkg4zg.jpg" width="450px" /><img src="http://www.mediafire.com/convkey/6642/w6yet8v1ozydrmxzg.jpg" width="450px" /></div><br><br><br>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery - DOM, CDN</title>
      <link href="2019/06/jquery-dom-cdn/"/>
      <url>2019/06/jquery-dom-cdn/</url>
      
        <content type="html"><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#jquery">intro</a></li><li><a href="#$">$</a></li><li><a href="#dom">DOM</a></li><li><a href="#cdn">CDN</a></li></ul><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a><a name="jquery"></a>Intro</h2><p>jQuery는 특별한 기술이나 프로그래밍 언어가 아니라 <strong>Java Script의 라이브러리</strong>이다.</p><p>라이브러리는 자주 사용하는 로직들을 재사용(Reuse)을 가능하도록 만든 로직들의 묶음이다.</p><p>자바스크립트는 이런 라이브러리가 많은데, 그 중 가장 많이 쓰이는 라이브러리가 jQuery이다.</p><div align="center">  <img src="http://uniformjs.com/pics/js-jquery.png" width="500px" /></div><p><strong>웹에서 Element를 선택하는 방법</strong>과 <strong>선택된 Element를 효율적으로 제어</strong>할 수 있는 **<u>JavaScript 라이브러리</u>**이다.</p><p>jQuery 라이브러리를 사용하기 위해서는 <a href="http://jquery.org" target="_blank">jQuery 공식 사이트</a>에서 코드를 다운받아서 웹서버에 올려서 사용하거나 아래 코드처럼 구글에서 제공하는 라이브러리를 불러와서 사용할 수 있다. 이렇게 사용하는 방식을 <a href="#cdn">CDN</a>이라고 한다.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Google Hosted Library</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// jQuery CDN</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://code.jquery.com/jquery-2.2.4.min.js&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CDN에 대한 <a href="#cdn">설명</a>은 아래에 정리했다.</p><p>jQuery의 구조는 다음과 같다. </p><img src="https://lh3.googleusercontent.com/DXJwULeoNn9FDzmIE1c9L8R8t68dnNJ2BfGw5WigQg50UU7ow5vNPJJFY8IbGkMPpr_n1M3TyJyFtX6IQh0JoROREQTpuStW88Mq64cpQuyc2xT_Yv4VSSoNk_jEA-rI7F8lfOzw8gBN2h1BjJxQOp_RMR3VJjUOW5LB2MJzreT3nN-OwOvIkwqYsIumfbVvlIxR3OFVcB_PLX-11FguNgP40IR9MFezY0IV5AAGJJGLlmDIhB1M7yMvIUtT868UFX1cNKqM0r_WQ1pkE--t3rZeCL39b5Rpzn_Ui9wf5lcDk_Eegm5ZzIi_zKGcJvdhknSYazZZ1jmrhIAlI0i0YcUiKDjiBa7ShvsB9xKb_cAIY_rvZbyAZhgIYxdfIpnGGIUv0B51hrV2s0ToaJUrCZTjrFi025FLGwgUUbXWVacrvvdwsen-fyTeAAOzRNTEgISxy6jA-LXqT3l0MS3iJOKLsPcOjtB5V58Ona9NPt_gct_BUNsA0bWBLYGClNcKYwiefzH7UqRLcHaNIw-kt2YV-KjHaHLwFZpMHRvBXzsGvOz9ZbiPFHOJx4KEFPErO0-n_oxkM1bjDp0_JMW6PxcG6aqm15f7tCNSdB3bdPAK-xMLKGt9sGeqxFGxMB4meUdtixOIlA9-y3wiFrUSI19VtvgWHTpO=w672-h233-no" height="100px" /><p>제어할 Element를 선택하고, 선택된 Element에 전달할 제어 명령어를 <code>.</code> 으로 이어서 작성하는 방식이다. 한 줄에 한 가지 제어만 가능한게 아니고, <code>.</code> 으로 여러개의 제어를 동시에 입력할 수 있다.</p><p>jQuery의 데이터타입은 <strong>Function</strong>이면서 <strong>Object</strong>이다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#div-section_1&#x27;</span>).setAlign();</span><br></pre></td></tr></table></figure><p>위 코드에서 <code>$</code> 가 jQuery의 <strong>객체</strong>, <code>&#39;#div-section_1&#39;</code>이 <strong>selector</strong>에 해당한다. 이 문자열들을 jQuery 선택자(selector)라고 한다. </p><p>참고로 Element를 선택할 때는 어떤걸 선택하느냐에 따라 사용법이 조금 다른데, DOM구조의 기본 Element라면 그냥 <code> $(&#39;body&#39;)</code> 이런 식으로 사용이 가능하나 class를 선택하려면, <code>$(&#39;#classSelector&#39;)</code>, id를 선택하려면 <code>$(&#39;.idSelector&#39;)</code> 로 사용해야 한다. </p><br><h2 id=""><a href="#" class="headerlink" title="$"></a><a name="$"></a>$</h2><p>앞서 jQuery는 <u>Element를 선택해서 효율적으로 제어</u>하는 JavaScript 라이브러리라고 했다. 이를 선택자(Selector)라고 한다. 따라서 jQuery가 HTML에서 하는 역할은 선택자에 해당한다고 이야기 할 수 있다.</p><p>여기서 Element를 선택할 때 사용하는 선택자를  <code>jQuery</code> 또는 <code>$</code> 라고 한다. 일반적으로는 <code>jQuery</code>보다 사용하기 편하고, 가독성이 높아서<code>$</code> 를 사용한다.</p><p><code>$</code> 는 정확히 <code>jQuery</code>와 역할이 일치하므로 <code>$</code> 의 데이터타입 또한 Function이면서 Object라는 특징을 갖는다. </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;welcome&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javscript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">         <span class="comment">// &quot;welcome&quot; class를 선택해서 html코드와 css코드를 명령한다.</span></span></span><br><span class="line"><span class="javascript">         $(<span class="string">&quot;welcome&quot;</span>).html(<span class="string">&quot;hello world!&quot;</span>).css(<span class="string">&quot;background-color&quot;</span>, <span class="string">&quot;yellow&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 아래 코드와 정확히 일치한다.</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// jQuery(&quot;welcome&quot;).html(&quot;hello world!&quot;).css(&quot;background-color&quot;, &quot;yellow&quot;);</span></span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a><a name="dom"></a>DOM</h2><p>웹 문서의 구조를 표현하는 개념이다. 데이터 스트럭쳐와 유사하다.</p><p>DOM은 Document Object Model의 약자로써 문서 객체 모델을 의미한다. 웹 페이지의 객체 지향적 표현이며, HTML, XML문서를 구조화함으로써 **<u>자바스크립트와 같은 프로그래밍 언어로 보다 쉽게 제어할 수 있도록 돕는 모델</u>**이다. </p><div align="center">  <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5a/DOM-model.svg/1920px-DOM-model.svg.png" width="400px" /></div><p>DOM을 구현하는 기준을 ‘웹 표준’이라고 하는데, 그동안 W3C, WHATWG 이라는 단체에서 웹 표준에 대한 문서를 발간했었고, 전 세계 웹 개발자들이 이를 적용하여 개발하고 있었다. 그런데 2019년 5월 28일 <a href="https://www.w3.org/blog/2019/05/w3c-and-whatwg-to-work-together-to-advance-the-open-web-platform/" target="_blank">W3C 블로그</a>에 WHATWG와 W3C가 이제 하나의 웹 표준을  지향할 수 있게 되었다는 글이 올라오면서 변화를 맞이하게 되었다. 원문을 읽어보면, WHATWG는 HTML과 DOM에 대한 기준을 유지하며, W3C는 독립적인 문서 발간을 중지한다고 밝혔다. 두 단체간의 웹 표준 전쟁에서 WHATWG가 이긴 것처럼 보인다. 아래 한글 기사를 첨부하지만, 내용이 어수선한 관계로 꼭 원문도 함께 읽기를 바란다.</p><ul><li><a href="http://www.zdnet.co.kr/view/?no=20190531184644" target="blank">지디넷 기사 : 둘로 나뉜 웹 표준, 하나로 합쳐진다.</a></li><li><a href="https://www.w3.org/blog/2019/05/w3c-and-whatwg-to-work-together-to-advance-the-open-web-platform/" target="blank">원문 : W3C and WHATWG to work together to advance the open Web platform</a></li></ul><br><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a><a name="cdn"></a>CDN</h2><p>CDN은 Content Delivery Network의 약자로써 다양한 컨텐츠를 복잡한 네트워크 환경에서 사용자에게 안정적으로 전송해주는 서비스라고 이해 할 수 있다. 네이버 지식백과를 인용하면 다음과 같다.</p><p style="color: gray">  <i>인터넷 사용자들로부터 멀리 떨어져 있는 컨텐츠 제공자의 웹 서버에 집중되어 있는 컨텐츠들 중 그림, 배너, 비디오, 오디오와 같이 용량이 크거나 사용자들의 요구가 많은 컨텐츠를 여러 인터넷 서비스 사업자(ISP)의 POP들에 설치한 CDN 서버에 미리 저장해 놓고, 컨텐츠 요구 발생 시 가장 최적의 CDN 서버로부터 신속한 경로를 통해 사용자에게 컨텐츠를 전달해주는 새로운 개념의 데이터 전송 서비스를 의미한다.</i></p><ul><li>컨텐츠(자료)를 효율적으로 전달하기 위해 준비된 네트워크</li><li>클라이언트의 컨텐츠 요청의 병목현상을 해결한다</li><li>서버의 불필요한 트래픽을 주링고 반복작업을 줄여준다</li><li>자주 사용디는 컨텐트를 네트워크 중간중간에 복사해두고 클라이언트의 요청을 받으면 적절한 위치의 컨텐츠를 전송하는 시스템</li></ul><p>jQuery CDN을 이용하면 자체 서로 호스팅하는 것보다 빠르고, <strong>브라우저 캐싱을 지원</strong>한다는 장점이 있다. </p><p style="color: gray">  <i><b>브라우저 캐싱</b>이란, 웹 페이지를 로드할 때마다 페이지를 표시하기 위해 필요한 웹 파일을 다운받게 되는데 매 번 웹 페이지에 접속할 때마다 모든 웹 파일을 다운받으면 통신 속도에 부담을 줄수도 있고, 비효율적이기도 하다. 따라서 한 번 접속해서 다운받은 웹 파일을 로컬에 유지시켜서 다음에 해당 웹 페이지에 접속할때마다 새로 다운받을 필요없이 로컬에 저장된 웹 파일을 이용하여 보다 빠르게 웹 페이지에 접속할 수 있다.</i></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jquery </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - Object</title>
      <link href="2019/05/javascript-object/"/>
      <url>2019/05/javascript-object/</url>
      
        <content type="html"><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#object">Intro</a></li><li><a href="#notation">객체 프로퍼티 표기법</a></li><li><a href="#naming">객체 프로퍼티 네이밍</a></li></ul><br><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a><a name="object"></a>Object</h2><p>자바스크립트 변수에 대해 정리한 <a href="https://youngjinmo.github.io/2019/05/javascript-0/#variables" target="_blank">포스트</a>에서 자바스크립트는 기본타입(number, String, Boolean, undefined, null)을 제외하곤 나머지 모든 데이터 타입이 객체라고 정리한 바 있다. </p><p>객체라는 표현은 추상적인 표현이기 때문에 모호하게 느껴질 수 있으나 사실 현실의 세계를 프로그래밍화 하려는 시도(?)라고 해석할 수 있다. 세상 모든건 객체로 구성되어 있기 때문이다. </p><p>자동차를 예로 들면, 아래 이미지의 자동차들은 ‘자동차’라는 범주에 똑같이 속하지만 색상, 차 종(type), 충전 상태 등 서로 다른 특징을 보유하고 있기 때문에 우리는 이들을 각각의 차로 구별할 수 있다.</p><div align="center">  <img src="https://car-images.bauersecure.com/pagefiles/79757/1752x1168/tesla_supercharging_1.jpg?mode=max&quality=90&scale=down" width="600px" /></div><p>위의 차를 자바스크립트 코드로 구현하면 아래와 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> automobile_n1 = &#123;</span><br><span class="line">  brand : <span class="string">&quot;Tesla&quot;</span>,</span><br><span class="line">  color : <span class="string">&quot;blue&quot;</span>,</span><br><span class="line">  type : <span class="string">&quot;Sports Utility&quot;</span>,</span><br><span class="line">  isCharging : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> automobile_n2 = &#123;</span><br><span class="line">  brand : <span class="string">&quot;Tesla&quot;</span>,</span><br><span class="line">  color : <span class="string">&quot;red&quot;</span>,</span><br><span class="line">  type : <span class="string">&quot;Sedan&quot;</span>,</span><br><span class="line">  isCharging : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> automobile_n3 = &#123;</span><br><span class="line">  brand : <span class="string">&quot;Tesla&quot;</span>,</span><br><span class="line">  color : <span class="string">&quot;white&quot;</span>,</span><br><span class="line">  type : <span class="string">&quot;Sports Utility&quot;</span>,</span><br><span class="line">  isCharging : <span class="literal">false</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(automobile_n1.color);   <span class="comment">//  blue</span></span><br><span class="line"><span class="built_in">console</span>.log(automobile_n3.isCharging);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><br><p>객체는 키(key)와 값(property)로 이루어져있다. 위의 코드처럼 중괄호로 감싸고 세미콜론(<code>;</code>) 대신 <code>,</code> 로 각각의 property를 구분한다. 세미콜론은 중괄호를 닫을 때 작성함으로써 객체를 완성한다.</p><br><h2 id="객체-프로퍼티-표현법"><a href="#객체-프로퍼티-표현법" class="headerlink" title="객체 프로퍼티 표현법"></a><a name="notation"></a>객체 프로퍼티 표현법</h2><div align="center">  <img src="https://images.unsplash.com/photo-1489875347897-49f64b51c1f8?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1950&q=80" width="600px" /></div><p>객체의 프로퍼티를 호출하는 방법은 두가지가 있다. </p><ul><li><code>object[&quot;property&quot;]</code> : Bracket Notation</li><li><code>object.property</code> : Dot Notation</li></ul><p>Dot 표기법이 Bracket 표기법보다 엄격하게 key를 구별하기 때문에 Dot 표기법으로 객체의 프로퍼티, Key를 작성하는 것을 권장한다.</p><p>추가로 객체의 프로퍼티로 함수나 배열을 포함시킬 수도 있다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCar = &#123;</span><br><span class="line">  brand : <span class="string">&quot;Tesla&quot;</span>,</span><br><span class="line">  color : [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;black&#x27;</span>],</span><br><span class="line">  type : <span class="string">&quot;Sports Utility&quot;</span>,</span><br><span class="line">  isCharging : <span class="literal">true</span>,</span><br><span class="line">  charged : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(myCar.isCharging === <span class="literal">true</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;This car is already charging.&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;This car will be charged&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myCar.charged();</span><br><span class="line"><span class="comment">// &quot;This car is already charging.&quot;</span></span><br></pre></td></tr></table></figure><br><h3 id="프로퍼티-네이밍-규칙"><a href="#프로퍼티-네이밍-규칙" class="headerlink" title="프로퍼티 네이밍 규칙"></a>프로퍼티 네이밍 규칙</h3><p>객체의 프로퍼티명을 작성하는 조건이 몇 가지 있다.</p><ul><li><code>&quot;&quot;</code> 을 사용하지 않는다.</li><li>숫자를 첫 글자로 사용하지 않는다.</li><li>띄어쓰기 대신 camel 표기법을 사용한다.</li></ul><br><hr><div align="center">  <img src="https://media.giphy.com/media/3o6QL6BkYYlWuu66oE/giphy.gif" /></div><p>이제 <a href="https://www.udacity.com/course/intro-to-javascript--ud803" target="_blank">Udacity - Intro to Javascript 강의</a>를 완강했다. 그러나 말 그대로 intro를 끝냈을뿐 여전히 자바스크립트에 알지 못한다고 생각한다. 사실상 모든 프로그래밍 언어의 기초적인 부분을 배운 느낌이다. 그래도 완강은 기분좋다.</p><p>이제는 Udacity에서 <a href="https://www.udacity.com/course/intro-to-jquery--ud245" target="_blank">jQuery에 대한 강의</a>를 들으려고 한다. DOM객체가 무엇인지, selector 태그에 대한 연습도 해보고 싶다. 얼른 강의 듣고 또 정리해보겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - 배열</title>
      <link href="2019/05/javascript-array/"/>
      <url>2019/05/javascript-array/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1554306274-f23873d9a26c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80"></p><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#intro">Intro</a></li><li><a href="#methods">Most Used Methods</a></li><li><a href="#loop">Loop for Array</a><ul><li><a href="#for-loop">For Loop</a></li><li><a href="#for-each">forEach( )</a></li><li><a href="#map">Map( )</a></li></ul></li></ul><br><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a><a name="intro"></a>Array</h1><p>자바스크립트에서 배열을 선언할 땐 Java와 달리 배열의 크기를 지정하지 않아도 된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> donuts = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">var</span> coffee = [<span class="string">&quot;Espresso&quot;</span>, <span class="string">&quot;Latte&quot;</span>, <span class="string">&quot;Mocca&quot;</span>]; </span><br></pre></td></tr></table></figure><br><h2 id="Most-Used-Methods"><a href="#Most-Used-Methods" class="headerlink" title="Most Used Methods"></a><a name="methods"></a>Most Used Methods</h2><p>자주 사용하는 Array의 메서드들이다.</p><ul><li><p><strong>Length</strong> :  배열이 갖고있는 대표적인 Property이다. </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffee = [<span class="string">&quot;Espresso&quot;</span>, <span class="string">&quot;Latte&quot;</span>, <span class="string">&quot;Mocca&quot;</span>]; </span><br><span class="line">coffee.length();   <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Push</strong> : 데이터를 추가할 때 사용하는 method이다. 배열의 마지막 인덱스에 추가된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffee = [<span class="string">&quot;Espresso&quot;</span>, <span class="string">&quot;Latte&quot;</span>, <span class="string">&quot;Mocca&quot;</span>]; </span><br><span class="line">coffee.push(<span class="string">&quot;Americano&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(coffee);</span><br><span class="line"><span class="comment">// [&#x27;Espresso&#x27;, &#x27;Latte&#x27;, &#x27;Mocca&#x27;, &#x27;Americano&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Pop</strong> : 데이터를 삭제할 때 사용하는 method이다. 배열의 마지막 인덱스의 element가 삭제된다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffee = [<span class="string">&quot;Espresso&quot;</span>, <span class="string">&quot;Latte&quot;</span>, <span class="string">&quot;Mocca&quot;</span>]; </span><br><span class="line">coffee.pop();</span><br><span class="line"><span class="built_in">console</span>.log(coffee);</span><br><span class="line"><span class="comment">// [&#x27;Espresso&#x27;, &#x27;Latte&#x27;, &#x27;Mocca&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>Splice</strong> : 원하는 인덱스에 데이터를 추가/삭제를 할 수 있는 method.</p><ul><li><p><code>Array.splice([method가 실행될 Index], [삭제될 Index 수], [새로운 element])</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffee = [<span class="string">&quot;Espresso&quot;</span>, <span class="string">&quot;Latte&quot;</span>, <span class="string">&quot;Mocca&quot;</span>]; </span><br><span class="line">coffee.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;Americano&quot;</span>);  </span><br><span class="line"><span class="comment">// Index 1로부터 element 1개를 삭제하고 &quot;Americano&quot; 추가</span></span><br><span class="line"><span class="built_in">console</span>.log(coffee);  </span><br><span class="line"><span class="comment">// [&#x27;Espresso&#x27;, &#x27;Americano&#x27;, &#x27;Latte&#x27;, &#x27;Mocca&#x27;]</span></span><br><span class="line"></span><br><span class="line">coffee.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">&quot;Nitro Coffee&quot;</span>);</span><br><span class="line"><span class="comment">// Index 0으로부터 element를 0개 삭제하고 &quot;Nitro Coffee&quot; 추가</span></span><br><span class="line"><span class="built_in">console</span>.log(coffee);</span><br><span class="line"><span class="comment">// [&#x27;Nitro Coffee&#x27;, &#x27;Espresso&#x27;, &#x27;Americano&#x27;, &#x27;Latte&#x27;, &#x27;Mocca&#x27;]</span></span><br><span class="line"></span><br><span class="line">coffee.splice(<span class="number">-1</span>, <span class="number">1</span>, <span class="string">&quot;Cafe Mocca&quot;</span>);</span><br><span class="line"><span class="comment">// Index-1(뒤)로부터 element 1개를 삭제하고 &quot;Cafe Mocca&quot; 추가</span></span><br><span class="line"><span class="built_in">console</span>.log(coffee);</span><br><span class="line"><span class="comment">// [&#x27;Nitro Coffee&#x27;, &#x27;Espresso&#x27;, &#x27;Americano&#x27;, &#x27;Latte&#x27;, &#x27;Cafe Mocca&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>그 외 자바스크립트에서 배열 객체가 갖는 Properties와 Methods는 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#" target="_blank">공식문서</a>에서 더 찾아볼 수 있다.</p><br><h2 id="Array-Loops"><a href="#Array-Loops" class="headerlink" title="Array Loops"></a><a name="loop"></a>Array Loops</h2><p>배열도 Loop를 사용할 수 있다. For Loop와 함께 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank">forEach</a> Loop, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank">Map</a>을 사용할 수 있다.</p><p><strong><a name="for-loop"></a>For Loop</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffee = [<span class="string">&quot;Espresso&quot;</span>, <span class="string">&quot;Latte&quot;</span>, <span class="string">&quot;Mocca&quot;</span>]; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orderCoffee</span>(<span class="params">func</span>) </span>&#123;  <span class="comment">// 문구를 완성할 함수 작성 </span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;func.length; i++) &#123;</span><br><span class="line">    func[i] += <span class="string">&quot; please.&quot;</span>;  <span class="comment">// 각 element 뒤에 &quot; please&quot; 추가</span></span><br><span class="line">    func[i] = func[i].toUpperCase();  <span class="comment">// method 사용해서 모든 문자 Capitalize</span></span><br><span class="line">    <span class="built_in">console</span>.log(func[i]);  <span class="comment">// 각 element 출력</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">orderCoffee(coffee); <span class="comment">// 함수 사용</span></span><br><span class="line"><span class="comment">// ESPRESSO PLEASE.</span></span><br><span class="line"><span class="comment">// LATTE PLEASE.</span></span><br><span class="line"><span class="comment">// MOCCA PLEASE.</span></span><br></pre></td></tr></table></figure><br><p><a name="for-each"></a><strong>forEach Loop</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffee = [<span class="string">&quot;Espresso&quot;</span>, <span class="string">&quot;Latte&quot;</span>, <span class="string">&quot;Mocca&quot;</span>]; </span><br><span class="line"></span><br><span class="line">coffee.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">drink</span>) </span>&#123;</span><br><span class="line">   drink = <span class="string">&quot;A cup of &quot;</span> + drink + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(drink);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// A cup of Espresso.</span></span><br><span class="line"><span class="comment">// A cup of Latte.</span></span><br><span class="line"><span class="comment">// A cup of Mocca.</span></span><br></pre></td></tr></table></figure><br><p><a name="map"></a><strong>Map</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffee = [<span class="string">&quot;Espresso&quot;</span>, <span class="string">&quot;Latte&quot;</span>, <span class="string">&quot;Mocca&quot;</span>]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orderCoffee = coffee.map(<span class="function"><span class="keyword">function</span>(<span class="params">drink</span>) </span>&#123;</span><br><span class="line">  drink = <span class="string">&quot;A cup of &quot;</span> + drink + <span class="string">&quot; please.&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> drink;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(orderCoffee);</span><br><span class="line"><span class="comment">// [ &#x27;A cup of Espresso please.&#x27;, </span></span><br><span class="line"><span class="comment">//   &#x27;A cup of Latte please.&#x27;</span></span><br><span class="line"><span class="comment">//   &#x27;A cup of Mocca please.&#x27; ]</span></span><br></pre></td></tr></table></figure><p><code>forEach</code> 와 달리 <code>Map</code>은 method를 사용할 때 새로운 객체를 선언한다는 점이 다르다. 주의하자.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript - 변수, 조건문</title>
      <link href="2019/05/javascript-variable/"/>
      <url>2019/05/javascript-variable/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1516116412344-6663387e8590?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1400&q=80"></p><p>학원 교육을 이수중인데 자바스크립트 객체에 대한 모호함때문에 자바스크립트를 정리해보고자 한다. 본 포스트는 지난해 말에 Udacity에서 들었던 <a href="https://www.udacity.com/course/intro-to-javascript--ud803" target="_blank">Intro to JavaScript</a>로 공부한 부분을 정리했다. 당시 Object에 대한 부분을 듣지 못하고 어영부영 끝냈는데, 이번 기회에 끝까지 이수하려고 한다.</p><p>Udacity 강의와 <a href="https://book.naver.com/bookdb/book_detail.nhn?bid=7400243" target="_blank">인사이드 자바스크립트</a>를 참고하여 정리했다.</p><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#intro">Intro to JavaScript</a></li><li><a href="#variables">Variables</a><ul><li><a href="#null">Null &amp; Undefined</a></li><li><a href="#equality">Equality</a></li></ul></li><li><a href="#conditional">Conditional</a><ul><li><a href="#false">The list of False value</a></li><li><a href="#ternary">Ternary Operator</a></li></ul></li><li><a href="#loop-array">Loop &amp; Array</a></li></ul><br><h2 id="Intro-to-JavaScript"><a href="#Intro-to-JavaScript" class="headerlink" title="Intro to JavaScript"></a><a name="intro"></a>Intro to JavaScript</h2><div align="center">  <img src="https://www.huszardev.com/wp-content/uploads/2018/07/1_l4xICbIIYlz1OTymWCoUTw1.jpeg" width="600px" ></div><p>자바스크립트는 Firefox, Safari, Chrome같은 브라우저에서 작동하는 언어이다. </p><p>웹의 3대 언어로 HTML, CSS, Javascript가 있는데 HTML과 CSS가 정적인 언어라면, 자바스크립트는 동적인 언어라고 할 수 있다. 애니메이션과 같은 효과, 사용자의 행동에 따른 이벤트 등의 기능을 다룬다.</p><div align="center">  <img src="https://ekaprasasti.com/assets/img/mengapa-harus-javascript/brendan-eich-2012.jpg" width="300px" /><br>자바스크립트의 아빠, Brendan Eich.</div><p>이름때문에 Java와 혼란스러울수도 있지만, 자바스크립트와 Java는 전혀 무관한 언어이다. 자바스크립트는 1995년 Brendan Eich가 만들었는데, 원래 초창기 Eich가 개발한 언어의 이름은 LiveScript였다고 한다. 그러나 당시 잘 나가던 언어인 Java의 인기에 편승하고자 이름을 지금의 JavaScript로 바꿨다고 한다. (<a href="https://dictionary.cambridge.org/ko/%EC%82%AC%EC%A0%84/%EC%98%81%EC%96%B4/piggyback" target="_blank">piggyback</a> 전략)</p><br><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a><a name="variables"></a>Variables</h2><div align="center">  <img src="https://images.unsplash.com/photo-1416339134316-0e91dc9ded92?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=400&q=60" width="500px" /></div><p>자바스크립트에서는 모든 변수를 데이터타입에 상관없이 <code>var</code>로 선언한다. 이를 느슨한 데이터 타입(Loosely data type)이라고 한다. </p><p>그러나 모든 변수를 <code>var</code> 로 선언한다고해서 모든 변수의 데이터 타입이 똑같은건 아니다. <code>typeof</code> 라는 연산자를 이용하여 확인해보면 다음과 같다.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> exNum = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">var</span> exString = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> exNull = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> exUndefined;</span><br><span class="line"><span class="keyword">var</span> exBoolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> exNum;<span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> exString;<span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> exNull;<span class="comment">// null</span></span><br><span class="line"><span class="keyword">typeof</span> exUndefined;<span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">typeof</span> exBoolean;<span class="comment">// boolean</span></span><br></pre></td></tr></table></figure><p>아마 자바스크립트 엔진이 데이터를 자동 분류하는게 아닐까 싶다. 이부분은 나중에 더 공부해보고 보충하는걸로..</p><p>자바스크립트의 데이터 타입은 크게 **기본 타입(숫자, 문자, 비교, undefined, null)**과 **참조 타입(객체)**으로 나뉜다. 5가지 기본타입을 제외하면 자바 스크립트는 모든 것이 객체로 구성되는 언어라고 할 수 있다. </p><div align="center">  <img src="diagram.png" width="700px" /></div><br><h3 id="Null-Undefined"><a href="#Null-Undefined" class="headerlink" title="Null, Undefined"></a><a name="null"></a>Null, Undefined</h3><ul><li><code>null</code> : 아무런 값이 없지만 <u>데이터가 <strong>존재</strong>하는 상태</u></li><li><code>undefined</code> : 아무런 값이 없고, <u>데이터가 <strong>존재하지 않는</strong> 상태</u></li></ul><div>  <div style="float: right; padding: 10px;">    <img src="https://lh3.googleusercontent.com/QCztkvKy5OhSpn430e9K5d3jSCJfWvrtH_xpwt-hU0LOMLAOldjZHP70bJ0KYWt-L_Fb3qqVfMz7O5eWL2S6IlBkFvPVuqOJOQeG9Hj0xfD8erxa9gvcovKyI40m7cHz_DTiWEMdkgyXyeK_afqBujLlxIGGYHN4khgOVbCr9V7Vey3K5GPOHc-9F2Be--thKt07Y3g-Skvk8CthU1h-935aDDCScPTWodeaNzm0ObP-KlsqILmtZbcqySj3KhnkMKRmaoMqCIpo_o8GBWFbhJQrPVGh9KvbIRsvNgiz2ITqzUHgbQsy9bRkLDzbxGHzoXKMrPg5XW-KKtcxgimrH2RAQzNwQhG5WLVXThqhJdgEx8vfa25jin_sZTsSP17xjeWw6hmgl5Ev-UxtJGuJEliJeoGAy9syTg9Mb9YCAZZPEs9jetR0rCmgDx6Kuq7kO6m9jRaaCTxabEP9YDER1SzM-fQsHlQrW8CmyyZO2Dl6f16kpwiRe8bJ3g3kL0grfLVUrqAtJt8edmvC5FiHKBPGiGScvv4nbb2B2ri6qd1oSB4HsTqvuT414Dnj4t7vdPVnLoBvV1XeNmlZScv1gRJl8hf2uC-qdJubmQ5B74hzGq6sWz0VnaG2vm-a9Dw5xDKjzp0bBEajVu-lRbrJvBribmA9dJHo=w318-h222-no" width=auto />  </div>  <div stsyle="float:left; padding: 20px; line-height: 1.5">    null과 undefined는 둘 다 값이 없다는 점에서 같다고 착각할 수 있다. <br>실제로 == 연산자를 이용하여 둘을 비교하면 같다고 출력된다. 그러나 엄격한 비교 연산자 === 를 이용하면 다르다고 출력된다.<br>비교 연산자에 대한 설명은 아래 이어진다.  </div></div><p>정리하면..</p><table><thead><tr><th>datatype</th><th>description</th></tr></thead><tbody><tr><td><code>null</code></td><td>- 아무런 값이 없지만 데이터가 존재하는 상태<br />- value of nothing</td></tr><tr><td><code>undefined</code></td><td>- 변수는 선언되었지만 초기값조차 선언되지 않은 아무런 값이 없는 상태<br />- absence of value</td></tr></tbody></table><div align="center">  <img src="https://media.giphy.com/media/l4Ep6uxU6aedrYUik/giphy.gif" width="300px"/></div><p>자바스크립트의 변수 중에서도 기본타입에 대해서만 정리해보았다. 사실 자바스크립트의 변수에 대한 공부는 더할 필요가 있어 보인다. 하지만 현재 필요한 부분은 아니므로 일단 여기까지만 알고 넘어가겠다.</p><br><h3 id="Equality"><a href="#Equality" class="headerlink" title="Equality"></a><a name="equality"></a>Equality</h3><p>변수와 변수를 비교한다고 가정할 때, value만 비교한다면 <code>==</code> 으로 비교할 수 있지만, 이 방법은 옳은 방법이라고 할 수는 없다. 데이터 타입까지 엄격한 비교 기호로 <code>===</code>를 쓸수 있는데, 이 방법으로 해야 모호함을 피할 수 있다. </p><p>예로 위에서 null과 undefined를 비교할 때 어떤 연산자를 쓰느냐에 따라 다른 boolean값이 출력됨을 알 수 있었다. 이와 비슷하게 number 타입 <code>1</code>과 boolean 타입 <code>true</code> 를 비교시, 어떤 동등 연산자를 사용하느냐에 true를 출력하기도, false를 출력하기도 한다. 하지만 엄밀히 비교한다면 당연히 false가 출력되어야 한다. <strong>때문에 <code>===</code> 를 기본적으로 사용하고 특수한 경우에만 <code>==</code> 를 사용하는 습관을 들여야 할 것같다.</strong></p><br><h2 id="Conditional"><a href="#Conditional" class="headerlink" title="Conditional"></a><a name="conditional"></a>Conditional</h2><div align="center">  <img src="https://images.unsplash.com/photo-1546338384-c6f21a91c04a?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1347&q=80" width="500px" /></div><p>Java와 마찬가지로 자바 스크립트에서의 조건문도 코드 스타일이 거의 비슷하다.</p><p>알아둬야할 부분만 정리해보았다.</p><br><h3 id="False-값을-반환하는-조건"><a href="#False-값을-반환하는-조건" class="headerlink" title="False 값을 반환하는 조건"></a><a name="false"></a>False 값을 반환하는 조건</h3><p><img src="https://media.giphy.com/media/oQjsQmQKlFDcQ/giphy.gif"></p><ol><li>false를 갖는 boolean 값</li><li>null 타입</li><li>undefined 타입</li><li>number 타입의 0</li><li>String 타입의 “”</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN">NaN</a> </li></ol><p>당연히 위 6가지 조건이 아닌 모든 조건은 true가 된다. 이를 활용하여 조건식을 만들면 된다.</p><br><h3 id="Ternary-Operator"><a href="#Ternary-Operator" class="headerlink" title="Ternary Operator"></a><a name="ternary"></a>Ternary Operator</h3><p>Java에서도 사용했던 삼항 연산자인데 익혀두면 좋아서 다시 정리해본다.</p><p><code>conditionals ? (if its true) : (if its false);</code> 형태로 구성된다.</p><p>이항 연산자만을 사용한 조건문과 같은 조건을 삼항 연산자로 사용했을 때의 코드를 비교해보자.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isGoing = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> lightColor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이항 연산자 사용</span></span><br><span class="line"><span class="keyword">if</span>(isGoing)&#123;</span><br><span class="line">  lightColor = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  lightColor = <span class="string">&quot;red&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(lightColor);<span class="comment">// green</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 삼항 연산자 사용</span></span><br><span class="line">isGoing ? lightColor=<span class="string">&quot;green&quot;</span> : lightColor=<span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(lightColor);<span class="comment">// green</span></span><br></pre></td></tr></table></figure><p>똑같이 green을 출력했는데, 어떤게 더 간단해 보이는가?</p><br><h2 id="Loop-amp-Array"><a href="#Loop-amp-Array" class="headerlink" title="Loop &amp; Array"></a><a name="loop-array"></a>Loop &amp; Array</h2><div align="center">  <img src="https://media.giphy.com/media/19zbJkzHgNsA/giphy.gif" width="300px" /></div>자바스크립트에서 반복문과 배열은 Java와 다른게 없어보인다. 향후 자바스크립트를 더 깊히 공부한다면 그 때 정리해보겠다.]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javscript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>자료구조 - 리스트</title>
      <link href="2019/05/datastructure-list/"/>
      <url>2019/05/datastructure-list/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1513106580091-1d82408b8cd6?ixlib=rb-1.2.1&auto=format&fit=crop&w=650&q=80"></p><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#basic">리스트 특징</a></li><li><a href="#languages">각 언어별 리스트 특징</a></li><li><a href="#comparison-list">배열과 리스트 비교</a><ul><li><a href="#insert">추가할 때</a></li><li><a href="#remove">삭제할 때</a></li></ul></li><li><a href="#comparison-linkedlist">ArrayList와 LinkedList 비교</a><ul><li><a href="#arraylist">ArrayList</a></li><li><a href="#linkedlist">LinkedList</a></li></ul></li></ul><br><p><a name="basic"></a>리스트의 특징은 다음과 같다.</p><ul><li><strong>순서</strong>대로 저장</li><li><strong>중복</strong>을 허용</li><li><strong>비어있는 데이터(null)를 허용하지 않는다.</strong></li><li><strong>처음, 끝, 중간에 element를 추가/삭제하는 기능</strong>이 포함되어야 함.</li></ul><br><h2 id="For-each-Languages"><a href="#For-each-Languages" class="headerlink" title="For each Languages"></a><a name="languages"></a>For each Languages</h2><ul><li><p>최근의 프로그래밍 언어는 리스트를 기본적으로 지원한다. 비교적 오래된 언어의 경우 리스트를 지원하지 않기도하다.</p></li><li><p><strong>C</strong>는 list를 지원하지 않는다. 따라서 개발자가 직접 리스트를 구현해야 한다.</p></li><li><p><strong>Python</strong>은 리스트를 지원하지만 배열을 지원하지 않는다.</p><ul><li>하지만 List는 Array라고도 볼 수 있기 때문에 자바만큼은 아니지만 리스트를 이용하여 배열처럼 사용할 수 있다(?)</li></ul></li><li><p><strong>Java</strong> 는 엄격하게 배열과 리스트를 구분한다.</p><ul><li><p>Array : <code>int[] numbers = new int[10];</code></p></li><li><p>List : <code>ArrayList numbers = new ArrayList();</code></p><ul><li><p>Java API 호출 필요</p><ul><li><code>import java.util.ArrayList;</code></li></ul></li><li><p>Java에서 List는 ArrayList와 LinkedList로 다시 나뉘어진다.</p><p>ArrayList와 LinkedList에 대해서도 알아보자.</p></li></ul></li></ul></li><li><p>결과적으로 <strong>데이터 스트럭쳐는 모든 언어마다 다르다는 것</strong>이다. 따라서 각각의 언어에 맞게 개발자의 선호에 맞게 데이터 스트럭쳐를 구현해서 사용할 수 있다.</p></li></ul><br><h2 id="Array-vs-List"><a href="#Array-vs-List" class="headerlink" title="Array vs List"></a><a name="comparison-list"></a>Array vs List</h2><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a><a name="insert"></a>Insert</h3><div align="center">  <img src="https://lh3.googleusercontent.com/d7XX_aWZC5UlIimBvNu8UPbc4Lt9slkS38ofRERmrlrs7Vbfc1zWXnjacCllJYxowMRDVSf3wDGfdvdK1XTZY65yZ-atPcold0L3Pnuz5yrCAd0yeMXHDzEngLzMp3_HyrJWoy_wAhSLNEB0LfW56DQEaBxwTl41Aj3Beca-_h0q6mQS338sKAi92TT1S5GlOmv7o05rW3-r-iK4PFlcPV2waGvjlIYpwqDCJBdu9zhzF6I0e6Z4iObuR0_-FZk19yNF43CPLycSaU_LmhsUtSYMHwzIHjofGTr_IaQGH-c-TtUjts1IDTrvhx67oHHeNDGPXzjgmHKxIRHzc6mD0k3VzpjisLFBZc_a9DslndmjSootcQObvRRDVKKxPiA7xGrsQJffJKcUn6l1EjYDYlbzQd8rCutJmMUbnM9diHnE8TwgEPeKhccR5I4GieHKqvGgApuKWTnm3Wz3pgqM4WxN53MwFQLsu6jp6KILs-jCvk73Zna9Xpn5ml_b9X1Uq1zk6BzzkA9mJWdrQIsxvj3QqEmhZpa5T3i4QJBJ5Oea9_Eob3CYz6eQB1xIOHZx_m2y2JGlFZqtZCfMg8G_70-9Nbt5W9jJuyQPfEIyK89Lwd8BAXn59iTmUeknnKs_jdIWrKUcROcoqB6g43YcVnP41wP2hxtW=w2210-h1168-no" width="600px" /><br>출처 : 생활코딩</div><ul><li><strong>Array</strong>에선 기존에 존재하는 element의 index에 다른 value를 삽입하면 기존 value를 덮어씌우는 방식으로 데이터가 추가된다. 새 값은 이식되었지만, 기존의 값은 사라졌으므로 length는 그대로 유지된다. 사실 Array는 애초에 크기를 변경할 수 없는 자료구조이기도하다.</li><li><strong>List</strong>에서는 기존의 index의 element가 뒤로 밀리면서 새로운 element가 그 사이에 삽입된다. Array처럼 기존의 값에 덮어씌어진게 아니라 추가되었으므로 전체 데이터의 length가 증가한다. </li></ul><br><h3 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a><a name="remove"></a>Remove</h3><div align="center">  <img src="https://lh3.googleusercontent.com/-GjEFys9O1Yoar6LIblE4c5zjvfgnASwuzm8g-pO0402l8IIpQmxw7yAKBcFPcYgghyh8WIkvk_9Fjl8PfnJwa_j6M6x5kzaXfa194hJDiSnOtW2eOm0mV2eo3mn9xbAckBX4ctUXowdBeqO71adJT1exFsWTo_XqNW6X5soSVR3l4U0fOpxEzneYVimlZSsbJCScTvpCmiHlXgQUSAqOE9HD3oPNPCOZBpWp4ZrKKWm4nmNV1oF-EgRs7l4ry6Imhy2rBBI8nIWdJjkWGEND9YtGdw6QYw-3U73Gqr_zkwVu26P_JCR5PBYqN53JkcRd85g76N-EWXrZdCIynGjTUWqRetoHRcHooTmL9-KG8EzeVJ5JbEcYiIrpAggdHAIC5Bzg21STr2H6RfxVF9EHWabQSilTLmbbgNAH1nSKnrbJLQeQWJDA9CG8iMfLEfoVPlJEmgwb9Yqh6RCKYnVL57cBHbhxMIrJX7DiojDYG1ESJOuYZQnjlD52ujtinrKP72MIO_NQhh3-cvqyLfHLMH3GZ6sIK1aQlA2LOgW7VnJk5Y1VYNbdMPh8FKLlr-9zOYnLe6ukHIYGlDCApasaetCYRABh5kbWqKDYn3Ty-dfJ3U9pE2dmJG_HhlMZAoIJ_SLQPGWP8ybIn7RbuVzJKy_r832G_VP=w1440-h802-no" width="600px" /><br>출처 : 생활코딩</div><ul><li><strong>Array</strong>에선 element를 삭제하면 해당 element가 null로 유지된다.<br>따라서 <strong>해당 인덱스에 value(실제 데이터)가 있는지 없는지에 대한 체크가 필요</strong>하다. (메모리 누수 가능성)</li><li><strong>List</strong>에선 element를 삭제하면 뒤의 index의 element가 앞으로 당겨온다.<br>모든 데이터가 연속되어지므로 null이 존재하지 않는다. 때문에 <strong><u>데이터를 추가/삭제 할 때 데이터가 있는지 여부를 체크할 필요가 없다.</u></strong></li><li>이를 바탕으로 <strong>Array와 List에서 index의 의미가 다르게 해석</strong>된다.<ul><li>List에서 index는 몇 번째 데이터 인지를 알려주는 정도라면, </li><li>Array에서 index는 그 값 자체를 의미하는 식별자가 될 수 있다.</li></ul></li></ul><br><div align="center">  <img src="https://media.giphy.com/media/l3nSILUHhuVDuWSnC/giphy.gif" width="300px" /></div><p>아직 정리하지는 않았지만, List에는 ArrayList와 LinkedList가 있는데, 둘을 비교해보았다. 그냥 이렇다는것만 알아두고 <a href="https://youngjinmo.github.io/2019/05/DataStructure-list/" target="_blank">다음 포스트</a>로 넘어가서 ArrayList에 대해 정리한 글을 읽어보도록 하자.</p><br><h1 id="ArrayList-vs-LinkedList"><a href="#ArrayList-vs-LinkedList" class="headerlink" title="ArrayList vs LinkedList"></a><a name="comparison-linkedlist"></a>ArrayList vs LinkedList</h1><div align="center">  <img src="https://lh3.googleusercontent.com/KtBMhDtUagnaN0Zbb5T0khFoaECjflsa1ASvprJ9B_ARv1zP7vKU8mfU9OvL2LzGq3-VkYoHIvDJW5enrmQxraVbgqyEra90TOyg3pGcJOVN0aAyYc2G3Ez1zGDiYOQieqtpJfFAydxxyojta71d5ycpMkQUciPBLBp1Mhj_LYHuBhmkJlrRfnZY7BWz_yketlCwGNxAL9HKEvnSJ9OLxcZyVkVgFfr72EklocggyzW3VKOWGPD55ZhxfCiIOLF68nuinO_l8Gl84lAzJja_RWZU_M1X3lG1m7iMR1B9jrrpctdLl1ZD_vlrP6WgY2nkFbVUFHMqm_XlE5DwxByxHfiXsfe2VczJE7ms9_M24xr2t8P7k3chobtHipXsmsq07Fx2bzE0bv4gG_3W-5cm11Qe0Ec2fvxf3l7a7CFPcJq4PMvqbOVn49DkhoQkf3hPc6L-Q_dQruFP7w1FXI6UVj-aVcMGLdjnqVP1d-8Bb98PKt5ItBaJXSAplOWjci9ZjP4p-azLl3SLY4ri-kOzcy8biaQH1gnm5Ksbjv3acvaeAn_jSZwfIg9c_-TfL1tc6abULlEA8pqW80Ujg2pISS0Np-KXPkfB1B-akvSZGxRDUqgy34u0u_kCylPd2JSr_v5PvLB57D6AazL8-EpuEZah_UjS27B8=w1350-h754-no" width="600px" /><br>출처 : 생활코딩</div><h3 id="인덱스-조회"><a href="#인덱스-조회" class="headerlink" title="인덱스 조회"></a>인덱스 조회</h3><p><strong>ArrayList</strong>는 데이터 탐색 시, 메모리에 적재된 Array의 주소에서 Index를 통해 상대적인 위치를 찾아서 주소를 전달하기 때문에 빠르다. </p><p>반면 <strong>LinkedList</strong>는 HEAD에서 부터 연결된 다음 노드를 하나씩 찾아가야 하기 때문에 탐색 속도가 느리다는 단점이 있다.</p><h3 id="데이터-관리-추가-삭제"><a href="#데이터-관리-추가-삭제" class="headerlink" title="데이터 관리 (추가/삭제)"></a>데이터 관리 (추가/삭제)</h3><p><strong>ArrayList</strong>에서 데이터를 추가하기 위해서는 새로운 데이터가 추가될 인덱스의 element부터 뒤의 모든 데이터를 뒤로 밀어서 빈 값을 만들어내고, 그 빈 값에 새로운 데이터를 추가하는 방식이다. 삭제하는 방법 역시 데이터를 삭제하면, 뒤의 모든 데이터를 삭제한 데이터만큼 앞으로 당겨와야 한다. 이 때문에 추가/삭제시 느리다는 단점이 있다.</p><p>반면 <strong>LinkedList</strong>는 element가 연결된 앞 뒤의 노드의 주소값만 변경하면 되기 때문에 ArrayList와 비교해서 훨씬 빠르다는 장점이 있다.</p><br><p>본격적으로 ArrayList는 다음 포스트에서 정리했다.</p><br><h3 id="자료구조-글-목록"><a href="#자료구조-글-목록" class="headerlink" title="자료구조 글 목록"></a>자료구조 글 목록</h3><ul><li><a href="https://devyoungjin.github.io/2019/04/datastructure-array/">자료구조-배열 (이전글)</a></li><li><strong><u>자료구조-리스트 (현재글)</u></strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datastructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>핏빗 버사를 구입하다.</title>
      <link href="2019/05/review-fitbit/"/>
      <url>2019/05/review-fitbit/</url>
      
        <content type="html"><![CDATA[<div align="center">    <img src="http://www.mediafire.com/convkey/b8e7/6ef7q09adzl08x4zg.jpg" /><br>Fitbit Versa 착용샷  </div><p>3년간 착용중이던 <a href="https://www.cnet.com/reviews/fitbit-charge-hr-review/" target="_blank">Fitbit Charge HR</a>을 대신해 지난해 출시한 Fitbit의 스마트 워치 <a href="https://www.fitbit.com/versa" target="_blank">Fitbit Versa</a>를 구입했다. 새 제품을 구매한 이유는 Charge HR이 고장났기 때문이다. 사실 고장이 나고나서는 며칠동안 그냥 외출을 했는데, 3년동안 들었던 습관때문에 공허함을 좀처럼 해결할 수 없었다. Charge HR을 착용하던 왼쪽 손목을 수시로 들어올려서 시간을 확인하곤 했는데 이제 더 이상 왼쪽 손목을 들어올려도 아무것도 볼 수 없었다. </p><p>아이폰이라는 백만원짜리 고급시계(?)가 있긴 했으나 나는 좀 더 저렴하고 양 손을 사용하지 못하는 순간에도 사용할 수 있는 직관적인 시계가 필요했다. 애플워치를 생각안한건 아니었으나 결국 내 선택은 또 핏빗이었다. 이로써 나는 1세대 Fitbit 모델이었던  Fitbit Flex, 심박수 체크 기능이 처음으로 도입된 모델 Fitbit ChargeHR에 이어 5년만에 세 번째 Fitbit모델을 손에 얻게 되었다. </p><div align="center">  <img src="https://icdn5.digitaltrends.com/image/pebble-2-review-2-800x534-c.jpg" width="700px"/><br>Pebble</div><p>혹시나 이 글을 읽는 사람 중에 안드로이드/iOS 에서 모두 사용가능했던 스마트워치 제조사 Pebble을 기억하는 사람이 있으려나. Fitbit Versa는 Fitbit이 Pebble의 스마트워치 개발 자산 일부를 인수<a href="https://techcrunch.com/2017/02/22/fitbit-pebble-acquisition/" target="_blank">[기사]</a>하여 개발한 Fitbit OS 3.0이 탑재된 스마트워치이다. </p><p>이 Fitbit OS 3.0을 말할 것 같으면, 지금은 세련된 애플워치와 갤럭시 기어가 시장을 주도하고 있지만 이런 제품이 없던 시절 안드로이드와 아이폰에서 모두 사용가능하면서 큰 사랑을 받았던 Pebble의 레거시라고 할 수 있겠다.</p><br><p>아이폰 사용자로써 애플워치를 구입할 수 있었음에도 불구하고 난 왜 이번에도 Fitbit을 선택한걸까?</p><p>이제 그 이야기를 해보도록 하자.</p><br><h1 id="Why-Fitbit"><a href="#Why-Fitbit" class="headerlink" title="Why Fitbit"></a>Why Fitbit</h1><p>Fitbit과의 인연은 5년이란 시간을 거슬러 올라가야 한다. 2014년 봄, 친구들과 맥주를 마시면서 웨어러블 컴퓨팅 기술에 대한 전망에 대해 토론을 하고 있었다. 군대를 막 전역한 나는 당시 웨어러블 컴퓨팅이라는 개념이 지나치게 모호하게 느껴져서 그 토론에 참여하지 못하고 구경만 했던 기억이 있다. </p><p>어떠한 역할을 할 수 있을지도 모르면서 십만원이 넘는 기기를 구입하는게 당시 큰 부담이었음에도 호기심을 이기지못해 돈을 탈탈 털어 Fitbit Plex를 이마트몰에서 구입했다. 당시만 하더라도 웨어러블 디바이스를 판매하는 온라인몰이 극히 적었다. 그도 그럴게 제품 자체가 적었으니.. </p><div align="center">    <img src="https://www.imore.com/sites/imore.com/files/styles/large_wm_brw/public/field/image/2014/03/fitbit_flex_hero_3.jpg?itok=lspCjvLJ" width="600px"/><br>내 첫 Fitbit제품이었던 Flex. (출처: iMore)</div><p>당시 이마트를 운영하는 신세계 그룹의 정용진 부회장이 <a href="http://it.chosun.com/site/data/html_dir/2013/05/16/2013051685033.html" target="_blank">Jawbone</a>을 착용하고 올린 트윗이 화제가 된 적이 있다. 부회장님의 관심덕분인지(?) 당시 이마트몰은 국내에 다양한 웨어러블 디바이스를 판매했다. 나도 여기서 Flex를 구입했다.</p><p>그리고 2015년 Heart Rate의 약자를 딴 HR 모델이 처음으로 등장했다. 단순히 걸음수만 체크하던 트래커에서 이제 심박수까지 체크하게 되면서 헬스케어 디바이스에 한 걸음 다가가게 된 것이다. 이제 “값 비싼 만보기” 라는 수식어에서는 벗어날 수 있었다. 만보기는 심박수 체크 못하니까…</p><div align="center">  <img src="https://i.kinja-img.com/gawker-media/image/upload/t_original/keesvhitqipa8xrlwug8.jpg" width="700px"/><br>두번째 Fitbit 제품, Charge HR. (출처:Gizmodo)</div><p>난 지금도 이 제품이 현존하는 최고의 피트니스 트래커라고 생각한다. 우레탄 재질의 밴드는 가볍고 방수에 강했다. 가죽의 경우 물이 묻거나 하면 부담스러울수 있으나 우레탄 재질은 저렴하고 방수가 되는 덕분에 선호하는 재질의 밴드이다. </p><p>이 때문에 샤워할 때를 제외하곤 정말 하루종일 착용하고 다녔던 제품이다. 축구할 때도 착용하면 내가 오늘 얼마나 뛰었는지를 눈으로 확인할 수 있었다.</p><p>Charge HR은 공식적으로 밴드 교체를 지원하지 않는다. Charge HR 2부터 악세서리를 판매한걸로 기억하는데.. 아무튼 그래도 방법이 아주 없지는 않았다. 나는 3년동안 Charge HR을 착용하면서 3번 밴드를 교체했다. 알리 익스프레스에서 Charge HR 교체용 밴드를 판매하는데 여기에서 $6-7 정도의 가격으로 주문해서 바꿔차곤 했다. 한 번 뺀 밴드는 다시 사용할 수는 없었다. 밴드에서 기기를 분리할 때 재사용이 불가능해질만큼 밴드에 손상이 가해지기 때문이다.</p><div align="center">  <img src="https://media.giphy.com/media/pPhyAv5t9V8djyRFJH/giphy.gif" width="380px"/><br>아니 그래서 왜 애플워치가 아니라 또 Fitbit이냐고?</div><p>이제 진짜 써보겠다 ㅋㅋㅋㅋ</p><br><h3 id="1-Price"><a href="#1-Price" class="headerlink" title="1. Price"></a>1. Price</h3><div align="center">  <img src="http://www.mediafire.com/convkey/c487/g8rn9lqh1aagc77zg.jpg" width="500px" /></div><p>우선 애플워치보다 훨씬 저렴하다. </p><p>애플에서 판매하는 가장 저렴한 모델의 애플워치와 Fitbit에서 판매하는 Versa 모델중 가격이 가장 높은 Special Edition과 비교해도 <strong>20만원</strong>이 차이난다. 내가 구입한 모델은 기본 모델이어서 이것보다도 더 저렴했다. </p><p>Special Edition은 우레탄 밴드 대신 다른 소재의 밴드가 기본 적용되며 우레탄 밴드도 추가로 주는걸로 알고 있다. 이외에 기능적으로는 NFC기반의 Fitbit Pay(한국지원X)가 지원된다고 한다. 둘 다 필요없는 나는 기본 모델을 구입했다.</p><br><h3 id="2-Battery-Life"><a href="#2-Battery-Life" class="headerlink" title="2. Battery Life"></a>2. Battery Life</h3><div align="center">  <img src="http://www.mediafire.com/convkey/cc82/sjp9eiz12jegxgnzg.jpg" width="600px" /><br>Fitbit의 Sleep monitoring 기능</div><p>애플 워치의 배터리 수명은 약 하루라고 한다. 이건 내가 감당할 수 있는 스펙이 아니다. 배터리 수명이 24시간이라면 사실상 수면측정 불가능하다. 수면중에 꺼진다면 누가 수면체크에 애플워치를 사용할까. 아마 대부분의 애플 워치 사용자들은 자신이 거주하는 모든 공간(방/사무실) 등에 애플워치 충전기를 놓아두거나 수면중에 충전을 할 것으로 생각한다. </p><p>수면측정은 내가 피트니스 트래커를 사용하는 주된 이유중 하나이기 때문에 애플워치가 배터리 수명을 최소 30시간 이상 확보하지 못한다면, 영원히 구매하지 않을 것 같다. 아니 못할 것 같다.</p><br><h3 id="3-What-does-we-reall-need"><a href="#3-What-does-we-reall-need" class="headerlink" title="3. What does we reall need?"></a>3. What does we reall need?</h3><div align="center">  <img src="https://media.giphy.com/media/xT0BKO5GkYwKy6Vksg/giphy.gif" width="380px" /></div><p>이게 가장 큰 포인트이다.</p><p>난 처음 애플워치가 공개됬던 날부터 지금까지 스마트 워치에 관심이 있으면서도 늘 부정적으로 보는 이중적인 사람이다. 시계가 인터넷과 통신할 수 있게되면서 “혁신”이라는 단어를 난잡하게 사용하고 있지만, <strong>현재까지 시장에서 손꼽을만한 혁신적인 스마트워치는 없다고 단언한다.</strong> </p><p>스마트폰으로 충분히 할 수 있는 일을 하면서 그저 주머니에서 스마트폰을 꺼내지 않아도 된다는 점을 장점으로 어필하는건 과장에 불과하다고 생각한다. 사람들이 주머니에서 꺼내는 것을 귀찮아한다는게 정말 행동에 대한 귀찮음일까? </p><p>과거에 애플 워치가 처음 출시했을 때 얼마 안되서 구입한 사람을 본 적이 있다. 본인은 매우 만족하면서 썼지만 난 몇 개월간 그 사람의 사용 패턴을 보면서 애플 워치를 구입하지 않기로 결정했다. 당시 그 사람은 아이폰을 자주 확인하지 않아도 된다며 만족했지만, 오히려 애플워치에 인해 더 많이 간섭을 받고 있었다. 수시로 워치를 확인하는 바람에 회의에 참여하는 모습이 방해되었고, 그것으로 인해 생산성이 오르기는 커녕 오히려 필요하지 않은 정보까지 손목으로 받음으로써 오히려 손목 위의 그 작은 디바이스에 구속되는듯 보였다. </p><p>애플워치로 카카오톡 메세지를 받을 수 있다는 것에 만족하다고 했지만 카카오톡을 통한 대화의 대부분이 Trash Talk임을 생각해보면 그게 정말 장점이 될수있을까? <strong>더 많은 정보를 전달받기 보다는 이제는 내게 정말 필요한 정보만을 추출해야할 시대라고 생각한다.</strong> </p><p>참고로 난 카카오톡 시스템 알람을 끄고 생활한지 3년이 되어간다. 그리고 전혀 불편하지 않다. 개인적으로 커뮤니케이션 수단으로서의 중요성은 <u>인스턴트 메신저(카카오톡/라인) &lt;&lt; 메일 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 전화</u> 라고 생각하기 때문이다.</p><p>난 여전히 스마트 워치의 존재 자체가 불필요한 존재라고 생각한다. 적어도 스마트폰의 일부 기능을 대체하는 정도로는 말이다. 최근 몇 년동안 스마트 워치를 포함한 전체 웨어러블 시장이 침체되는 이유도 여기에 있다고 생각한다. 그런데 최근 애플의 실적 발표에서 하드웨어 부문에서 아이패드와 함께 괄목한 성적을 기록한 디바이스가 애플 워치이다. 왜 애플워치는 시장과 반대로 반응했을까?</p><div align="center">  <img src ="https://cdn.macrumors.com/article-new/2014/09/applewatchseries4ecgfeature.jpg" width="600px"/></div><a href="https://ko.wikipedia.org/wiki/%EC%8B%AC%EC%A0%84%EB%8F%84">심전도</a>(ECG, Electrocardiogram) 측정 기능이 애플워치4에 도입하기 시작했는데 이후부터 애플워치에 대한 인기가 높아지지 않았을까 생각한다. 이전까지는 스마트 워치에 대한 단순한 호기심만 있었다면 이젠 이 기기가 필요한 분명한 이유가 하나 늘었기 때문이다. 심전도 측정 기능은 단지 분당 심장이 몇 번뛰는지를 체크하는 심박수 체크 기능과 달리 심장의 비정상적인 리듬을 측정하고 진단하는 기능이라고 한다. 이 기능을 통해 심근경색 등 심장의 건강을 체크할 수 있다고 한다.<p>내가 생각하는 스마트워치가 앞으로 갈 길이 애플워치 4세대 모델이라고 생각한다. 그저 스마트워치 OS를 개발하거나 이식하는 것만으로는 필요성을 전혀 느끼지 못한다. 가격을 낮춘다고 해서 해결될 문제도 아니다. 스마트워치가 아니라 피트니스 트래커로서 이걸 착용한 사람들에게 특별한 가치를 제공해야만 한다. 내 건강을 확인할 수 있다는 점은 스마트폰이 대체할 수 없는 역할이다.</p><p>또 위와 같은 이유로 Fitbit이 아쉽기도 하다. Fitbit은 애플보다 먼저 시장을 선점했고, 애플워치가 론칭되고 나서도 한동안 북미 시장에서 1등 사업자는 Fitbit이었다. 그러나 최근 들어서는 비교하기가 민망할만큼 점유율 격차가 커졌다.</p><p><img src="http://www.mediafire.com/convkey/1a34/3a3n5hsgtxymkeqzg.jpg"></p><p>위에서 부터 아래로 시간이 최신순이며, 파란색이 애플워치, 빨간색이 Fitbit의 Market share이다. 애플워치가 본격적으로 판매되기 시작한 15년 분기(1Q ‘15)부터 애플워치의 share가 보이기 시작한다. Fitbit의 share는 17년부터 하향세를 보임이 분명하게 보인다.</p><p>통계 데이터 사이트 Statista에서 가져왔다.</p><p>그러나 애플워치 4세대 모델과 Fitbit Versa 간의 차이가 내가 생각하기에 위의 ECG 측정 외엔 없어보였다. 그렇다면 내게 ECG 측정 기능에 대한 기회비용은 20만원이었다. 20만원을 더 지불하고 ECG 기능이 측정되는 애플워치를 구입할 것이냐, ECG 측정을 포기하고 20만원을 절약할 것이느냐. 난 절약을 선택했다. </p><p>음.. 지금 별다른 소득이 없어서 그럴수도 있겠으나 아마도 소득이 있었어도 내 선택은 달라지지 않았을것 같다. 물론 소득이 엄청나게 높았다면, 애플워치 에르메스 에디션을 구매했을 것이다. 엄청나게 높았다면 말이다..</p><p>Fitbit Versa를 착용한지 며칠 되지 않았지만 생각보다 디자인도 이쁘고 가벼워서 착용감이 뛰어나다는 생각이 든다. 아이폰과의 궁합은 사실 전혀 기대하지 않았는데 아이폰 화면에 켜지는 Notification을 인식해서 Fitbit versa로 전송을 해주기도 한다. 보너스를 받은 기분이다 ㅋㅋ</p><div align="center">  <img src="http://www.mediafire.com/convkey/9855/2jkzmh585k50162zg.jpg" width="700px" /></div><p>실시간 정보가 필요한 날씨나 미세먼지 이외에 헬스케어 관련한 앱의 notification을 Fitbit Versa를 통해 전달받고 있다. 음악을 제어할 수 있는 기능도 있는데, 이것도 쏠쏠한 것 같다. </p><div align="center">  <img src="https://media.giphy.com/media/gnE4FFhtFoLKM/giphy.gif" width="250px"/></div>개인적인 선호와 별개로 주변 사람들에겐 Fitbit을 추천하지 않는 편이다. 심박수와 걸음수를 체크하는데 십만원 넘는 비용을 지불하고자 하는 사람이 별로 없기 때문이다. 심박수와 걸음수 체크는 샤오미의 미밴드를 통해서도 가능한데 미밴드는 5만원도 되지 않는 가격에 판매하고 있다. <div align="center">  <span><a href="https://coupa.ng/brpiAa" target="_blank"><img src="https://static.coupangcdn.com/image/affiliate/banner/89860ac3df4b2fd6f63f1ff43c3379d3@2x.jpg" alt="샤오미 스마트 미밴드 4, XMSH07HM, 블랙" width="120" height="240"></a></span>  <span><a href="https://coupa.ng/brpi7F" target="_blank"><img src="https://static.coupangcdn.com/image/affiliate/banner/152b252d3808dd4cf4ac76023f6bb7b9@2x.jpg" alt="Apple 애플워치4 GPS+셀룰러 44mm, MTX42KH/A, 골드 스테인레스 스틸 + 스톤 스포츠 밴드" width="120" height="240"></a></span></div><p>이 글을 읽고 Fitbit Versa에 대해 관심이 생긴 사람이 있다면, 그냥 애플워치를 사라고 얘기하고 싶다. Fitbit은 위에서 언급했듯 서비스가 좋지 않다. 가격에 비해 보증기간이 1년으로 짧은데 기가막히게 1년이 지나자마자 크고 작은 에러가 발생한다. 그리고 국내 지사로부터는 그 어떤 서비스도 받을 수 없기 때문에 미 본사 CS팀에 직접 문의해야하는 경우가 많다. 그렇다고 해서 크게 달라지는 없으나 난 본사와 직접 커뮤니케이션해서 보증기간이 지나고나서도 리퍼 제품을 받은 적이 있었다. </p><p>무엇보다 <strong>자신이 왜 이런 피트니스 트래커를 원하는지에 대해 분명하게 정의하고 제품을 찾아봤으면 좋겠다.</strong> 그저 신기해보여서 구입한다면, 얼마 지나지 않아 충전기에 꽂힌채로 책상 서랍에 들어가거나 A+급 상태로 중고나라에 올라갈지도 모른다.</p><div align="center">  <img src="http://www.mediafire.com/convkey/21e8/kw4744httpnnh2kzg.jpg" width="300px" /><br>당신의 제품이 여기 추가될지도 모른다..</div>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gadget </tag>
            
            <tag> healthcare </tag>
            
            <tag> IoT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>자료구조 - 배열</title>
      <link href="2019/04/datastructure-array/"/>
      <url>2019/04/datastructure-array/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1498243691581-b145c3f54a5a?ixlib=rb-1.2.1&auto=format&fit=crop&w=800&q=60"></p><h2 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h2><ul><li><a href="#data-structure">자료구조, 왜 배워야할까?</a></li><li><a href="#array">배열</a></li><li><a href="#element">요소, Element</a></li></ul><br><h1 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a><a name="data-structure"></a>Data Structure</h1><p>왜 자료구조를 알아야 할까?</p><p>원하는 <strong>데이터를 가장 효율적으로 탐색하는 방법이 알고리즘</strong>이라면, <strong>자료구조는 그런 탐색이 용이하도록 돕는 인프라</strong>라고 생각한다. </p><br><p><img src="https://proxy.duckduckgo.com/iu/?u=http://i.imgur.com/qQgcos9.jpg&f=1"></p><p>위의 이미지처럼 정리되어 있으면 특정 음료수를 찾으라고 할 때, 쉽게 찾을 수 있다.</p><p>위와 같은 식료품 매장에서 우유를 찾는다고 가정해보자. 다음과 같은 절차를 통해 우유를 찾을것이다. </p><ol><li>먼저 음료가 모아진 코너를 간다. </li><li>그리고 유제품끼리 정렬된 쪽으로 간다.</li><li>제조사에 맞춰 우유를 찾는다.</li></ol><br><p>위의 절차가 알고리즘이라고 생각한다. 그리고 사진 속처럼 같은 제품으로 분류한 방식이 자료구조인 셈이다. 따라서 <u>자료구조는 알고리즘을 공부하기 위해서 반드시 필요한 개념</u>이라고 할 수 있다. </p><br><p>자료 구조는 크게 배열과 리스트가 있다. 배열부터 살펴보도록 하자.</p><div align="center">    <img src="https://media.giphy.com/media/xT1XGFetUNzdysWUb6/giphy.gif"/>      </div><br><h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a><a name="array"></a>Array</h1><p><strong>배열은 비슷한 속성을 갖는 데이터끼리 패키징하는 방식의 Data Structure(자료 구조)이다.</strong> 연관된 데이터끼리 묶기 때문에 데이터가 많아졌을 때 데이터를 찾기에 용이하다는 장점이 있다.</p><p>프로그래밍에서 배열을 사용하면 다음과 같다. 언어는 Java를 사용했다.</p><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataStructureEx</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      String country[][] = &#123;</span><br><span class="line">       &#123;<span class="string">&quot;Korea&quot;</span>, <span class="string">&quot;Japan&quot;</span>, <span class="string">&quot;China&quot;</span>, <span class="string">&quot;india&quot;</span>, <span class="string">&quot;Vietnam&quot;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;Canada&quot;</span>, <span class="string">&quot;United States&quot;</span>, <span class="string">&quot;Mexico&quot;</span>, <span class="string">&quot;Costa-Rika&quot;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;Brazil&quot;</span>, <span class="string">&quot;Argentina&quot;</span>, <span class="string">&quot;Chile&quot;</span>, <span class="string">&quot;Uruguay&quot;</span>, <span class="string">&quot;Colombia&quot;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;France&quot;</span>, <span class="string">&quot;United Kingdom&quot;</span>, <span class="string">&quot;Italy&quot;</span>, <span class="string">&quot;Germany&quot;</span>, <span class="string">&quot;Netherland&quot;</span>&#125;,</span><br><span class="line">       &#123;<span class="string">&quot;Ghana&quot;</span>, <span class="string">&quot;South Africa&quot;</span>, <span class="string">&quot;Nigeria&quot;</span>, <span class="string">&quot;Egypt&quot;</span>, <span class="string">&quot;Cameroon&quot;</span>&#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 영국 출력 </span></span><br><span class="line">      System.out.println(country[<span class="number">3</span>][<span class="number">1</span>]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>String형 2차 배열 <code>country[][]</code>를 생성했다. 코드를 보면 알겠지만, <code>country[1][]</code>은 Asia 국가들로만, <code>country[2][]</code>은 북중미 국가들로만 묶는 식으로 대륙별 2차 배열을 생성했다. 이렇게 데이터를 분류하면 총 25개의 국가이지만 빠르게 국가를 찾을 수 있다. 물론 데이터가 많아질수록 배열로 인한 편리함은 극대화된다.</p><br><div align="center">    <img src="https://media.giphy.com/media/cCbJmshGlftajmf7HN/giphy.gif"/>  <p>    잠깐, 배열을 구성하는 요소는 어떻게 구성되어 있는걸까?  </p></div><br><h3 id="Element"><a href="#Element" class="headerlink" title="Element"></a><a name="element"></a>Element</h3><p>데이터의 가장 작은 구성 단위를 요소, Element라고 한다. Element는 value(값)와 index(인덱스)로 구성되는데, 여기서 중요한 개념이 index이다. index는 해당 전체 데이터에서 element를 나타내는 식별자이다. </p><blockquote><p>Element(요소) = Index(인덱스) + Value(값) </p></blockquote><div align="center">  <img height="auto" width="360px" src = "https://lh3.googleusercontent.com/RtPHEEKEMVEqP8SFmu_nGV9HhhSnxPu0U-J4qXFr_hjHq4KvLh7RmAS9gZ7FpfXZvyLJj9Yf4wTRrlZEdBhueg22WvEawI_E75dZ-4ne0NPnYHju7q_z9sVFu4Rx_7EMRU0Cs7cu2h_4-3vFDC1662xXR_WvrJ8KuOrd6OQg_0vvSs4CWX9VeSJeYW-ho91YevEkS4R3B3TrgFteiNByVOFIqKqMAi_X66jMlZoBcDsL7Cj-gKgPHuJ4ixfYV8zpaUFjXcTRir8t40aXwdsrHoGh9FQt0Bfpo_lAt2H8YyWDBl3-HJoDGC_liMkP7tE7i7snVj75pjORA--sre7kIt6EeKbinOlsVZTKIR03bHskNUveBIvZ_idvdhU58NVS9xB2ia2lGKcxfFeJsQOs_LtIFgQt6kz1-xE4pQIXEHb5o7M6j_j1OmAM0e5wRvwZbLzfAPv0BlAF0xOJOTNrGVACRgMfIVaKzC8D_O_MKd0O2WhfKX2IlTD3TFCinoCpZJhUi0Wd0dNxAwhQ9fFmpwxwXvBN90e2HYdlw3Mc9nLg2ebiQ_XtP7OFzH8uQ5V3ZmKTlCSBQKoOJEFm5CwUMbqej0UoLwTL_l07hBbayaTYxP5hBOFTFXAdSOgZH1ADx9-o2avm6qeFfNIrSL9XOjHJ_Cj6KDMY=w1044-h612-no"/>  <p>    출처 : 생활코딩  </p></div><br><p>자 이제 배열과 함께 자료구조로 쓰이는 리스트에 대해 알아보도록 하자.</p><div align="center">  <img src="https://media.giphy.com/media/CjmvTCZf2U3p09Cn0h/giphy.gif" width="300px" /></div><br><br><h3 id="자료구조-글-목록"><a href="#자료구조-글-목록" class="headerlink" title="자료구조 글 목록"></a>자료구조 글 목록</h3><ul><li><strong><u>자료구조-배열 (현재글)</u></strong></li><li><a href="https://devyoungjin.github.io/2019/05/datastructure-list/">자료구조-리스트 (다음글)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> datastructure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git - Commit</title>
      <link href="2019/04/git-commit/"/>
      <url>2019/04/git-commit/</url>
      
        <content type="html"><![CDATA[<p>본 포스트는 <a href="https://www.youtube.com/watch?v=x8P_jDOcl-8&feature=youtu.be" target="_blank">코드 스쿼드의 커밋하면 스테이지의 내용은 어디로 갈까</a>를 시청하고 정리한 포스트입니다.</p><hr><h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#intro">Intro</a></li><li><a href="#status">git status</a></li><li><a href="#commit">git commit</a></li></ul><p><img src="https://images.unsplash.com/photo-1477949331575-2763034b5fb5?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80"></p><p><a name="intro"></a>버전관리 소트트웨어인 Git은 객체로 구성되어 있다. Git을 구성하는 객체는 다음과 같다. </p><ul><li><a href="#commit"><strong>Commit</strong></a><ul><li>우리가 가장 신경써야할 Commit(커밋) 이다.</li></ul></li><li><a href="#git-tree">Tree</a><ul><li>커밋에 포함된 파일 목록.</li></ul></li><li><a href="#git-blob">Blob</a><ul><li>파일의 내용</li><li>파일 내용 변경되면, 객체주소 변경되면서 <code>git status</code> 에서  <code>modified</code> 메세지 출력.</li><li><code>git hash-object file.txt</code> 로  file의 객체주소 확인 가능</li></ul></li><li>Tag</li><li>reference<ul><li>branch</li><li>HEAD</li></ul></li></ul><br><h2 id="Git-status"><a href="#Git-status" class="headerlink" title="Git status"></a><a name="status"></a>Git status</h2><p><a href="https://git-scm.com/book/ko/v2/%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-CLI" target="_blank">CLI</a> 환경에서 <code>git status</code> 명령어를 입력하면 알 수 있는 것들이다.</p><ul><li>작업 디렉토리</li><li>스테이지</li><li>Commit <code>&lt;HEAD&gt;</code></li></ul><p>status 명령어를 통해서는 local repo에 어떤 파일이 올라갔고, 어떤 파일이 아직 local repo에 동기화되지 않은지를 볼 수 있다. 이를 위해서는 우선 Git에서 데이터가 어떻게 이동되는지 경로를 먼저 보도록 하자.</p><div align="center">  <a name="git-transport"></a>  <img src="https://i.stack.imgur.com/caci5.png" width="450px" /></div><p>workspace는 프로그래머가 작업하고 있는 공간을 의미한다. git이 추적하지 않는 상태이다. </p><p>git을 설치하고, git에 의해 추적하길 원한다면 <code>git add &lt;file&gt;</code> 명령어를 통해 파일들을 index에 올려두어야 한다. index에 있는 파일들만 local repository로 커밋할 수 있기 때문이다.</p><p>local repository는 작업이 끝난 파일들이 저장된 최종 저장소라고 할 수 있다. 이를 원격 저장소와 연동하여 <code>push</code> 명령어로 서버에 git을 보낼 수 있다.</p><p>터미널에서 직접 보도록 하자.</p><p>opentutorials_git 이라는 폴더를 생성 후, code.txt, code2.txt, code3.txt  파일을 각각 생성하여 각기 다른 상황을 만들어보았다. 현재 파일들의 상태는 다음과 같다.</p><ul><li><p><strong>code.txt</strong></p><ul><li><p>파일 생성</p><ul><li><code>vim code.txt</code></li></ul></li><li><p>stage에 add후, 커밋 </p><ul><li><code>git add code.txt</code></li><li><code>git commit -m &quot;add code.txt&quot;</code></li></ul></li><li><p>파일 수정</p></li><li><p>다시 stage에 올려둠 </p><ul><li><code>git add code.txt</code></li></ul></li></ul></li></ul><ul><li><strong>code2.txt</strong><ul><li>파일 생성<ul><li><code>vim code2.txt</code></li></ul></li><li>stage에 add후, 커밋<ul><li><code>git add code2.txt</code></li><li><code>git commit -m &quot;add code2.txt&quot; </code></li></ul></li><li>파일 수정</li></ul></li></ul><ul><li><p><strong>code3.txt</strong></p><ul><li>파일 생성</li><li>파일 수정</li></ul></li></ul><div align="center">  <a name="example"></a>  <img src="http://www.mediafire.com/convkey/4295/vsjncogu6l2yz5gzg.jpg" width="600px" /></div><p>위 이미지를 보면 의도한대로 세 파일 모두 전부 다르게 git에 의해 tracking(추적)되고 있음을 알 수 있다. 먼저 code.txt부터 살펴보도록 하자. </p><p>code.txt는 커밋한 이후 파일에 변경이 발생하여, 다시 stage에 올려두어 커밋할 준비가 되어있는 상태의 파일이다. 커밋할 준비가 되어 있는 파일, <strong>즉 stage에 올라가 있고 변경사항이없는 최신상태일 경우 파일이름은 초록색으로 표시된다.</strong></p><p>code2.txt는 커밋한 이후 파일에 변경이 발생했지만 아직 stage에 올려두진 않은 상태다. <strong>변경이 발생한 파일이 커밋할 준비가 되어 있지 않기 때문에 code.txt와 달리 빨간색으로 파일 이름이 표시됨을 알 수 있다.</strong></p><p>code3.txt는 파일 생성 직후, git 명령어를 입력하지않은 상태에서 한 차례 수정한 파일이다. <strong>git에 의해 추적되지 않고 있기 때문에 code.txt나 code2.txt와 달리 파일에 변경사항이 발생했음에도 불구하고 modified라는 표시가 출력되지 않는다.</strong> 그래서 <code>(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</code> 라는 메세지를 친절하게 출력하여 git에 의해 파일이 추적되도록 stage에 파일을 올릴것을 의도한다.</p><p>위의 이야기를 제대로 이해하기 위해서는 커밋(Commit)이 객체라는 사실을 숙지해야만 한다.</p><div align="center">  <img src="https://media.giphy.com/media/xksAgXS9jSouPVdH0z/giphy.gif" width="300px" /><br>괜찮다. 포기할거면 지금 포기해도 좋다.<br>나중에 다시 필요해졌을 때 돌아오자..</div><h2 id="Git-Commit"><a href="#Git-Commit" class="headerlink" title="Git Commit"></a><a name="commit"></a>Git Commit</h2><p>커밋(Commit)은 Git에서 작업단위를 의미한다. 파일 하나를 수정할 때마다 커밋을 하는게 아니라, login기능을 구현했다면 login 기능을 구현하는데 사용한 파일들을 묶어서 하나의 커밋 객체를 생성하는 방식이다.</p><p><code>git commit</code> 이라는 명령어를 통한 제어는 다음과 같은 일을 수행한다.</p><ul><li><strong>스테이지에 있는 내용을 가지고 새로운 커밋 객체를 생성</strong></li><li><strong>이전 HEAD가 가리키는 커밋이 새로운 커밋의 부모가 됨</strong></li><li>Commit에 포함된 정보<ul><li>Commit Message</li><li>Tree-blobs</li><li>Parent Commit</li></ul></li><li>커밋 이후엔 작업 디렉토리와 스테이지, HEAD 커밋의 내용이 모두 같아진다</li></ul><p>git의 원리를 파악하는데 유용한 소프트웨어, <a href="https://youtu.be/KyGfapLpWhY" target="_blank">Gistory</a>를 통해 위에서 만든 git의 객체들을 구경해보자.</p><p>Gistory로 git의 객체를 확인하려면, 당연하게도 git의 객체를 생성해야 한다. 따라서 위의 <a href="#example">예제 상황</a>에서 code.txt를 “changed code.txt”라는 메세지와 함께 커밋하였다.</p><div align="center">  <a name="git-tree"></a>  <img src="http://www.mediafire.com/convkey/66d8/k9ac4f88g0rggugzg.jpg" width="450px" /></div><p>이미지를 보면, 객체가 생성되었음을 알 수 있다. 커밋 메세지도 볼 수 있다.</p><p>여기서 tree와 parent를 살펴볼건데, 위의 이미지는 해당 객체의 tree를 클릭했을 때 볼 수 있는 화면이다. 해당 객체가 어떤 파일들을 포함하고 있는지를 보여준다. blob은 <a href="#intro">위에서</a> 파일 객체라고 하였다. 이를 클릭하면 아래처럼 파일의 내용을 볼 수 있다.</p><div align="center">  <a name="git-blob"></a>  <img src="http://www.mediafire.com/convkey/025e/wcgxv9g4re74hv2zg.jpg" width="450px" /></div><p>code.txt에 입력한 코드 두 줄이 보인다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">code1</span><br><span class="line">changed</span><br></pre></td></tr></table></figure><p>이제 parent를 클릭해보자.</p><div align="center">  <img src="http://www.mediafire.com/convkey/a9a9/mv53vw3fc0p7l9xzg.jpg" width="450px" /></div><p>해당 커밋 객체의 부모 객체를 보여준다. code.txt를 커밋하기 전의 커밋은 code.txt와 code2.txt를 “add code.txt and code2.txt” 라는 메세지와 함께 커밋을 한 것이다. 이 메세지를 부모 객체에서 확인할 수 있다.</p><p>그리고 ./logs/HEAD/를 들어가면 git으로 제어하고 있는 워크스페이스 즉 local repository에서 생성된 모든 커밋 객체를 확인할 수 있다. 커밋 객체들이 HEAD의 노드임을 알 수 있다.</p><div align="center">  <a name="git-head"></a>  <img src="http://www.mediafire.com/convkey/3aec/i4zhys5u3ycbp8dzg.jpg" width="450px" /></div><p>오래 전 커밋한 객체도 보이고, 멘 아래 방금 커밋한 메세지의 커밋 객체도 볼 수 있다.</p><p>다소 복잡하지만 git을 이해하기 위해 필요한 필수 과정이라고 생각한다. 원리를 이해해야 협업과정에서 발생할 수 있는 여러가지 충돌에 대응할 수 있다고 생각한다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>System.out.print의 정체</title>
      <link href="2019/04/java-systemoutprint/"/>
      <url>2019/04/java-systemoutprint/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1471890701797-59336a877de4?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1088&q=80"></p><p>자바에서는 이클립스 콘솔 창에 출력 할 때, <code>System.out.println();</code> 이라는 코드로 출력을 한다. 그런데 이 코드는 어떻게 구성되어 있는걸까? 생각없이 출력을 위해서만 작성하다가 문뜩 생각나서 정리해보았다.</p><p>자바가 내장하고 있는 기본 패키지인 <code>java.lang</code> 패키지에는 System 이라는 클래스가 포함되어 있다고 한다. 그러니 <strong>System은 자바의 내장 객체</strong> 인 셈이다.</p><p>그럼 <code>out.println</code>은?</p><p><strong>System 클래스엔 표준 입출력을 위한 3가지 클래스 변수(static variable)</strong> 가 포함되어 있는데, 이게 <code>System.in</code>, <code>System.out</code>, <code>System.err</code> 이다. 이들을 <strong>PrintStream</strong> 이라고도 한다.</p><p>표준 입력 작업을 수행할 때엔 <code>System.in</code>,<br>표준 출력 작업을 수행할 때엔 <code>System.out</code>을 사용한다.</p><p>그리고 파일에 직접 입력할 때엔 <code>System.err</code>을 사용한다.</p><p>그리고 다시 <code>out</code> 이라는 클래스 변수에 출력에 필요한 <code>print()</code>, <code>println()</code> 의 메서드가 포함되어 있는 것이다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>(번역) Java로 코딩을 배우는 방법</title>
      <link href="2019/03/how-to-learn-to-code-in-java/"/>
      <url>2019/03/how-to-learn-to-code-in-java/</url>
      
        <content type="html"><![CDATA[<h1 id="How-to-learn-to-code-in-Java-why-you-should-and-where-to-start"><a href="#How-to-learn-to-code-in-Java-why-you-should-and-where-to-start" class="headerlink" title="How to learn to code in Java.: why you should and where to start"></a>How to learn to code in Java.<br>: why you should and where to start</h1><p><img src="https://cdn-images-1.medium.com/max/1600/1*ul3RsMeBo2H_PS2oduGGig.png"></p><p>출처 : <a href="https://medium.freecodecamp.org/learn-to-code-in-java-why-you-should-and-where-to-start-39022d15655d" target="_blank">How to learn to code in Java: why you should and where to start</a></p><h3 id="👎-지양해야-하는-것-🚫"><a href="#👎-지양해야-하는-것-🚫" class="headerlink" title="👎 지양해야 하는 것. 🚫"></a>👎 지양해야 하는 것. 🚫</h3><ul><li><p><strong>특별한 목표없이 공부하기</strong></p><ul><li>프로그래밍 공부에 앞서 스스로에게 질문하기<br>“나는 왜 프로그래밍이 필요하지?”</li></ul></li><li><p><strong>한번에 여러 가지 기술을 공부하기</strong></p><ul><li>학습 계획에 너무 많은 언어나 기술을 포함하지 않도록 주의하여 번아웃을 피하자.</li></ul></li><li><p><strong>이론에만 몰두하기</strong></p><ul><li>프로그래밍이라는 기술은 많은 연습을 통해서 얻을 수 있는 기술이다. 배경에 대한 이론이 필요할 수 있지만, 거기에만 너무 몰두하면 코딩을 할 수 없다.</li></ul></li><li><p><strong>혼자 공부하기</strong></p><ul><li>누구도 당신이 안되길 바라는 사람은 없다. 개발자 커뮤니티나 행사에 참여해서 도움을 얻자. 당장 오프라인 커뮤니티에 참여하기 어렵다면, 온라인부터 시작하자. 단체 카카오톡 채팅방 또는 페이스북 그룹 등에서 찾아 볼 수 있다.</li></ul></li><li><p><strong>언젠간 프로그래밍을 마스터할 수 있다는 착각</strong></p><ul><li>프로그래밍의 세계는 급격하게 변하는 세상이다. 당신이 개발자가 되기로 마음먹었다면, 개발자가 된 그 순간까지도 학습을 멈춰서는 안된다.  </li></ul></li></ul><br><h3 id="🙏-지향해야-하는-것-📌"><a href="#🙏-지향해야-하는-것-📌" class="headerlink" title="🙏 지향해야 하는 것 📌"></a>🙏 지향해야 하는 것 📌</h3><ul><li><p><strong>공부 목적 설정과 프로그래밍 언어 선택</strong></p><ul><li>개발자가 되기위해 프로그래밍 언어의 모든 걸 학습할 필요는 없다. 어떤 목적으로 학습하고자 하는지에 따라 분명한 학습 영역을 생각해보자.</li></ul></li><li><p><strong>학습 플랜 설계</strong></p><ul><li>평일엔 최소 2-3시간, 주말엔 5시간 이상 학습,<br>이렇게 3개월에서 6개월을 학습하면 주니어 개발자에 이를 수 있음</li><li>학습 절차를 나눠서 설계<ul><li>ex) JDK 설치 및 자바 실행 환경(Eclipse, IntelliJ IDEA) 구축</li><li>Java 문법 학습</li><li>Java Core 학습</li><li>컬렉션 학습</li><li>유명한 라이브러리와 프레임워크 학습</li><li>자주 쓰이는 API 학습 (ex. servlets, JSP 등)</li><li>Git </li></ul></li><li>프로그래밍은 매일 해야하는 **’스킬’**이므로 이론과 실습을 적절히 병행해야 한다.</li></ul></li><li><p><strong>프로그래밍 학습에 필요한 커뮤니티를 골라라.</strong></p><ul><li>Java 코딩을 하다가 어떤 것이든 질문을 할 수 있는 커뮤니티에 가입해라. 그리고 당신의 생각을 공유하고 마음에 맞는 사람을 찾아라. Java 개발자들에게 최고의 커뮤니티를 아래에 리스팅해놓았다.</li></ul></li></ul><br><h3 id="💻-Java를-공부하는데-유용한-사이트-💡"><a href="#💻-Java를-공부하는데-유용한-사이트-💡" class="headerlink" title="💻 Java를 공부하는데 유용한 사이트 💡"></a>💻 Java를 공부하는데 유용한 사이트 💡</h3><ul><li><a href="https://www.codecademy.com/learn" target="_blank">CodeAcademy</a><ul><li>가장 유명한 프로그래밍 교육 웹사이트이다. 입문자에게 적합한 웹사이트이다.</li><li>주어진 과제를 읽고, 과제를 해결하는 코드를 작성하고 결과를 체크한다. 다음 step으로 넘어갈수록 어려워진다.</li></ul></li><li><a href="https://codegym.cc/" target="_blank">CodeGym</a><ul><li>Codegym은 게임을 하면서 Java를 학습할 수 있는 웹사이트이다.</li></ul></li><li><a href="https://www.codewars.com/" target="_blank">Codewars</a><ul><li>‘초보’딱지를 뗀 프로그래밍에 대한 기본 지식이 있는 사람들에게 적합한 웹사이트이다.</li></ul></li><li><a href="https://www.edx.org/learn/java" target="_blank">EdX</a><ul><li>개발자라고 할 수 있는 ‘프로’ 레벨의 사람들에게 적합한 웹사이트이다.</li><li>EdX는 하버드 대학과 MIT에 의해 설립된 교육 플랫폼이다. Java를 포함하여 다양한 강좌가 있으며, 대학들로부터 제공받은 인증된 강좌들이 많이 있다. Certification을 제공하는 프로그램도 있다.</li></ul></li></ul><br><hr><p>출처 : <a href="https://medium.freecodecamp.org/learn-to-code-in-java-why-you-should-and-where-to-start-39022d15655d" target="_blank">Medium,  Johan Selawsky</a></p><br><p>처음으로 번역을 해 본 글이다.</p><p>프로그래밍 실력만큼이나 부족한 영어 실력이기에 발번역이 된 것 같지만.. Medium에서 좋은 글을 발견하면 꾸준히 번역해서 아카이브 해둬야겠다. </p><p>Medium 무료계정은 한 달에 글을 5개 밖에 볼 수 없는걸 알았다. 좋은 글이고, 번역할 생각이 있는 글은  에버노트에 클리핑해둬야겠다.</p>]]></content>
      
      
      <categories>
          
          <category> Articles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tip </tag>
            
            <tag> career </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>개발자가 질문하는 법</title>
      <link href="2019/03/how-to-ask-question/"/>
      <url>2019/03/how-to-ask-question/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1534551767192-78b8dd45b51b?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80"></p><p>프로그래밍을 공부하다 보면, 스스로 해결 하지 못하는 상황이 발생하곤 한다. 이 때엔 온라인이나 오프라인을 통해 도움을 요청해야 하는데, 이 때 질문을 어떻게 하느냐에 따라 내가 원하는 솔루션을 효율적으로 접근할 수 있다.</p><p>여기에 좋은 글과 영상을 하나 씩 공유하고자 한다.</p><p><strong>질문을 잘하는 개발자</strong> 는 <a href="https://toss.im/" target="_blank">토스</a>를 서비스하는 비바 리퍼블리카에서 프론트 엔드 개발자로 계신 <a href="https://jbee.io/about" target="_blank">JBee</a>님이 블로그에 작성하신 글이며, 유튜브 영상 <strong>동기부여 - 질문 잘 하는 법</strong> 은 <a href="https://www.codesquad.kr" target="_blank">코드스쿼드</a>에서 백엔드 교육 담당을 맡고 계신 정호영님의 영상이다.</p><br><h2 id="질문을-잘하는-개발자"><a href="#질문을-잘하는-개발자" class="headerlink" title="질문을 잘하는 개발자"></a>질문을 잘하는 개발자</h2><p><a href="https://jbee.io/essay/good_questionor/" target="_blank">출처 : JBee님 블로그</a></p><p>문제가 발생했을 때 또는 모르는 것이 생겼을 때, 이를 해결할 수 있는 가장 빠른 방법은 자신의 상황을 잘 알고 있는 누군가에게 질문하는 것입니다. 그 누군가는 옆 동료가 될 수도 있고 멘토나 사수 등이 될 수 있습니다.</p><br><h3 id="충분한-구글링을-우선-선행"><a href="#충분한-구글링을-우선-선행" class="headerlink" title="충분한 구글링을 우선 선행"></a>충분한 구글링을 우선 선행</h3><p>당연히 위에서 말한 ‘문제’와 ‘모르는 것’은 구글링으로 해결되는 문제를 의미하지 않습니다. 우리가 마주하게 되는 대부분의 문제는 이미 웹 상에 그 해결책이 있습니다.</p><p>아쉽게도 구글링을 잘하면 나올법한 질문들이 종종 보이거나 그런 질문들을 받게 됩니다. 구글링 또한 의식적으로 해야 한다고 생각합니다.</p><p>웹 상에 공유된 해결책으로 문제가 해결되지 않거나 여러 해결책들을 기반으로 새로운 해결책을 도출해야할 경우, ‘모르는 것’이 생겨납니다.</p><blockquote><p>나 이거 모르는데, 알려주세요.</p></blockquote><br><h3 id="동료의-시간을-낭비하지-마세요"><a href="#동료의-시간을-낭비하지-마세요" class="headerlink" title="동료의 시간을 낭비하지 마세요."></a>동료의 시간을 낭비하지 마세요.</h3><p>무턱대고 ‘A’을 모른다고 하면 질문을 받는 사람 입장에서는 난처할 수 밖에 없습니다. 그 이유는 다음과 같기 때문입니다.</p><ul><li>‘A’와 관련된 내용을 정말 <strong>전부</strong> 모르는 것인가</li><li>그것이 아니라면 정확히 <strong>무엇이 문제</strong>인 것인가</li><li><strong>무엇을 하다가</strong> A까지 갔을까</li><li>현재 A로 무엇까지 <strong>해보았을까</strong> (trial)</li></ul><p>질문에 위 내용에 대한 질문이 전혀 없기 때문입니다. 당연히 이러한 <strong>정보</strong>가 포함된 질문이 좋은 질문입니다.</p><p>옆의 동료도 자신의 개발, 업무를 하고 있을 겁니다. 질문을 받는 옆 동료의 Context와 자신의 Context가 다르다는 것을 인지해야 합니다. 문제가 빨리 해결되길 원한다면 <strong>Context를 맞추는 작업</strong>이 선행되어야 합니다. 그리고 이 작업이 빠르게 선행되기 위해서는 질문자가 질문을 <strong>정리</strong>해야 합니다.</p><br><h3 id="Two-Question"><a href="#Two-Question" class="headerlink" title="Two Question"></a>Two Question</h3><p>질문에는 다음 두 가지 종류가 있습니다.</p><ul><li>정답이 <strong>있는</strong> 질문</li><li>정답이 <strong>없는</strong> 질문</li></ul><p>정답이 있는 질문에는 <strong>‘예/아니오’로 대답</strong>할 수 있도록 질문하는 것이 좋습니다. 정답이 없는 질문에는 <strong>토론</strong>으로 이어지게 끔 자신의 입장을 정리하여 질문을 정리하는 것이 좋습니다.</p><p>추상적인 것 같으니 간단한 예를 들어볼까요?</p><br><h4 id="Example-1-“Jbee님-QA-중-올라온-이슈인데요-보던-화면이-유지가-안-되는데-이거-어떻게-해야하죠-”"><a href="#Example-1-“Jbee님-QA-중-올라온-이슈인데요-보던-화면이-유지가-안-되는데-이거-어떻게-해야하죠-”" class="headerlink" title="Example 1. “Jbee님, QA 중 올라온 이슈인데요, 보던 화면이 유지가 안 되는데 이거 어떻게 해야하죠?”"></a>Example 1. “Jbee님, QA 중 올라온 이슈인데요, 보던 화면이 유지가 안 되는데 이거 어떻게 해야하죠?”</h4><p>여기에서 제가 역으로 질문할 내용은 다음과 같습니다.</p><ol><li>모든 디바이스, 브라우저에서 발생하는 이슈인가요?</li><li>어떤 상황에서 보던 화면이 유지가 안되나요?</li><li>기존에는 어떠한 방식으로 보던 화면을 복원하고 있었나요?</li><li>이슈를 받고 어떠한 시도들을 해봤나요?</li></ol><br><h4 id="Example-2-“Jbee님-이-로직은-A에-들어가는게-맞나요-B에-들어가는게-맞나요-”"><a href="#Example-2-“Jbee님-이-로직은-A에-들어가는게-맞나요-B에-들어가는게-맞나요-”" class="headerlink" title="Example 2. “Jbee님, 이 로직은 A에 들어가는게 맞나요, B에 들어가는게 맞나요?”"></a>Example 2. “Jbee님, 이 로직은 A에 들어가는게 맞나요, B에 들어가는게 맞나요?”</h4><p>여기에서 제가 역으로 질문할 내용은 다음과 같습니다.</p><ol><li>이 로직은 왜 필요한건가요?</li><li>A에 들어가야 한다고 생각하는 이유는 무엇인가요?</li><li>B에 들어가야 한다고 생각하는 이유는 무엇인가요?</li><li>두 방법을 고민하는 이유는 무엇인가요?</li></ol><p>1번부터 4번까지 역으로 질문하다가 1시간은 흘러가겠네요. 서로 피곤해질 것이 뻔합니다. 그리고 답변을 해주는 사람도 1~4번 내용을 모르고서는 쓸모있는 답변을 하기 힘듭니다.</p><br><h3 id="질문-정리하기"><a href="#질문-정리하기" class="headerlink" title="질문 정리하기"></a>질문 정리하기</h3><p>위와 같은 상황이 발생하지 않도록 질문을 하려면 어떻게 해야 할까요? Context를 맞추는 작업은 무엇을 말할까요? 모르는 것이 생겨서 질문을 해야 겠다는 생각이 들면, 아래 내용을 정리해보세요. 정리를 하다가 스스로 해결이 되는 경우도 많습니다.</p><br><h3 id="지금-이슈가-된-것이-무엇인가"><a href="#지금-이슈가-된-것이-무엇인가" class="headerlink" title="지금 이슈가 된 것이 무엇인가?"></a>지금 이슈가 된 것이 무엇인가?</h3><p>정확한 상황 설명을 추가하면 좋습니다. 이러한 부연 설명을 최대한 줄이기 위해 최소한 <strong>자신이 무슨 프로젝트를 하고 있는지 알고 있는</strong>, 또는 <strong>자신의 수준을 알고 있는</strong> 동료 개발에게 질문을 하는 것이 좋습니다.</p><ul><li>지금 개발 중인지, QA 중인지, 배포 후 긴급 대응인지</li><li>이슈가 발생한 환경은 무엇인지 (OS, 브라우저 등)</li><li>어떠한 상황에서 이슈가 발생했는지</li></ul><br><h3 id="어디까지-해보았나"><a href="#어디까지-해보았나" class="headerlink" title="어디까지 해보았나?"></a>어디까지 해보았나?</h3><p>발생한 이슈에 대해서 자신이 어느 정도까지 파악을 했고 어떠한 시도를 해봤는지 공유를 하면 좋습니다. 질문을 받는 사람이 이미 자신이 아는 것을 설명해주거나 이미 시도해본 방법을 제시한다면 서로 시간 낭비가 됩니다.</p><ul><li>발생한 이슈의 원인이 무엇이라고 생각하는가?</li><li>그 원인을 토대로 내린 결론은 무엇인가</li><li>결론대로 시도를 해보았는가</li></ul><p>이러한 내용들이 담긴 질문을 한다면 답변자는 약간의 시간만 들여서 수월하게 문제를 함께 해결해볼 수 있습니다. 즉 답변자는 다음과 같은 액션을 취할 수 있습니다.</p><ul><li>이슈의 원인을 다시 짚고 그에 따른 새로운 해결 방안을 제안</li><li>파악된 원인을 기반으로 다른 시도를 제안</li><li>올바른 방향의 결론이었다면 함께 디버깅을 진행</li></ul><blockquote><p>질문 정리하다가 답을 찾아서 질문할 필요가 없어지겠네요.</p></blockquote><p>스스로 해결하는 경우가 당연 베스트이지 않을까요? 😁</p><br><h3 id="온라인에-질문-올리기"><a href="#온라인에-질문-올리기" class="headerlink" title="온라인에 질문 올리기"></a>온라인에 질문 올리기</h3><blockquote><p>다음 내용은 <a href="https://www.youtube.com/watch?v=L2p1mdpxD5w">코드스쿼드의 정호영 마스터님의 발표 영상(동기부여 - 질문 잘하는 법)</a>을 참고하여 작성하였습니다.</p></blockquote><p>페이스북 그룹에 종종 질문 글이 올라옵니다. 하지만 답변을 받지 못하는 경우도 많이 봤고 답변해주고 싶어도 이해가 안 가는 질문글이 많았습니다. 다음과 같은 부분들을 고려해보면 어떨까 싶습니다.</p><br><h3 id="질문의-제목에"><a href="#질문의-제목에" class="headerlink" title="질문의 제목에!"></a>질문의 제목에!</h3><ul><li>질문의 status를 추가하자<ul><li>답변 대기, 해결됨 등</li></ul></li></ul><br><h3 id="질문의-본문에"><a href="#질문의-본문에" class="headerlink" title="질문의 본문에!"></a>질문의 본문에!</h3><ul><li>API , 핵심 에러메시지을 포함하기 - 발생한 에러 메세지는 정확히</li><li>예의바르게, 깔끔하게, 맞춤법을 맞춰서</li><li>코드는 스크린샷이 아닌, 텍스트 그 자체가 아닌 code share 툴을 사용.<ul><li>Gist, code sandbox, jsbin 등</li></ul></li><li><strong>질문을 올리고 반드시 tracking</strong></li></ul><p>마지막 ‘질문을 올리고 반드시 tracking’ 부분은 개인적으로 정말 중요하다고 생각합니다. 질문을 올리고나서 답변이 달려도 아무 반응이 없는 질문글들이 보이면 마음이 아픕니다. 답변이 원하는 내용이 아니더라도 도움을 주시려는 분에게 최소한의 예의가 아닐까 생각합니다.</p><br><h3 id="한-걸음-더-나아가기"><a href="#한-걸음-더-나아가기" class="headerlink" title="한 걸음 더 나아가기"></a>한 걸음 더 나아가기</h3><p>질문에 대한 답을 듣고 문제를 해결했습니다. 여기서 한 발 더 나아가서 그것을 공유해보는 것은 어떨까요? 답변을 해준 사람이 ‘감히 내 소중한 지식을 너가 공유해?’라고 하진 않을 겁니다.</p><blockquote><p>이거 별거 아닌데… 굳이 공유까지 하나요?</p></blockquote><p>대부분 공유를 부탁하면 이런 반응입니다. 질문을 하고 답변을 듣기 전 이 이슈는 자신에게 굉장히 힘겨운 문제였는데도 까맣게 잊어버립니다. 누군가는 같은 이슈로 고통받고 있지 않을까요?</p><blockquote><p>블로그가 없어요!</p></blockquote><p>블로그가 없어도 공유는 가능합니다. 간단히 정리하여 페이스북 커뮤니티 그룹에 올려도 되구요, 요즘 많이 사용하시는 <a href="https://www.notion.so/">notion</a>은 정리한 내용을 바로 웹 상으로 공유도 할 수 있습니다.</p><p>우리는 개발자이니 GitHub 저장소를 활용할 수도 있겠습니다. 저는 <a href="https://github.com/JaeYeopHan/tip-archive/issues">tip-archive</a>라는 GitHub 저장소를 하나두고 블로그에 올리기에는 너무 짧은 snippet 성의 지식들을 이슈로 정리하고 있습니다.</p><br><h3 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h3><p>질문자는 질문하기 전 조금만 시간을 더 투자해서 서로의 시간을 아끼고 함께 성장할 수 있지 않을까요?</p><p>감사합니다.</p><br><hr><br><h2 id="동기부여-질문-잘-하는-법"><a href="#동기부여-질문-잘-하는-법" class="headerlink" title="동기부여 - 질문 잘 하는 법"></a>동기부여 - 질문 잘 하는 법</h2><p>출처 : <a href="https://youtu.be/L2p1mdpxD5w" target="_blank">코드스쿼드 유튜브 - 동기부여 질문 잘 하는 법</a></p><iframe width="560" height="315" src="https://www.youtube.com/embed/L2p1mdpxD5w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>### 질문 작성하기<ul><li><p>맞춤법은 정확하게 / 질문은 예의바르게 / 포맷은 깔끔하게!</p></li><li><p>코드보다 상황 설명을 먼저 하자</p></li><li><p>재현 가능하도록 매우 구체적으로 상황을 기술한다.</p></li><li><p>코드를 스크린샷으로 첨부하지 않는다!</p><ul><li><a href="https://pastebin.com/">https://pastebin.com</a> 또는 <a href="https://gist.github.com/">https://gist.github.com</a> 을 이용</li></ul></li><li><p>발생한 에러 메세지는 정확하게 첨부한다.</p></li><li><p>적절한 스크린샷을 첨부한다.</p><br></li></ul><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><table><thead><tr><th>BAD</th><th>프로그램이 안돌아가요</th></tr></thead><tbody><tr><td><strong>GOOD</strong></td><td>int 나누기 int 결과값이 이상하게 나오는 이유가 뭘까요?</td></tr><tr><td><strong>BAD</strong></td><td>[node] 세션 문제 도와주세요ㅜㅜ</td></tr><tr><td><strong>GOOD</strong></td><td>[node] 페이지 리다이렉트를 해도 세션을 유지하려면?</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Articles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tip </tag>
            
            <tag> career </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java API Documentation</title>
      <link href="2019/03/why-we-should-to-read-document/"/>
      <url>2019/03/why-we-should-to-read-document/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1524402822060-94f4fb30f6ff?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80"></p><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="1-Math-random"><a href="#1-Math-random" class="headerlink" title="1) Math.random()"></a>1) Math.random()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example_01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rollDice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// random num between 0 and (almost) 1</span></span><br><span class="line">        <span class="keyword">double</span> randomNumber = Math.random();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// change range to 0 to (almost) 10</span></span><br><span class="line">        randomNumber = randomNumber * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// convert datatype from double to integer</span></span><br><span class="line">        <span class="keyword">int</span> randomInt = (<span class="keyword">int</span>)randomNumber;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// returns</span></span><br><span class="line">        <span class="keyword">return</span> randomInt;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Math</code> 클래스의 <code>random()</code> 사용법이다. 랜덤으로 수를 반환하는 메서드이다.</p><p><code>Math.random()</code>은 0부터 1까지의 <code>double</code>형 랜덤 상수를 추출한다. 여기에 다른 상수를 곱하면 (min) 0은 그대로지만 (max) 1이 상수와 연산되어 랜덤 값의 범위를 조정할 수 있다.</p><p><code>random()</code>가 실행될 때마다 서로 다른 값을 추출하게 되므로 변수를 선언하여 값을 여러개 생성할 수 있다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ran1 = randomInt;   <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">int</span> ran2 = randomInt;   <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h3 id="2-Math-max"><a href="#2-Math-max" class="headerlink" title="2) Math.max()"></a>2) Math.max()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example_02</span> <span class="keyword">extends</span> <span class="title">Example_01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// save random number to a</span></span><br><span class="line"><span class="keyword">int</span> a = rollDice();</span><br><span class="line">System.out.println(<span class="string">&quot;a is &quot;</span>+a);  <span class="comment">// shows what is number of a</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// save random number to b</span></span><br><span class="line"><span class="keyword">int</span> b = rollDice();</span><br><span class="line">System.out.println(<span class="string">&quot;b is &quot;</span>+b);   <span class="comment">// shows what is number of a</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare which is the larger between a and b</span></span><br><span class="line"><span class="keyword">int</span> largeNum = Math.max(a, b);</span><br><span class="line">System.out.println(<span class="string">&quot;Largest is &quot;</span>+largeNum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 출력 결과 </span></span><br><span class="line"><span class="comment">// a is 2(random)</span></span><br><span class="line"><span class="comment">// b is 4(random)</span></span><br><span class="line"><span class="comment">// Largest is 4</span></span><br></pre></td></tr></table></figure><p><code>Math</code> 클래스의 <code>max()</code> 사용법이다. argument로 받은 두 수중 어느 수가 더 큰지를 판별할 때 사용하는 메서드이다.</p><p>앞서 <a href="https://youngjinmo.github.io/2019/02/java-constructor/">상속</a>을 배워서 깨알처럼 이용해봤다 ㅋㅋ  <code>Example_01</code> 클래스를 상속받아서 <code>rollDice()</code> 를 사용했다. 변수를 선언하여 각각 <code>rollDice()</code> 가 반환하는 값을 저장하고, <code>max()</code>를 사용하여 두 수중 어느 수가 더 큰 수인지를 비교했다.</p><h2 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h2><p>공부하는데에 빠질 수 없는 부분이다.</p><p>위에서 소개한 <code>Math.random()</code> 은 Java의 내장 객체 <code>Math</code> 클래스의 <code>random()</code> 를 사용한 것이다. 개발자는 그저 호출하여 사용할 뿐이고, 내부에서 어떤 동작을 하는지 원리에 대해선 알 수 없다. 이를 알기 위해서는 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank">Java API Documentation</a>을 봐야 한다. </p><p><img src="https://media.giphy.com/media/ePeHKwWSed0Ag/giphy.gif"></p><p>그런데 <b>왜</b> <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank">Java API Documentation</a>을 봐야할까?<br>어떻게 작동되는지 여부를 꼭 알아야 하는 걸까?</p><br><p><img src="http://www.mediafire.com/convkey/e7f1/asnnl43h3tz2kovzg.jpg"></p><p>몰라도 상관없다면 좋겠지만, <strong>Example_01</strong>에서 사용한 <code>Math.random()</code>만 하더라도 이게 <code>int</code>형을 반환하는지, <code>double</code>형을 반환하는지 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank">Java API Documentation</a>을 보기 전까지는 알 수 없다. 그래도 이 정도는 친절하신 Eclipse께서 알려주실거다. 그러나 반환값의 범위가 0부터 1인것은 어덯게 알 수 있을까?</p><br><p><img src="http://www.mediafire.com/convkey/97cb/f3c7q2aa9dmp9fgzg.jpg"></p><p>마찬가지로 <strong>Exmapl_02</strong>에서 사용한 <code>Math.max()</code> 역시 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank">Java API Documentation</a>에서 상세하게 설명되어지고 있다. argument로 어떤 값이 들어와야 하고, 그럼 어떤 값이 return되는지.</p><hr><p>자바에 있는 모든 개념을 알 수 없기 때문에 필요할 때마다 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank">Java API Documentation</a>을 보는 훈련을 꾸준히 하는 것이 중요할 것 같다.  블로그를 운영하는 목적도 이와 비슷하다. 내 머리는 하드 드라이브처럼 비휘발성 메모리가 아닌 RAM과 같은 휘발성 메모리이기 때문에, 이 블로그를 하드 드라이브로 운영하고, 이 블로그를 다시 찾아봄으로써 필요한 지식을 RAM으로 끌어와서 코딩(CPU)을 할 생각이다.</p><p><img src="https://media.giphy.com/media/gJwndwkdZ2umk/giphy.gif"></p><h3 id="updated"><a href="#updated" class="headerlink" title="updated."></a>updated.</h3><p>트위터에서 좋은 글을 발견해서 남겨본다.<br>경험 사례를 통해 왜 공식문서를 봐야 하는지를 정리한 포스팅이다.<br><a href="https://github.com/SoYoung210">이소영 - 공식문서에서 시작하기</a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> api </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>별찍기(2).java</title>
      <link href="2019/03/startree-02/"/>
      <url>2019/03/startree-02/</url>
      
        <content type="html"><![CDATA[<p><a href="https://devyoungjin.github.io/2019/03/startree-01/" target="_blank">별찍기(1).java 보고오기</a></p><p><img src="https://images.unsplash.com/photo-1544202628-1798f05c9444?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=967&q=80"></p><h2 id="5-bottom-up-하프-별-트리"><a href="#5-bottom-up-하프-별-트리" class="headerlink" title="5) bottom-up 하프 별 트리"></a>5) bottom-up 하프 별 트리</h2><p><img src="https://lh3.googleusercontent.com/BrMzMvlTpuzKI_r-h4hESQNKp43InbR66nu9IEiNpLFXvGIY-rHNXW0n2uowh03XJ70q35kNVk6xut2pgMcK1_Y1g4cv5VbIXpyZyBnYeuvfXdOjYSk8zLpbNt5Uqws79Qdva1sns5_VVAKtLhkMCkmLgh2uLCDzX11HwIUs1c5M8TlJKrmnlii6SREH8tcqekKxXCoPW_lPnzhjp03SuCpbBsbd_YVPT_IiWKDjaLnE8gkj3W_N322UZpyqpRO8Fd6Uf4AeRjRLWxF0fBd5dhTjOcuy8vAicJ-EiBcLiCoTjWUPFvasfqwu0F03d3FJLPPreRPhTvysNeO2z3PICgbeftKiRByMyr99u6m_tlspa9tG-niMqWZRom_KGRHgoXQstHpikImEKXb5oM3ocrlywqVcVV71vp1MmHL2s2i3O6rIhpkrKftPz_g6kDpz6wkxYPfC02AoxniSz9vccskB75HreOl7DolOyjMsujXWuYqZ8ALt0XmDLqk1xvogbWvi8TR2dnhrztP5Gj4OKk5lCRwmn7Ax-fH06pOYawR8rF3ZQNrSkxyphqFYbIzuArYOzjeTqdSpG2oBSmFH1_pr-GPtkVul8Y_joAs50vhSpKgVIsX9JlnlgI3WVdRCaBRlIgSUrUBRzY-KDuRx2QYnjsJY-lzJ=w657-h258-no"></p><p>크리스마스 트리모양으로 별이 아래로 갈수록 2개씩 증가하는 형태이다. </p><p>반복문은 중첩반복문 2개가 필요해보인다. 왼쪽에서 부터 공백을 채우는 중첩반복문과 *을 찍는 중첩반복문. 먼저 별 트리의 왼쪽 공백을 채우는 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len-i; j++) &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>별을 찍는 조건은 조금 복잡하다(?) 별의 갯수가 하나씩 증가하는게 아니라 <code>(len*i)-1</code>만큼 증가하기 때문에 중첩반복문의 조건에도 이 조건을 포함해야 한다. 다만, <code>(len*i)-1</code>의 조건을 그대로 사용할 경우 len층 트리가 아니라 len-1층 트리가 출력된다. 첫번째 줄에서 별이 출력되지 않았기 때문이다. 따라서 i에 1을 추가하여 <code>(len*(i+1))-1</code>로 조건을 변경해야 한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; (<span class="number">2</span>*(i+<span class="number">1</span>))-<span class="number">1</span>; j++) &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이 공백이 끝나는 지점에서부터 (i<em>2)+1까지 증가하는 반복문으로 \</em>를 채워나간다. 마지막으로 줄을 띄우는 print문을 함으로써 반복문 작성을 마친다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">star_5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Input star length: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num-i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; (<span class="number">2</span>*(i+<span class="number">1</span>))-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input star length: 5</span></span><br><span class="line"><span class="comment">//      *</span></span><br><span class="line"><span class="comment">//     ***</span></span><br><span class="line"><span class="comment">//    *****</span></span><br><span class="line"><span class="comment">//   *******</span></span><br><span class="line"><span class="comment">//  *********</span></span><br></pre></td></tr></table></figure><br><h2 id="6-top-down-하프-별-트리"><a href="#6-top-down-하프-별-트리" class="headerlink" title="6) top-down 하프 별 트리"></a>6) top-down 하프 별 트리</h2><p><img src="https://lh3.googleusercontent.com/4IWKx92vaLEmDM7QOnZhswyoORXEedgZZyHqPhgwZM_kRBrl3JGnH_zatJnpj8OcJ9yaaoWgeFacxm4orysQeKy3wJdTPcPj5GZkZYBvdsB29Wt83RvNsGdYklJoyHEKxlKGuOQSuXCDi_9KIFByhG3yKkARW4isFZuzpoldVgo1G9tHqMeIixB3BcsS4MUwCkoCdoNiz3DGgssA2Ojdxptye4ewJUi7_rhznjCQHATqe9CLBUH4ZXZsdC1-u6jvl8eah5OiDwtXbndjfuP4WKMjVpH8zbkBgDztVVxg4VSIxvBjasbhqWe35qzXebXALzdA5spk734U0KHvYPitNLzE4yovQSK-H0XTcR6XiyuItNt6i5b4liNQjfrV528xXlMqxGuAN1WRdF_qssn1a8uuvYZWb1NABSVrRiIlXKsDwwO5lKsAs-Dp2wJUmiEDSQy-dnF6r2b93I33k4EUH8SO8cQTTYpawnaa0nZpJK4ra1WBICS8yT33kFG-__tOKH6FENemqoIhMX7wDHht5LKDKcX-FQrct3ZYaHzV1yI32B7_6glUyu3s40fYUc3nRFAa9brH4X-Deg2gnnxUMfxvng-sipHINDEgnbtl-Mdpi8ZIUWDPYqHHCKH5kRU3hYQJrlmWmvgmTdasLU1_AbQdesq0VDiE=w662-h259-no"></p><p>중첩반복문 2개가 사용된다.</p><p>먼저 왼쪽의 공백을 작성하는 중첩반복문을 보자. 0에서부터 시작해서 전체 반복문의 iterator만큼 증가시킨다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 이 지점에서부터 *을 찍어야 한다. *은 0부터 시작해서 <code>(2*len)-1</code>까지 증가시키며 row가 하나씩 늘어날수록 *이 <code>(i*2)</code>만큼 줄어들어야 하므로 조건식에 들어갈 식은 <code>(2*len)-1-(i*2)</code>가 되어야한다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">2</span>*len)-<span class="number">1</span>-(i*<span class="number">2</span>); j++) &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전체 작성은 아래와 같다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">star_6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Input star length: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">2</span>*len)-<span class="number">1</span>-(i*<span class="number">2</span>); j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input star length: 5</span></span><br><span class="line"><span class="comment">//  *********</span></span><br><span class="line"><span class="comment">//   *******</span></span><br><span class="line"><span class="comment">//    *****</span></span><br><span class="line"><span class="comment">//     ***</span></span><br><span class="line"><span class="comment">//      *</span></span><br></pre></td></tr></table></figure><br><h2 id="7-다이아몬드형-별"><a href="#7-다이아몬드형-별" class="headerlink" title="7) 다이아몬드형 별"></a>7) 다이아몬드형 별</h2><p><img src="https://lh3.googleusercontent.com/pgZ4HxAk7_uQst9l1ylSuTYYRzCHgfc_2mEHRj3MsHHfKlKZ7wl-N2iXmTpjSHqiy7lSE6dgvaJst-l92IS6k2WtCPdi12fKdlPE6k_GYd9HGgEep5GQXFiqMu82-25ojxXAU1tqavo8hddP8N7yYYaRqPdbjL9OTzOoGjqn2J86S8WUz2gp1gJgprWTzRcP74Eyyhg8idkwMtDMNXFwKR5wkXTftfSy1x5Ef2Zvb8BJstdgfdpY2e94m2aTcXBJxyN_lPeEnn8js0Ma0GMQVHzZLZQxYMLSq9O1pHshwHS2uVNMm56uDH4Hc-RVxgZpMWdR6qPjP3s3nM2sAOhLkTWYPUk5uZm7NYI32_XBzJZGWupbepwm17J4tQzDWhHqnlRU_1oyx4_yBw7o5EyI_VEgb__H6s9sk1bXFhqYU8ON74zVp4aDBhRLsZ0kSHCeLWNhJF7fnPe3w7fkkeb4Ka3zg-vb3aEPNDTfNUPpynhjDZj3vBryHwnr-n6QgLNKhl_oQHQf9HJJGFWoAO2yA-TzG3PeVeJZmAfAZNiJL9-gf8SzANeV3eM02k_oiePbhL6Q32JsMlMC5l9dATPrH_D8_qShZirqeU67BG16zrj7NJMwI4jLMnKf5SedambL1b4tmA7xvxaO_92d1g4uIXURx5Y_KpB7=w666-h450-no"></p><p>다이아몬드 형태의 별은 두개로 나뉘어서 보면 좋다. 별 트리의 허리에 해당하는 별의 길이가 이 트리의 전체 row에 해당하는데, 이 row를 기준으로 나누어서 보면 편하다. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">star_7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; num-i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (<span class="number">2</span>*(i+<span class="number">1</span>))-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">2</span>*num)-<span class="number">1</span>-(<span class="number">2</span>*i); j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input star length: 5</span></span><br><span class="line"><span class="comment">//     *</span></span><br><span class="line"><span class="comment">//    ***</span></span><br><span class="line"><span class="comment">//   *****</span></span><br><span class="line"><span class="comment">//  *******</span></span><br><span class="line"><span class="comment">// *********</span></span><br><span class="line"><span class="comment">//  *******</span></span><br><span class="line"><span class="comment">//   *****</span></span><br><span class="line"><span class="comment">//    ***</span></span><br><span class="line"><span class="comment">//     *</span></span><br></pre></td></tr></table></figure><br><h2 id="8-모래시계형-별"><a href="#8-모래시계형-별" class="headerlink" title="8. 모래시계형 별"></a>8. 모래시계형 별</h2><p><img src="https://lh3.googleusercontent.com/aSwCLZsf1hG2BylRHtEdDhdTWRF2bzKZ_GuvSeC9F89JmZaJHiVgXotkFjBUS47hsbqHoIXg8FPKVufri456owUTMathjCWowxphLyKPLJi6YnXgkQLL4OY8SXasgM0vsAIfsH74rCT3Am7reB-L4DnMzd3uO2Aj0CEK6JrVAWSf2Jfh57bie4G2hvhHvwm9y6SvTMqm3KoLn5ybPUV2TagGx870fQwIGNNMJJUNE39qPVlJSsAt5V449cLFo_15OEK8qZ8CWRs9KNAOQ1wgUX7Ual7ji2F6-qf8Olk6pWd-E3Ehdn1hwkS4bIHnLBZumGlEN8ia2R7hmpHb4tyb56ZPzWLbJuOlxqEOusOZmI6cwNFhSVqECIlHmWxabd9Um66OpZ97ROtXFFMgzjlABbZMca0gS9qvYxYSIEnEerQLKq-X95W5FrlQW0khHWW5pHfIcgB2Ei89JJgxh8xaFFVy9d5C6PuvuT5bRaEYDgVDBYEj8xl59XH2NJimZhHJKtWsA4lKvknh1fN8ibMhZFBGoyuWshCoIrhMD8ApInbsgGRZXimeO4wE-gHZQk6wlbE3Rnd2ewfkcC9SjEPBVIJCE_LUI_RgTVniSWRWOtnm7yPDRn0aWvC1_xGwksgWh0-5ST1aZ5UXqu9QHSRKHxfvoFvLe7K3=w819-h416-no"></p><p>이번에도 5)의 트리와 6)의 트리를 활용해서 만들 수 있다. 이번에도 입력값을 수정해서 출력해야 하는데, 7)과는 달리 입력값을 2로 나눈후 +1을 해야한다. 이렇게 해야 트리의 위/아래에 입력값으로 받은만큼의 별 문자열을 출력할 수 있다.</p><p>그리고 어떤 길이를 받던 결국 중간의 별 문자열은 별 하나만 와야 하는데, 이 때 5)와 6)의 코드를 그대로 가져다 사용하면 별 하나짜리 문자열이 2개가 중복될 수 있다. 따라서 5)또는 6)의 코드를 수정해야 한다. 아래 코드는 5)의 코드를 수정해서 작성해보았다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">star_8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Input star length: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> n = (len/<span class="number">2</span>)+<span class="number">1</span>; </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 6) top-down 별 트리</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n-i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n-i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5) bottom-up 별 트리</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123; </span><br><span class="line">            <span class="comment">// iterator의 시작을 1에서 시작함으로써 중간 중복을 제거</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n-i; j&gt;<span class="number">0</span>; j--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input star length: 5</span></span><br><span class="line"><span class="comment">//    *****</span></span><br><span class="line"><span class="comment">//     ***</span></span><br><span class="line"><span class="comment">//      *</span></span><br><span class="line"><span class="comment">//     ***</span></span><br><span class="line"><span class="comment">//    *****</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>별찍기(1).java</title>
      <link href="2019/03/startree-01/"/>
      <url>2019/03/startree-01/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1495465798138-718f86d1a4bc?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=2100&q=80"></p><p>중첩 for문에 익숙해지기위해 별찍기를 연습해봤다.</p><br><h2 id="1-왼쪽-상단에서-하단으로"><a href="#1-왼쪽-상단에서-하단으로" class="headerlink" title="1) 왼쪽, 상단에서 하단으로"></a>1) 왼쪽, 상단에서 하단으로</h2><p><img src="https://lh3.googleusercontent.com/xsW9EUlnDRS2uPf-36dysYa1PcdGbTfflskoAgmdbTvjii-8IWWA7wrkw3mkswRThgoYBzqdA5oqpjEh_KolsImUU5FizRNOH7vv8c3rBHxJlGfGPdDMqUsWeVV7rr_HwZtiL3nxw4aoVJlY9PDWAodyHPnSxZUwRDraU9T9LX2IYscsiJpYuqknlAVsK52TZ-qHjEpmT5rgOClD05gg-LQ4o5ous9qiqAF6qpzrbE-HvPsMPZ07H7SlOoyIiQ3ZVJMsKgLTtA6cxoBzuF0D1PsRG5dvof6MVY48l2kTl5XSUEKDpNquxn2J1ypA6Rhvl7fC3Z_IbuE_WjREK43Q70BGCroeK7W1AcO6fXJimdYZOK3tqxKzpRLxI3Xw_2WD3bjTP2eSvQzIdWLBHMGzaus-GbXDt2EW_gzAGD2mD1X8FKtmP4VaHoFCZwl8qcMqlLEBaEVQdXewW5e-EYw0osEUd8nWY2TzXS04HiM8sUwVp7SQiMIAcTOT1PqI-Bulj_D4vQKEgDhbGjqic9WA2kVggyJtFP69qfYBvy4F5TNYl1Cvj6mk91O-bQKGFNcuzcJo2zxDNKXUnEAOSE0UHwtEOdIF9JjsWCwTnDyNG7PZMUejIvbX8X52jMVxcipgPHkyO3Ad5y529Qc1sItB5TGpZf0Hjg-k=w663-h252-no"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">star_1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Input star length : &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 출력 결과 </span></span><br><span class="line"><span class="comment">// Input star length : 5</span></span><br><span class="line"><span class="comment">//  *</span></span><br><span class="line"><span class="comment">//  **</span></span><br><span class="line"><span class="comment">//  ***</span></span><br><span class="line"><span class="comment">//  ****</span></span><br><span class="line"><span class="comment">//  *****</span></span><br></pre></td></tr></table></figure><p>왼쪽에 붙어있으면서 상단에서 하단으로 내려갈수록 별이 많아지는 별 트리이다.</p><p>첫번째 for문, 즉 <strong>바깥쪽 for문은 Column</strong>에 해당한다. 입력받은 정수만큼의 별을 그대로 출력하면 되기 때문에 <code>for(int i=0; i&lt;len; i++) &#123;&#125;</code> 를 사용했다.</p><p><img src="https://proxy.duckduckgo.com/iu/?u=https://keydifferences.com/wp-content/uploads/2016/09/rows-vs-column.jpg&f=1"></p><p>두번째 for문이자 <strong>안쪽 for문은 Column을 작성하는 부분</strong>에 해당한다. 첫번째 줄(Row)부터 별이 하나씩 증가(row)하는 형태인데, <strong>증가하는 별은 Row 수에 비례해서 증가</strong>하고 있다. 따라서 두번째 for문의 반복조건은 첫번째 for문에서 사용한 iterator <code>i</code>만큼 반복되어야 한다. for문 조건식에서 <code>&lt;=</code> 을 사용하지 않고, <code>&lt;</code> 를 사용했기 때문에 반복조건에 +1을 해서  <code>for(int j=0; j&lt;i+1; j++) &#123;&#125;</code> 로 작성했다.</p><p>별을 찍었으면, iterator <code>i</code>가 증가할 때마다 줄을 바꿔야 하기 때문에 <code>System.out.println(&quot;&quot;);</code> 을 바깥쪽 for문과 안쪽 for문 사이에 작성해준다.</p><br><h2 id="2-오른쪽-상단에서-하단으로"><a href="#2-오른쪽-상단에서-하단으로" class="headerlink" title="2) 오른쪽, 상단에서 하단으로"></a>2) 오른쪽, 상단에서 하단으로</h2><p><img src="https://lh3.googleusercontent.com/lw6Tvbgb0H5uCYM1HUx42g8Nm95t1WkqCHQPgT1U4tLPOpU0zTb5xywfx7Yw5xVi0O2R3yAgzAFmu3bPqwfzPaPM5_khmDGoPj4MG_5Tr_iXRhRBXv82R25V7fogzY7h-rVK8eEmy8wRhwOiKJU8Sqloe0_HfnjnClA8xGA7_sJK5hhJpCi_M6F1-vmlTT5i5I5lca1v72DJRYzfhCceQZL9lnEY_diKZcSeFmD7-haNvdmzRUNNO9JFLkSjP3qbwSSOogmuqm3ZHh6qvbpKb2TGF8dRfNCZhcmzP7GzqeU5_SNFG679X8LEEhMQk9FQMiCrvQbpVSgPTVryBErAf_ria6UQAuvZMCFLOXgddvFtiIL52jEcqZL4dM8ZLNEeykDq3ATsuRV4QjK3E9K_IShPaWCrPxuhJ0WD67jYxQ02pZ4y-x2676pSnwrNM5Am4WufuayLHVexi4nC9PZg3rGLhv4C3VJodROw0qxHn75of3uYdWHILVrgy3TTvuXQXAl0VbNM_sx2VwqbtX4gUxmKdlNqNvDE_UYLy_oIkcJTVd7NPQgnh20GCFCct88DEoXM74Fc2EP2m30xoP-QiZaAaICLT8O5i5gje4nNJb42wVqg1q6IhnWYUpYZCvmMugcCDuwZWSpwxZvlbIHgpQx8Ma3lzwNQ=w657-h259-no"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">star_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">      </span><br><span class="line">        System.out.print(<span class="string">&quot;Input star length: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;len-i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 출력 결과</span></span><br><span class="line"><span class="comment">// Input star length: 5</span></span><br><span class="line"><span class="comment">// (1)     *</span></span><br><span class="line"><span class="comment">// (2)    **</span></span><br><span class="line"><span class="comment">// (3)   ***</span></span><br><span class="line"><span class="comment">// (4)  ****</span></span><br><span class="line"><span class="comment">// (5) *****</span></span><br></pre></td></tr></table></figure><p>이번엔 1) 에서 했던 별을 오른쪽으로 밀어넣은 형태의 별 트리이다.</p><p>1)의 반복문이 2개를 중첩함으로써 구현했다면, 2) 부터는 반복문 1 개에 2 개의 반복문을 중첩시킴으로써 구현해야 한다. <strong>1)에서는 신경쓰지 않아도 되었던 빈 칸을 임의로 만들어서 별의 위치를 오른쪽으로 고정시켜야 하기 때문이다.</strong> 빈 칸을 만들어내는 코드이다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;len-i; j++) &#123;</span><br><span class="line">      System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://lh3.googleusercontent.com/T1w4XebGkRqsIHQPUHGKc2uVVcmPRZhx4EGTwKQYrShvqafeeSJ0wdUNH9X43T3Q17N7Sbme1LRTqcV44u-oSeBjUTfID26xpF0NOU7DGbU1L7UCEi0PUWYvySz8jD1Wag2-fUvV0gzIBob1nZbG-s7a8lM0GF88DNbtbf2rFRAIG7oOgaVz5E3RI6LQcA3DZt4T8wHS4E-i51c72hKsNjcIo1VBqKDm0ChFVg40FdJ2tp2AplHvKGbLh_kYHwVsmprGwbpe1eNbK3VD9HyENAEXuj-8PgFRw-32CgqwA4m3plW0Sn6KFAbR3zaAzEFPRSCdvZ9X7xpSDoZF5B97I07XtBWPiQZigQ20hZjMT6uC1hA-5v_E9T4RHl8rjelnE7Q-S9sOWIMnKtKV-VEg2hINMM2wt4eBK-vAEIQ41XPTeoShVGlrdcq-NemYlSDilT9rdQuQTOtvzchKi62AjCYQLQqMnIk8aKIUX5hrzAu1p88T6fi1cjeXAUOx20EACHhuapuF95Dv2LwglHEeG-MRhz-lhaoVm6aNhlRJ8cBQg53fVOAnZECz2xtbeQSXXSNC_Fwv6e_dttL96FE_1WXiV_hvEHVFSlrLQyrMjgq-ONSPJwaTbEAps_NINvkPqbzfXAZrEvkPxfnh2KTKPi1LR0FoBI9s=w237-h168-no"></p><p>여기서 반복문의 조건식이 중요하다. 빈 칸은 시작점은 0에서 똑같이 시작하나, 갯수가 점차 적어지는 형조건이어야한다. 따라서 iterator <code>j</code> 에 사용자로부터 입력받은 최댓값(<code>len</code>)을 선언해주어야 한다.</p><p>그리고 한 줄씩 내려갈수록 빈칸의 갯수는 하나씩 줄어야 하므로 빈칸을 생성하는 안쪽 for문의 iterator <code>j</code> 의 시작 값을 <code>j=len-i</code> 로 만들어준다. 그러면 한 줄이 바뀔때마다 <code>i</code>의 값이 1씩 커지므로 이와반대로 <code>j</code>의 값은 1씩 줄어들면서 그 다음 for문으로 생성되는 별을 하나씩 앞당겨준다.</p><br><h2 id="3-왼쪽-하단에서-상단으로"><a href="#3-왼쪽-하단에서-상단으로" class="headerlink" title="3) 왼쪽, 하단에서 상단으로"></a>3) 왼쪽, 하단에서 상단으로</h2><p><img src="https://lh3.googleusercontent.com/q6JbPdl2kRTptr6zgVw_qf7m8GeasvIDqWw3SGOyvisZ_vimWy7Uou8a9R8qjksKhlwAuh7JzE2fICRTpyeywK23CmgSaH20NzTnEJ8QBCqDxu4yXEp3vNoZ9W4Xla3abWUeYdnaLdEKk3BUD5PRvudzIyclIHYbtLalu6CNvv2asYwO1_OKROP4z9poulacghLADRccyhF5-6pbriXDp0dpq3yQjatwmbNK6Fqrkjyu3Uh19kN1wHrSN4yxDI13IKoWC1Q3qF79nhOHe_n5tXfAT8LQmbCZCaiIVyzCCxyTXXNtap9cyPLJUA8Trc6o0Zyhh6b6KeEuV6GuOKjDit_Sihx_gNu041eKvn201vX-tjj926GyV-gPdvNGKojygP9n3agapFeKcQN6VU_MPZzfoNVQtKZYJ9-ndbJIYxpwhN4pK-g-zSMBLgaL5A7YXiBar-j4WSXRBZAHvDBbQl7qNqxkIMz_f0C8WhNNw6RfgYeBBLwVbA4eqGGUNsZItbvvZugR4cJwHbmL1NLQiZEWZSLpaDubPcnLSFmtshs4ZkUd2VGejfg3Egf2SovSpR_iCArUMGB12wu_GhLgsGgtAQ9iZzHYjjaAFig32FjlwhbIyxQIS0caZcj_IfoU7CkAJ_L9O5aB6Uvm7YXnTtVTW7FdeoQ0=w662-h258-no"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">star_3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Input star length: &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n; j&gt;i; j--) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input star length: 5</span></span><br><span class="line"><span class="comment">// (1) *****</span></span><br><span class="line"><span class="comment">// (2) **** </span></span><br><span class="line"><span class="comment">// (3) ***  </span></span><br><span class="line"><span class="comment">// (4) **   </span></span><br><span class="line"><span class="comment">// (5) *    </span></span><br></pre></td></tr></table></figure><p>별을 사용자로부터 입력된 값만큼 출력하고 빈칸을 출력하는 프로그램이다.</p><p>따라서 별을 출력하는 안쪽 첫번째 반복문은 0에서 시작해서 <code>len-i</code>가 될 때까지 별 출력을 반복한다. <strong>반복조건을 <code>len-i</code>로 작성한 이유는 바깥쪽 반복문의 iterator <code>i</code>가 하나씩 증가할 때마다 별이 하나씩 줄어야 하기 때문이다.</strong> </p><br><h2 id="4-오른쪽-하단에서-상단으로"><a href="#4-오른쪽-하단에서-상단으로" class="headerlink" title="4) 오른쪽, 하단에서 상단으로"></a>4) 오른쪽, 하단에서 상단으로</h2><p><img src="https://lh3.googleusercontent.com/rTYpXueYtpJ95b-CCKdcDPhNZjEJI7eeXiQgLbN2xTSmI-9bPZYTQqBAtLK7Tr9Osn4knavmINQt0hbNs2nSRfLu7aZ-W68o42RIYzqr8rZQZzXUz3_0MOXH4wI78NFOXHsePqVJvq4Da6IWaHJ_oxJfpeQ9ihnjDiR1ahx4N2ADEFygOpy9OWcJB69OIYos3gdXsFp-i8Jd1JNmqzE_xwXHS-fG4AFaKMK3kfEpIsqJuChnsl2MMpNEIDhTL9yT6jGrdiJ6eLLfe0rGaRbDr6Tmrx8Bi44Th0VCb5RLcZi8yxbSdik7T1wZP3jxakJPtlob4WGrpd4FRTSdrCoWBVFTG6JMvwrTLRZouKy4VYeAS3isQ2fGQYRDLM4kcBTOAWN-7cQV1PPvJ3-uVRug804hhzADWnQ6wZs6YasSQ_XEhW5kBsb7Kt9CWQVWmMbdAmtifDrigKJdVxa6gTYgnAOLDs46aOkzRAlQYG8FJEOUEOK9R_n41lIGcBL42DEio7HOrvx-MPOOVNO3ekFlk4G9h--cpeqGSinckIbI-tvr0TXQKX1Ea7G2dJ0vzSIa1ZdhQLyXtwXF0uRNtnmP7Dulgddhu7GVlu8OCNYb3P5GRqpCNFBve9b3d-BybshgERB2v5vh9oec2az1HmsSj9MiTCmI6oZh=w659-h257-no"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">star_2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">&quot;Input star length : &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;(&quot;</span>+(i+<span class="number">1</span>)+<span class="string">&quot;) &quot;</span>);  <span class="comment">// printout line number</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len-i; j++) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 출력 결과 </span></span><br><span class="line"><span class="comment">// Input star length : 5</span></span><br><span class="line"><span class="comment">// (1) *****</span></span><br><span class="line"><span class="comment">// (2)  ****</span></span><br><span class="line"><span class="comment">// (3)   ***</span></span><br><span class="line"><span class="comment">// (4)    **</span></span><br><span class="line"><span class="comment">// (5)     *</span></span><br></pre></td></tr></table></figure><p>이번엔 반대로 3)의 별 트리를 오른쪽으로 밀어붙인 형태이다. 왼쪽이 빈 칸, 오른쪽이 별인 형태이다. </p><p>안쪽 첫번째 반복문은 빈 칸을 작성하는 반복문이고, 안쪽 두번째 반복문은 별을 작성하는 반복문이다. </p><p>안쪽 첫 번째 반복문부터 보면, 왼쪽이 빈 칸이므로 빈 칸을 작성하는 반복문을 작성하였다. 0에서 시작해서 바깥쪽 iterator <code>i</code>가 될 때까지 1씩 증가하는 조건으로 작성하였다.</p><p>안쪽 두 번째 반복문은 빈 칸에 이어 별이 입력되는 반복문인데, 0에서 반복조건을 <code>k&lt;len-i</code> 로 작성하였다. <strong>별 트리의 넓이를 사용자로부터 입력받은 len 에 맞추고, 줄이 바뀔 때마다 별의 갯수가 하나씩 줄어들기 때문이다.</strong></p><p><a href="https://devyoungjin.github.io/2019/03/startree-02/">진짜 별사진으로 눈정화하고 별찍기(2) 보러가기 </a></p><p><a href="https://devyoungjin.github.io/2019/03/startree-02/"><img src="https://images.unsplash.com/photo-1487715224545-78f0cedc19bd?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=634&q=80"></a></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>개발자에게 공부란.</title>
      <link href="2019/03/how-to-learn-programming/"/>
      <url>2019/03/how-to-learn-programming/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1538029192284-570deb5a788f?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=750&q=80"></p><p>개발자 단톡방에서 공유받은 개발자들의 공부방법에 대한 글을 아카이브 목적으로 남겨둔다.</p><hr><ol><li><p>지금 다니고 있는 회사에서 하는 일을 잘하기 위해서 노력하는 것이 가장 좋은 공부다.<br><br></p></li><li><p>회사에서 하는 일과 개인적으로 공부하는 내용을 최대한 근접시키기 위해서 노력하라.<br><br></p></li><li><p>새로운 기술을 익히는 최선의 방법은 스스로 문제를 정의한 다음, 새로운 기술을 이용해서 그 문제를 풀어보는 것이다. 책을 읽거나 동영상을 보는 것은 그보다 하위수준의 방법이다.<br><br></p></li><li><p>신기술을 좇는 메뚜기가 되지 말라.<br><br></p></li><li><p>모든 것을 알아야 한다는 강박을 버려라. 미리 획득하는 지식의 99%는 무용지물이다. 필요할 때 필요한 기술을 익힐 수 있는 것이 능력이다. 그 능력을 키워라.<br><br></p></li><li><p>이상한 나라의 앨리스에 나오는 토끼굴(rabbit hole)을 피하라. 카테고리이론을 알아야 함수형 언어를 쓸 수 있는게 아니고, 선형대수학을 공부해야 머신러닝을 할 수 있는게 아니다. 토끼굴에 빠져서 한없이 들어가다보면 비본질적인 공부에 시간을 허비하게 된다.<br><br></p></li><li><p>겉만 핥는 것은 경박하지만 토끼굴에 빠지는 것은 우매하다. 둘 사이의 적당한 지점에서 균형을 잡는 것이 개발자의 능력이다.<br><br></p></li><li><p>머리에 들어오지 않는 어려운 개념이나 용어는 자투리 시간을 이용해서 반복적으로 읽고 암기하라. 나중에 큰 그림을 공부할 때 도움이 된다.<br><br></p></li><li><p>항상 겸손해야 하지만 동시에 자긍심을 가져라. 그대가 지금 작성한 코드, 지금 읽은 책, 지금 공부한 내용을 그대보다 잘 아는 사람은 지구상에 없다. 모든걸 알고 있는 것처럼 보이는 다른 사람들도 그대와 마찬가지로 불안해하고, 위축되고, 두려워하면서 살아가고 있다. 자긍심이란 그런 타인을 돕고자 하는 마음가짐의 다른 이름이다.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Articles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tip </tag>
            
            <tag> career </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>내가 받아보는 뉴스레터</title>
      <link href="2019/02/newsletters-in-my-inbox/"/>
      <url>2019/02/newsletters-in-my-inbox/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1466096115517-bceecbfb6fde?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80" alt="unsplash"></p><p>블로그에 처음으로 프로그래밍 관련하지 않은 포스팅을 남겨본다.</p><p>가끔 만나는 사람들을 통해 “그런 정보는 어디서 들으시나요?” 라는 질문을 종종 받는다. 불과 지난달까지 학생이었고, 이제 공식적인 백수가 된 내가 아는 정보가 고급정보일리 만무하다. 그저 어딘가에 공개되어 있는 정보를 내 메일박스로 받아볼 뿐인데, 오늘 그 정보처(?)를 공개한다 ㅋㅋ</p><br><h2 id="1-스타트업-위클리-Startup-Weekly"><a href="#1-스타트업-위클리-Startup-Weekly" class="headerlink" title="1. 스타트업 위클리, Startup Weekly"></a>1. 스타트업 위클리, Startup Weekly</h2><p><img src="http://www.mediafire.com/convkey/e807/66cqhvxxx2b6pvkzg.jpg"></p><p>몇 년전만 하더라도 나도 힙하고 잘나가는 스타트업을 꿈꾸던 스타텁 피플 중 하나였다.  <em>물론 지금도 그런 스타트업을 꿈꾸고 있긴 하지만..</em></p><p><strong>스타트업 관련한 소식</strong>을 전달받는 뉴스레터이다. 국내 스타트업들의 서비스 소식과 투자 유치 소식, 정책지원 관련 소식, 업계 인플루언서의 새로운 블로그 포스트, 해외 뉴스까지. <strong>국내에서 스타트업을 준비중이거나 재직 또는 취업을 준비중인 사람들에게 더 없이 좋은 뉴스레터</strong>라고 생각한다. </p><p><strong>일주일에 한 번 월요일에 발송</strong>되기 때문에 지난 한 주간 있었던 국내외 소식을 한 번에 정리하기 좋다. 또한 돌아오는 한 주의 이벤트를 정리해두었기 때문에 참석할만한 이벤트를 알아보기에도 좋다.</p><p>우리나라에 어떤 스타트업들이 존재하는지, 또 그들이 어떤 서비스를 운영중이고 그래서 성과가 어떤지 알아보기에 좋다. <strong>특히 Startup Weekly에 다뤄지는 회사들의 경우, 상장사에 비하면 규모가 작을 지언정 성과를 내는, 소위 이 바닥에서 엘리트로 취급되는 회사들이 많기 때문에 스타트업 취업을 준비중인 구직자들에게 특히 추천</strong>하고 싶다. 스타트업 취업과 관련해서는 다음에 간략하게 정리해서 다시 한 번 남길 생각.</p><p>구독은 <a href="http://glance.media/subscription/subscribe" target="_blank">여기</a>서 할 수 있다.</p><br><h2 id="2-스넥-SNEK"><a href="#2-스넥-SNEK" class="headerlink" title="2. 스넥, SNEK"></a>2. 스넥, SNEK</h2><p><img src="http://www.mediafire.com/convkey/61ee/6u0tz9a10e4he6rzg.jpg"></p><p>SNEK은 금융/증권 관련 정보 소식지이다. </p><p>산업과 회사에 대해 인사이트있는 리포트를 발행한다. 투자한 회사 또는 잠재적 투자 대상 기업을 구독하면, 해당 회사에 대한 최신 소식이나 리포트를 놓치지않고 구독할 수 있다.</p><p>평소 투자에도 관심이 있어서 재미삼아 소액으로 국내외 주식투자를 하곤하는데, SNEK에서 제공되는 리포트를 읽으면서 아이디어를 얻곤 한다.</p><p>SNEK은 프리미엄(Freemium)서비스이다. 유료로 구독하면 더 많은 글들을 읽을 수 있다. 그러나 무료 컨텐츠도 다 읽지못할만큼 많으며, 일부 컨텐츠는 기다리면 무료로 읽을 수 있기 때문에 무료만으로 충분하다. 단 가입을 해야 무료로 이용이 가능하다.</p><p>회원가입은 <a href="https://www.snek.ai/account/signup" target="_blank">여기</a>서 할 수 있다.</p><br><h2 id="3-뉴닉-Newneek"><a href="#3-뉴닉-Newneek" class="headerlink" title="3. 뉴닉, Newneek"></a>3. 뉴닉, Newneek</h2><p><img src="http://www.mediafire.com/convkey/8300/lbo9arma5ifkwt4zg.jpg"></p><p>스타트업 위클리(<strong>Startup Weekly</strong>)가 스타트업 위주의 뉴스 레터였고, 스넥(<strong>Snek</strong>)이 금융관련 뉴스 레터였다면, 뉴닉(<strong>Newneek</strong>)은 <u>종합 선물 세트</u>다.</p><p>정치/사회를 망라하는 국내에서 발생하는 다양한 이슈들을 정리해서 발송하는 뉴스 레터인데, <strong>한 번에 Follow하기 어려운 이슈들을 읽기 쉽게 정리</strong>해놓은게 특징이다. 포털에서 검색해서 여러 매체의 기사를 볼 것 없이 기다렸다가 뉴닉이 정리해준 걸로 이해하곤 한다. 아침에 지하철에서 스마트폰으로 구독하기 딱 좋은 컨텐츠이다.</p><p>뉴닉 <a href="https://newneek.co/?utm_medium=email&utm_source=newneek&utm_campaign=dailynewsletter" target="_blank">구독</a>은 여기서 할 수 있다. 다른 서비스들과 달리 구독 페이지마저 뉴닉의 컬러가 입혀져있다. 일단 구독 페이지에 들어오면 구독안하고 갈 수가 없을 것 같다 :)</p><br><h2 id="4-모닝-브루-Morning-Brew"><a href="#4-모닝-브루-Morning-Brew" class="headerlink" title="4. 모닝 브루, Morning Brew"></a>4. 모닝 브루, Morning Brew</h2><p><img src="https://www.campaignmonitor.com/assets/uploads/2018/04/morning-brew-email-marketing-newsletter.png"></p><p>친구로부터 추천받아서 <strong>Morning Brew</strong>를 알게 되었는데, 사실상 정보구독을 목적으로 구독한 첫 뉴스레터 서비스였다. 너무 깔끔하게 정리를 해주었고, 다양한 분야의 소식을 발행해서 애정하는 서비스이다.</p><p><strong>Morning Brew는 실리콘 밸리부터 월 스트리트까지 미국의 다양한 소식을 전달</strong>해주는 뉴스레터이다. 나처럼 미국을 한 번도 방문한 적없는 사람들에게 꽤나 유익한 뉴스 레터라고 할 수 있다. </p><p>이렇게만 쓰면.. 아마 나를 모르는 분들은 내가 영어에 굉장히 능통한줄 알거다. 하지만 난 영어가 정말 꽝이다.. 지난해에 처음으로 토익시험에 응시하고 받아본 점수에 크게 충격을 받은 바 있다.. 난 영어를 못함에도 불구하고 영어 울렁증이 없는 이상한 놈(?)이다. 덕분에 영어로 된 컨텐츠도 크게 부담을 갖지는 않는 편이다. 다만 이해력이 필요한 난해한 이슈를 다룬 컨텐츠는 스킵을 하는 편이다..</p><p><strong>Morning Brew는 매일 발행되는 뉴스 레터</strong>이다. 바쁘게 지내다보면 못 읽고 메일 박스에 몇 개씩 쌓이곤 하는데, 그럴 때엔 그냥 타이틀만 보고 읽고 싶은 컨텐츠만 골라 읽고 있다.</p><p>Referral 이벤트를 하고 있는데, 내 계정으로 발행된 <a href="https://www.morningbrew.com/?kid=6fc9b6" target="_blank">링크</a>로 Morning Brew를 구독하는 사람 수에 따라 Morning Brew만의 굿즈를 받을 수 있다. 지금까지 5명의 구독자를 만들어서 랩탑 스티커를 받아서 지금까지 잘 붙이고 다니고 있다^^</p><p><img src="http://www.mediafire.com/convkey/5c35/b25z1h59ez0rbknzg.jpg"></p><p><strong>Morning Brew</strong> 구독은 <a href="https://www.morningbrew.com/?kid=6fc9b6" target="_blank">여기</a>서 할 수 있다.</p><br><h2 id="5-생각노트"><a href="#5-생각노트" class="headerlink" title="5. 생각노트"></a>5. 생각노트</h2><p><img src="http://www.mediafire.com/convkey/252e/nqwrz37s4jaxxm4zg.jpg"></p><p>지금까지 소개한 뉴스레터 중 가장 감각적인 뉴스레터이다. 뭐랄까, 지메일보다는 인스타그램이 더 잘어울릴것 같은.. 그런 느낌적인 느낌이랄까..? </p><p>생각노트님의 블로그는 인사이트를 전달하는 블로그이다. 뉴스레터는 생각노트님의 신규 컨텐츠와 생각노트님께서 흥미롭게 읽은 컨텐츠에 대한 인사이트 및 소셜 미디어에서 본 흥미로운 컨텐츠들을 배달한다.</p><p>아는 사람은 알겠지만, 전체적인 분위기가 <a href="https://publy.co/" target="_blank">퍼블리</a>와 굉장히 잘 어울린다. 잘어울리는 이 조합은 이미 협업을 한 바 있다 ㅎㅎ</p><p><img src="http://www.mediafire.com/convkey/97b8/ohqrl6vf2b4do33zg.jpg"></p><p><strong>퍼블리는 인사이트 있는 다양한 리포트를 시리즈물로 발행하는 플랫폼</strong>이다. 넷플릭스처럼 월 정액 구독을 하면, 퍼블리 내 컨텐츠를 무제한으로 읽을 수 있다. 퍼블리가 아니면 접할 수 없는 고퀄리티 컨텐츠들이 많아서 애정하는 서비스 중 하나다.</p><p>생각노트님은 퍼블리를 통해 컨텐츠를 성공적으로 판매하시고 <a href="https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=175548542" target="_blank">종이책 출판</a>까지 이어졌는데 퍼블리에서도 손꼽히는 성공적인 프로젝트 중 하나가 아닐까 싶다. 책도 다른 책들과 달리 디자인이 이뻐서 소장용으로 최근 구입해두었다 ^^</p><p>마케팅을 하거나 또는 인사이트를 얻고자 하는 분들께 추천하는 뉴스레터이다.</p><p>여기서 <a href="https://insidestory.kr/subscription" target="_blank">구독</a>할 수 있다.</p><br><hr><p>이 외에도 다양한 뉴스레터를 구독하지만, 특히 추천할만한 다섯가지의 뉴스레터를 정리해봤다. </p><p>취준생 중에 이메일을 이용하지 않는 사람들이 꽤나 볼 수 있는데, 위 서비스들을 구독하기 위해서라도 꼭 이용하길 바란다. <strong>전화번호와 이메일은 사용목적이 다르다.</strong> 구직을 준비중인 산업에 따라 다르겠지만,  블로그에 방문한 분들이라면 아마도 이메일 주소가 필요한 산업에 종사하고 계시거나 앞으로 필요할 분들로 생각된다. 꼭 이용하시길! </p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Review </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Repository 생성.Git</title>
      <link href="2019/02/git-create-repo/"/>
      <url>2019/02/git-create-repo/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1521898284481-a5ec348cb555?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=934&q=80" width="650px" /><p><i>git의 원격 저장소를 github으로 사용하였으며, MacOS에서 실행하였습니다.</i></p><p>Github에 가입했다면, 프로필 사진 옆의 + 버튼을 클릭해서 저장소(Repository)를 생성하자.</p><p><img src="http://www.mediafire.com/convkey/e730/vabzayvttabj0g4zg.jpg" alt="create repo"></p><p><br>버튼을 누르면 아래와 같은 화면을 만날 수 있다.</p><p><img src="http://www.mediafire.com/convkey/8e62/ozxrfd5xhswe5xpzg.jpg" alt="create repository2"></p><p>저장소 이름을 입력하고, 저장소를 설명하는 글도 간단하게 작성할 수 있다.<br>이전 포스트에서도 이야기했지만, public / private은 저장소의 접근 권한을 이야기한다. <strong>상업적인 목적의 프로젝트라면 private, 오픈소스 프로젝트나 개인 포트폴리오라면 public</strong>으로 권한 설정을 하면 된다.  접근 권한 설정은 저장소 생성 이후에 변경 할 수 있다.</p><p><img src="http://www.mediafire.com/convkey/eec1/4a8mqa8kqlaz9ujzg.jpg" alt="repository on the commandline"> </p><p>이 화면까지 나왔다면 이제 브라우저에서 할 작업은 끝난걸 의미한다. 이제 터미널로 이동한다.</p><p>버전 관리를 할 디렉토리로 이동하고 git을 초기화한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>위와 같은 명령어를 입력하고 파일 내 목록을 확인하는 명령어를 입력한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><p>해당 디렉토리에 .git 이라는 폴더가 생성되었음을 확인할 수 있다. 이 폴더가 git이 저장되는 로컬 저장소이다. 여기까지만 해도 로컬 저장소를 바탕으로 버전 관리가 가능하다. 그러나 협업을 하기 위해서는 서버가 필요하다. 이 서버를 제공하는게 우리가 아까 가입하고 저장소를 생성했던 Github과 같은 git 호스팅 서비스이다. **Github에 만들어둔 저장소는 원격 저장소 (Remote Repository), 로컬에 있는 저장소는 로컬 저장소 (Local Repository)**이다. </p><p>이제부터는 원격 저장소와 로컬 저장소를 동기화하는 작업을 할 것이다. 다시 터미널로 돌아가자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Username&quot;</span><br><span class="line">git config --global user.email &quot;Your Github Email&quot;</span><br></pre></td></tr></table></figure><p>이름과 이메일을 입력하는건데, <strong>이메일은 Github에 가입된 이메일</strong>이어야 한다.<br></p><p>그리고 버전관리 할 이 프로젝트를 설명하는 설명서를 간단히 만들어보자.  <br></p><p><img src="http://www.mediafire.com/convkey/6f22/6rnt0dhpbynqguwzg.jpg" alt="hexo-autolinker"></p><p>마크다운(Markdown) 포맷의 README라는 이름의 파일을 생성해보자. 이 파일은 위의 이미지와 같은 역할을 하게 된다. 마크다운에 대해선 다음에 다뤄보도록 하겠다. 일단 형식만 갖추기 위해 vi 명령어로 파일만 만들어보겠다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim README.md</span><br></pre></td></tr></table></figure><p><img src="http://www.mediafire.com/convkey/cf51/qxlhmmtmzn14dihzg.jpg" alt="vi editor"></p><p>검은 화면이 열리면 아무 <code>i</code> 를 입력한다. <code>i</code> 는 insert를 의미한다. 이 화면에서 해당 프로젝트가 어떤 프로젝트를 의미하는지 간단히 한 줄로 작성한다. 이후 <code>esc</code>를 누르고, <code>:wq</code>  를 입력하고 빠져나오자. <code>w</code>는 저장, <code>q</code>는 <a href="https://wiki.kldp.org/KoreanDoc/html/Vim_Guide-KLDP/Vim_Guide-KLDP.html" target="_blank">vi 에디터</a> 종료를 의미한다.<br></p><p>이제 다시 Github 원격 저장소와 연동을 마무리하자. 터미널로 돌아가서 다음과 같은 명령어를 입력하자.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;repository.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>여기서 입력하는 저장소 주소는 아까 Github에서 본 주소를 입력하면 된다.</p><p><img src="http://www.mediafire.com/convkey/7986/csc6suj96cdk9s0zg.jpg" alt="github"> </p><p>다시 Github으로 돌아가서 refresh하면 이제 페이지에 README 파일이 생성된걸 확인할 수 있을 것이다.</p><p><img src="https://media.giphy.com/media/4xpB3eE00FfBm/giphy.gif"></p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>버전 관리의 시작.Git</title>
      <link href="2019/02/git-started/"/>
      <url>2019/02/git-started/</url>
      
        <content type="html"><![CDATA[<img src="https://images.unsplash.com/photo-1516321497487-e288fb19713f?ixlib=rb-1.2.1&auto=format&fit=crop&w=2100&q=80" width="650px" /><p>스마트폰을 이용하다 보면, 모바일 앱 업데이트를 경험하게 된다.<br>아래 이미지는 명함관리 앱, <a href="https://itunes.apple.com/kr/app/리멤버-국민-명함앱/id840553277" target="_blank">리멤버 앱</a>의 앱스토어 버전 기록이다.</p><img src="https://lh3.googleusercontent.com/mLVn01jtUIsf5OTCsvitMAZns6MYB_iF9CNb_f-iOS2XlklbR7t-utzG_3XwqJQuSEZVZm3DDJspiBFVE4-2S1xHLM-DUQRBSyFVJXjSQKWt10g5phDnLwc7hkOWxtraynhxS-MRZQvBY40HvpgRmW29Tu6fk0aRoSOLpYyMyvD0JPnNRCptVa9hEsDy6YlOKgYQBXwKEDDJbrSNxGa4Dse27Mh1AObYu2LRTIKKuPTZVaN3IMujuJ-tsVBtbrgkjj8xoKZKVmrGIBDioszjcsawnr0DG5zV3QPHSk6IQyFVPbmiaSMN9aYrROrV6_ZeSMwXwXeyE8Mss8C2QQeUKEg38NtEhMNd9seuh3tIekCD5OEoc0B-YS85lW8nqHqF-YtIQ3AZBTSI2L9-UOOy9u426qe4GVf5tmR0bCRn7RX1hBlv7D6HrUieVj_RVR4o7b0DXGZtecOkGX4tmRqFUiL-yGiA2rK7c-yhCsVGqmItAd1QzEBwcZMaSvgcVhcPGdNlZIdjlR19kiLfOqDd0JyYht2wKSbkz9TP88sUvCcUDgdpLOTFtW05BtOpPlzhO1RQIbAvJ59QAEwYxHMVS0ZsQC4MNVSIsGjVN1f4368247N79GywrdauU8LmdUZGS-Pn5C77ObYDEOFO5pRGEodoKROOGqnC=w750-h680-no" alt="remember app" style="zoom:50%;" /><p>리멤버는 2.8.2 버전에서는 마이너 버그를 수정했고, 2.8.3에서는 ‘명함 지도’ 라는 기능을 추가했다. 이렇게 파일이나 프로그램을 수정하고, 각 수정 파일을 버전에 맞게 저장하고 관리하는 일을 **버전 관리(Version Control)**이라 한다. 이렇게 파일을 관리하면 돌아가고 싶은 버전으로 언제든지 돌아갈 수도 있다. 멋지지 않은가!</p><p>그럼 버전 관리를 하면, 타임 머신같은 기능만 사용할 수 있는걸까? 당연히 아니다.</p><p>버전 관리를 하게 되면, 효율적인 **협업 (Collaboration)**이 가능하다. 먼저 아래의 이미지부터 보자.</p><p><img src="https://lh3.googleusercontent.com/7wd1fxMKZ15W0JwtEpdakoeBig9Ru5RRSWpL_GxgEODh0aOzzVIr0T84zONv82x1hcC6KRLHp6WB9WSamanj5JW3RUoNprKpHI2CAa1OzbyUuGAIUVHtw7S-j1TzIsEkzQWqwO_zLlCq6US-oXW25595EMCxUc3quqhTfesFhsnTR-4s1gCfRidMdtqTjmRBUL6lDm8g5ZVxgYJWoh1w0ypwXGUoUqF3lEbbuVEW8o7Jim7GOWKnzhnFjRwB5e979AOOkqLtPHbODrXH7x1-MK1357hUBM9RVDOoDJ8UaJaordZ4jnHMJHMz3DP_nzUn9FuN0Euf9Vuy3ldcPLaas94jCxC-h1JVO5I6dYIiB5HgWlIVYYYjE-cPUt3AKewfMxjlzwi2S9aA_2U0tlyw-W6qITfLN0tKKdxXUHtsKMFB8wso4dRdgE_a6Jy-HxmrvaM_bx6NdhvqbiFelCTSzAEWf4HHiWOYsg9lYcYc97RI2aQHIRX9zXXCT7QwqRtnnA3jXw1tuWd9VQM-fppBuJH-UFxereMAEPH3KwOacSLe4nynALl0Xo93I927EcnXfuApui68O2gxaS1IMENfulunTZesjnwkdLFFkLcm5EL15yK05RfTiwUDw_nWWEksVAaBFRxcGStGqWYMHjmIDxMOAFWE4xgG=w766-h448-no" alt="finalfinalfinal"></p><p>이런 파일을 한 번도 본적이 없다면, 당신은 거짓말을 하고 있거나 매우 불성실한 사람일게다.</p><p>분명 최종본을 만들었건만 최종본의 최종본은 얼마 지나지 않아 탄생하고, 에일리언 영화에서나 볼법한 엄청난 번식력으로 우리를 새벽까지 컴퓨터 앞에서 뜬 눈으로 지새게 한 바로 이 경험.</p><p>버전 관리를 하게 되면, 이 과정을 최소화하여 효율적으로 코워킹 할 수 있다.</p><p>자, 이제 상상을 해보자.</p><p>A, B, C 세 사람이 있다고 가정하자.<br>A가 작업을 마치고, B가 작업을 하고, 마지막으로 C가 하는 순차적인 작업은 지나치게 비효율적이다. 심지어 C가 작업을 하고 있는데, A가 수정해야할 부분을 발견한다면 끔찍한 상황이 연출된다. </p><p>그냥 각자 맡은 부분을 작성, 수정하고 이 파일들의 중복되지 않는 부분만 **병합(merge)**한다면 어떨까?</p><p>그걸 가능케하는 마법같으면서도 지옥같은 <strong>Git</strong>의 이야기이다.   <br><em>버전관리에 대한 자세한 내용은 git <a href="https://git-scm.com/book/ko/v1/시작하기-버전-관리란%3F" target="_blank">여기</a>에서 확인바란다.</em></p><br><h3 id="Git-설치하기"><a href="#Git-설치하기" class="headerlink" title="Git 설치하기"></a>Git 설치하기</h3><p><img src="https://media.giphy.com/media/ZvLUtG6BZkBi0/giphy.gif" alt="giphy"></p><ul><li><strong>Mac</strong><ul><li><a href="http://git-scm.com/download/mac">http://git-scm.com/download/mac</a> </li></ul></li><li><strong>Windows</strong><ul><li><a href="http://git-scm.com/download/win">http://git-scm.com/download/win</a></li></ul></li></ul><p>이외 리눅스거나 CLI 환경에서 명령어를 통해 설치를 원한다면, <a href="https://git-scm.com/book/ko/v2/시작하기-Git-설치" target="_blank">여기</a>를 확인바란다.</p><br><h3 id="Git-호스팅"><a href="#Git-호스팅" class="headerlink" title="Git 호스팅"></a>Git 호스팅</h3><p>git을 사용하면서 각 버전, 즉 파일을 관리할 서버가 필요하다. 이런 서버를 무료로 서비스해주는 제품들이 있는데, 대표적인 <a href="https://github.com/" target="_blank">Github</a>이다. </p><p><img src="https://lh3.googleusercontent.com/5BE2NDYVWVP3jwjZB0mCCmTLdmbn8lV7oVZcMv9ysofssq1kEi4_xbStT-dVFSQ6poTDNy815mRu-5MWO40FgHBXFryGFX_7-rsxy0JfXmOs-tQk6ZEmCjh43brD7ghblcu70ENWQBkT63gwz96LNR1KzW74B2KSS7s61OsGw01-KFVja2TQL_w99xTG0_KDePzVNH6hCMTC8RMZSYUb38-9X2bMRxtAqxWWhNibYirtrvZgqsA9ky4QANdhQGNz1iRx-47W3dVA_s3RNGQITX1PIxrhL7ZJ27gK_0HwQh2RCJpUNmSkLzbQ-TTKa84dVeW3dSXk4WNVwt8iLDV6SwnUIu08tc-8hNMpmmwp6xxBdFyD6Mw41PCl_56_dRpIeEwjie2_j5q5xcOBljVAeRBEjgJX9noUdzbfvXzbIP5PybEUcQqDUD2Fqzd3lzq9vxHhXVB6ya2MEvA72XEOYxKaTaqQCrTouIcVIHIchlVAeGycVogwFGuBTbkGiiuY5GujKNU1ynxXWWWPm_oIwCrG9KD8DWK93FJI-NS8VfO_0pcbaGNBQlth7234LVbcYAz_UcSW-VQdnjFuvrUj_5N7cJu5fhDQ8S0EkACZuXDpyHW9GcGi3KmSONxzGE29S_rKZ5X-QDTNAlVZNquaf9w31eWl51Yce4sUJBzj-zaKjyNb9U_Xmt1y8_stw2Hk-DBxniyEe5aJNvZ_vCAcPAv7lcdBuzgsGH9txmuovvn3gHLNMyix-04=w325-h122-no" alt="Github"></p><p>혹시 Github 대신 다른 호스팅 서비스를 쓰고 싶다면, <a href="https://www.git-tower.com/blog/git-hosting-services-compared/" target="_blank">링크</a>를 통해 비교해보고 자신에게 맞는 서비스를 이용하면 된다.</p><p>원래 몇 개월 전만 하더라도 Github에서 무료 계정은 private repository를 이용할 수 없었다. 그러나 Microsoft가 무려 8조원에 달하는 거금으로 인수하면서 얼마 전 무료 계정에도 private repository를 만들수 있도록 허용해주었다.</p><p><strong>Repository는 저장소</strong>를 의미한다. 줄여서 그냥 repo라고도 한다.</p><p>private repo는 접근 권한을 갖고 있는 사람들만 소스코드에 접근 할 수 있는 권한을 의미하며, public repo는 누구나 해당 저장소에 접근해서 소스코드를 볼 수 있다. 따라서 오픈 소스의 경우에는 public repo를 이용하고, 상업적인 목적을 지닌 프로젝트를 할 경우에는 private repo에서 하면 된다. </p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Intro .Java</title>
      <link href="2019/02/java-intro/"/>
      <url>2019/02/java-intro/</url>
      
        <content type="html"><![CDATA[<h3 id="목차"><a href="#목차" class="headerlink" title="목차"></a>목차</h3><ul><li><a href="#feature">Java의 특징</a></li><li><a href="#philosophy">Java의 철학</a></li><li><a href="#conclusion">정리</a></li><li><a href="#foot-note">주석</a></li></ul><br><img src="http://www.mediafire.com/convkey/af35/opivqpoyrlo8n5gzg.jpg" width="500" /><blockquote><p><em>Write once, *<br>*Run anywhere.</em></p></blockquote><br><h2 id="Java의-특징"><a href="#Java의-특징" class="headerlink" title="Java의 특징"></a><a name="feature"></a>Java의 특징</h2><ul><li>Java는 ‘Java의 아버지’로 불리우는 <a href="https://www.linkedin.com/in/jamesgosling/" target="_blank">James Gosling</a>가 1995년, Sun Microsystems.Inc,(이하 Sun)에서 다른 연구원들과 함께 개발한 프로그래밍 언어이다. 1995년에 Java 1.0을 발표했다. </li><li>2009년 Oracle이 Sun을 56억불에 Oracle에 <a href="https://www.cbsnews.com/news/oracle-buys-sun-microsystems-for-74b/" target="_blank">인수</a>하면서 모든 권리가 Oracle로 이전되었다.</li><li>Java는 <a href="#oop"><strong>객체지향언어</strong>(Object Oriented Language)</a><sup><code>1</code></sup>이다.</li><li>Java가 등정하기 이전의 객체지향언어인 C++ 문법을 기본으로 개발되었다.</li><li>Java가 다른 언어와 다른 가장 큰 특징은  <a href="#jvm"><strong>JVM</strong></a><sup><code>2</code></sup> 위에서 작동되기 때문에 <a href="#os-independent"><strong>플랫폼 독립적</strong></a><sup><code>3</code></sup> 이라는 점이다. HW에 맞게 완전하게 컴파일된 상태가 아니라 실행 시에 해석(Interpreter)되기 때문에 속도가 느리다는 단점을 가지고 있었다. 그러나 최근엔 JIT 컴파일러와 최적화된 기술로 인해 속도의 격차가 크게 줄었다.</li><li>Java는 C/C++와 달리 <strong>메모리를 자동으로 관리</strong>해준다. <strong>Garbage Collector</strong>(이하 GC)가 사용하지 않는 메모리를 자동으로 정리해준다.</li></ul><br><h2 id="Java의-철학"><a href="#Java의-철학" class="headerlink" title="Java의 철학"></a><a name="philosophy"></a>Java의 철학</h2><ul><li><a href="#oop">객체 지향 방법론</a><sup><code>1</code></sup>을 사용해야 한다.</li><li>프로그램(바이트 코드)가 여러 운영체제에서 실행될 수 있어야 한다. (<a href="#os-independent">플랫폼 독립성</a><sup><code>3</code></sup>)</li><li>컴퓨터 네트워크 접근 기능이 기본으로 탑재되어 있어야 한다.</li><li>원격 코드를 안전하게 실행할 수 있어야 한다.</li><li>다른 객체 지향 언어들의 좋은 부분만 가지고 와서 사용하기 편해야 한다.</li></ul><br><h2 id="정리하면"><a href="#정리하면" class="headerlink" title="정리하면.."></a><a name="conclusion"></a>정리하면..</h2><ol><li>Java는 <a href="#oop">객체지향언어</a><sup><code>1</code></sup>이다.</li><li>애플리케이션이 운영체제에 직접 실행되지 않고, JVM을 거치기 때문에 어떤 운영체제에서든 실행할 수 있다는 장점(<a href="#os-independent">플랫폼 독립성</a><sup><code>3</code></sup>)이 있다.</li><li>수동으로 메모리를 관리하는 C/C++와 달리 Java에는 Garbage Collector가 있어서 GC가 자동으로 메모리를 관리해준다.</li></ol><br><hr><p><a name="foot-note"></a></p><p><sup><code>1</code></sup> <a name="oop"></a><strong>객체지향 언어</strong> (Object Oriented Programming) : 말 그대로 객체지향은 객체를 만드는 일이다. 현실 세계에 있는 것들을 프로그래밍화 한다고 할 수 있다. 더 자세히는 프로그램의 로직을 상태(state)와 행위(behave)로 이루어진 객체로 만드는 것이다. 반복되는 구문을 객체화하여 작성하는 프로그래밍 기법이다. = <strong>Modularization or Encapsulation</strong></p><p><sup><code>2</code></sup> <a name="jvm"></a><strong>JVM</strong> (Java Virtual Machine) : 컴파일된 소스코드인 바이트 코드를 운영체제에서 실행시키기 위한 가상의 기계. Java로 작성된 프로그램은 반드시 JVM에서 실행되어야만 한다. </p><p><sup><code>3</code></sup> <a name="os-independent"></a><strong>플랫폼 독립적</strong> : 바이트 코드가 JVM에 의해서 실행되기 때문에 특정 운영체제에 종속되지 않고, 같은 바이트 코드로 여러 운영체제에서 실행할 수 있다는 장점이 있다. Java 프로그램은 운영체제에 종속되지 않지만, 대신 JVM을 운영체제에 맞게 설치해야 한다.</p>]]></content>
      
      
      <categories>
          
          <category> Dev </category>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>내가 블로그를 시작하는 이유</title>
      <link href="2019/02/first/"/>
      <url>2019/02/first/</url>
      
        <content type="html"><![CDATA[<p><img src="https://images.unsplash.com/photo-1510511498717-4326639c999c?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1050&q=80" alt="cover img"></p><p>공부를 할 땐 누군가를 설명할 수 있는정도로 공부를 하라는 이야기를 자주 들었다. 나도 잘 못하는데, 대체 누굴 가르키란 말인가. 그런데 프로그래밍 공부를 하면서 생각이 바뀌었다. </p><p>생활코딩, 인프런, Udacity 등 동영상 강의를 찾아 듣긴 하지만 실상 강의를 시청하는 시간보다 구글링하는 시간이 더 길었다. 구글링해서 발견하는 대부분의 포스트는 Stackoverflow거나 개발자 블로그들이었다. 개발자들이 공부하면서 알게 된 걸 블로그에 남기는 것을 알았다. 그리고 언제부턴가 그렇게 방문하게 된 개발자들의 블로그를 보면서 그 분의 프로필은 모르지만 이 분이 어디에 관심이 있으며, 어떤 언어/공부를 했는지를 블로그만으로 판단하고 있다는 사실을 자각했다.</p><p>누군가를 알려준다기엔 지금의 내가 너무 많이 부족하지만, 공부하고 있는걸 기록차원에서 남기고 또 이렇게 기록을 남기기 위해서 한 번 더 정리하는 과정이 필요하다고 생각했다. 그래서 연휴 기간동안 <a href="https://hexo.io/ko/" target="_blank">Hexo</a>를 이용해서 깃헙 페이지로 블로그를 만들었다. Hexo는 지인이 추천해준 프레임워크이다. Nodejs 기반이긴 하지만, Nodejs가 뭔지 몰라도 만들수 있을만큼 간단하다. 다음 포스트에서 Hexo로 깃헙 페이지에 블로그를 만드는 법을 작성할 예정이다.</p><p>네이버 블로그나 Medium, 브런치가 있음에도 깃헙 페이지에 블로그를 만든 이유는 github.io라는 충분히 개발자스러운 도메인에 대한 욕심도 있었고, 무엇보다 새해부터 <a href="https://evernote.com" target="_blank">에버노트</a> <sup><code>1</code></sup>를 대신해서 노트 테이킹에 쓰고 있는 Markdown으로 포스트를 작성할 수 있다는 점이 가장 컸다. 네이버 블로그나 티스토리 등은 각자 포스팅에 편하도록 각자의 플랫폼에 맞춰서 에디터를 잘 만들어주긴 했으나, Markdown 문법 <sup><code>2</code></sup> 만큼의 높은 자유도를 보장하지는 않았다.</p><p>깃헙 블로그이므로 아마 내가 충분히 컨텐츠를 많이 만들거나 SEO에 신경쓰지 않는 이상 네이버, 구글과 같은 검색엔진 플랫폼에서 잘 검색되기도 힘들것이다. 그러나 이 점이 단점이라기보다는 오히려 누구도 보지 않는다는 점에서 시작하기에 더 수월했다.</p><p>앞으로 이 곳에 공부의 흔적을 남기고,  나처럼 뭘 모르는지 모르는 분들께 조금이나마 도움이 되는 블로그를 운영해보겠다.</p><br><br><hr><p><sup>1</sup><strong>에버노트</strong> : 모바일과 데스크톱에서 동기화하여 사용가능한 노트 앱. 전 세계에서 가장 인기가 많은 노트 서비스지만, tag를 이용한 노트 관리 때문에 처음 시작하는 사람들에겐 약간의 허들이 있는 서비스. 에버노트에서는 ‘노트’ &lt; ‘노트북’ &lt; ‘스택’ 3단계 형태로 노트를 수직 관리할 수 있다. 때문에 많은 노트를 관리하기 위해서는 태그, 링크 사용이 필수이다.</p><p><sup>2</sup><strong>Markdown</strong> : 일반 텍스트 문서의 양식을 편집하는 문법. README 파일이나 온라인 문서 등의 양식을 편집할 때 쓰인다. 마크다운을 이용해 작성된 문서는 쉽게 HTML 등 다른 문서형태로 전환이 가능하다 (출처: <a href="https://ko.wikipedia.org/wiki/마크다운" target="_blank">위키</a>)</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
          <category> Thought </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
