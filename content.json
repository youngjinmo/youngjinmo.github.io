{"meta":{"title":"DevAndy - 개발자앤디의 개발블로그","subtitle":"개발블로그","description":"개발자앤디가 되어가는 과정을 기록하는 블로그","author":"Youngjin Mo","url":"http://youngjinmo.github.io","root":"/"},"pages":[],"posts":[{"title":"Hello, Vue.js","slug":"hello-vue","date":"2020-12-02T21:44:20.000Z","updated":"2020-12-03T08:32:07.055Z","comments":true,"path":"2020/12/hello-vue/","link":"","permalink":"http://youngjinmo.github.io/2020/12/hello-vue/","excerpt":"","text":"What is Vue공식문서를 보면, 사용자 UI를 위한 Progressive Framework라고 소개한다. View layer에 맞추어 다른 프로젝트와의 통합이 쉬운 편이라고 하며, View를 강조하기 위해 이와 비슷하게 들리는 Vue로 이름을 지었다고 한다. 데이터 바인딩과 화면 단위를 컴포넌트 형태로 제공한다고 한다. 처음 회사에 들어왔을 때 배운 웹스퀘어처럼 비동기적으로 데이터를 바인딩하는 UI 프레임워크인것으로 보인다. Vue Instance모든 Vue 앱은 Vue 함수로 새 Vue 인스턴스를 만드는것부터 시작한다. 123var vm = new Vue(&#123; // Vue.js&#125;) Vue 앱은 new Vue 를 통해 만들어진 루트 Vue 인스턴스로 구성된다고 한다. 재사용 가능한 컴포넌트 트리로 구성할 수 있으며, Todo 앱을 구현한다고 하면, 앱의 컴포넌트 트리는 다음과 같다. 12345678Root Instance└─ TodoList └─ TodoItem | └─ DeleteTodoButton | └─ EditTodoButton └─ TodoListFooter └─ ClearTodosButton └─ TodoListStatistics 출처 : https://kr.vuejs.org/v2/guide/instance.html Model-view-viewmodel Instance Lifecycle HookVue의 각 인스턴스는 생성될 때 일련의 초기화 단계를 거치며, 템플릿을 컴파일 하는 경우, 인스턴스를 DOM에 마운트하는 경우, 그리고 데이터가 변경되어 DOM을 업데이트하는 경우가 발생한다. 그 과정에서 사용자 정의 로직을 실행할 수 있는 라이프사이클 훅도 호출된다. Lifecycle Diagram Installationinstall nodehttps://nodejs.org/en/download/ install vuehttps://vuejs.org/v2/guide/installation.html Hello Vue1234567891011121314151617181920&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Vue.js Sample&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue-app&quot;&gt; &lt;h2&gt;&#123;&#123; message &#125;&#125;&lt;/h2&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &#x27;#vue-app&#x27;, data: &#123; message: &#x27;Hello World&#x27; &#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; script 코드로 Vue 객체를 생성한다. 단 이 때 Vue를 cdn으로 가져와야 페이지에서 Vue가 동작한다. el 은 DOM에서 셀렉트 영역을 선택하는 속성이다. id가 vue-app 을 선택해야지만 해당 영역을 선택하고, Vue를 동작시킨다. data 는 비동기적으로 화면에 전달되는 데이터를 의미한다. 화면에서 &#123;&#123; name &#125;&#125; 이라고 입력하면, Vue의 data 속성중 message 라는 이름의 값이 출력된다. v-if -&gt; 조건문12345678910111213&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Vue.js Sample&lt;/title&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue-app&quot;&gt; &lt;span v-if=&quot;brazil&quot;&gt;Brazil won the worldcup champion in 2002.&lt;/span&gt;&lt;br&gt; &lt;span v-if=&quot;france&quot;&gt;France won the Worldcup champion in 1998.&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567var app =new Vue(&#123; el: &#x27;#vue-app&#x27;, data: &#123; brazil: true, france: false &#125;&#125;); v-if 를 사용하면, 조건에 따라 화면에 출력여부를 결정할 수 있다. v-for -&gt; 반복문123456789101112131415&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Vue.js Sample&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue-app&quot;&gt; &lt;ul v-for=&quot;player in players&quot;&gt; &lt;li&gt;&#123;&#123; player.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12345678910var app = new Vue(&#123; el: &#x27;#vue-app&#x27;, data: &#123; players: [ &#123; name: &#x27;Minkyun Kim&#x27; &#125;, &#123; name: &#x27;Leandro&#x27; &#125;, &#123; name: &#x27;Sangmin Lee&#x27; &#125; ] &#125;&#125;); v-for 태그를 사용하여 for-loop를 구현한다. 처음 할 때 조금 신기하다고 생각했던건 그냥 문자열같은 v-for의 값도 elements in list 구조로 파싱하여 elements를 추출한다는점이었다. 위의 코드는 players 라는 Vue 객체의 요소를 player 라는 이름으로 바인딩해서 화면에서 &lt;li&gt; 태그로 출력한다. 리스트에 새로운 이름을 추가(Push) 할 수도 있다. 1234567891011var app = new Vue(&#123; el: &#x27;#vue-app&#x27;, data: &#123; players: [ &#123; name: &#x27;Minkyun Kim&#x27; &#125;, &#123; name: &#x27;Leandro&#x27; &#125;, &#123; name: &#x27;Sangmin Lee&#x27; &#125; ] &#125;&#125;);app.players.push(&#123; name: &#x27;New player!&#x27; &#125;); v-on:click -&gt; 이벤트 처리버튼을 생성해서 버튼을 클릭하면 텍스트를 변경하는 함수를 추가했다. 1234567891011121314151617&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Vue.js Sample&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue-app&quot;&gt; &lt;h2&gt;&#123;&#123; club &#125;&#125;&lt;/h2&gt; &lt;button v-on:click=&quot;changeclub&quot;&gt;Change Club&lt;/button&gt; &lt;ul v-for=&quot;player in players&quot;&gt; &lt;li&gt;&#123;&#123; player.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456789101112131415var app = new Vue(&#123; el: &#x27;#vue-app&#x27;, data: &#123; players: [ &#123; name: &#x27;Minkyun Kim&#x27; &#125;, &#123; name: &#x27;Leandro&#x27; &#125;, &#123; name: &#x27;Sangmin Lee&#x27; &#125; ], club: &#x27;Seoul Eland FC&#x27; &#125;, methods: &#123; changeclub = &#x27;Seoul City FC&#x27; &#125;&#125;);app.players.push(&#123; name: &#x27;New player!&#x27; &#125;); v-on:click=&quot;changeclub&quot; 속성을 &lt;button&gt; 에 추가해서 버튼을 클릭하면, changeclud 함수를 실행하도록 구현했다. v-model -&gt; 양방향 바인딩1234567891011121314&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Vue.js Sample&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue-app&quot;&gt; &lt;h2&gt;&#123;&#123; club &#125;&#125;&lt;/h2&gt; &lt;input v-model=&quot;message&quot;&gt; &lt;/div&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456var app = new Vue(&#123; el: &#x27;#vue-app&#x27;, data: &#123; message: &#x27;Hello Vue!&#x27; &#125;&#125;); &lt;input&gt; 태그로 들어오는 값을 바인딩하여 화면에 값을 동적으로 변경하는 코드이다. ComponentsHTML Element를 확장하여 재사용 가능한 코드를 캡슐화하는 Vue의 기능이다. 12345678910111213141516&lt;!DOCTYPE html&gt; &lt;head&gt; &lt;title&gt;Vue.js Sample&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;index.css&quot;&gt; &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;vue-app&quot;&gt; &lt;ol&gt; &lt;todo-item&gt;&lt;/todo-item&gt; &lt;todo-item&gt;&lt;/todo-item&gt; &lt;/ol&gt; &lt;/div&gt; &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 123456Vue.component(&#x27;todo-item&#x27;, &#123; template: &#x27;&lt;li&gt;This is Vue.js Component&lt;/li&gt;&#x27;&#125;);var app = new Vue(&#123; el: &#x27;#vue-app&#x27;&#125;); Vue 객체를 생성해서 component()안에 이름을 지정하고 &#123; template : &#125; 안에 입력한 HTML Element를 화면에 뿌린다. HTML에서는 Vue.Component()에서 지정한 컴포넌트 이름으로 태그를 만들면 Vue.component()로 생성한 Element를 화면에서 출력한다. 출처 : https://kr.vuejs.org/v2/guide/components.html","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://youngjinmo.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://youngjinmo.github.io/tags/vue/"}]},{"title":"WeeklyReview - 11월 5주차","slug":"weeklyreview-2020-nov-fifth","date":"2020-11-29T05:00:05.000Z","updated":"2020-11-30T01:28:07.536Z","comments":true,"path":"2020/11/weeklyreview-2020-nov-fifth/","link":"","permalink":"http://youngjinmo.github.io/2020/11/weeklyreview-2020-nov-fifth/","excerpt":"","text":"ToC 무엇을 했는가 Junit5 공부 스터디 2달 회고 무엇을 읽었는가 프로그래머의 길, 멘토에게 묻기 무엇을 하겠는가 Spring Boot, JPA로 CRUD 구현해보기 &lt;함께 자라기&gt; 읽기 약 13개월만에 위클리 리뷰를 하려고 한다. 매일 업무 일지와 간헐적으로 다이어리를 쓰지만 다시 보는 일이 별로 없어서 주단위로 내가 어떻게 지냈는지를 돌아보면 좋을것 같아서 다시 위클리 리뷰를 시작하려고 한다. 무엇을 했는가 JUnit5 공부 회사에서 일이 별로 없어서 혼자 공부를 하게되었다. 주말에 하는 스터디에서 테스트 코드를 작성하는 법을 배웠는데, 자바 테스트 프레임워크인 JUnit을 이번 기회에 제대로 공부해보고 싶다는 생각이 들었다. 지난 여름에 구입하고 잠깐 보다가 그만두었던 백기선님의 더 자바 - 애플리케이을 테스트하는 다양한 방법를 보면서 JUnit5의 주요 어노테이션을 정리했다. 이강의를 보며, 생각한것보다 테스트를 광범위(?)하게 해볼 수 있구나라는걸 알았다. 특히 @EnabledOnOs(&#123;OS.LINUX, OS.MAC&#125;) 어노테이션을 통해서 그런걸 느낄 수 있었다. 운영체제에 따라서도 테스트 메서드 실행여부를 구분할 수 있을거라곤 전혀 생각도 못했다;; Github에 예제 코드와 문서를 정리해두긴했는데, 다시 정리해서 블로그에 올릴 생각이다. 스터디 2달 회고 사실 이 것 때문에 1년만에 위클리 리뷰를 해보고 싶었다. 2달 전인 9월부터 영등포에서 진행하는 모각코에 참여했다. 주말에 나태하고 게으른 육신을 어떻게든 굴려보고 싶던 차에 ‘각자 코딩하고, 공부한걸 나눈다.’ 라는 취지가 맘에들어서 모각코에 참여하게 되었다. 당시에 간헐적으로 오는 요청에 따라 쿼리를 조회하거나 작업을 해야하는 일이 있었기 때문에 모각코 초반엔 해커랭크에서 SQL 문제를 풀었다. 그리고 이어서 스프링부트와 MyBatis, 오라클을 연결하여 미리 만들어둔 테이블을 스프링부트로 만든 API로 조회하는 실습도 해보았다. 그러던차에 서비스 기업 이직을 목표로 코딩테스트 준비를 하던 모각코 호스트가 갑자기 프로젝트를 제안했다. 이렇게 모각코를 하면 남기는게 없다면서 기왕이면 같이 남기는 공부를 하자며 프로젝트를 제안한 것이다. 개인적으로 이직할 의사도 없었고, 프로젝트도 시기상조라는 생각이 있었기 때문에 거절을 했었는데 끊임없이 제안을 해서 ‘이것도 좋은 기회겠다.’ 라는 생각이 들어서 프로젝트에 참여하게 되었다. 처음엔 기대보다 훨씬 좋았다. 실무 경험(SI) 최소 2년차 이상의 개발자들과 개발을 하니 이것저것 많이 배울수 있었다. 4-5개월 신입 개발자였지만 현재 파견나간 프로젝트(금융권 SM)에서 거의 일이 없는바람에 사실 시간만 그냥 지나가고 있었는데, 이렇게 경력 개발자들과 함께 프로젝트를 하니 개발다운 개발을 하는것 같아 재미있었다. 테스트 코드를 작성하는 법을 호스트에게 처음 배웠다. given, when, then 의 마틴 파울러가 제안한 테스트 코드 작성법을 알게 되었고, git으로 혼자 형상관리만 해보았지, 제대로 브랜치 관리를 하며 팀 단위의 협업과 코드 리뷰를 하는것도 처음이었다. 언젠가 코드 리뷰를 꼭 해보고 싶었는데, 모각코하려고 참여한 모임에서 코드 리뷰를 하게되어 정말 재밌고 유익했다. 그런데 어느샌가부터 균열이 발생하기 시작했다. 주말에 공부할 목적으로 참여한 모각코였으나 프로젝트로 확대되면서 평일에도 연락이 오기 시작했다. 처음엔 평일 요청에도 응답했지만, 서서히 부담이 되기 시작했다. 평일에 개인공부를 하기 위해서 월수금은 퇴근 후 스타벅스를 가고, 화목은 쉬는 루틴으로 살고있었는데, 이 프로젝트를 진행하면서 내 생활 루틴이 완전히 깨지기 시작했다. 코드 리뷰나 회의를 밤 10시로 요청했는데, 보통 난 10시면 스타벅스에서 공부를 마치고 퇴근을 하는 시간 또는 집에서 편하게 개인시간을 보내는 시간이었다. 점점 루틴이 깨지니 개인 공부시간이 줄어들기 시작했고, 점점 부담되기 시작했다. 그래서 이를 호스트에게 솔직하게 이야기하고 평일보다 주말에 집중하고 싶다는 의사를 전달했다. 그런데 호스트는 이걸 있는그대로 받아들이기 보다 내가 실력이 많이 부족해서 이 프로젝트를 따라오지 못하는것으로 생각한것 같다. 진짜 문제는 지금부터 발생했다. 내 루틴을 깨야하긴 했지만, 어쨋든 퇴근하고 늦은시간에 코드리뷰를 해주었기 때문에 호스트에게 무한감사를 느끼고 있었다. 아 늦은시간에 코드리뷰를 해준다는 말이 조금 이상하게 들릴 수 있었는데, 이 호스트가 Github으로 비동기로 코드 리뷰하는게 잘 안되는것 같다면서 Zoom으로 화면을 보면서 리뷰를 해준다고 했다. 나도 이렇게 하면 즉각 도움을 받으니 더 도움될거라고 생각했다. 그런데 코드리뷰를 거듭할 수록 점점 이사람의 애티튜드가 달라지기 시작했다. 처음엔 코멘트를 할 때 논리적인 이유를 함께 해주었던 분이 점점 논리적인 이유 대신 ‘보통 이렇게 해요’ 라는 무성의한 코멘트로 리뷰를 해주기 시작했다. 내 코드가 잘못되었다면, 왜, 어떤 부분에서 잘못되었는지를 알고 싶었으나 이 사람은 계속 ‘이렇게 많이 해요’ 라는 말로 대신했다. 어느순간 내가 이 사람의 코드리뷰를 그대로 받아들이면 안되겠다고 생각하게 된 계기가 있었는데, 그게 REST에 대한 부분이었다. 내가 API를 만들기위해 Controller를 생성할 때, 파라미터를 URI에 노출하는 대신 @PathVariable 로 REST API를 생성했는데 이 사람은 이 코드를 처음본다고 이야기했다. 그러더니 URI를 왜 이렇게(REST) 작성했느냐고 물어서, “REST니까요..” 라고 대답을 했던 기억이 난다. 학원에서 JSP를 공부하긴 했지만, 이후엔 JSP를 한 번도 만져본적이 없었고, 인터넷 강의나 회사에서 배운 방식도 REST 였지만 막상 왜 REST를 쓰는지에 대해 설명할만큼 이해하고 있지 못했다. 그래서 코드 리뷰 다음날 회사에서 동료분들과 이야기 나누며 REST를 쓰는 이유에 대해 정리할 수 있었다. 그리고 생각해보니 연차가 3년이나 되셨고, 서비스 기업 이직을 준비한다고 하신 분께서 REST를 처음본다는 말이 이상하게 느껴지게 되었다. 그리고 바로 이 코드 리뷰때 이 분이 했던 또 다른 질문도 갑자기 이상하게 느껴지기 시작했다. Zoom으로 화면을 보여주며 개발하다가 Git 명령어를 위해 iTerm으로 커맨드 명령어를 입력했는데, 이 때 이사람이 갑자기 인상을 잔뜩 찌뿌리면서 “CLI로 하면 안복잡하세요?” 하며 한숨을 내쉬었다. 이 때만 하더라도 이 사람이 내가 Git-cli를 사용하는걸 어떻게 생각하는지 전혀 상상하지 못했다. 슬랙에서 커뮤니케이션 중에 작은 오해가 생겨 브랜치 관리를 주제로한 토론을 하게되었다. 호스트가 맥락을 생략하며 말을 했는데, 내가 이걸 알아듣지 못했던 것이다. 이 대화에서 이 분은 끊임없이 무성의한 코멘트로 대화를 진행했다. ‘바쁘다보면, 이럴 수도 있겠지‘ 하고넘기던 차에 마지막 댓글로 나도 감정이 불편해지기 시작했다. 내가 혹시 뭔가 오해를 한건가 싶어 그 지점을 다시 묻는 질문에 대한 답변이었다. 일단 말씀하신대로 진행하시고 만나서 얘기하시죠 텍스트로 대화하기가 한계가 있어보여서요 텍스트로 대화하기 한계가 있다라는 표현은 이 사람이 해선 안되는 표현이었다. 이 대화에 최선을 다한건 나였다. 혹시나 내가 잘못알고있을까봐 내가 현재 이해하고 있는 상황을 다소 장황하더라도 길게 써내려간건 나였고, 처음 요청부터 맥락을 생략하고, 내 답변을 제대로 읽지도 않고 답변을 하는등 무성의하게 일관한 사람이 할 수 있는 말이 아니었다. 더군다나 Slack과 Git은 개발자들이 주로 사용하는 대표적인 비동기 커뮤니케이션툴인데, 이를 먼저 제안한 사람이 텍스트는 한계가 있다는 표현도 이해할 수 없었다. 이 일이 있기전에도 모각코에 관한 의견을 슬랙 다이렉트 메세지로 보냈더니 기왕이면 이런 내용은 전화로 해달라고 한적이 있었는데, 이 또한 이해할 수가 없다. 기록을 남기기위해 슬랙을 쓰자고 하던 사람은 어디가고 중요한 내용은 전화나 만나서 하자니… 주말까지 기다리기 싫어서 Zoom 미팅을 제안했고, 이 미팅은 마지막 미팅이 되었다. 위에서 이야기 했던 부분을 불만을 이야기했더니 이 사람은 이성을 놓고 흥분하기 시작했다. 이런게 불만스러우면 자신은 이 프로젝트로 무엇을 얻는거냐며 나에게 화를 냈는데, 나도 궁금한 부분이었다. 본인은 스스로를 PM, PL으로 지칭하며 개발보다 지시만 하는데 이렇게 하는 프로젝트로 대체 어떻게 이직을 준비한다는지 잘 이해가 가지 않았다. Mongo DB를 적용해볼거라고 이야기했지만, 이 사람은 단 한번도 자신이 공부한걸 공유하지 않았다. DB 세팅관련 application.properties 파일을 수정한 커밋 한 번과 톰캣서버를 실행하니 Exception이 발생하길래 이걸 다시 제외처리한 커밋 딱 2개였다. 아무튼 다시 마지막 Zoom 미팅으로 돌아가면, 본인의 감정을 주체하지 못한건지 혼자 화를 내더니 Zoom 미팅을 나가버렸고, 결국 나와 다른 분만 남아서 조심스럽게 이야기를 더 진행했다. 그 분께선 자신의 회사동료이기도한 이 호스트가 평소에 내가 Git Cli를 사용하는것에 불만이 있었다고했다. 이유는 Git을 도와주고 싶어도 자신이 CLI를 몰라서 못도와주는데 대체 왜 ‘아무도 안쓰는 Git CLI’ 를 쓰냐며 불만을 드러냈다고 한다. 아무도 안쓰는 Git CLI를 쓰는 바람에 나에게 불만이 많았다니… 할말이 많았지만, 밤을 샐수는 없었기에 서둘러 이 분과도 Zoom 미팅을 마쳤고, 이렇게 첫 모각코아닌 모각코를 마무리했다. 더 이상의 시간을 낭비하지 않은건 다행이라고 생각하면서도 대체 무엇이 이 사람을 이렇게 만들었나 생각하게 만들었다. 분명히 열정도 있고, 열심히 노력하는 사람인데 이 분은 평소 모각코에서도 자신이 알고있는것 외에 것들을 받아들이려고 하지 않았다. 오직 자신이 알고있는것이 최선인것마냥 자신이 아는것들만 공유하려고 노력했다. 자신이 알고있는 것이 최선인지 아닌지 여부를 떠나서 어쨋든 자신이 알고있는걸 공유해주는건 감사했지만, 신입 개발자인 내가 Git CLI나 REST에 대해서 알려주려고 하니 “가르치려고 하는것 같아 사람으로써 기분이 나빴다.” 라는 말은 각자 공부하고 함께 나누자는 취지의 모각코를 기획한 사람의 입에서 나올 수 있는 말인지 다시 이해 할 수 없다. 이번 경험을 통해 앞으로 어떻게 성장해야 하는지에 대해 진지하게 생각해볼 수 있었다. 내가 아는게 전부가 아닐 수 있으며, 내가 모르는 기술을 상대가 알고 있을땐, 호기심을 갖고 물어보거나 들으려고 해야겠다는 생각이 들었다. 이건 자존심의 문제가 아니라 내 성장의 문제 이기 때문이다. 또 한편으론 앞으로 이런 분을 또 만날수 있을텐데, 그 땐 어떻게 커뮤니케이션을 하는것이 공동의 목적을 지속적으로 추구할 수 있는지에 대해서도 지속적으로 고민해봐야겠다. 무엇을 읽었는가 읽기 좋은 코드를 위한 간단한 원칙 코드 리뷰 in 뱅크샐러드 개발 문화 누구나 원하는 개발자 되기 위에서 너무 많이 써버리는바람에 이 섹션은 Github에 내가 issue를 링크로 다는것으로 대신하려고 한다. 이 글들도 모각코에서 발생한 문제를 이해하고, 해결하기 위해 읽은 글이었다. 결국 해결하지 못했지만, 조금씩 나아지고 개선하기 위햇 노력해야겠다. 그리고 모각코에서 나 역시 잘못한게 있을수 있다고 생각한다. 따라서 이 날 슬랙에서 했던 대화내용을 스크린샷으로 떠놨는데, 딱 1년이 지난 시점에 다시 보려고 한다. 연차가 쌓일수록 지금 내가 경험한 일을 혹시 다른 시각에서 볼 수 있지않을까 싶어서이다. 지금은 내 잘못보다 상대 잘못만 보이는것 같지만, 막상 연차가 쌓여서 되돌아보니 내 잘못이 더 크거나 내 책임이 더 커보일 수 있기 때문이다. 문제가 발생했을때, 그냥 그 상태로 끝내는건 그냥 실패로 기억되지만, 이런 실패를 다시 되돌아보게 되면 시간이 지날수록 같은 실수를 안하거나 조금씩 성장할 수 있을거라고 믿는다. 다음주엔 무엇을 하겠는가 Spring Boot, JPA로 CRUD 구현해보기 이제 스터디를 쉬게 되었는데, 엎친데 덮친격으로 수도권에서 코로나 바이러스가 확산하면서 어딜 가기에도 힘들게 되었다. 다음주엔 평일 퇴근이후 또는 주말에 집에서 스프링부트와 JPA로 CRUD를 실습해보려고 한다. &lt;함께 자라기&gt; 읽기 그리고 &lt;함께 자라기&gt;라는 책을 구입했다. 현재 &lt;프로그래머의 길, 멘토에게 묻다&gt;를 거의 다 읽었는데, 이 책 다 읽으면 읽으려고 한다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"신입개발자가 생각하는 개발 문서","slug":"how-to-write-readme","date":"2020-11-19T18:20:34.000Z","updated":"2020-11-26T01:35:46.839Z","comments":true,"path":"2020/11/how-to-write-readme/","link":"","permalink":"http://youngjinmo.github.io/2020/11/how-to-write-readme/","excerpt":"","text":"주말에 진행하고 있는 사이드 프로젝트에서 본격적인 프로젝트 개발 전에 개발 문서를 작성하며 시작하자는 이야기가 나왔다. 현재 파견나와 있는 프로젝트에서 하는 것처럼 전통적인 메뉴얼 느낌의 문서가 아닌 개발자들을 위한 개발 문서를 이야기하는 것이다. 이 문서에서는 코딩 컨벤션이나 변수명 규칙 등 사소하지만 개발할 때 고민하는 시간을 줄여주거나 충돌을 피하게 해주는 꽤 중요한 부분들이라고 생각한다. 그런데 회사에서도 개발 문서를 작성하자는 이야기가 나왔다. 향후 확장성을 고려해서 마크업 언어로 문서를 작성하자고 이야기가 나와서 한 번 정리하면 좋겠다는 생각이 들어 정리를 하게 되었다. 본문에 앞서 이 글은 6개월차 신입 개발자가 작성했음을 알려드립니다.부족한 내용이 있을수 있고, 심지어는 잘못 이해하여 오해하고 있는 부분이 있을 수 있습니다. 이런 부분에 대해서는 가감없이 댓글로 지적해주시면 감사하겠습니다. 왜 개발 문서를 쓰는가난 항상 Why가 가장 중요하다고 생각한다. Why가 중요하다고 느낀 한 가지 사례를 이야기해보겠다.최근에 테스트 코드를 작성하는 법을 배웠는데, 이 테스트를 통해서 개발자가 의도한대로 서비스 플로우가 정상 작동하는지 파악하는 과정이다. 그리고 이런 테스트가 중심이 되는 개발방식을 TDD(Test Driven Development)라고 한다. TDD에선 테스트 코드를 먼저 작성하며 개발을 한다고 한다. 사이드 프로젝트에선 테스트 코드까지 작성하는게 하나의 사이클이다보니 여전히 테스트 코드에 대한 이해도는 부족하나 조금씩 익숙해져 가고 있다. 테스트 코드를 작성하면서 느낀건, 테스트 코드를 통해 확인하는건 단지 이 코드가 정상 작동하는지를 파악할 뿐 아니라 개발자가 어떤 코드를 필요한지 정리하는 과정같다는 생각이 들었다. 테스트 코드를 통해 입력받는 값은 무엇인지 (given), 이 코드가 서비스 플로우에서 언제 처리되며 (when), 그래서 어떤 값을 반환하는지 (then). Refactoring 의 저자 Martin Fowler는 테스트 코드를 작성할 때 위와같이 given, when, then의 방식으로 테스트 코드를 작성하라고 말한다.출처 : GivenWhenThen - martinfowler.com 테스트 코드를 작성하며 정리를 한 다음, 실제 코드를 작성하게 됨으로써 불필요한 코드를 작성할 일을 사전에 방지할 수 있는 효과도 기대할 수 있다고 생각한다. 이런걸 이해하니까 테스트 코드가 왜 필요한지를 더 분명하게 이해할 수 있었다. 이같은 Why는 어떠한 행동을 이끌어내는데 가장 강력한 motivation 이라고 생각한다. 그래서 왜 왜 왜 개발문서를 써야하는가? 이 글을 읽는 개발자라면, 당신도 어딘가에서 어떠한 프로젝트를 수행중일 것이다. 프로젝트의 수명이 아직 끝나지 않은 상황에서 현 프로젝트의 개발자들이 어느날 갑자기 이직을 선언한다면 어떨것 같은가?혹은 이 프로젝트의 A to Z를 다 알고있는 개발자가 갑자기 아침 출근길에 교통사고를 당해서 2주간 출근할 수 없게 된다면? 이런 끔찍한 상황을 제외하더라도 프로젝트 단위로 계약을 맺는 프리랜서 개발자들이 아니라면, 프로젝트의 수명과 개발자는 항상 운명을 같이 할 수 없다. 아니 이를 보장할 수 없다. 개발중인 프로젝트에 신규 개발자가 투입되는 일은 이처럼 특별한 일이 아니다. 이미 몇년간 개발과 유지보수를 이어온 프로젝트라면, 중간에 합류한 개발자에게 해당 프로젝트의 아키텍처는 복잡하게 느껴질 것이며, 봐야할 소스코드의 양도 상당할 것이다. 그런데 이를 가이드할 사람이 없다면 어떻게 해야할까? 결국 문서다. 우리가 새로운 유형의 전자제품을 구입했을때 메뉴얼을 보고 설치/사용법을 익히듯 프로젝트에 대한 개발 문서는 너무나 당연히 필요한 존재이다. 신규 개발자가 프로젝트에 투입되어서 프로젝트를 파악하는 시간을 줄일 수 있는 가장 효율적인 방법이 개발 문서인 것이다. 그래서 개발 문서는 어떻게 쓰는가?1. 친절한 설명은 비용을 낮춘다Github에 있는 오픈소스 프로젝트들을 보면, 모든 프로젝트가 첫 페이지에 README를 보여주고 있다. 이 README를 통해 이 프로젝트가 어떤 프로젝트이며, 이 프로젝트를 사용하기 위해서 어떤 절차가 필요한지를 쉽게 이해할 수 있다. Github에서 본 README 문서중 잘 정리가 된듯한 README 문서 몇가지를 예시로 사용하려고 한다. 그리고 이 문서들의 목록(ToC)을 정리해보았다. Github CLI Short description with images. Documentation(사용법) Contributing (프로젝트 기여하는 법) Installation Jsoup Short description Example Open Source (License) Getting Started Development and Support (Contact) Status (배포 상태) Tech Kakao (Archived) 설치 사용법 라이센스 주의할 점 위 3개의 문서에서 발견한 공통적인 목록은 프로젝트를 소개하는 짧은 설명과 사용법을 정리했다는 점이 공통적이다. 마지막으로 프로젝트의 라이센스를 표기함으로써 문서가 마무리된다. 중요한건 사용법이라는 생각이 든다. 얼마나 친절하게 쓰여있는지에 따라 프로젝트에 참여/실행하는 비용이 낮아진다. 문서가 불친절할수록 해당 프로젝트에 대한 접근성이 떨어지며, 이는 곧 비용의 상승으로 이어진다. 가독성 높은 README 를 작성하는 방법을 정리하는 글을 인용한다. How to Write Beautiful and Meaningful README.md 이 글에서 인상깊은 부분은 설명을 위한 이미지를 첨부하라는 것. 사실 텍스트보다 훨씬 가독성 높은건 이미지이다. 프로젝트를 실행/동작하는 스크린샷을 첨부한다면 보다 쉽게 이해할 수 있을 것이다. 프로젝트를 실행/동작시키는 방법도 GIF 포맷으로 만든다면 금상첨화일 것 같다. 2. Markdown으로 작성하기README 문서는 Markdown 기반으로 작성된다. 여기서도 Why를 물어보자. 왜 Markdown으로 작성하는가. 먼저 마크업 언어로 문서를 작성하는 이유부터 알아보자. 개인적인 추론이라는 점을 서두에 밝힌다. HTML 문서는 PDF로 export하기도 쉽고, 그 자체를 웹에 배포할 수도 있다. 따라서 확장성이 높다고 할 수 있다. 그런데 HTML 문서를 작성하는건 모두에게 쉬운 일은 아니다. 일일히 태그를 열고 닫아야 하며, CSS 까지 신경써야 한다. 여기서부터는 마크업 문서를 만들기 위해 Markdown을 사용해야하는 이유를 알아보자. Column A Column B A-value1 B-value1 A-value2 B-value2 한 예로 위와 같은 테이블을 생성한다고 하면 HTML로 작성한다고 하면 아래처럼 길게 늘어뜨려야 한다. 1234567891011121314&lt;table&gt; &lt;tr&gt; &lt;th&gt;Column A&lt;/th&gt; &lt;th&gt;column B&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;A-value1&lt;/td&gt; &lt;td&gt;B-value1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;A-value2&lt;/td&gt; &lt;td&gt;B-value2&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 고작 컬럼 2개, 로우 2개를 갖는 테이블을 생성하기 위해 이렇게 태그를 열고 닫기를 반복해야 한다면, 문서 작성을 포기하더라도 이해가 된다. 그런데 Markdown을 이용하면, 보다 쉽게 마크업 페이지를 만들어낼 수 있다. 위에서 만든 똑같은 테이블을 Markdown으로 작성해보았다. 123|Column A|Column B||A-value1|B-value1||A-value2|B-value2| 이게 Markdown을 사용해야 하는 이유이다. Markdown 문법은 Markdown Cheat Sheet를 보며 문서를 하나 직접 작성해보면 금방 익힐 수 있다. 이 글에선 문법을 나열하지는 않겠다. Markdown 에디터는 여러가지가 있지만, Typora를 추천한다. Typora를 사용하면 Preview 화면(Rendered)으로 보면서 작성할 수 있기 때문에 효율적으로 문서를 작성할 수 있다. 결론정리되지 않은 생각을 쓰면서 정리하다보니 글이 장황해졌지만, 결론은 친절한 개발 문서를 작성하는 습관을 들이자. 개발 문서는 프로젝트의 시작과 끝이 되어야 한다고 생각한다. 내가 작성한 코드가, 우리가 만든 프로젝트가 나에게만 또는 우리에게만 이해하기 쉬운 코드일지 모른다. 그러니 신규 개발자가 이 개발문서를 보고 빠르게 프로젝트를 이해할 수 있도록 친절한 개발 문서를 작성하도록 노력해야겠다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Others","slug":"Dev/Others","permalink":"http://youngjinmo.github.io/categories/Dev/Others/"}],"tags":[{"name":"documentation","slug":"documentation","permalink":"http://youngjinmo.github.io/tags/documentation/"},{"name":"readme","slug":"readme","permalink":"http://youngjinmo.github.io/tags/readme/"}]},{"title":"Lombok 라이브러리","slug":"lombok","date":"2020-11-11T00:07:06.000Z","updated":"2020-11-30T06:24:54.408Z","comments":true,"path":"2020/11/lombok/","link":"","permalink":"http://youngjinmo.github.io/2020/11/lombok/","excerpt":"","text":"ToC Why Lombok How can be change Lombok Annotations How to use Why Lombok?VO를 작성할 때면, 거의 생각하지 않고 반복적으로 작성하는 코드가 있다. getter(), Setter(), ToString() 그리고 생성자이다. VO에 정의된 필드가 많을수록 코드에 대한 가독성이 떨어질수밖에 없다. 필드 개수의 2배수만큼의 메서드 (Getter/Setter)를 생성하기 때문에 다른 메서드가 있는지 확인하려면 스크롤해서 내려가야 한다. 그러나 Lombok 라이브러리를 사용하면, Getter, Setter 메서드로 코드를 어지럽게 작성할 필요도, 생성자를 작성할 필요도 없다. 딱 필드만 남게되므로 오히려 코드의 가독성이 높아진다. How can be change?Lombok을 적용하기 전과 Lombok을 적용한 이후 어떻게 달라지는지 확인해보자. Before Lombok임의로 만들어본 VO 객체이다. 게시판을 만든다고 생각하고 게시판에 필요한 6개의 필드를 작성했으며, 이 필드를 사용하는 Getter(), Setter(), toString(), 생성자를 만들었다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package com.devandy.web.domain.vo;public class Domain &#123; private int no; private String title; private String author; private String createdDate; private String updatedDate; private int hit; public int getNo() &#123; return no; &#125; public void setNo(int no) &#123; this.no = no; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; public String getCreatedDate() &#123; return createdDate; &#125; public void setCreatedDate(String createdDate) &#123; this.createdDate = createdDate; &#125; public String getUpdatedDate() &#123; return updatedDate; &#125; public void setUpdatedDate(String updatedDate) &#123; this.updatedDate = updatedDate; &#125; public int getHit() &#123; return hit; &#125; public void setHit(int hit) &#123; this.hit = hit; &#125; @Override public String toString() &#123; return &quot;Domain [no=&quot; + no + &quot;, title=&quot; + title + &quot;, author=&quot; + author + &quot;, createdDate=&quot; + createdDate + &quot;, updatedDate=&quot; + updatedDate + &quot;, hit=&quot; + hit + &quot;]&quot;; &#125; public Domain(int no, String title, String author, String createdDate, String updatedDate, int hit) &#123; super(); this.no = no; this.title = title; this.author = author; this.createdDate = createdDate; this.updatedDate = updatedDate; this.hit = hit; &#125; &#125; 4가지 기능(Getter, Setter, toString, 생성자)을 추가했을 뿐인데, 코드가 엄~청 길어졌다..이제 Lombok을 적용해보자. After Lombok1234567891011121314151617181920package com.devandy.web.domain.vo;import lombok.AllArgsConstructor;import lombok.Getter;import lombok.NoArgsConstructor;import lombok.Setter;import lombok.ToString;@ToString@Getter @Setter@NoArgsConstructor@AllArgsConstructorpublic class Domain &#123; private int no; private String title; private String author; private String createdDate; private String updatedDate; private int hit;&#125; 코드가 획기적으로 줄어들었다! 무엇보다 좋은건 이 VO 객체가 하는 행동(?)을 직관적으로 명확하게 이해할 수 있다는 점이다. 이 Domain 이라는 VO 객체는 toString() 과 getter(), setter() 를 가지고 있으며, 인자값이 없는 기본생성자와 모든 필드를 인자값으로 갖는 생성자를 각각 갖는 VO라는 사실을 어노테이션 만으로 알 수 있다.Lombok에서 사용하는 어노테이션에 대한 설명은 아래에 정리해두었다. Lombok을 사용하기 전보다 Lombok을 사용한 이후에 VO 객체가 더 직관적으로 바뀌었으므로 왠만하면 Lombok을 사용해야 할 것 같다. Lombok Annotations@ToString자동으로 ToString() 를 사용할 수 있는 어노테이션이다. @Getter and @Setter자동으로 getter(), setter() 를 사용할 수 있는 어노테이션이다. @NoArgsConstructor인자값이 없는 기본 생성자를 사용할 수 있는 어노테이션이다. @AllArgsConstructorVO 객체에 있는 모든 필드를 인자로 받는 생성자를 사용할 수 있는 어노테이션이다. @Data@ToString, @EqualsAndHashCode, @Getter, @Setter, @RequiredArgsConstructor 를 모두 자동으로 사용할 수 있는 어노테이션이다. How to use?메이븐 프로젝트의 경우, pom.xml에 dependency를 추가하면 Lombok을 사용할 수 있다. 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.16&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 그러나 VO 객체에서 Lombok 어노테이션을 추가했음에도 불구하고, DAO나 다른 곳에서 VO 데이터를 사용하지 못하기도 하다. getNo(), getTitle() 등의 메서드를 VO 외부에서 사용했을때 불러오지 못하는 경우를 말한다. 이 땐 운영체제에 lombok.jar를 직접 설치해서 컴파일하고, Lombok을 사용중인 프로젝트의 IDE 환경에서도 lombok을 설치해주어야 한다. 이 방법은 Lombok 공식 홈페이지에서 각각의 환경에서 어떻게 Lombok을 설치하는지 확인할 수 있다. 아래는 STS(Spring Suite Tools 4.4.8)에 맞춰서 설명을 해보았다. Lombok 홈페이지에서 lombok.jar 를 설치한다. 다운받은 디렉토리에서 터미널을 실행하여 lombok.jar를 실행한다. 1java -jar lombok.jar STS의 검색창에서 [Install New Software..]를 실행한다. Work with 라고 적힌 blank에 설치할 라이브러리의 저장소 주소를 입력한다. Lombok은 https://projectlombok.org/p2 를입력하면된다. 위의 이미지처럼 주소를 정상적으로 입력했다면, 아래에 Lombok 라이브러리가 검색되는걸 확인할 수 있다. 체크박스를 체크하고 install 한다. STS를 종료하고 다시 실행하면, Lombok 어노테이션이 작동된다!","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Springboot","slug":"Dev/Springboot","permalink":"http://youngjinmo.github.io/categories/Dev/Springboot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"}]},{"title":"SpringBoot + MyBatis + Oracle 초간단실습","slug":"springboot-mybatis-oracle","date":"2020-10-25T03:29:51.000Z","updated":"2020-11-30T02:05:01.252Z","comments":true,"path":"2020/10/springboot-mybatis-oracle/","link":"","permalink":"http://youngjinmo.github.io/2020/10/springboot-mybatis-oracle/","excerpt":"","text":"JPA를 공부하기 전에 먼저 MyBatis로 서버를 셋팅하는걸 해보고 싶었다. 지난해 학원에서 교육받을때는 실력있는 팀원이 해주셔서 내가 직접 해본 경험이 없었다. 이 실습의 목적은 스프링부트로 만든 서버에서 MyBatis로 오라클에 쿼리를 던져서 조회하는 실습을 해볼 것이다. DB는 도커(Docker) 로 오라클 컨테이너를 생성해서 이용할 것이며, 커맨드라인에서 SQL PLUS 을 통해 테이블을 생성하고, 데이터를 삽입한다. 서버는 스프링부트(Spring Boot) 로 생성하며, MVC 패턴으로 생성한다. DB 생성하기 Spring Boot 서버 생성하기 Postman으로 API 호출하기 소스코드 @Github DB 생성하기도커 컨테이너 접속해서 SQL PLUS 실행하기 12$ docker start oralce11g$ docker exec -it oracle11g bash 1root@a0ddd3dd3495: /# sqlplus 테이블 생성하기123456CREATE TABLE members( id number PRIMARY KEY, name varchar2(20), job varchar2(20), loc varchar2(30)); id값에 INSERT할 때 사용하기 위한 SEQUENCE 생성하기 123456CREATE SEQUENCE id_seq -- 시퀀스 이름INCREMENT BY 1 -- 시퀀스 증감 숫자START WITH 1 -- 시퀀스 시작 숫자MINVALUE 1 -- 최솟값MAXVALUE 100 -- 최댓값NOCYCLE; -- 순환하지 않음 테이블에 값 추가하기 12345678910111213141516INSERT INTO members(id, name, jon, loc)VALUES (id_seq.nextval, &#x27;Sam&#x27;, &#x27;Athelete&#x27;, &#x27;Seoul&#x27;);INSERT INTO members(id, name, jon, loc)VALUES(id_seq.nextval, &#x27;Andy&#x27;, &#x27;Programmer&#x27;, &#x27;Kyonggi&#x27;);INSERT INTO members(id, name, jon, loc)VALUES(id_seq.nextval, &#x27;Nani&#x27;, &#x27;Mechanical Engineer&#x27;, &#x27;Seoul&#x27;);INSERT INTO members(id, name, jon, loc)VALUES(id_seq.nextval, &#x27;Gil&#x27;, &#x27;Fashion MD&#x27;, &#x27;Seoul&#x27;);INSERT INTO members(id, name, jon, loc)VALUES(id_seq.nextval, &#x27;Tom&#x27;, &#x27;Reporter&#x27;, &#x27;Seoul&#x27;);COMMIT; Spring Boot 서버 생성하기 프로젝트 생성하기 application.properties에 Datasource 설정 추가하기 VO 생성하기 DAO 생성하기 Mapper 생성하기 (Oracle 쿼리) Service 생성하기 Controller 생성하기 프로젝트 생성하기[Spring Start Project] 로 생성하고, Dependency로 Spring Web, Lombok, MyBatis Framework, Oracle Driver 을 주입한다. 프로젝트의 패키지 구조는 다음과 같다. application.properties에 Datasource 설정 추가하기먼저 MyBatis Mapper와 DBMS에 대한 Datasource 설정을 application.properties에서 한다. 본 파일은 /src/main/resources에 위치해있다. 1234567891011# Setting for Oraclespring.datasource.driver-class-name=oracle.jdbc.driver.OracleDriverspring.datasource.url=jdbc:oracle:thin:@localhost:1521/xespring.datasource.username=[db-user-name]spring.datasource.password=[db-user-password]# VO locationmybatis.type-aliases-package=com.devandy.web.vo# XML locationmybatis.mapper-locations=classpath:mappers/**/*.xml VO 생성하기데이터를 오브젝트 형태로 담아놓을 VO를 생성한다. 경로 : /src/main/java/com/devandy/web/vo파일명 : MemberVO.class 12345678910111213141516171819package com.devandy.web.vo;import com.fasterxml.jackson.annotation.JsonProperty;import lombok.Data;@Datapublic class MemberVO &#123; @JsonProperty private int id; @JsonProperty private String name; @JsonProperty private String job; @JsonProperty private String home;&#125; Getter/Setter 메서드를 자동으로 생성해주는 Lombok 라이브러리의 @Data 어노테이션을 클래스 위에 작성한다. 그리고 Postman으로 Json 형식으로 데이터를 호출할것이므로 VO 각 필드위에 @JsonProperty 라는 어노테이션도 추가해준다. 이 어노테이션을 붙이지 않으면, API를 호출하는 과정에서 Serializable(직렬화) 에러가 발생한다. DAO 생성하기DB에 쿼리를 던지는 MyBatis Mapper 클래스를 생성하는 단계이다. DAO 안에 실제 쿼리까지 포함시킬수 있으나 인터페이스와 Mapper를 분리했다. 경로 : src/main/java/com/devandy/web/dao파일명 : MemberDAO.class 12345678910package com.devandy.web.dao;import java.util.List;import org.apache.ibatis.annotations.Mapper;import com.devandy.web.vo.MemberVO;@Mapperpublic interface MemberDAO &#123; public List&lt;MemberVO&gt; selectAllMembers();&#125; Mapper 작성하기 (Oracle 쿼리)DAO를 구현하는 xml이다. 실제로 던지는 쿼리를 작성한다. 경로 : /src/main/resources/mappers/member파일명 : SelectSQL.xml 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.devandy.web.dao.MemberDAO&quot;&gt; &lt;select id=&quot;selectAllMembers&quot; resultType=&quot;MemberVO&quot;&gt; SELECT ID, NAME, JOB, LOC FROM MEMBERS &lt;/select&gt;&lt;/mapper&gt; Mapper 태그안의 namespace 를 통해 MyBatis가 맵핑할 이 쿼리가 어떤 DAO에서 호출될 것인지 명시한다. Mapper 태그 내부에는 쿼리의 타입으로 SELECT 인지, INSERT 인지를 명시하고, id는 DAO에서 해당 쿼리를 implement하는 메서드명을 작성해준다. resultType 은 DAO 메서드를 통해 반환받을 타입을 작성한다. 위의 쿼리를 단순히 MEMBERS라는 테이블을 조회하는 쿼리이므로, 반환받을 데이터는 VO 객체에 해당한다. 따라서 resultType 으로 VO 명을 작성한다. 정리하면, 위의 쿼리는 MemberDAO.class 의 selectAllMembers() 를 구현하는 쿼리이며, 쿼리의 결과로 VO를 반환받는 객체이다. Service 생성하기Service 클래스는 MVC 패턴에서 Controller에의해 호출되며, 앞서 생성한 DAO를 호출하는 클래스이다. 경로 : src/main/java/com/devandy/web/service파일명 : MemberService.class 12345678910111213141516171819package com.devandy.web.service;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.devandy.web.dao.MemberDAO;import com.devandy.web.vo.MemberVO;@Servicepublic class MemberService &#123; @Autowired MemberDAO memberDao; public List&lt;MemberVO&gt; selectAllMembers() &#123; return memberDao.selectAllMembers(); &#125;&#125; Controller 생성하기드디어 API를 호출하는 컨트롤러를 생성한다. 123456789101112131415161718192021222324package com.devandy.web.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.ResponseBody;import com.devandy.web.service.MemberService;import com.devandy.web.vo.MemberVO;@Controllerpublic class APIcontroller &#123; @Autowired MemberService memberService; @GetMapping(&quot;/members&quot;) public @ResponseBody List&lt;MemberVO&gt; selectListMembers() &#123; List&lt;MemberVO&gt; allMembers = memberService.selectAllMembers(); return allMembers; &#125;&#125; /members라는 API를 호출하는 selectListMembers()라는 메서드를 생성했다. 웹페이지를 반환하는게 아니라 Json 형식으로 데이터를 반환받을 것이므로 메서드의 리턴타입은 @ResponseBody 로 한다. 그리고 제네릭타입으로 MemberVO 를 갖는 List를 생성해서 List에 memberService 의 selectAllMembers() 호출 결과를 담는다. 메서드의 리턴타입으로 이 List를 받으면, Postman을 통해 Json으로 데이터를 받을 수 있을 것이다. Postman으로 API 호출하기Postman은 API를 테스트할 수 있는 애플리케이션이다. Postman을 사용하면, 파라미터(param)나 인증(Authorization), Header 등을 변경해서 간편하게 API를 호출하는 테스트를 해볼수 있다. GET 메서드로 http://localhost:8080/members 로 API를 호출해보니 오라클에서 작성한 테이블의 데이터가 정상적으로 JSON형식으로 반환받는 것을 확인할 수 있다. Github에 소스코드를 올려두었다.https://github.com/youngjinmo/MyBatisOraclePractice","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Springboot","slug":"Dev/Springboot","permalink":"http://youngjinmo.github.io/categories/Dev/Springboot/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"docker","slug":"docker","permalink":"http://youngjinmo.github.io/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://youngjinmo.github.io/tags/springboot/"},{"name":"mybatis","slug":"mybatis","permalink":"http://youngjinmo.github.io/tags/mybatis/"}]},{"title":"Github 디폴트 브랜치, Main으로 전환하기","slug":"github-branch-to-main","date":"2020-10-22T02:27:46.000Z","updated":"2020-10-26T05:52:33.327Z","comments":true,"path":"2020/10/github-branch-to-main/","link":"","permalink":"http://youngjinmo.github.io/2020/10/github-branch-to-main/","excerpt":"","text":"인종차별 이슈가 불거지며 테크 업계에서도 자성의 목소리가 나기 시작했다.아래의 권고사항을 통해 인종차별적인 용어를 사용하지 않기위해 노력해야겠다. Before After Master Leader, Primary Slave Follower, Replica Whitelist Allowlist Blacklist Denylist 기술 용어중 인종차별적인 용어들이 일부 있었는데, Github에서 가장 먼저 이를 바꾸는 움직임을 보였다. Github의 디폴트 브랜치는 지금까지 Master라고 했었으나 10월부터는 디폴트 브랜치명이 Main으로 바뀐다. 본 포스트는 10월 전까지 생성한 레포지토리에 대한 디폴트 브랜치를 Main으로 바꾸는 법을 정리해보았다. Breonna Taylor, George Floyd, Ahmaud Arbery, Tony McDade, and countless others deserve justice. We extend our support to Black Hubbers and Black developers. GitHub stands with the Black community in the fight against racism and injustice, and will continue to take action.&mdash; GitHub (@github) June 7, 2020 지금까지는 사용하던 저장소의 디폴트 브랜치이름을 master라고 불렀는데, 이 디폴트 브랜치이름을 더 직관적이면서 인종차별적인 의미를 제거하는 차원에서 main 으로 바꾸기로 결정되었다. 그럼 이제 디폴트 브랜치를 main 으로 바꾸는법을 알아보겠다. Github 원격 저장소 디폴트 브랜치 변경하기Github의 레포지토리 설정에서 디폴트 브랜치를 바꿀수 있다.[Settings] - [Branches] 를 들어가면 아래와 같은 화면에서 바꿀수 있다. 여기에서 Master 를 main 으로 바꾸고 Update 버튼을 클릭하면 레포지토리의 디폴트 브랜치명이 변경된다. 로컬 저장소 디폴트 브랜치 변경하기로컬 환경에서는 어떻게 브랜치명을 바꿀수 있을까 Git 2.28 부터 브랜치를 디폴트 브랜치를 main으로 바꿀수 있게 되었다. 따라서 우선 git부터 2.28 버전으로 업데이트를 하자. 1$ brew upgrade git git config에서 디폴트 브랜치를 main으로 바꾸는 명령어가 필요하다. 1$ git config --global init.defaultBranch main 이후부터 git init 으로 로컬에서 레포지토리를 생성하면 디폴트 브랜치가 main 브랜치로 생성될 것이다. 이미 생성한 프로젝트의 디폴트 브랜치 변경하기기존에 디폴트 브랜치로 master 를 쓰고 있는 프로젝트도 main 으로 변경할 수 있다. 12$ git checkout -B main$ git push -u origin main 따로 생성하지 않아도 checkou 으로 main 브랜치 이동이 가능하다. 이 상태에서 원격 저장소에 push 하면 원격저장소에서 main브랜치가 올라간걸 확인할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[{"name":"github","slug":"github","permalink":"http://youngjinmo.github.io/tags/github/"},{"name":"blacklivesmatter","slug":"blacklivesmatter","permalink":"http://youngjinmo.github.io/tags/blacklivesmatter/"}]},{"title":"뉴욕타임즈에 투자하다","slug":"why-i-invested-nyt","date":"2020-09-22T03:29:45.725Z","updated":"2020-09-22T03:29:45.725Z","comments":true,"path":"2020/09/why-i-invested-nyt/","link":"","permalink":"http://youngjinmo.github.io/2020/09/why-i-invested-nyt/","excerpt":"","text":"어젯밤 오랜만에 주식을 좀 샀다. 국내증시는 너무 올랐고, 미국증시도 만만찮게 올랐는데 평소에 관심있게 보던 회사의 기사가 자꾸 생각나서 소액 투자해보았다. 새로운 시대가 요구하는 미디어지난 달에 이런 기사를 읽었다.조선비즈 - 美 유료구독 1위 뉴욕타임스, 디지털 매출이 종이신문 추월 뉴욕타임즈가 이번 2분기 실적에서 최초로 디지털 부문 매출이 종이신문 매출을 추월했다고 한다. 2010년 이후에 재개한 유료 서비스에서 발생한 매출이 100년이 넘는 시간동안 판매한 종이신문 매출을 추월한데에는 구독 서비스에 익숙한 밀레니얼 세대의 문화와 더불어 최근 발생한 팬데믹이라는 이벤트가 기인한 것으로 보여진다. 뉴욕타임즈는 미국에서 디지털 전환을 가장 빨리 한 회사이기도 하다. 2011년쯤 유료 서비스를 론칭하였으며, 지난해에는 전체 유료구독자 490만명중 온라인으로 400만명을 유치했다고도 한다.(출처) 그래서 난 왜 미디어에 투자했나전대 미문의 팬데믹에서 사람들은 모두 혼란스러워했고, 가짜 뉴스가 트위터, 유튜브 등을 통해 빠르게 퍼져나가기 시작했다. 뭐가 진짜이고, 뭐가 가짜인지 분별하기 힘든 시대이다. 이럴 때일수록 정보의 출처, 신뢰할만한 정보에 대한 수요가 커질거라고 생각한다. 이제 누구나 손 안의 휴대폰으로 언제 어디서나 원하는 정보를 찾을 수 있는 세상이 되었다. 이젠 정보의 양이 아닌, 정보의 질이 더 중요한 시대이다. 어떤 정보를 갖고있는지보다 얼마나 신뢰도 높은 정보를 갖고있는지가 훨씬 더 중요해지고 있다. 우리의 취향을 파악해서 큐레이션하는 알고리즘은 확증 편향성을 부각시켜, 가짜뉴스에 파묻혀있는 사람은 계속 알고리즘에 의해 가짜뉴스에만 갇히고있다. 최근에 내가 어떻게 정보를 소비중인지 생각해보니 다양한 분야의 정보를 소셜미디어 플랫폼으로 접하기보다 각각의 전문 미디어 스타트업을 통해 구독중인데, 이유는 믿을만한 정보의 출처, 즉 ‘신뢰’ 때문이다. 믿을 수 있는 정보를 소비할 수 있다는 측면에서 이들 서비스가 유료화를 한다하더라도 구독을 유지할 생각이다. 신뢰받는 미디어만이 할 수 있는 도전뉴욕타임즈의 디지털 전환 성공은 단순히 시대가 부합하는 모델을 잘 적용해서 성공한 것으로 볼 수만은 없다. 모든 미디어가 뉴욕타임즈처럼 성공하길 원할 수 있지만, 독자들로부터의 신뢰를 얻지못하면 이같은 디지털 전환은 불가능하다.포털에 올려서 그저 클릭을 유발하는 기사를 생산하는 매체들은 감히 시도할 수 없는 도전이다. 국내에서도 뉴욕 타임즈처럼 광고가 아닌 컨텐츠로 수익화를 시도하는 시도가 이뤄지고 있다. 이런 도전은 기성 매체가 아닌 오히려 뉴닉, 듣똑라같은 스타트업들이 주도하고 있다. 이들이 밀레니얼 세대에게 선택받은 이유는 단지 힙해서 또는 ‘모바일 프렌들리’ 하기 때문은 아닐 것이다. 나는 미국의 뉴욕타임즈, 한국에선 듣똑라처럼 컨텐츠로 돈을 버는 새로운 미디어들의 도전을 환영한다. 항상 관심있게 지켜보고 있으며, 소액이지만 뉴욕타임즈의 주주가 된만큼 앞으로도 미디어 산업이 어떻게 바뀌는지 계속 지켜볼 예정이다. 아래 기사는 뉴욕타임즈의 최근 실적에 대한 아티클이다.(출처 : NYT)NYT - Digital Revenue Exceeds Print for 1st Time for New York Times Company 2분기에 신규가입자 증가폭이 역대 최다였고, 이에 힘입어 디지털 매출이 늘어나며 종이신문 매출을 처음으로 추월했다고.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"stock","slug":"stock","permalink":"http://youngjinmo.github.io/tags/stock/"}]},{"title":"첫 오픈소스 기여","slug":"github-contribution","date":"2020-09-18T06:20:21.000Z","updated":"2020-10-22T12:20:50.971Z","comments":true,"path":"2020/09/github-contribution/","link":"","permalink":"http://youngjinmo.github.io/2020/09/github-contribution/","excerpt":"","text":"뭐 엄청 작은부분이지만, 그래도 첫 오픈소스 기여를 기념하여 그 과정을 기록한다. 오픈소스를 기여하는 방법은 4가지 정도로 생각할 수 있다. 오픈소스 프로젝트 후원하기 문서 번역하기 버그 수정해서 PR하기 새로운 기능 제안하기 난 이 중 2번인 문서 번역을 선택했다. 막연히 오픈소스에 기여해보고 싶던차에 1년 넘게 잘 사용하고 있는 깃헙 블로그 테마인 Hueman 프로젝트를 살펴봤다. 아직까지 사용하며 버그를 발견하지는 못했고, 새로운 기능을 제안하기 앞서 먼저 문서를 살펴봤다. 여러가지 언어를 지원하는데, 한글 컨텐츠 중에 일부가 번역이 되있지 않은걸 확인했다. 그래서 이 부분을 번역해서 PR하기로 했다. 그럼 이제부터 오픈소스에 참여하는 절차를 정리해보자. 저장소 fork하기 로컬에 프로젝트 clone 개발 하기 Commit &amp; Push Pull Request Merge 1. 저장소 fork하기참여하고 싶은 오픈소스 저장소를 내 github 저장소로 fork를 한다. 우측 상단에 보면 fork버튼이 있다. 이걸 클릭하면 내 저장소로 저장소를 그대로 복제한다. Github CLI 명령어는 다음과 같다. 1$ gh repo fork [repository][flags] fork한 이후 생긴 저장소이다. 2. 로컬에 프로젝트 clone이제 저장소를 로컬환경으로 clone한다. 1$ gh repo clone &lt;repository&gt; [&lt;directory&gt;] [-- &lt;gitflags&gt;...] 3. 개발하기내가 한 작업은 개발이 아닌 번역 수준이지만, 어쨋든 코드를 작성한다. 4. Commit &amp; Push혼자만 볼게 아니라 나중에 프로젝트 관리자가 리뷰를 할 것이므로 가급적이면 커밋도 작게 나누도록 하자. 1$ git commit -am &quot;commit-message&quot; &amp;&amp; git push -u origin [branch-name] 5. Pull Requestpush한 저장소로 웹에 접속하면, 아래의 이미지처럼 오리지널 저장소와 비교하고 Pull Request할 수 있는 버튼이 활성화된걸 볼 수 있다. 개발자분이 쉽게 이해하실수 있도록 신경써서 PR 메세지를 작성하도록 하자. 당연히 Github CLI로도 PR을 할 수 있다. 1$ gh pr create [flags] 오픈소스 저장소 Pull Request에 들어가면 방금 올린 PR을 확인할 수 있다. 1$ gh pr list 이제 커밋이 Merge되거나 거절당할때까지 기다리면 된다. 6. MergeMerge되면 아래처럼 PR 라벨이 Open에서 Merged로 변경된다. 이렇게 저장소의 Contributor에 이름도 추가되었다! 비록 번역 몇 단어한 것에 불과하지만 첫 오픈소스 기여여서 기념차 작성한 포스팅이다. 나중엔 버그를 잡아보거나 새로운 기능을 제안하는 PR도 해보고 싶다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[{"name":"github","slug":"github","permalink":"http://youngjinmo.github.io/tags/github/"},{"name":"contribution","slug":"contribution","permalink":"http://youngjinmo.github.io/tags/contribution/"}]},{"title":"XML, JSON 그리고 XMLHttpRequest","slug":"xml-json-xmlhttprequest","date":"2020-09-01T03:00:59.000Z","updated":"2020-09-13T01:53:27.932Z","comments":true,"path":"2020/09/xml-json-xmlhttprequest/","link":"","permalink":"http://youngjinmo.github.io/2020/09/xml-json-xmlhttprequest/","excerpt":"","text":"웹에서 API로 통신을 할 때 데이터를 전달받는 형식이 있다. XML과 JSON이 그 형식들이다. Ajax나 API로 요청하고 데이터를 받을때, JSON으로 데이터가 넘어오고 하는데, 한 번 정리하고 넘어가고 싶어서 정리한 글이다. JSON과 XML은 데이터 통신을 위해 고안된 형식이라고 한다. 그래서 자바, 파이썬 같은 프로그래밍 언어에 의해 파싱될 수 있으며, 계층적 구조(Hierarchical Structure)를 갖고 있다. XMLHTML과 유사한 마크업 언어이다. 데이터를 저장하고, 전달할 목적으로 고안되었다. 123456&lt;dog&gt; &lt;name&gt;식빵&lt;/name&gt; &lt;family&gt;웰시코기&lt;family&gt; &lt;age&gt;1&lt;/age&gt; &lt;weight&gt;2.14&lt;/weight&gt;&lt;/dog&gt; dog라는 객체의 name 속성으로 식빵, family 속성으로 웰시코기, age 속성으로 1, weight 속성으로 2.14를 반환하는 데이터이다. JSONXML과 마찬가지로 데이터 저장과 전달을 목적으로 고안되었으며, 자바 스크립트 기반으로 작성되었다. XML의 대안으로서 고안되었으며, XML 대비 더 직관적이며, 작성하기 편리하다는 특징이 있다. 또 배열을 파싱할 수 없는 XML과 달리 JSON은 배열을 사용할 수 있다. JSON은 key와 value가 한 쌍을 이루는 구조의 객체로 구성되어 있다. 123456&#123; &quot;name&quot;: &quot;식빵&quot;, &quot;family&quot;: &quot;웰시코기&quot;, &quot;age&quot;: 1, &quot;weight&quot;: 2.14&#125; 위의 XML로 전달받은 동일한 객체를 JSON으로 전달받았을때 볼 수 있는 코드이다. name, family, age, weight가 key가 되며, 각각의 key에 해당하는 value가 식빵, 웰시코기, 1, 2.14에 해당한다. XML이 XML Parser로 파싱을 한다면, JSON은 자바스크립트 표준함수인 eval()로 파싱한다고 한다. 함께 읽어보면 좋은 문서 JSON 개요 XML이든 JSON이든 결국 XMLHttpRequest 객체를 사용해서 동작한다. XMLHttpRequest에 대해서도 알아보도록 하자. XMLHttpRequestXMLHttpRequest는 서버와 상호작용(동기/비동기)하기 위하여 사용하는 객체이다. WebAPI의 인터페이스중 하나이다. 페이지의 Reload없이도 웹서버로부터 데이터를 가져올 수 있기 때문에 Ajax에서 주로 사용된다고 한다. XML과 JSON 모두 XMLHttpRequest 객체를 이용하여 서버에서 데이터를 전송받는다. 주요 속성과 메서드는 MDN 공식문서를 통해 확인가능하다. XMLHttpRequest를 이용한 데이터 전송을 하는 예제 코드이다. 12345678910111213141516function loadDoc() &#123; // XMLHttpRequest 객체를 생성 var xmlHttp = new XMLHttpRequest(); // onreadystatechange 이벤트 핸들러 생성 xmlHttp.onreadyStatechange = function() &#123; // 서버에 문서가 존재하고, 요청한 데이터의 처리가 완료되어 응답 준비가 완료되었을때 if(this.status == 200 &amp;&amp; this.readyState == this.DONE)&#123; // 요청한 데이터를 문자열로 반환 document.getElementById(&quot;parseText&quot;) = xmlHttp.responseText; &#125; &#125;; // 요청 초기화 xmlHttp.open(&quot;GET&quot;, &quot;/data.txt&quot;, true); // 요청을 실행. 기본값은 비동기(Asynchronous) 요청 직후 즉시 반환. xmlHttp.send();&#125; 위에서 사용한 XMLHttpRequest의 속성은 다음과 같다. XMLHttpRequest.onreadystatechange readyState 속성(attribute)이 변경될때마다 호출되는 이벤트핸들러 XMLHttpRequest.status 요청의 응답 상태를 갖는 unsigned short를 반환 XMLHttpRequest.readyState 요청의 상태를 unsigned short로 반환 XMLHttpRequest.responseText 요청에 대한 응답을 텍스트로 갖는 DOMString을 반환. 요청에 실패할 경우 null 반환 XMLHttpRequest.open() 요청을 초기화하는 메서드. XMLHttpRequest.send() 요청을 보낸다. 요청이 비동기(default)일 경우, 요청 직후 즉시 반환하는 메서드. 출처 : MDN - XMLHttpRequest 왜 JSON을 사용해야 하는가?XMLHttpRequest를 사용해서 데이터를 통신할 경우 배열 객체를 전달받고 사용하는 일이 까다로워질 수 밖에 없다. XMLHttpRequest.responseText는 문자열을 반환하므로 이를 사용하기 위해서는 , 를 중심으로 문자열을 나눠야한다. 그러나 JSON을 사용하면 배열 자체를 사용할 수 있기 때문에 번거로운 파싱작업을 할 필요가 없어진다. 또 XML 대신 최근에 JSON만을 사용하는 이유로는 JSON은 XML처럼 엔드 태그가 존재하지 자바스크립트로 간단히 작성할 수 있으며, 더 가볍기 때문이다. 또한 XML로는 배열을 표현하는데 한계가 있지만, JSON은 그렇지 않다는 특징도 있다. Reference TCPSchool - JSON과 XML: TCPSchool - XMLHttpRequest MDN - XMLHttpRequest MDN - Using XMLHttpRequest","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Others","slug":"Dev/Others","permalink":"http://youngjinmo.github.io/categories/Dev/Others/"}],"tags":[{"name":"xml","slug":"xml","permalink":"http://youngjinmo.github.io/tags/xml/"},{"name":"json","slug":"json","permalink":"http://youngjinmo.github.io/tags/json/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://youngjinmo.github.io/tags/XMLHttpRequest/"}]},{"title":"Oracle - Sequence 생성하고 테이블에 삽입하기","slug":"create-table-sequence","date":"2020-08-31T09:57:13.000Z","updated":"2020-09-13T01:53:29.136Z","comments":true,"path":"2020/08/create-table-sequence/","link":"","permalink":"http://youngjinmo.github.io/2020/08/create-table-sequence/","excerpt":"","text":"시퀀스를 생성하고, 이 시퀀스를 적용한 데이터 필드를 테이블에 삽입하는 쿼리이다. 시퀀스 생성12345CREATE SEQUENCE seqSTART WITH 1INCREMENT BY 1NOMAXVALUENOMINVALUE; 생성한 시퀀스 확인하기12SELECT *FROM USER_SEQUENCES; 테이블 생성하기1234CREATE TABLE User ( seq id PRIMARY KEY, name varchar2(10)); 데이터 삽입하기123456INSERT INTO User(id, name)VALUES(seq.NEXTVAL, &#x27;devandy&#x27;);INSERT INTO User(id, name)VALUES(seq.NEXTVAL, &#x27;devjoyce&#x27;);INSERT INTO User(id, name)VALUES(seq.NEXTVAL, &#x27;devkami&#x27;); 테이블 조회하기12SELECT *FROM User; 테이블에서 현재 시퀀스 조회하기12SELECT seq.CURVALFROM User; Referencehttps://hellogk.tistory.com/33","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"}]},{"title":"Servlet - Redirect와 Forward","slug":"servlet-redirect-forward","date":"2020-08-30T13:32:44.000Z","updated":"2020-11-19T03:27:37.080Z","comments":true,"path":"2020/08/servlet-redirect-forward/","link":"","permalink":"http://youngjinmo.github.io/2020/08/servlet-redirect-forward/","excerpt":"","text":"Redirect 위의 이미지를 설명하면, 리다이렉트는 클라이언트가 redirect01.jsp를 요청했더니 웹서버로부터 반환된 내용에 리다이렉트 내용이 있어서 웹서버로 다시 요청, 웹서버에서 최종적으로 redirect02.jsp를 반환하는 과정이다. 리다이렉트를 현실에서 비유를 들자면, 휴대폰 관련 상담을 위해 고객상담센터에 연락을 했다고 가정해보자.휴대폰 보험 관련 문의를 위해 고객상담센터에 전화했더니 센터에서는 해결을 못하니 보험 회사로 직접 연락하라며 번호를 알려주었다. 이 번호로 다시 연락해서 보험 상담원과 연결이 되었다. 이렇게 클라이언트가 처음 요청과 다른 요청을 해서 2번의 요청을 통해 연결되는 상황을 리다이렉트라고 할 수 있다. 결과적으로 브라우저를 통해 페이지 로드가 한 번 되는것처럼 보이지만, 사실은 클라이언트와 웹서버간 통신이 각각 2번씩 이뤄진다는 점 이다. 클라이언트가 웹서버에 2번의 요청을 하는 것이다. 클라이언트 &gt;&gt; 웹서버(redirect) &gt;&gt; 클라이언트(redirect) &gt;&gt; 웹서버 &gt;&gt; 클라이언트 예제코드RedirectFirst.class 12345678910111213141516171819202122232425import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class redirect01 */@WebServlet(&quot;/redirect-first&quot;)public class RedirectFirst extends HttpServlet &#123; private static final long serialVersionUID = 1L; public redirectFirst() &#123; super(); &#125; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; PrintWriter out = response.getWriter(); out.println(&quot;Hello Servlet 01&quot;); response.sendRedirect(&quot;/redirect-second&quot;); &#125;&#125; RedirectSecond.class 12345678910111213141516171819202122232425262728import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class redirect01 */@WebServlet(&quot;/redirect-second&quot;)public class RedirectSecond extends HttpServlet &#123; private static final long serialVersionUID = 1L; public redirectSecond() &#123; super(); &#125; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;Hello Servlet 02&quot;); &#125;&#125; 서블릿 클래스를 생성한 예제 코드이다. /redirect-first 라는 API로 요청이 들어오면, HttpServletResponse의 sendRedirect()를 이용하여 /redirect-second API로 요청을 리다이렉트하는 코드이다. 결국 화면에 Hello Servlet 02가 출력된다. HttpServletResponse의 sendRedirect()에 대해 더 알아보자. 아래 포워드에서 비교해서 알 수 있겠지만, 리다이렉트는 sendRedirect() 함수가 호출되는 시점에 페이지를 바로 이동하는게 아니라 서블릿 클래스 내에 코드가 모두 실행되고 반환될 때, 웹서버의 서블릿 클래스가 클라이언트의 요청을 바꿔서 다시 요청받는거다. HTTP Header의 Status Code를 301(Permanently) 또는 302(Temporarily)로 바꿔서 반환한다. 그래서 바뀐 Header값으로 클라이언트가 웹서버에 재요청하여 다른 페이지를 반환받는 것이다. 이게 리다이렉트 과정이다. Forward 포워드는 클라이언트가 웹서버에 forward01.jsp를 요청했더니 forward01.jsp에서 작성된 코드에의해 포워딩되어 forward02.jsp를 반환하는걸 의미한다. 결과적으로 위에서 설명한 리다이렉트와 비슷하지만, 클라이언트와 서버간 통신이 각각 1번씩이라는 점에서 다르다. 이번에도 현실에서 비유를 들어보겠다.고객상담센터에 전화를 걸어서 요금 관련 문의를 했더니, 잠시만 기다려달라고 하더니 저절로 요금 관련 상담원으로 전화연결이 바뀌었다. 전화를 끊고 다시 한것도 아닌데 고객상담센터에서 내 전화를 요금 관련 상담원으로 연결해준 것이다. 이처럼 클라이언트는 한 번의 요청을 했지만, 서버에서 페이지를 바꿔서 반환하는 것을 포워딩이라고 한다. 포워드는 다른 서버와는 할 수 없고, 클라이언트가 처음 요청한 서버내에서 다른 클래스를 전달할 수 있다. 또한 포워딩하는 과정에서 처음 요청받은 서블릿 클래스의 request와 response도 함께 포워딩할 수 있다는 특징이 있다. 클라이언트 &gt;&gt; 웹서버(forward) &gt;&gt; 웹서버(forwared) &gt;&gt; 클라이언트 예제코드FrontServlet.class 12345678910111213141516171819202122232425262728import java.io.IOException;import javax.servlet.RequestDispatcher;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class FrontServlet */@WebServlet(&quot;/front&quot;)public class FrontServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public FrontServlet() &#123; super(); &#125; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; int randNum = (int)(Math.random() * 6) +1; req.setAttribute(&quot;rand&quot;, randNum); RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/forward&quot;); requestDispatcher.forward(req, resp); &#125;&#125; BackServlet.class 1234567891011121314151617181920212223242526272829303132333435import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class BackServlet */@WebServlet(&quot;/forward&quot;)public class BackServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public BackServlet() &#123; super(); &#125; protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(&quot;text/html&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); PrintWriter out = response.getWriter(); out.println(&quot;&lt;html&gt;&quot;); out.println(&quot;&lt;head&gt;&lt;title&gt;form&lt;/title&gt;&lt;/head&gt;&quot;); out.println(&quot;&lt;body&gt;&quot;); int rand = (int)request.getAttribute(&quot;rand&quot;); out.println(&quot;랜덤 수 : &quot;+rand); out.println(&quot;&lt;/body&gt;&quot;); out.println(&quot;&lt;/html&gt;&quot;); &#125;&#125; /front 로 요청이 들어오면, FrontServlet.class 에서 랜덤 숫자를 생성했다. 이렇게 생성한 숫자를 포워딩할 클래스에 보내려면, HttpServletRequest의 setAttribute()와 RequestDispatcher의 forward()를 사용해야한다. 12int randNum = (int)(Math.random() * 6) +1;req.setAttribute(&quot;rand&quot;, randNum); 생성된 랜덤 숫자를 “rand”라는 이름으로 attribute에 넣는다. 이렇게 저장된 attribute를 포워딩하는 서블릿 클래스로 보낼때 사용하는 객체가 RequestDispatcher이다. 12RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;/forward&quot;);requestDispatcher.forward(req, resp); /forward 로 요청을 포워딩하는 RequestDispatcher를 생성하고, RequestDispatcher의 forward() 파라미터에 request와 response를 넣으면, 포워딩되는 클래스에 request와 response를 함께 보내준다. 이 request 객체에 attribute가 있기 때문에 RequestDispatcher.forward() 파라미터에 request와 response를 주입하는 것이다. 123456response.setContentType(&quot;text/html&quot;);response.setCharacterEncoding(&quot;UTF-8&quot;);PrintWriter out = response.getWriter();int rand = (int)request.getAttribute(&quot;rand&quot;);out.println(&quot;랜덤 수 : &quot;+rand); 그럼 포워딩되는 서블릿 클래스에서 API 요청을 받아서 랜덤숫자가 저장된 attribute를 화면에 출력하는 코드이다. RequestDispatcher 객체는 HttpServletRequest에서 제공하는 객체며, forward()와 include() 2개의 메서드를 가지고 있다. 출처 : 생활코딩 - JSP/서블릿 훑어보기 Reference edwith - 웹 프로그래밍 Outsider’s Dev Story - response.sendRedirect()에 대해서…","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://youngjinmo.github.io/tags/servlet/"}]},{"title":"Leetcode - Twosum","slug":"leetcode-twosum","date":"2020-08-24T05:28:47.000Z","updated":"2020-09-13T01:53:28.332Z","comments":true,"path":"2020/08/leetcode-twosum/","link":"","permalink":"http://youngjinmo.github.io/2020/08/leetcode-twosum/","excerpt":"","text":"TwoSum Problem Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the *same* element twice. 주어진 int형 배열에서 2개의 수를 더했을때 특정값(target)이 되는 배열의 인덱스를 반환하는 문제이다. Example1234Given nums &#x3D; [2, 7, 11, 15], target &#x3D; 9,Because nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9,return [0, 1]. Solution12345678910111213141516class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] returnValue = new int[2]; for(int i=0; i&lt;nums.length-1; i++)&#123; for(int j=1; j&lt;nums.length; j++)&#123; if(i!=j &amp;&amp; nums[i]+nums[j]==target)&#123; returnValue[0] = i; returnValue[1] = j; &#125; &#125; &#125; return returnValue; &#125;&#125; 오랜만에 알고리즘 문제를 풀어봤다. 올초만 하더라도 1일1백준을 했었는데, 취업 준비를 하며 알고리즘 문제를 전혀 안풀어봤었다. 그러다 이렇게 아예 손놓으면 나중에 더 힘들어지겠다 싶어서 점심시간에 잠시 짬내서 leetcode 문제를 풀어보았다. 간단한 문제였다. int형 배열을 반복문으로 더해보며 target에 해당하는 연산결과가 나오면 해당 인덱스들을 새로운 int형 배열에 담아서 반환하면 되는 문제였다. 문제 풀이 결과 코드는 맞췄지만, Runtime 성능이 133ms로 하위 5% 대로 나왔다. 퇴근하면서 유튜브로 다른 사람의 해설을 참고해봐야겠다.","categories":[{"name":"Quiz","slug":"Quiz","permalink":"http://youngjinmo.github.io/categories/Quiz/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://youngjinmo.github.io/tags/algorithms/"}]},{"title":"Docker로 MySQL 실행하기","slug":"run-mysql-with-docker","date":"2020-08-23T08:12:43.000Z","updated":"2020-09-21T13:20:02.264Z","comments":true,"path":"2020/08/run-mysql-with-docker/","link":"","permalink":"http://youngjinmo.github.io/2020/08/run-mysql-with-docker/","excerpt":"","text":"먼저 도커를 실행한다. 이후 도커에서 MySQL 이미지를 조회하고, 내려받는다. 12$ docker search mysql$ docker pull mysql 도커 이미지가 내려받아지면, 이제 이미지 기반으로 컨테이너를 생성한다. 1$ docker run -d -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=1q2w3e4r mysql 각 옵션을 설명하면 다음과 같다. run : 컨테이너를 생성(create)하자마자 실행(start)한다. -d : detach, 백그라운드에서 컨테이너를 실행한다는 명령어이다. -p : port, 컨테이너의 포트를 도커가 실행되고 있는 호스트 PC의 포트와 맵핑할 때 사용하는 옵션이다. 위의 명령어는 컨테이너의 3306번 포트와 호스트 PC의 3306번 포트를 맵핑하는 명령이다. --name : 컨테이너의 이름을 지정하는 옵션이다. 이미지 이름과 같은 이름을 컨테이너에 지정하다보니 위의 명령어가 헷갈릴수 있는데, 명령어 마지막에 붙은 mysql은 이미지 이름을 의미한다. -e : 환경변수를 설정하는 옵션이다. 위의 명령어에선 mysql의 ROOT 비밀번호를 지정하는 명령으로 사용했다. 이제 도커가 실행되면, 컨테이너 내부로 진입을 해야한다. 1$ docker exec -it mysql bash bash 모드로 컨테이너를 진입하겠다는 명령이다. 도커 컨테이너에 진입했다면, mysql을 실행할 차례이다. 1$ mysql -u root -p 그리고 아까 환경변수에 입력했던 비밀번호를 입력하면 mysql이 실행될 것이다. 이제 막 mysql 컨테이너를 생성했기 때문에 컨테이너 내부 데이터베이스엔 기본 데이터베이스만 있을 것이다. 1mysql&gt; show databases; 이제 데이터베이스를 생성해보자. connectdb 라는 이름의 데이터베이스를 생성해보겠다. 1mysql&gt; CREATE DATABASE connectdb; 데이터베이스를 사용할때 이용할 사용자 계정을 생성하겠다. 12mysql&gt; CREATE USER devandy@&#39;%&#39; identified by &#39;1q2w3e4r&#39;;mysql&gt; CREATE USER devandy@&#39;localhost&#39; identified by &#39;1q2w3e4r&#39;; 데이터 베이스에 사용할 수 있는 권한으로 방금 생성한 사용자를 등록해보겠다. 123mysql&gt; GRANT ALL PRIVILEGES ON connectdb.* TO devandy @ &#39;%&#39; identified BY &#39;1q2w3e4r&#39;;mysql&gt; GRANT ALL PRIVILEGES ON connectdb.* TO devandy @ &#39;localhost&#39; identified BY &#39;1q2w3e4r&#39;;mysql&gt; FLUSH PRIVILEGES; 마지막에 flush 명령어를 입력해주어야만 privileges 설정이 MySQL에 반영된다. 방금 생성한 사용자 계정으로 데이터베이스를 실행해보겠다. 1$ mysql -h127.0.0.1 -udevandy -p connectdb; -h 옵션은 host를 의미한다. 데이터베이스를 실행하는 환경이 어디인지를 지정하는 것이다. 로컬에서 작업하므로 127.0.0.1을 입력하였다. -u옵션은 사용자를 지정하는 옵션 명령어이다. 프롬프트창에서 비밀번호를 입력하면, 위에서 생성한 계정으로 접속했음을 알 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"DevOps","slug":"Dev/DevOps","permalink":"http://youngjinmo.github.io/categories/Dev/DevOps/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://youngjinmo.github.io/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"http://youngjinmo.github.io/tags/mysql/"},{"name":"database","slug":"database","permalink":"http://youngjinmo.github.io/tags/database/"}]},{"title":"Java - Generic","slug":"java-generic","date":"2020-08-19T07:24:46.000Z","updated":"2020-09-13T01:53:28.596Z","comments":true,"path":"2020/08/java-generic/","link":"","permalink":"http://youngjinmo.github.io/2020/08/java-generic/","excerpt":"","text":"ToC 제네릭이란? 타입 매개변수 제네릭의 효용 - 타입 안정성 제네릭의 특징 제네릭 메서드 왜 제네릭 메서드가 필요한가? 제네릭 메서드에서 타입 매개변수를 제한하고 싶을때 컴파일러의 제네릭 타입 추론 제한된 제네릭 와일드 카드 와일드카드 종류 제한된 제네릭과 와일드 카드의 차이? 제네릭(Generic)제네릭은 클래스 내부에서 사용하는 데이터 타입을 외부에서 지정하는 기법이다. 오픈튜토리얼스에서 이고잉님이 설명하신 제네릭 이미지를 인용한다.제네릭 클래스 Person을 사용하여 인스턴스를 만들때 타입 매개변수로 String을 주입했다. 이렇게 하면, 인스턴스 p1은 String형 Person 객체에 대한 인스턴스로 생성된다. 마찬가지로 인스턴스 p2는 StringBuilder형 Person 객체에 대한 인스턴스로 생성된다. 하나의 객체의 인스턴스를 생성하며 다양한 타입의 인스턴스로 생성할 수 있는 것이다. 다른 예제 코드도 함께 첨부한다. Person.class 1234567891011class Person &lt;T&gt; &#123; public T id; public T getId() &#123; return id; &#125; public T setId(T id) &#123; this.id = id; &#125;&#125; PersonExam.class 1234567891011class PersonExam &#123; public static void main(String[] args)&#123; Person&lt;String&gt; t1 = new Person&lt;String&gt;(); t1.setId(&quot;DevAndy&quot;); System.out.println( t1.getId() ); Person&lt;Integer&gt; t2 = new Person&lt;Integer&gt;(); t2.setId(123456789); System.out.println( t2.getId() ); &#125;&#125; 123&#x2F;&#x2F; 출력결과DevAndy123456789 Person 클래스의 멤버필드 id는 따로 데이터타입을 지정하지 않았다. 그냥 T 라는 기호를 붙여뒀을뿐인데, 이 T는 **타입 매개변수(Type variable)**이라 하며, 클래스에서 파라미터를 통해 가져오는 데이터 타입이다. 외부에서 Person 클래스를 사용할때 데이터 타입을 지정하면 이 때 지정한 데이터 타입이 파라미터를 통해 멤버필드의 타입으로 주입되는 것이다. 타입 매개변수위에서 타입 매개변수라고 했는데, 일반적으로 타입 매개변수로 T를 많이 사용하긴 하나 왜 T를 사용하는지 몰랐다. 그러나 이 타입 매개변수를 작성하는데에도 관례가 존재했다. 원칙이나 표준은 아니기에 타입 매개변수는 조직 내에서 약속된 범위내에서 자유롭게 쓸수 있을거라고 생각한다. Type Variable Definition T Type S, U, V 2nd, 3rd, 4th.. E Element K Key V Value N Number 제네릭의 효용 - 타입 안정성자, 근데 그래서 이걸 왜 쓰는걸까..? 아니 그냥 선언할때 데이터 타입 지정하면 외부에서 가져다 쓸때도 편하지 않을까? 굳이 데이터 타입 명시하는 일을 외부에 넘기는 이유가 뭘까? Java에서 List를 사용하면 IDE에서 자동으로 제네릭을 사용하는걸 경험해봤을 것이다. 자료구조 특징상 같은 데이터 타입의 데이터를 저장할 것이기에 제네릭으로 데이터 타입을 고정하여 타입 안정성을 높힌 것이다. 1234List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();stringList.add(1) // compile errorstringList.add(&quot;2&quot;) // ok 아래의 예제 코드를 통해 타입 안정성이 무슨 말인지 알아보자. 123456789101112131415import java.util.ArrayList;import java.util.List;public class itemBox &#123; public static void main(String[] args)&#123; List items = new ArrayList(); items.add(&quot;ABC&quot;); // unchecked items.add(123); // unchecked for(Object obj : items)&#123; System.out.println(obj); &#125; &#125;&#125; List를 선언하면서 제네릭을 사용하지 않았다. 이때에 List는 기본적으로 Object 타입이므로 모든 객체 타입을 받아들일 수 있다. 즉 String 형 데이터도 add 할 수 있고, int 형 데이터도 add 할 수 있는 것이다. 이런 경우가 타입 안정성이 검증되지 않았다고 이야기할 수 있다. 어떤 타입의 데이터가 List에 add될지 알 수 없으므로 개발자가 의도하지 않은 에러가 런타임시에 발생할 수도 있는 불확실성이 존재한다. List는 자바에서 자료구조 인터페이스에 해당한다. 따라서 다른 타입의 데이터가 같은 리스트에 묶이기 보다는 서로 같은 타입의 데이터가 묶여야 한다. 그러나 위 코드에서 제네릭을 적용한다면, 12345678910111213141516import java.util.ArrayList;import java.util.List;public class ItemBox &#123; public static void main(String[] args) &#123; List&lt;String&gt; items = new ArrayList&lt;String&gt;(); items.add(&quot;hello&quot;); items.add(&quot;generic!&quot;); // items.add(123); // compile error for(String str : items)&#123; System.out.println(str); &#125; &#125;&#125; 123&#x2F;&#x2F; 출력 결과hellogeneric! String 형만 add 할 수 있으므로 다른 데이터 타입을 List에 add 하려고 하면, 컴파일 에러를 유발하게 된다. 이렇게 제네릭을 사용하면 개발자가 의도하지 않은 데이터 타입이 List에 추가될시 컴파일 단계에서 이 문제를 인지할 수 있게된다. 제네릭의 이런 특징을 타입 안정성을 보장 한다고 표현한다. 런타임시에 발생할 수 있는 에러를 컴파일 시에 발생하도록 유도하여 안정적인 개발을 돕는 것이다. 제네릭의 특징기본형 타입은 타입 매개변수에서 불가능 제네릭에서 타입 매개변수에 들어올 수 있는 데이터 타입으로 기본형 타입은 쓸 수 없다. 123456789101112131415161718class Person&lt;T, S&gt; &#123; public T num; public S name; public Person(T num, S name)&#123; this.num = num; this.name = name; &#125;&#125;class PersonExam &#123; public static void main(String[] args)&#123; // Person&lt;int, String&gt; p1 = new Person&lt;int, String&gt;(10, &quot;devandy&quot;); // compile error System.out.println(p1.name); &#125;&#125; 위의 코드처럼 제네릭 클래스를 사용하는 외부 클래스에서 타입으로 기본형 타입을 사용할 수 없다는 이야기이다. 기본형 타입을 사용하고자 한다면, 직접 사용할 순 없고 기본형 데이터 타입을 객체화하는 Wrapper 클래스를 사용해야 한다. 12345678910111213141516class Person&lt;T, S&gt; &#123; public T num; public S name; public Person(T num, S name)&#123; this.num = num; this.name = name; &#125;&#125;class PersonExam &#123; public static void main(String[] args)&#123; Person&lt;Integer, String&gt; p1 = new Person&lt;Integer, String&gt;(10, &quot;devandy&quot;); System.out.println(p1.name); &#125;&#125; 12&#x2F;&#x2F; 출력 결과devandy 제네릭 메서드 제네릭은 클래스뿐만 아니라 메서드에서도 사용가능하다. 1public &lt;T&gt; void foo(List&lt;T&gt; list)&#123; &#125; &lt;T&gt; : 타입 매개변수 void : 리턴 타입 foo : 메서드 명 List&lt;T&gt; list : 매개변수 메서드를 제네릭 메서드로 선언하기 위해서는 접근제한자와 리턴타입 사이에 타입 매개변수를 작성해야 컴파일러에서 이 메서드를 제네릭 메서드로 인식하여 컴파일시 파라미터로 들어오는 타입 매개변수를통해 타입 추론을 할 수 있다.이 내용은 아래에서 더 정리를 했다! 왜 제네릭 메서드가 필요한가?1234public List&lt;String&gt; add(List&lt;String&gt; list, String element)&#123; list.add(element); return list;&#125; add()는 String형 List에만 대응할 수 있는 메서드이다. 그런데 만약 String형뿐만 아니라 Integer 등 다른 타입의 List도 대응하고 싶다면, 위의 메서드에서 List의 타입을 제네릭으로 바꿔야한다. 1234public &lt;T&gt; List&lt;T&gt; add(List&lt;T&gt; list, T element)&#123; list.add(element); return list;&#125; 이렇게 하면, 다양한 데이터 타입의 List에 대응할 수 있는 add()로 변경된다. 예제 코드 12345678910111213141516171819202122232425262728public class GenericMethodEx &#123; // 일반 메서드 public List&lt;String&gt; add(List&lt;String&gt; list, String element)&#123; list.add(element); return list; &#125; // 제네릭 메서드 public &lt;T&gt; List&lt;T&gt; add(List&lt;T&gt; list, T element)&#123; list.add(element); return list; &#125; public static void main(String[] args)&#123; GenericMethodEx ex = new GenericMethodEx(); List&lt;String&gt; strList = new ArrayList&lt;String&gt;(); strList.add(&quot;hello&quot;); strList.add(&quot;world&quot;); List&lt;Integer&gt; intList = new ArrayList&lt;Integer&gt;(); intList.add(123); intList.add(456); System.out.println(ex.add(strList, &quot;!&quot;)); System.out.println(ex.add(intList, 1000)); &#125;&#125; 123&#x2F;&#x2F; 출력 결과[hello, world, !][123, 456, 1000] 제네릭 메서드에서 타입 매개변수를 제한하고 싶을때메서드로 전달되는 타입 매개변수의 범위를 제한하고자 한다면 아래처럼 입력할 수 있다. 123public &lt;T extends Fruit&gt; void foo(List&lt;T&gt; list)&#123; // success &#125; 그러나 아래처럼 메서드의 파라미터 안에서 extends 키워드를 사용한다면 이는 컴파일 에러가 발생한다. 파라미터가 아니라 메서드 리턴 타입에서 제한을 시켜야만 제네릭을 인자로 불러올 수 있다. 123public &lt;T&gt; void foo(List&lt;T extends Fruit&gt; list)&#123; // compile error&#125; 컴파일러의 제네릭 타입 추론Java를 처음 공부할때엔 접근제한자, 리턴 타입, 메서드명, 파라미터 순으로 메서드에 대한 정의가 제대로 이루어져야만 컴파일이 된다고 배웠다. 당연히 그도 그럴 것이, 컴파일러가 해당 메서드가 호출되는 시점에 메모리에 올리려면 정확한 객체 정보가 필요하기 때문이다. 그런데 제네릭을 사용하면, 대체 컴파일러는 어떻게 타입을 추론하는걸까? 1234567891011class GenericEx01&lt;T&gt; &#123; public void genericSample(T param)&#123; System.out.println(param); &#125; public static void main(String[] args)&#123; genericEx01&lt;String&gt; ex = new genericEx01&lt;String&gt;(); ex.genericSample(&quot;hello&quot;); &#125;&#125; 12&#x2F;&#x2F; 출력결과hello 위의 코드는 제네릭 클래스 GenericEx의 인스턴스를 생성해서 genericSample()을 호출하는 코드이다. genericSample()은 제네릭 타입의 파라미터를 받고 있는데, main()에서 인스턴스를 생성하면서 데이터 타입을 String으로 전달했기 때문에 컴파일러가 데이터 타입을 추론할 수 있었다. 이제 여기서 변화를 줘보겠다. GenericEx를 제네릭 클래스에서 일반 클래스로 바꿔보겠다. 1234567891011class GenericEx02 &#123; public void genericSample(T param)&#123; System.out.println(param); &#125; public static void main(String[] args)&#123; genericEx02 ex = new genericEx02(); ex.genericSample(&quot;hello&quot;); // compile error &#125;&#125; 123&#x2F;&#x2F; 출력결과Error: Unable to initialize main class genericExDevAndy.genericEx02Caused by: java.lang.NoClassDefFoundError: T T라는 클래스를 찾을수 없다는 메세지와 함께 컴파일 에러가 발생했다. 왜 컴파일러는 타입 추론을 하지 못한걸까? 위의 코드를 다시 훑어보면, genericSample()의 파라미터로 들어오는 T라는 타입을 컴파일러 입장에서 추론할 수 있는 방법이 없다. 인스턴스를 통해 전달된 데이터 타입이 없기 때문에 컴파일러가 타입 매개변수 T가 어떤 타입인지 추론하지 못하는 것이다. 그래서 컴파일러에게 이 T 가 제네릭 타입 매개변수임을 알려주기 위해 genericSample()이 있는 클래스를 제네릭 클래스로 바꾸던, 메서드 자체를 제네릭 메서드로 바꾸던 해주어야 한다. 그럼 컴파일러는 T를 제네릭 타입 매개변수로 인지하고 이 객체를 사용하는쪽에서 주입하는 데이터 타입으로 맞춰서 호출해준다. 1234567891011// okpublic class GenericEx03 &#123; public &lt;T&gt; void genericSample(T param) &#123; System.out.println(param); &#125; public static void main(String[] args) &#123; GenericEx03 ex = new GenericEx03(); ex.genericSample(&quot;hello&quot;); &#125;&#125; 12// 출력결과hello 1234567891011// okpublic class GenericEx04&lt;제네릭&gt; &#123; public void genericSample(제네릭 param) &#123; System.out.println(param); &#125; public static void main(String[] args) &#123; GenericEx04&lt;String&gt; ex = new GenericEx04&lt;String&gt;(); ex.genericSample(&quot;hello&quot;); &#125;&#125; 12// 출력결과hello 지금까지는 일반 메서드 예제코드를 다뤄봤다. 그렇다면 static 메서드에서는 어떨까. 12345class GenericEx05&#123; public static void genericSample(T param)&#123; // compile error. 타입 추론 불가. &#125; &#125; static 키워드를 사용함으로써 런타임시 heap 메모리에 바로 객체를 올려두어야 하는데, 런타임시에는 이 파라미터의 데이터 타입을 알 수 없으므로 heap 메모리에 객체를 올릴수가 없게된다. 따라서 이 경우엔 static 메서드를 제네릭 메서드로 바꿔주어야만 컴파일이 가능해진다. 그냥 리턴 타입 앞에 제네릭 타입 변수를 명시해주면 된다. 12345class GenericEx06 &#123; public static &lt;T&gt; void genericSample(T param)&#123; // ok. 타입 추론 가능. &#125; &#125; 이렇게 제네릭 메서드로 바꾸면, 컴파일러에서 타입 추론이 가능해진다. 컴파일러는 genericSample() 가 타입 매개변수 T를 사용하는 제네릭 메서드라는걸 알고 있고, 제네릭 메서드 타입 매개변수와 같은 타입 매개변수가 파라미터로 들어왔기 때문에 컴파일러가 이 타입을 추론할 수 있는 것이다. 만약 아래의 코드처럼 파라미터의 타입 매개변수와 제네릭 메서드의 타입 매개변수가 다르면, 컴파일러에서 타입 추론이불가능해지기 때문에 이 역시 컴파일 에러를 유발한다. 123456class GenericEx07 &#123; public static &lt;T&gt; void genericSample(S param)&#123; // compile error. // T cannot be resolved to a type &#125;&#125; 타입 매개변수 T를 기대했지만, 파라미터로 들어온 타입 매개변수는 S이기 때문이다. 제한된 제네릭제네릭 클래스는 이를 인스턴스로 생성해서 사용하는 쪽에서 타입 변수로 아무런 데이터 타입을 넣어서 사용할 수 있다. 그러나 이 타입변수에 extends 키워드를 사용하면, 특정 클래스를 상속받는 클래스로만 타입 변수를 제한할 수 있다. 이를 제한된 제네릭이라고 한다. 예제 코드를 살펴보자. 1234567public class Box&lt;T extends Fruit&gt; &#123; List&lt;T&gt; items = new ArrayList&lt;&gt;(); void add(T item)&#123; items.add(item); &#125;&#125; 위의 코드처럼 타입 매개변수 뒤에 extends 키워드를 사용하면, 이 제네릭 클래스는 특정 클래스를 상속받는 타입 변수만 허용된다는 제한 조건이 성립된다. 따라서 타입변수 T 에 아무 데이터 타입이 들어올 수 없게 된 것이다. 제한된 제네릭의 특징제한된 제네릭에선 타입 매개변수의 제한조건으로 extends 키워드만 사용할 수 있다. 설사 인터페이스를 구현하는 제약을 추가하려고 해도 implement대신 반드시 extends 만 사용해야 한다. 12interface Eatable &#123; &#125;class sample&lt;T extends Eatable&gt; &#123; &#125; 추가로 클래스 Fruit의 자식이면서 인터페이스 Eatable도 구현해야한다면 &amp; 기호를 사용한다. 1class FruitBox&lt;T extends Fruit &amp; Eatable&gt;&#123; &#125; 제한된 제네릭 사용예제 코드 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859interface Eatable &#123; &#125;class Fruit implements Eatable &#123; public String toString() &#123; return &quot;Fruit&quot;; &#125;&#125;class Apple extends Fruit &#123; public String toString() &#123; return &quot;Apple&quot;; &#125;&#125;class Grape extends Fruit &#123; public String toString() &#123; return &quot;Grape&quot;; &#125;&#125;class Toy &#123; public String toString() &#123; return &quot;Toy&quot;; &#125;&#125;class Box&lt;T&gt; &#123; List&lt;T&gt; list = new ArrayList&lt;T&gt;(); void add(T item) &#123; list.add(item); &#125; T get(int i) &#123; return list.get(i); &#125; int size() &#123; return list.size(); &#125; public String toString() &#123; return list.toString(); &#125;&#125;class FruitBox&lt;T extends Fruit &amp; Eatable&gt; extends Box&lt;T&gt; &#123; &#125;class FruitBoxEx &#123; public static void main(String[] args) &#123; FruitBox&lt;Fruit&gt; fruitBox = new FruitBox&lt;Fruit&gt;(); FruitBox&lt;Apple&gt; appleBox = new FruitBox&lt;Apple&gt;(); FruitBox&lt;Grape&gt; grapeBox = new FruitBox&lt;Grape&gt;(); // FruitBox&lt;Grape&gt; grapeBox2 = new FruitBox&lt;Apple&gt;(); // compile error. 타입 불일치. // FruitBox&lt;Grape&gt; grapeBox2 = new FruitBox&lt;Fruit&gt;(); // compile error. 타입 불일치. // FruitBox&lt;Toy&gt; toyBox = new FruitBox&lt;Toy&gt;(); // compile error. FruitBox의 제한조건에 부합하지 않으므로. fruitBox.add(new Fruit()); fruitBox.add(new Apple()); // appleBox의 타입 Apple이 FruitBox의 타입인 Fruit의 자식 객체이므로 Ok. fruitBox.add(new Grape()); // Grape가 FruitBox의 타입인 Fruit의 자식 객체이므로 Ok. appleBox.add(new Apple()); // applpeBox.add(new Grape()); // appleBox의 타입 Apple과 Grape는 서로 상속관계가 아님. 타입 불일치. grapeBox.add(new Grape()); System.out.println(&quot;fruitbox : &quot;+fruitBox); System.out.println(&quot;appleBox : &quot;+appleBox); System.out.println(&quot;grapeBox : &quot;+grapeBox); &#125;&#125; 1234&#x2F;&#x2F; 출력 결과fruitbox : [Fruit, Apple, Grape]appleBox : [Apple]grapeBox : [Grape] Repl에서 실행해보기 와일드 카드와일드 카드란 제네릭 타입을 파라미터나 리턴 타입으로 사용할 때 구체적인 타입 대신 사용하는 문법이다. 예제 코드를 따라가보자. 12345678910111213141516171819202122232425262728public class GenericsWildCards &#123; public int intSum(List&lt;? extends Number&gt; list) &#123; int sum = 0; for(Numer num : list)&#123; sum += num.doubleValue(); &#125; return sum; &#125; public static void main(String[] args)&#123; GenericsWildCards generic = new GenericsWildCards(); List&lt;Integer&gt; intNums = new ArrayList&lt;Integer&gt;(); List&lt;String&gt; stringWords = new ArrayList&lt;String&gt;(); intNums.add(3); intNums.add(5); intNums.add(10); int sum1 = generic.intSum(intNums); int sum2 = generic.intSum(stringWords); // compile error. 와일드카드 조건에 불일치. System.out.println(&quot;sum of integers : &quot;+sum1); System.out.println(&quot;Sum of doubles : &quot;+sum2); &#125;&#125; 위의 코드를 보면, sum2를 선언하는 코드에서 컴파일 에러가 발생한다. 원인은 sum2를 선언하는 과정에서사용한 intSum() 의 파라미터로 들어간 타입이 generic 인스턴스 객체의 와일드카드 조건에 부합하지 않은 인자(argument)로 들어왔다는 경고 문구이다. intSum()을 보면 다음과 같이 와일드 카드를 사용하고 있다. 1public int intSum(List&lt;? extends Number&gt; list) &#123; &#125; intSum() 파라미터로 List형을 받을 수 있는데, List의 타입은 Number를 상속하는 자식객체 타입으로 사용을 제한하는 와일드카드가 선언되어 있다. 123GenericsWildCards generic = new GenericsWildCards();List&lt;String&gt; stringWords = new ArrayList&lt;String&gt;();int sum2 = generic.intSum(stringWords); 그런데 intSum()의 파라미터로 String형 List를 인자로 사용하니 컴파일 에러가 발생한 거였다. 와일드카드 종류제네릭에서 와일드 카드는 크게 3가지로 분류할 수 있다. 와일드 카드 (Unbounded Wildcards) &lt;?&gt; 제한이 없기때문에 모든 클래스나 인터페이스 타입이 올 수 있다. 사실상 &lt;? extends Object&gt;와 같다. 1public int intSum(List&lt;?&gt; list) &#123; &#125; 와일드 카드의 하위 클래스 제한(Upper Bounded Wildcards) &lt;? extends T&gt; 타입 매개변수 T와 그 자식 객체들을 구현한 매개변수만 가능 1public int intSum(List&lt;? extends T&gt; list) &#123; &#125; 와일드 카드의 상위 클래스 제한 (Lower Bounded Wildcards) &lt;? super T&gt; 타입 매개변수 T와 그 부모 객체들을 구현한 매개변수만 가능 1public int intSum(List&lt;? super T&gt; list) &#123; &#125; 와일드카드 예제 코드 1234567891011121314151617181920212223242526272829303132333435363738394041public class GenericWildcards &#123; // 와일드카드 unbounded wildcard public static void printData(List&lt;?&gt; list)&#123; for(Object obj : list)&#123; System.out.println(obj+&quot; ::&quot;); &#125; &#125; // 와일드카드 상위클래스 제한 lower bounded wildcard public static void addInteger(List&lt;? super Integer&gt; list)&#123; list.add(120); System.out.println(list); &#125; // 와일드카드 하위클래스 제한 upper bounded wildcard public static double sum(List&lt;? extends Number&gt; list)&#123; double sum = 0; for(Number n : list)&#123; sum += n.doubleValue(); &#125; return sum; &#125; public static void main(String[] args)&#123; List&lt;Integer&gt; intNums = new ArrayList&lt;Integer&gt;(); List&lt;String&gt; stringWords = new ArrayList&lt;String&gt;(); intNums.add(3); intNums.add(10); intNums.add(200); stringWords.add(&quot;hello&quot;); stringWords.add(&quot;generic&quot;); stringWords.add(&quot;widlcard&quot;); printData(stringWords); addInteger(intNums); System.out.println(sum(intNums)); &#125;&#125; 123456&#x2F;&#x2F; 출력 결과hello ::generic ::wildcard ::[3, 10, 200, 120]333.0 Repl에서 실행하기 제한된 제네릭과 와일드 카드의 차이?제네릭을 공부하다보니 제한된 제네릭과 와일드카드가 헷갈렸다. 아래의 글을 읽고 관점을 구분해서 바라보니 그 차이를 조금씩 이해할 수 있었다. 제한된 제네릭 와일드카드 관점 제네릭 클래스를 선언하는 개발자 메서드를 만드는 개발자 목적 객체 생성시 사용될 객체를 제한 메서드에 사용될 매개변수가 제네릭 클래스를 구현한 객체일때 그 제네릭 클래스의 타입 매개변수를 제한 이제 코드 작성시 제한된 제네릭과 와일드카드의 차이를 살펴보겠다. 제네릭 메서드는 파라미터에서 제한된 제네릭을 사용할 수 없었다. 1234567public &lt;T&gt; void genericMethodEx01(List&lt;T extends Fruit&gt; list)&#123; // compile error.&#125;public &lt;T extends Fruit&gt; void genericMethodEx02(List&lt;T&gt; list)&#123; // ok.&#125; 반면, 와일드카드는 파라미터에서 제한된 제네릭을 사용하는게 가능하다. 123public void genericMethodEx03(List&lt;? extends Fruit&gt; list)&#123; // ok.&#125; References 생활코딩 - 제네릭 10분 테코톡 - 💫두강의 Generics 한빛미디어 - 이것이 자바다 13.1 왜 제네릭을 사용해야 하는가 YABOONG - 자바 제네릭 이해하기 Siyoon210 - 제네릭스(Generics) 와일드카드&lt;?&gt; Java의 정석","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"generic","slug":"generic","permalink":"http://youngjinmo.github.io/tags/generic/"}]},{"title":"Github Two-Factor 적용이후 Authenticatin Fail 발생할때","slug":"git-access-token","date":"2020-07-31T12:49:35.000Z","updated":"2020-09-13T01:53:28.928Z","comments":true,"path":"2020/07/git-access-token/","link":"","permalink":"http://youngjinmo.github.io/2020/07/git-access-token/","excerpt":"","text":"Github에서 Two-factor 인증을 적용하고 나니 CLI에서 push할 때 계속 Authentication failed 에러가 발생했다. 원격 서버(Github)에서 인증 정보가 바뀌었는데 로컬에 적용된 인증 정보와 일치하지 않으면서 발생한 현상이다. 로컬의 인증정보를 업데이트하려면, 1) Github에서 토큰을 발급받아서 2) 로컬에서 authentication을 등록해두어야 한다. 그럼 일단 토큰을 업데이트 해야한다. Github 설정에 들어가서 새로운 토큰을 발급받자. Generate 버튼을 클릭해서 신규 Personal access 토큰을 발급한다. 발급을 시도하면, 토큰의 권한을 설정할 수 있다. 필요한 권한만큼 체크해서 넘어가면 된다. 그럼 아래의 이미지처럼 토큰 주소가 발급된다. 이 토큰 주소를 로컬에서 authentication할 때 패스워드로 등록하면 된다. Username에는 Github에서 사용하는 이메일을 입력하고, 패스워드는 토큰을 발급받으면서 받은 주소를 입력하면 된다. 이후부터는 다시 CLI에서 원격서버와 통신(push, pull)이 가능해진다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[{"name":"github","slug":"github","permalink":"http://youngjinmo.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"http://youngjinmo.github.io/tags/git/"},{"name":"error","slug":"error","permalink":"http://youngjinmo.github.io/tags/error/"}]},{"title":"Java - JVM","slug":"java-jvm","date":"2020-07-27T14:37:43.000Z","updated":"2020-09-13T01:53:28.552Z","comments":true,"path":"2020/07/java-jvm/","link":"","permalink":"http://youngjinmo.github.io/2020/07/java-jvm/","excerpt":"","text":"자바 소스코드를 class 파일로 컴파일해주고 실행하는 **JVM(Java Virtual Machine)**의 메모리 구조에 대한 이야기이다. 왜 JVM이 필요한가? 자바로 프로그래밍된 파일을 실행하려면 JVM이 필수적이다. 자바 소스코드는 그 자체로 OS에서 즉시 실행할 수 없고 자바 런타임환경에서 실행될 수 있는데, 그러려면 JVM이 운영체제에 맞게 바이트 코드로부터 기계어로 컴파일 해주어야 한다. 자바 애플리케이션 실행과정 운영체제에서 자바 프로그램을 실행하기 위한 과정은 다음과 같다. 프로그래머가 작성한 소스코드(.java)를 JDK에 내장된 자바 컴파일러(javac)로 컴파일한다. 컴파일 결과로 바이트 코드(.class)가 생성된다. 컴파일 하는 목적은 JVM을 위함이다. JVM은 바이트 코드만 읽을 수 있기 때문이다.(웹 개발시 Maven이나 Gradle로 빌드하면서 생성되는 jar파일은 이런 class 파일들의 집합이다.) 자바 컴파일러(javac)로 컴파일한 class 파일은 JVM 에서 구동할 수 있다. 그럼 JVM은 바이트 코드로부터 실행환경(운영체제)에 맞는 기계어(binary)로 컴파일 한다. 이렇게 컴파일된 기계어는 자바 런타임 환경(JRE)에서 애플리케이션(프로세스)으로 실행된다. OS에서 바로 실행하는 것이 아닌 JVM이라는 가상머신을 통해 구동하기 때문에 Java는 플랫폼 독립적이라는 특징을 가질 수 있는 것이다. JVM은 바이트 코드를 읽어서 프로세스로 동작시키는 것 외에도 가비지 컬렉터(GC)를 내장하고 있어서 GC가 메모리 관리를 해준다. 메모리 관리란, 이미 쓰임을 다한 메모리 주소를 반납하는 것을 의미하는데, C 계열의 언어에서는 프로그래머가 수동으로 해야하는 일이지만, 자바는 그럴 필요가 없다. JVM과 함께 언급되는 키워드로 JDK, JRE가 있는데, JDK와 JRE는 서로 다른 환경에서 필요하다. JDK는 자바 애플리케이션을 개발하는 환경에서 필요하며, JRE는 자바 애플리케이션을 실행하는 환경에서 필요한 자원이다. Java와 C의 차이자바는 소스 코드(.java)로부터 바이트 코드(.class)로 컴파일 하고, 다시 바이트 코드로부터 기계어로 컴파일하는 과정을 거치지만, C에서는 바이트 코드 변환과정없이 소스코드에서 곧바로 기계어로 번역된다. 그래서 C가 자바보다 실행 속도가 더 빠르다고 이야기되곤 한다. 그렇다면 자바는 왜 C처럼 소스 코드를 기계어로 바로 컴파일하지 않고, 바이트 코드로 컴파일하는 과정을 거치는 걸까? 이유는 이미 위에 작성해두었다! ㅎㅎ JVM 구동 원리위에서 자바 애플리케이션의 구동원리를 크게 두번의 과정으로 설명했는데, 위의 과정에서 2번을 좀 더 상세히 정리해보려고 한다. 즉, JVM에서 어떻게 프로세스로 변환되는지에 대한 과정이다. 자바 애플리케이션이 실행되면, JVM은 이 애플리케이션의 실행에 필요한 메모리를 운영체제로부터 할당받는다. 이렇게 할당된 메모리는 용도에 따라 여러 영역으로 나누어 관리된다. 그리고 JVM의 클래스 로더에 의해 class 파일(바이트 코드)들이 JVM으로 로딩된다. 로딩된 class 파일은 Execution Engine을 통해 해석된다. 해석된 바이트 코드들이 Runtime Data Areas로 배치되어 프로세스로써 실질적인 수행이 이루어진다. JVM의 구성 ClassLoader Runtime 시에 동적으로 클래스 파일들을 JVM으로 로딩하는데 사용하는 서브 시스템이다. 클래스 로더에서 발생하는 행위는 아래 3가지로 구분할 수 있다. Loading - JVM으로 로딩한다. Linking - 필요한 영역으로 배치하는 역할을 수행. Initialization Method Area 클래스 정보를 메모리 공간에 처음 올릴 때 초기화되는 대상을 저장하기 위한 메모리 공간이다. 올라가게 되는 메서드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드이다. 거의 모든 바이트 코드가 Method Area에 할당된다고 생각하면 된다. 클래스 데이터를 위한 공간이라고 이해하면 좋다. Method Area는 Constant runtime pool이라는 관리 영역도 존재하는데, 이곳에서 상수형 자료형을 저장하고 참조하여 중복을 막는 역할을 수행한다. Heap 인스턴스 변수들과 배열 등 모든 변수가 Heap 에 저장된다. new 키워드로 생성된 인스턴스 변수들이 할당되는 곳이라고 이해하면 된다. Method Area가 클래스 데이터를 위한 공간이라면, Heap은 객체를 위한 공간이다. JVM Language Stacks 메서드 안에서 사용되는 변수(local variable)들을 저장하는 영역이다. 자바 애플리케이션 실행 과정에서 임시로 할당되었다가 메서드를 빠져나가며 바로 소멸되는 특성의 데이터를 저장하기 위한 영역이다. 메서드 호출시마다 각각의 스택 프레임(해당 메서드만을 위한 공간)이 생성된다. 메서드 수행이 끝나면 스택 프레임 별로 삭제를 한다. PC Register 현재 실행중인 JVM의 주소를 저장한다. 쓰레드가 시작될 때 생성되는 공간으로 쓰레드마다 PC 레지스터를 각각 갖는다. 쓰레드가 어떤 명령에 의해 어떤 부분을 실행해야하는지를 기록하는 영역이다. Native Method Stacks 자바 애플리케이션이 컴파일되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어(바이너리)로 작성된 프로그램을 실행시키는 영역이다. Execution Engine 클래스를 실행시키는 역할을 수행한다. 클래스 로더가 JVM 내의 Runtime Data Area에 바이트 코드를 배치시키면, 이것이 실행 엔진에 의해 실행된다. 실행 엔진은 바이트 코드를 JVM에서 실제로 기계가 실행할 수 있는 형태인 바이너리로 변경한다. Native Method Interface JVM 에서 실행중인 자바 코드가 라이브러리와 네이티브 애플리케이션들에 의해 호출되도록 허용하는 역할을 수행한다. Native Method Libraries 실행 엔진에 필요한 네이티브 라이브러리들의 모음(컬렉션)이다. Run Time Area 자바 애플리케이션을 실행하기 위해 운영체제에서 할당받은 메모리 영역이다. 함께 읽으면 훠얼씬 좋은 글 페페로니피자 - [Java]JVM Architecture란? Jbee - JVM이란 무엇인가? Jbee - GC/JVM 구동원리에 이어서","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://youngjinmo.github.io/tags/jvm/"}]},{"title":"Enumeration 인터페이스와 Iterator 인터페이스","slug":"enumeration-iterator","date":"2020-07-05T07:39:14.000Z","updated":"2020-09-13T01:53:28.948Z","comments":true,"path":"2020/07/enumeration-iterator/","link":"","permalink":"http://youngjinmo.github.io/2020/07/enumeration-iterator/","excerpt":"","text":"Enumeration 인터페이스와 Iterator 인터페이스 모두 하는 역할은 비슷하다. 배열의 원소(Element)들을 한 순간에 하나씩 처리할 수 있는 메서드를 제공하는 컬렉션들이다. 일반적으로 배열문과 함께 사용되며, 다음에 처리할 수 있는 원소가 있는지 없는지 등의 여부(boolean)와 다음 원소를 반환할 수 있다. Enumeration 인터페이스와 Iterator 인터페이스의 메서드를 알아보며 어떤 차이가 있는지 알아보자. Enumeration 인터페이스Enumeration 인터페이스는 Java 8에서 Iterator 인터페이스가 추가되기 전까지 사용하던 컬렉션이다. Enumeration의 주요 메서드 hasMoreElements() : boolean element가 더 남아있는지 boolean 값을 반환한다. nextElement() : E 다음 element를 열거형(E)으로 반환한다. Iterator 인터페이스Enumeration 인터페이스와 비슷하지만, 원소를 삭제할 수 있는 메서드가 존재한다는 점에서 Enumeration가 다르다. Iterator의 주요 메서드 hasNext() : boolean 다음에 처리할 element가 남아있는 boolean 값을 반환한다. next() : E 다음 element를 열거형(E)로 반환한다. remove() : void element를 삭제한다. Iterator 인터페이스는 Java 1.2부터 추가되었는데, 오라클 공식문서에서는 아래와 같은 이유로 Enumeration 인터페이스 대신 Iterator 인터페이스를 쓰라고 권하고 있다. NOTE : The functionality of this interface is duplicated byu the Iterator interface. In addition, Iterator adds an optional remove operation, and has shorter method names. New implementatinos should consider using iterator in preference to Enumeration. 삭제할 수 있는 메서드가 생겼고, 메서드의 이름이 더 짧아졌기 때문에 새로 구현하는 객체에서는 Enumeration 대신에 Iterator를 사용하라는 문구이다. 참고문서 Oracle - Enumeration Oracle - Iterator","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"enumeration","slug":"enumeration","permalink":"http://youngjinmo.github.io/tags/enumeration/"},{"name":"iterator","slug":"iterator","permalink":"http://youngjinmo.github.io/tags/iterator/"},{"name":"interface","slug":"interface","permalink":"http://youngjinmo.github.io/tags/interface/"}]},{"title":"Servlet - 서블릿 생명주기와 HttpServletRequest, HttpServletResponse","slug":"servlet-lifecycle","date":"2020-07-02T10:55:33.000Z","updated":"2020-10-12T04:21:49.629Z","comments":true,"path":"2020/07/servlet-lifecycle/","link":"","permalink":"http://youngjinmo.github.io/2020/07/servlet-lifecycle/","excerpt":"","text":"앞서 서블릿을 이용해 화면에 Hello world를 찍어보는 간단한 실습을 해보았다. 이번엔 이 때 사용했던 개념들에 대해 조금 더 알아보는 시간을 가지려고 한다. 우선 서블릿이 어떻게 호출되고, 실행되는지부터 알아보자. Servlet 작동원리웹서버에 HTTP 프로토콜로 요청이 들어오면, 웹서버는 해당 요청을 파악하고, 요청에 맞는 리소스를 다시 HTTP 프로토콜로 반환한다. 간단하지만 이게 웹의 기본이자 핵심이다. 웹의 동작을 천천히 따라가보자. 브라우저 주소창에서 URL을 입력하면, 브라우저는 요청메세지를 만들어서 HTTP 프로토콜을 이용하여 DNS에 보낸다. 그럼 DNS에서는 해당 URL 주소를 갖는 IP주소를 찾아서 IP주소가 가리키는 웹서버로 아까 클라이언트로부터 받은 요청 메세지를 던진다. 위의 이미지는 웹서버를 띄워서 요청메세지(HttpServletRequest)를 통해 어떤 정보를 웹서버가 알 수 있는지를 보여주는 코드를 작성해보았다. 그럼 웹서버는 이 요청에 맞는 리소스를 찾아서 응답 메세지로 만들어 다시 HTTP 프로토콜을 이용하여 요청메세지의 클라이언트에 반환한다. 이 과정에서 서블릿에서 일어나는 일들을 정리해보면, 웹 서버가 실행되고, 서블릿의 초기화 메서드(init())가 호출된다. 이후 웹 서버에 요청이 들어오면, 서비스(service())가 호출되면서 요청을 파악하게 된다. 서비스에서 요청을 파악하여 HTTP 메서드가 GET이면 doGet()을, POST이면 doPost()을 호출한다. Apache의 HttpServlet 클래스 문서를 보면, HttpServlet의 메서드들 대부분이 HTTP 메서드와 연관된 메서드(GET/POST/PUT/DELETE..)들임을 확인할 수 있다. 그리고 이 HttpServlet 클래스에서 사용하는 파라미터는 HttpServletRequest와 HttpServletResponse 인터페이스 객체이다. Servlet 생명주기서블릿에 여러가지 메서드가 중요하지만, 서블릿의 시작과 끝 등을 다루는 주요 메서드로는 아래 3가지가 있다. .init() .service(request, response) .destroy() 위 메서드들은 HttpServlet의 메서드를 오버라이딩해서 사용할 수 있다. 서블릿을 생성해서 위 3가지 HttpServlet 메서드를 오버라이딩해서 사용해보자. 생성자와 HttpServlet 3가지 메서드를 포함하여 4가지 메서드가 생성된다. Sysout으로 콘솔에서 식별할 수 있는 문구를 작성해보자. 12345678910111213141516171819@WebServlet(&quot;/lifecycle&quot;)public class LifecycleServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; public LifeCycleServlet() &#123; System.out.println(&quot;LifeCycleServler 생성!!&quot;); &#125; public void init(ServletConfig config) throws ServletException &#123; System.out.println(&quot;init 호출!!&quot;); &#125; public void service(HttpServletRequest request, HttpServletResponse response) &#123; System.out.println(&quot;Service 호출!!&quot;); &#125; public void destroy() &#123; System.out.println(&quot;destory 호출!!&quot;); &#125;&#125; 1234&#x2F;&#x2F; console resultLifeCycleServler 생성!!init 호출!!Service 호출!! 서버 실행 후, URL로 호출하면, 콘솔결과에 출력되는걸 확인할 수 있다. 생성자 : 서블릿이 생성될때 호출된다. init : 서블릿이 초기화될때 호출된다. service : 서블릿이 호출될때 호출된다. 서버를 실행하고, 브라우저에서 URL을 호출하면, WAS는 서블릿 요청을 받아서 해당 서블릿이 메모리에 있는지 여부를 확인한다. 있으면 바로 service()를 호출하고, 없으면 생성자부터 init()을 호출하게 된다. 처음 웹서버를 실행하고 서블릿을 호출하면, 생성자 호출 init() 호출 service() 호출 순으로 호출된다. 브라우저에서 다시 URL을 호출하거나, 현재창에서 refresh하면, 1) 생성자, 2) init() 을 skip하고 service()만 호출한다. WAS가 서블릿 요청을 받아서 해당 서블릿이 메모리에 있는지 확인했는데 이미 존재하기 때문에 서블릿을 생성하지 않고 곧바로 service()를 호출한 것이다. 여기서 하나 알아둬야할 점은 JSP 처럼 서블릿을 이용하여 화면에 뿌리는 메서드는 service() 뿐이다. service()에서만 반환객체 HttpServletResponse 를 파라미터로 받고있기 때문이다.(JSP 엔진에서 사용하는 서비스 메서드명은 _jspService()이다.) 그럼 destory()는 언제 실행되는걸까? 서블릿 클래스를 수정하면, eclipse가 자동으로 수정된 클래스를 바탕으로 재 빌드를 하면서 콘솔화면에 destroy()가 실행된걸 알 수 있다. 즉, destroy()가 호출되는 경우는 WAS가 죽는 경우, 즉 웹 애플리케이션이 종료되는 시점이다. Servlet 2.x대와 3.x대의 차이서블릿 버전 2.0과 3.0의 작성법이 다르다고 한다. 3.0에선 HttpServlet을 상속받고, 어노테이션 @WebServlet()을 작성함으로써 간단하게 작성이 가능하지만, 2.0에선 XML 기반으로 작성해야했다. Servlet 2.xx 12345678910&lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;myServlet&lt;/display-name&gt; &lt;servlet-name&gt;myServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;edwith.myServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;url-pattern&gt;/helloservlet&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; Servlet 3.xx 12345@WebServlet(&quot;/helloservlet&quot;)public class helloservlet extends HttpServlet &#123; protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; ... &#125; protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; ... &#125;&#125; Servlet의 요청과 응답요청할 때엔 갖고있는 정보를 HttpServletRequest에 저장한다. 응답을 보낼때는 HttpServletResponse 객체를 생성해서 HttpServletResponse를 통해 응답한다. HttpServletRequest ServletRequest를 상속받는 클래스이다. http 프로토콜의 request 정보를 서블릿에게 전달하기 위한 목적으로 사용한다. 헤더 정보, 파라미터, 쿠키, URI, URL 등의 정보를 읽어 들이는 메서드를 가진다. body의 stream을 읽어들이는 메서드가 존재한다. HttpServletRequest 클래스의 주요 메서드 getParameterNames() : E 현재 요청에 포함된 매개변수를 반환한다. 열거(Enumeration)로 가져온다. 파라미터가 없으면 빈 열거를 반환한다. getParameter(name) : String 문자열 name과 같은 이름을 가진 매개변수 값을 요청으로부터 가져온다. getParameterValues(name) : String[] 문자열 name과 같은 이름을 가진 매개변수 값을 문자열 배열 형태로 가져온다.( 주로 checkbox, mutilple list 등에 사용 ) getCookies() : Cookie[] 모든 쿠키값을 javax.servlet.http.Cookie의 배열 형태로 가져온다. getMethod() : String 현재 요청이 GET인지 POST인지 HTTP Method를 반환한다. getSession() : HttpSession 현재 세션 객체를 가져온다. getRemoteAddr() : String 현재 클라이언트의 IP 주소를 가져온다. getProtocol() : String 현재 서버의 프로토콜을 문자열 형태로 가져온다. setCharacterEncoding() : void 웹서버로 전달되는 내용을 인코딩한다. getAttribute(name) : Object 문자열 name과 같은 이름을 갖는 매개변수 값을 Object 타입으로 가져온다. setAttibute(name, value) : void 문자열 name과 같은 이름을 가진 매개변수의 값을 value로 수정한다. HttpServletRequest의 메서드를 활용한 예제 코드. header로 저장되는 정보 브라우저 화면에서 출력하는 법 123456Enumeration&lt;String&gt; headerNames = request.getHeaderNames();while( headerNames.hasMoreElements() ) &#123; String headernames = headerNames.nextElement(); String headerValue = request.getHeader(headernames); out.println(headerNames+&quot; : &quot;+headerValue+&quot;&lt;br&gt;&quot;); &#125; HttpServletResponse​ • WAS는 어떤 클라이언트가 요청을 보냈는지 알고 있고, 해당 클라이언트에게 응답을 보내기 위한 HttpServlerResponse 객체를 생성하여 서블릿에게 전달한다. ​ • 서블릿은 해당 객체를 이용하여 content-type, 응답 메세지 등을 HttpServlerResponse 에 담아서 전송한다. HttpServletResponse 클래스의 주요 메서드 setContentType() : void 문자열 형태의 type에 지정된 MIME Type으로 Content Type으로 지정한다. setHeader(name, value) : void 문자열 name의 이름으로 value 값을 헤더로 설정한다. setDateHeader(name, date) : void 문자열 name의 이름으로 date에 설정된 ms시간 값을 헤더에 설정한다. sendRedirect(url) : void 클라이언트 요청을 다른페이지로 보낸다. 참고 문서 Apache - Class HttpServlet Apache - Interface HttpServletRequest Apache - Interface HttpServletResponse woojong92 - JAVA Servlet구조와 HtppServlet 클래스 devbox - [Servlet] 서블릿 기초 서블릿으로 Hello World 찍어보는 실습 구경하러 가기-&gt; Servlet 실습하며 알아보기","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"http","slug":"http","permalink":"http://youngjinmo.github.io/tags/http/"},{"name":"servlet","slug":"servlet","permalink":"http://youngjinmo.github.io/tags/servlet/"}]},{"title":"Servlet - 서블릿 튜토리얼","slug":"servlet-tutorial","date":"2020-07-02T10:55:30.000Z","updated":"2020-10-12T04:24:10.098Z","comments":true,"path":"2020/07/servlet-tutorial/","link":"","permalink":"http://youngjinmo.github.io/2020/07/servlet-tutorial/","excerpt":"","text":"스프링을 공부하다가 모호한 부분이 많아서 시작하게된 공부이다. 스프링 기반기술이 서블릿인데 사실 자바 언어를 사용하며 웹 애플리케이션을 개발하기 위해서는 반드시 서블릿을 사용할 수 밖에 없다. 웹 애플리케이션을 개발하기 위해서는 Http로 통신하는 애플리케이션을 개발해야하는데 서블릿은 HttpServlet 클래스를 상속받아서 Http 프로토콜로 요청과 응답을 구현하는, WAS에서 동작하는 클래스이기 때문이다. 요즘은 개발자가 직접 서블릿을 생성할 필요가 없는데 스프링 프레임워크와 스프링부트처럼 간단하게 웹 개발할 수 있는 프레임워크가 존재하기 때문이다. 그러나 개발자가 직접 생성하지 않을뿐이지 결국 이런 자바 기반의 웹 개발 프레임워크 모두 서블릿 기반의 프레임워크라는 사실을 잊어서는 안된다. 서블릿은 WAS에서 동작하는 자바 클래스이다. Servlet 만들어보기프로젝트(Dynamic Web Project) 생성하기 서블릿은 정적 웹(Static Web)이 아닌 동적인 웹(Dynamic Web)을 위해 탄생한 기술이다. 따라서 이클립스에서 [File] - [New] - [Other] 를 클릭하고, [Dynamic Web Project] 선택한다. 앞서 서블릿은 WAS에서 작동하는 자바 클래스라고 했다. 따라서 설정할때 어디서 실행될지(Terget runtime)를 정해야한다. 필자는 Apache Tomcat 9.0을 WAS로 지정했다. 이렇게 WAS를 지정하고, Next로 넘어간다. 서블릿 클래스 생성하기 프로젝트가 생성되었으니 이제 프로젝트에서 서블릿 클래스를 생성할 차례이다. src 디렉토리 하위에 패키지를 하나 생성하고(생성하지 않아도 상관은 없다. default package가 생성될 것이다.) 생성된 패키지 하위에 [New] - [Web] - [Servlet] 을 선택해서 서블릿 클래스를 생성한다. 서블릿 클래스 작성하기 서블릿 클래스를 생성하면, 자동으로 doGet(), doPost() 가 완성된 클래스 파일이 생성된다. 현 상태로도 브라우저에서 화면을 출력할 수 있지만, 상징적인 의미로 Hello World를 찍어보겠다. 서블릿의 동작원리는 다음과 같다. java 코드를 작성하고, Run on Server를 실행하면, IDE(Eclipse)에서 java코드를 class코드로 컴파일. 컴파일한 코드를 톰캣(서블릿 컨테이너)에서 서블릿 규칙에 따라 코드를 실행하고 결과를 서버에 전달. 전달받은 서버는 클라이언트로부터 정해진 요청(HttpServletRequest)이 들어올 경우, 해당 요청에 맞는 응답(HttpServletResponse)을 HTTP 프로토콜을 통해 브라우저로 전송한다. 따라서 doGet() 에 코드를 작성해보겠다. 전체 코드 보기 12345678protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; // TODO Auto-generated method stub PrintWriter out = response.getWriter(); out.println(&quot;&lt;h1&gt;Hello World&lt;/h1&gt;&quot;); out.println(&quot;My &lt;span style=\\&quot;color: red;\\&quot;&gt;First&lt;/span&gt; Servlet!&quot;); response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath());&#125; 그리고 서버를 실행하면, 브라우저가 자동으로 실행되며 다음과 같은 화면을 뿌려줄 것이다. 서버를 실행할 때 어떤 서버에서 실행할지 실행환경을, 즉 WAS를 물어보는데 이 때 서버를 선택하고 Next로 넘어가면 된다. 아래 Always user thie server 라는 체크박스를 체크하면, 다음부터 서블릿을 실행하면 자동으로 해당 WAS로 서블릿을 실행하게 된다. 만약 브라우저가 안열린다면 이클립스의 Preference에서 browser 설정을 다음처럼 바꿔준다. 클라이언트로부터 요청을 받아야 서버가 응답을 한다고 했는데, 어떤 요청을 했길래 웹 서버가 자동으로 결과를 뿌려준걸까? 여기서 사용자가 한 요청은 웹 브라우저 주소창에 있는 URL이다. 1http:&#x2F;&#x2F;localhost:8080&#x2F;&#123;server-name&#125;&#x2F;&#123;annotation&#125; 로컬 환경에서 작업중이기 때문에 localhost:8080까지는 알겠는데, server-name은 어디서 알 수 있는걸까? 이클립스의 Servers 탭에서 서버를 더블클릭한다. (이미지에서 표기한 Servers탭 말고 해당 탭에 있는 로컬서버를 클릭하셔야한다.) 그리고 서버 환경설정 화면이 나오면, 하단 메뉴에서 Modules를 클릭한다. 그럼 위와 같이 Web Modules에서 현재 서버의 Path를 볼 수 있다. 이 Path가 우리가 서블릿으로 만든 웹서버에 접속할 수 있는 요청을 할 URL에 포함시켜야할 주소이다. 간단하게 서블릿 작업만 하고 싶다면, 위의 Path를 그냥 / 로 바꾸는게 편할 수 있다. 위의 주소로 입력하면, 내장 톰캣 서버가 해당 요청에 맞는 응답을 클라이언트로 response하는 건데, 이 과정은 다음과 같다. 서블릿 클래스에서@WebServlet(&quot;/HelloServlet&quot;) 이라는 어노테이션을 작성하면, 어노테이션의 파라미터로 들어간 URI(“/HelloServlet”)로 접속을 하면, 서블릿 클래스에 작성된 로직이 실행되는 것이다. 그리고 이 서블릿 클래스 중에서도 doGet()에 작성된 로직이 웹 서버에 요청되면서 아까 PrinterWriter 객체로 작성한 html 코드가 브라우저로 반환된 것이다. 파라미터 담아서 요청하기URL에 파라미터를 붙여서 요청할 수도 있다. 요청할 URL에 ?를 붙이고 파라미터 이름과 파라미터 값을 추가하면 된다. 1http:&#x2F;&#x2F;localhost:8080&#x2F;&#123;server-name&#125;&#x2F;&#123;annotation&#125;?&#123;parameter1&#125;&#x3D;&#123;value1&#125;&amp;&#123;parameter2&#125;&#x3D;&#123;value2&#125; 이렇게 브라우저 주소창에 입력한 파라미터를 웹서버에서 요청받고, 응답하려면 서블릿 클래스에도 파라미터를 받아줄 코드를 작성해주어야 한다. doGet()에서 HttpServletRequest 객체의 getParameter()를 이용하면 URI로 넘어오는 인자값을 서버에서 받아서 처리할 수 있게 된다. 12String name = request.getParameter(&quot;name&quot;);out.printWriter(&quot;Hello, &quot;+name); 그럼 이렇게 요청받은 인자값을 서버에서 받아서 다시 화면에 출력한 걸 확인할 수 있다. 다음 포스트에서는 이 간단한 실습때 사용했던 서블릿의 개념들에 대해 조금 더 알아보자.다음 포스트 읽으러 가기","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"http","slug":"http","permalink":"http://youngjinmo.github.io/tags/http/"},{"name":"servlet","slug":"servlet","permalink":"http://youngjinmo.github.io/tags/servlet/"}]},{"title":"Java8 - 람다와 함수형 인터페이스","slug":"java8-lambda-functional-interface","date":"2020-06-29T12:49:09.000Z","updated":"2020-10-07T04:44:35.921Z","comments":true,"path":"2020/06/java8-lambda-functional-interface/","link":"","permalink":"http://youngjinmo.github.io/2020/06/java8-lambda-functional-interface/","excerpt":"","text":"자바 8에 람다(Lambda)가 도입되면서 자바는 객체지향언어인 동시에 함수형 언어가 될 수 있었다. 람다식을 간단히 표현하면, 메서드를 하나의 식(expression)으로 표현한 익명 함수(Anonymous function) 이다. 여기서 알아두어야 할 점은 람다가 메서드가 아니라 함수라는 점이다. 람다를 알기 전까지는 메서드와 함수를 같은 의미로 해석했지만, 람다를 이해하기 위해서는 이 둘을 분리해서 생각해야 한다. 메서드 역시 함수와 같은 기능을 하지만, 메서드는 클래스에 반드시 속해야 한다는 제약조건이 존재 한다. 그러나 람다에서 함수는 어떤 클래스에도 종속될 필요가 없다. 그냥 사용하면 된다. 자바 8 이전의 자바에서는 메서드를 파라미터로 전달할 수 있는 방식이 없었다. 오직 인스턴스를 생성해서 객체를 통해서만 전달할 수 있었는데, 람다가 도입되면서, 인스턴스 없이도 파라미터안에 메서드를 정의 할 수 있게되었다. 이렇게 함수형 프로그래밍을 하게 될 경우, 객체지향에서처럼 메서드를 객체로 만들어서 파라미터에 넣어 사용하는대신 람다식은 함수 내에서 곧바로 사용할 수 있다는 특징이 있다. 이러한 프로그래밍을 함수형 프로그래밍이라 한다. 함수형 프로그래밍객체지향 : “Do..”함수형 : “It is..” 함수형 프로그래밍은 다른 말로 선언형 프로그래밍이라고 한다. 객체지향 프로그래밍이 각각의 객체에게 어떠한 행동을 명령형 프로그래밍이라고 한다면, 함수형 프로그래밍은 하나의 거대한 함수를 디자인하는 기법이다. input에 따라 output이 확정된다는 이야기이다. 객체지향의 경우 각각의 객체에서 개발자가 예측하지 못한 일이 발생한다면, 프로그래머의 기대와 다른 output이 나올수 있지만, 함수형 프로그래밍의 경우엔 함수의 동작에서 변수의 부수적인 값 변경을 원천 배제(=immutable)했기 때문에 input만 동일하다면 언제나 동일한 output을 기대할 수 있다. 즉, 객체 지향이 동작에 집중하는, How에 집중하는 방식의 프로그래밍이라면, 함수형 프로그래밍은 동작을 최소화하고 What 에 집중하는 방식의 프로그래밍이다. 람다식람다는 코드 한 줄로 작성해서 호출하는 방식의 함수식이다. 1( parameters ) -&gt; function body 소괄호 안에 파라미터를 정의하고, 람다 연산자(-&gt;)를 기준으로 오른쪽에 람다 함수를 정의한다. 람다 연산자(-&gt;)는 람다 함수로부터 파라미터를 분리해서 표현하는 역할을 한다. 여기서 알아두어야 할 점은 람다 함수 본체에서 return 키워드를 사용하지 않는다 는 점이다. return 키워드를 사용할 순 있으나, 그럴 경우 반드시 중괄호&#123;&#125; 를 사용해야 한다. return 키워드를 사용하지 않는다면 중괄호를 사용하지 않아도 무방하다. 123(int a, int b) -&gt; &#123; return a&gt;b ? a:b; &#125; // 이것도 맞고,(int a, int b) -&gt; a&gt;b ? a:b // 이것도 맞다.(a, b) -&gt; a&gt;b ? a:b // 심지어 이것도 맞다. 오히려 헷갈릴 수 있기 때문에 중괄호도, 추론가능한 파라미터의 데이터 타입, return 키워드도 생략하는게 더 편하지 않을까 생각한다. 람다식에서 이렇게 파라미터의 데이터 타입을 생략하더라도 자바 컴파일러가 데이터 타입을 추론가능한 이유는 인터페이스를 통해서 추론이 가능하기 때문이다. 람다는 함수임에도 불구하고 메서드 이름과 타입을 작성하지 않는다. 그래서 람다를, 식별자(identifier)없이 실행가능한 함수, 즉 익명 함수(anonymous function) 라고도 이야기한다. 간단히 쓰레드를 생성하는 예제를 통해 람다가 어떻게 쓰이는지 알아보자. 하나는 람다를 적용하지 않았고, 다른 하나는 람다를 적용했다. without Lambda 123456789101112131415public class lambdaExam_01 &#123; public static void main(String[] args) &#123; // without Lambda new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;Hello Lambda!&quot;); &#125; &#125;).start(); &#125;&#125; with Lambda 123456789public class lambdaExam_02 &#123; public static void main(String[] args) &#123; // with Lambda new Thread( () -&gt; System.out.println(&quot;Hello Lambda!&quot;) ).start(); &#125;&#125; 1hello lambda! 둘 다 정확히 같은 결과를 출력한다. 람다를 사용해서 코드가 더 간결해진걸 확인할 수 있다. 여기서 확인해야할 점은 단지 람다식 덕분에 코드가 짧아졌다는 것뿐만이 아니다. 쓰레드를 생성하기 위해서는 쓰레드가 상속받는 Runnable 인터페이스의 run()을 구현해야 하는데, 개발자가 직접 명시하지 않은 run()를 어떻게 알고 자바컴파일러는 run() 을 구현하여 쓰레드를 생성할 수 있었을까? 함수형 인터페이스이 비밀을 알기 위해서 Runnable 인터페이스를 열어보았다. 123456789101112131415@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object&#x27;s * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 추상메서드가 run() 하나만 존재하는걸 알 수 있다.그리고 이 Runnable 인터페이스위에 @FunctionalInterface가 작성되어있는데, 이것도 열어보았다. 12345678910111213141516171819202122package java.lang;import java.lang.annotation.*;/** * ( 중략 ) * * Conceptually, a functional interface has exactly one abstract * method. Since &#123;@linkplain java.lang.reflect.Method#isDefault() * default methods&#125; have an implementation, they are not abstract. * * ( 중략 ) * * &lt;p&gt;Note that instances of functional interfaces can be created with * lambda expressions, method references, or constructor references. * * ( 중략 ) */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface FunctionalInterface &#123;&#125; 다소 길어서 중간 부분을 좀 생략했는데, Functional Interface(함수형 프로그래밍)에 대한 설명을 해놓은 것 같다. 함수형 인터페이스는 하나의 추상 메서드를 갖는 인터페이스라고 정의해놓았다. 그리고 이 함수형 인터페이스의 인스턴스들은 람다식으로도 표현될 수 있다고 설명한다. 즉, 람다 예제 코드에서 Runnable 인터페이스를 사용할 수 있었던 이유는 Runnable 인터페이스가 추상 메서드를 하나만 갖고있는 함수형 인터페이스였기 때문이다. 그리고 추상 메서드가 하나만 있었기 때문에 람다식과 1:1로 맵핑되어 개발자가 run()를 직접 선언하지 않아도 함수 구현체를 run()으로 구현했음을 컴파일러가 인식한 것이다. 이번엔 직접 함수형 인터페이스를 만들어서 람다를 구현해보았다.이 코드에 대한 실행은 아래 링크를 통해 확인 가능하다. Repl에서 실행하기","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://youngjinmo.github.io/tags/java8/"},{"name":"lambda","slug":"lambda","permalink":"http://youngjinmo.github.io/tags/lambda/"},{"name":"functional interface","slug":"functional-interface","permalink":"http://youngjinmo.github.io/tags/functional-interface/"}]},{"title":"자바8의 신규 기능","slug":"java8-new-features","date":"2020-06-22T12:03:51.000Z","updated":"2020-09-13T01:53:28.352Z","comments":true,"path":"2020/06/java8-new-features/","link":"","permalink":"http://youngjinmo.github.io/2020/06/java8-new-features/","excerpt":"","text":"우분투에서 JDK를 설치하며 JDK의 가장 최신 버전이 12이까지 나왔음을 알았다. 그리고 프로그래머스 강의를 듣다보니 내가 그동안 사용한 자바 코드는 과거 버전에 머물러있음을 알았다. 그것도 5-6년 전 수준의.. 그동안 사용하지 않았던 자바의 새로운(?) 문법도 공부할겸, 이종립님 블로그에서 영감을 얻어 자바 언어 버전별 변경점을 정리하기로 했다. 회사에서 자바 8에 추가된 기능들을 정리해주었으면 좋겠다는 제안을 받아서 일단 자바 8 부터 정리를 해보려고 한다. 추후에 개인 Wiki에 다른 버전의 변경점들도 정리를 해나갈 예정이다. 오라클 문서에 정의된 내용을 모두 정리하기 보다는 개발자가 알아두어야할 부분만 정리하기 위해 Udemy에서 자바 8 features 로 검색하여 나온 강의들의 목차를 추려서 자바 8에서 개발자가 알아두어야할 변경점들을 정리했다. 그래서 자바 8에서 알아두어야할 특징들은 다음으로 정리하였다. 람다식을 시작으로 하나씩 정리하도록 하겠다. New features in JDK 8 Lambda Expressions Functional Interfaces Stream API Default Method Method References Optional Class Joda API (Date API &amp; Time API)","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://youngjinmo.github.io/tags/java8/"}]},{"title":"Java - File 읽고(Read) 출력(Write)하기","slug":"java-file-io","date":"2020-06-20T08:18:47.000Z","updated":"2020-09-13T01:53:28.600Z","comments":true,"path":"2020/06/java-file-io/","link":"","permalink":"http://youngjinmo.github.io/2020/06/java-file-io/","excerpt":"","text":"Java에서 파일을 입력하고, 출력해보는 예제이다. Java에서 파일을 입력하기 위해서는 FileInputStream 클래스를 사용해야 한다. 마찬가지로 입력받은 파일을 다시 새로운 파일로 생성하기 위해서는 FileOutputStream 클래스를 사용해야 한다. 사용하기 전 먼저 초기화를 해준다. 12FileInputStream fis = null;FileOutputStream fos = null; 이제 FileInputStream 클래스로 생성한 인스턴스에 입력할 대상 파일의 경로(path)를 지정해주어야 한다. 그런데 이렇게 exception이 발생할 수 있다고 경고가 발생하고 있다. FileNotFoundException이 발생할 수 있기 때문에 try-cat문으로 예외처리를 해준다. File 입력 인스턴스 아래에 출력할 파일의 경로도 지정해준다. 123456try &#123; fis = new FileInputStream(&quot;src/io/helloworld.txt&quot;); fos = new FileOutputStream(&quot;src/io/cloneHello.txt&quot;);&#125; catch (Exception e)&#123; e.printStackTrace();&#125; 입력대상 파일은 미리 만들어주자. 12Hello World!My name is Devandy. 입출력 관련 인스턴스를 생성했으므로, 이제 파일을 입력하는 코드를 작성해보자. 파일을 입력하기 위해서는 FileInputStream 클래스의 read()를 사용해서 입력할 수 있다. Eclipse에서 command(windows: control) 키를 누르고 read()를 클릭해서 확인해보니, byte 단위로 입력을 받으며, 더 이상 읽을 데이터가 없을 때 -1을 출력하는걸 알 수 있다. 그럼 read()가 -1을 반환할 때까지 반복문으로 파일을 입력시키면 될 것 같다. 한 byte 단위로 입력하기 때문에 출력하는 시점도 byte 단위로 읽어들이는 그 순간, 순간 해주어야 한다. 1234int readData = 0;while((readData=fis.read()) != -1)&#123; fos.write(readData);&#125; int형 변수 readData는 FileInputStream 클래스의 read()로 읽어들인 byte를 저장하는 임시 공간역할을 한다. readData에 byte가 담겨지면, 곧바로 FileOutputStream 클래스의 write()를 이용하여 readData에 담긴 byte를 출력한다. 이러한 행위를 fis.read()를 통해 readData에 -1이 들어올때까지 반복한다. fis.read()에 -1이 들어왔다는건 더 이상 읽어들일 byte가 없다는 의미라는걸 앞에서 확인했다. 파일 입력이 끝나면, 끝났다는걸 콘솔에 알려줄 print문 하나를 while문 아래에 추가하자. 123if(readData==-1) &#123; System.out.println(&quot;Read Done!!&quot;);&#125; 최종 코드는 아래와 같다. 1234567891011121314151617181920212223242526272829package io;import java.io.FileInputStream;import java.io.FileOutputStream;public class DevAndyExamIO &#123; public static void main(String[] args) &#123; FileInputStream fis = null; FileOutputStream fos = null; try &#123; fis = new FileInputStream(&quot;src/io/helloworld.txt&quot;); fos = new FileOutputStream(&quot;src/io/cloneHello&quot;); int readData = 0; while((readData=fis.read())!=-1) &#123; fos.write(readData); &#125; if(readData==-1) &#123; System.out.println(&quot;Read Done!!&quot;); &#125; &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; FileInputStream,FileOutputStream 클래스의 인스턴스의 쓰임이 다했다면, close()로 클래스를 닫아주어야한다. Stream 인스턴스를 닫아주어야 하는 이유를 공식문서에서는 다음과 같이 설명하고 있다. Streams have a BaseStream.close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.) 모든 stream 인스턴스는 닫아줄 필요가 없긴 하지만, IO 관련 stream 클래스의 경우는 닫아주어야 한다. 그러나 명확한 설명은 작성되어 있지 않은데, 그래서 구글링을 해보니 10여년전, 이미 이것에 대해 OKKY에서 여러 의견이 오고갔음을 확인했다. 요약하면, GC가 메모리 관리를 해주긴 하지만, GC가 인스턴스를 언제 종료시킬지 알 수 없기 때문에 사용이 끝난 시점에 개발자가 수동으로 종료해주는게 좋은듯하다. try-cat문의 finally를 추가하여 close()를 작성할 수 있지만, 공식문서에서 try-with-resources를 추천했으니 이걸로 수정해보겠다. 1234567891011121314try ( FileInputStream fis = new FileInputStream(&quot;src/io/helloworld.txt&quot;); FileOutputStream fos = new FileOutputStream(&quot;src/io/cloneHello.txt&quot;);) &#123; int readData = 0; while((readData=fis.read())!=-1) &#123; fos.write(readData); &#125; if(readData==-1) &#123; System.out.println(&quot;Read Done.!!&quot;); &#125;&#125; catch(Exception e) &#123; e.printStackTrace();&#125; 이렇게 try-with-resources를 사용하면, try{}문 안에 작성된 코드가 모두 실행되면 자동으로 try문에 선언된 객체의 close()를 실행시킨다고 한다. 이제 main 메서드를 실행하면, 콘솔에 메세지와 함께 디렉토리에 helloworld.txt를 복사한 cloneHello.txt가 생성될 것이다. Eclipse에선 즉시 파일이 생기지 않으므로 io 패키지를 refresh 해야 생성된 파일을 볼 수 있다. 이렇게 해도 파일을 입력하고, 출력할 수 있지만, 한 byte씩 입출력하는건 효율적이지 않다. 입력을 한 번에 많이 받아두고, 한 번에 출력하면 입출력 성능이 더 좋아질것 같다. 이를 위해 buffer 개념을 적용해서 출력해보았다. 12345int readData = 0;byte[] buffer = new byte[512];while(fis.read()!=-1) &#123; fos.write(fis.read());&#125; 이렇게 해야하는 이유는 기존의 한 byte씩만 입출력하는것보다 효율적이기 때문인데 왜냐면, 개발자가 한 byte씩 입출력을 하더라도 운영체제는 512 byte씩 InputStream클래스에서 가져와서 OutputStream으로 가져가기 때문이다. 마치 512명을 태울수 있는 비행기가 한 명만 태우고 비행하는 것과 같은 개념이다. 한 번에 512명을 모투 태워서 비행한다면, 비행 회수가 줄어들것이다. 이 방식으로 buffer를 만들면 입출력 성능이 개선될 수 있는 것이다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"io","slug":"io","permalink":"http://youngjinmo.github.io/tags/io/"}]},{"title":"REST","slug":"rest-api","date":"2020-06-18T11:29:48.000Z","updated":"2020-11-26T07:38:24.177Z","comments":true,"path":"2020/06/rest-api/","link":"","permalink":"http://youngjinmo.github.io/2020/06/rest-api/","excerpt":"","text":"회사에서 REST에 대한 강의를 들을 기회가 있어, 강의를 듣고 정리해보았다. ToC REST란? Why REST? RESTful API? REST API 특징 Rest API 디자인 가이드 URI 설계 가이드 Five clues that your api isn’t RESTful. REST 약점 RESTREST를 한 문장으로 정의하면, REST는 HTTP 프로토콜을 사용하는 아키텍처이다. REST란 일반적으로 HTTP method와 URI까지를 이야기한다. Why REST? How do I imporve HTTP without breaking the Web HTTP의 주요 저자중 한 사람인 Roy Fielding이 HTTP 설계의 우수성에 비해 제대로 사용되어지지 못하는 모습에 안타까워하여 HTTP의 장점을 최대한 활용하는 아키텍처 로써 박사학위 논문에서 소개한 아키텍처이다.한 문장으로 정리한다면, API 역할에 따라 HTTP 스펙을 더 잘 사용하기 위한 아키텍쳐가 REST 라고 할 수 있다. REST 특징 Uniform Interface 자원의 위치가 아닌 HTTP 메서드로 접근하는 대상이 무엇인지를 구체적이고, 명확히 표현한다. 무상태성 (Stateless) 세션, 쿠키없이 HTTP로만 독릭적으로 통신이 가능해야한다. 캐시가능 (Cacheable) REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹 표준을 그대로 사용하기 때문에 웹에서 사용하는 기존 인프라를 그대로 활용이 가능하다는 점이다. 따라서 HTTP가 가진 캐싱을 적용가능하다. 자체 표현구조 (Self-descriptiveness) REST의 또 다른 큰 특징 중 하나는 REST API 메세지만 보고도 이를 쉽게 이해할 수 있는 표현이어야 한다. Client - Server 구조 REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트(세션, 로그인 정보) 등을 직접 관리하는 구조로 각각의 역할이 계층형 구조 (Hierarchical Structure) REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있으며 Proxy, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게한다. REST API 디자인 가이드REST API 설계시 신경써야할 두가지 설계 가이드이다. URI는 리소스를 표현해야 한다. 리소스에 대한 행위는 HTTP method로 표현한다. URI 설계 가이드REST의 뜻인 Representational State Transfer에서 알 수 있듯이 REST는 어떻게 표현되는가가 중요한 아키텍처이다. REST는 HTTP method만 사용한다고 REST라고 할 수 없다. URI 설계를 잘해야 RESTful API라고 할 수 있다. URI만으로 이 API 메세지의 의도를 개발자가 직관적으로 이해할 수 있을 때, RESTful API라고 할 수 있다. 1HTTP-method &#123;service-name&#125;&#x2F;&#123;api-version&#125;&#x2F;&#123;resource-category&#125;&#x2F;&#123;resource-path&#125;&#x2F;&#123;path-variable&#125; 1GET tmap&#x2F;2.1&#x2F;location RESTful API를 위한 URI 작성 규칙은 다음과 같다. 명사(noun) HTTP methods가 동사(verb)이므로 URI마저 동사로 작성한다면, API 의미가 직관적이지 이지 않게된다. GET /fruits/bananas 요청한다. 과일들 중 바나나를. 복수형(mutiple) API는 특성상 리소스들이 하나기보다는 복수형일 수 있다. 위의 API를 해석하면, 과일 중 바나나를 요청한다고 했을때, 바나나가 1개만 조회될리 없기 때문이다. 구체적(specifically) URI 만으로 해당 API가 RESTful한지 아닌지를 판단할 수 있기 때문에 URI는 추상적이지 않고 구체적일수록 좋다. 과일을 요청하는게 아니라 바나나를 요청해야한다. RESTful API?RESTful하다는 표현과 REST를 아키텍쳐라고 표현한 부분에서 알 수 있듯이 REST는 규약(protocol)이 아니다. 따라서 REST는 이분법적으로 판단할 수 없으며, 추상적으로 판단할 수 밖에 없다. REST의 조건을 충분히 충족시키는 API를 RESTful 하다는 다소 추상적인 표현을 하는 이유이다. Five clues that your api isn’t RESTful. PHP 개발자인 Lorna Mitchell이 작성한 *당신의 API가 RESTful 하지 않다는 다섯가지 증거*라는 제목으로 작성한 글이다. Lorna Mitchell이 언급한 API가 RESTful하지 않은 5가지 증거는 아래에 정리해두었다. It has a single endpoint. GET /phones 이런 API는 RESTful 하지 않는 API이다. 아래의 API가 더 직관적이며, RESTful API라고 할 수 있는 API이다. GET /devices/phones All requests are POSTs. 무조건 POST method로만 API를 작성하는 것도 RESTful하지 않은 방식이다. API의 기능에 따라 HTTP method를 다양하게 활용할 수 있어야 한다. Response meta data is in the body. 메타 데이터는 최대한 HTTP header에 포함해야한다. status는 body로 보낼 필요가 없는 데이터이다. response 메타데이터(결과 값, 세션 키)는 body가 아니라 header에 포함되어야 한다. 요청 경로에 리소스가 없을때 : 404 요청 정보가 정확하지 않을때 : 400 인증에 실패했을때 : 401 요청에 성공했을때 : 200 body에는 결과 값이나 인증 키같은 메타데이터가 아니라 순수 데이터만 포함시켜야 한다. There are verbs in the URL. HTTP method가 이미 동사(verb)기 때문에 URI이 명사(noun)로 작성되어야 API가 더 직관적으로 표현된다. The URL includes method names. REST는 resource를 표현하는 아키텍처라고 설명했다. 따라서 URL에 메서드명을 노출하는건 RESTful하지 않은 방식이다. 더군다나 url 작성 규칙과 프로그래밍 언어단에서의 메서드 작성 규칙은 다르기 때문에 메서드명이 url에 등록이 되면 안된다. REST 약점 HTTP 메서드를 사용하기 때문에 모바일/웹 등 사용할 수 있다는 인프라 범위가 넓다는 장점이 있지만, HTTP 메서드를 사용하기 때문에 제한적이라는 단점 또한 존재한다. 표준이 존재하지 않기때문에 REST API 디자인 가이드가 따로 존재하지 않는다. 그래서 Lorna Mitchell이 작성한 글(Five clues that your api isn’t festful)처럼 RESTful API를 위한 약속들만 존재한다. 참고 문서 및 함께 보면 좋은 글/영상 (Youtube) 얄팍한 코딩사전 - REST API가 뭔가요? NHN Toast - REST API 제대로 알고 사용하기 Lorna Jane - Five Clues That Your API isn’t RESTful (Youtube) 2017 DEVIEW - 그런 REST API로 괜찮은가","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Web","slug":"Dev/Web","permalink":"http://youngjinmo.github.io/categories/Dev/Web/"}],"tags":[{"name":"api","slug":"api","permalink":"http://youngjinmo.github.io/tags/api/"},{"name":"architecture","slug":"architecture","permalink":"http://youngjinmo.github.io/tags/architecture/"},{"name":"rest","slug":"rest","permalink":"http://youngjinmo.github.io/tags/rest/"}]},{"title":"웹서버와 WAS","slug":"webserver-was","date":"2020-06-15T13:05:56.000Z","updated":"2020-09-13T01:53:28.048Z","comments":true,"path":"2020/06/webserver-was/","link":"","permalink":"http://youngjinmo.github.io/2020/06/webserver-was/","excerpt":"","text":"웹서버와 WAS 차이를 이해하기 전, Static Web과 Dynamic Web의 차이를 먼저 이해할 필요가 있다. Static Web 정적인 웹 애플리케이션이다. 클라이언트로부터 리소스 경로를 요청 받으면, 웹 서버상의 리소스(html, css, js 등의 static 리소스)를 반환하는 기능을 수행한다. 사용자의 요청에 따라 능동적으로 반환하기 보다는 그저 리소스의 경로를 요청받으면, 거기에 맞는 리소스만 반환하는 제한된 역할을 수행한다. 현재 이 블로그도 이러한 static web의 형태이다. Dynamic Web 동적인 웹은 클라이언트의 요청에 따른 리소스를 반환한다. 예를 들면, 브라우저 검색창에 https://www.google.co.kr/search?q=devandy 라고 입력하고 접속하면, 구글 검색창에 devandy를 검색한 결과창이 출력된다. Google 서버에 q에 대입한 키워드로 search 결과를 요청한 것에 따른 반환 결과인 것이다. 다른 키워드를 검색하면 당연히 검색결과는 해당 키워드에 맞는 문서들로 출력될 것이다. 이런 웹의 형태를 클라이언트의 요청에 따라 dynamic한 응답을 한다고 해서 dynamic web이라고 한다. Web Server 웹 서버는 크게 두 가지 형태로 구분한다. 하드웨어와 소프트웨어로 구분할 수 있는데, 하드웨어 웹 서버는 리소스를 저장하는 물리적 서버(컴퓨터)를 이야기한다. 소프트웨어로써 웹 서버는 클라이언트로부터 HTTP 요청을 받아서 리소스를 반환하는 프로그램을 이야기한다. Apache와 Nginx가 웹 서버에 해당한다. WAS(Web Application Server) WAS는 웹서버와 웹 컨테이너를 결합한 형태(WAS = Web Server + Web Container)를 의미한다. 웹 컨테이너란, JSP, Servlet을 실행시킬수 있는 소프트웨어를 말하는데, WAS가 웹 컨테이너의 구동 환경임을 제공한다. WAS는 dynamic web을 구성함과 동시에 트래픽을 분산 처리하기 위해 사용된다. 정적 리소스에 대한 요청은 웹 서버에서 해결하고, DB 조회가 필요한 경우에만 웹 컨테이너가 동작되게끔 구조적으로 분리되어있다. 웹 컨테이너만으로도 웹 애플리케이션을 구성할 수 있을것 같지만, 웹 서버를 따로 분리한 이유는 역할에 따라 구분함으로써 서버 부하를 방지하며, 로드밸런스를 위해서이다. 여기서 로드 밸런스란 하나의 웹 서버로 모든 요청을 처리하면, 클라이언트 요청이 많아질수록 서버 부담이 커지므로, 서버를 증설하여 요청을 분산하여 결과적으로 서버 부하를 방지할 수 있는 웹 서비스이다. 로드 밸런스를 구축하면, 하나의 웹 서버가 뻗는다하더라도 클라이언트 요청을 정상적으로 작동하는 서버로 보내서 무중단 서비스를 구축하는 일이 가능해진다. 같이 읽어보면 좋을 글 또는 영상 권희정님 블로그 - Web Server와 WAS의 차이와 웹 서비스 구조 [우테코 10분 테크톡] - 희봉님의 웹서버와 WAS","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Web","slug":"Dev/Web","permalink":"http://youngjinmo.github.io/categories/Dev/Web/"}],"tags":[{"name":"jar","slug":"jar","permalink":"http://youngjinmo.github.io/tags/jar/"},{"name":"war","slug":"war","permalink":"http://youngjinmo.github.io/tags/war/"},{"name":"webserver","slug":"webserver","permalink":"http://youngjinmo.github.io/tags/webserver/"}]},{"title":"Git - Stash 활용법","slug":"git-stash","date":"2020-06-13T04:06:10.000Z","updated":"2020-09-13T01:53:28.864Z","comments":true,"path":"2020/06/git-stash/","link":"","permalink":"http://youngjinmo.github.io/2020/06/git-stash/","excerpt":"","text":"rebase를 다루다보면, stash 기능이 필요할 때가 있다. stash는 현재 staging된 파일들이 있는 status를 잠시 저장할 때 사용하는 명령어이다. 아래의 예제를 보면서 이해해보자. git init저장소를 만들어서 a부터 d까지 이름을 각각 갖는 txt 포맷의 파일 4개를 생성했다. 그리고 a.txt만 staging 해두었다. 12$ git add a.txt$ git status 현재의 상태는 다음 그림과 같다. Git은 stage에 있는 파일만 버전관리를 하기 때문에 stage 바깥에 있는, 즉 아직 staging하지 않은 파일들은 추적되지 않는다. 따라서 따라서 rebase처럼 stage가 비워져있어야지만 진행할수 있는 상황에서는 현재처럼 staging된 파일이 있을 경우 다음으로 진행할 수가 없다. 이 때 stash를 사용하면 stage에 있는 파일들을 다른 임시 저장소로 옮겨두고, stage를 비울수 있다. git stash현재 예제로 작성한 저장소가 커밋이 없는 관계로 stage에 있는 a.txt를 커밋하고, 이번엔 b.txt를 staging하고 stash로 저장해보겠다. 123$ git commit -m &quot;add a&quot;$ git add b.txt$ git stash git stash list커밋을 하지 않았음에도 status에서 b.txt가 보이지 않는다. 성공적으로 임시저장소에 저장한것이다. 그럼 임시저장소에 저장된 b.txt는 어떻게 볼 수 있을까? 12$ git stash list$ git stash show stash 명령어의 list 옵션으로 임시저장소에 저장된 stash 리스트를 출력할 수 있다. 그리고 show 옵션으로 해당 stash에 어떤 파일이 담겨있는지도 자세히 볼 수 있다. 그럼 이 stash list에 하나 더 추가해보겠다. c.txt로 staging하고 stash로 저장했다. 1234$ git add c.txt$ git stash$ git status$ git log git stash show 이렇게 stash list에 두개의 stash가 생성된 것이 보인다. 12stash@&#123;0&#125;: WIP on master: 205a72d add astash@&#123;1&#125; : WIP on master: 205a72d add a add a라는 커밋메세지를 갖고있는 커밋(205a72d)를 바라보는 stash들임을 알 수 있으며, 인덱스 갖고잇음으로 이들을 서로 구분할 수 있다. 따라서 각각의 stash에서 어떤 상태를 저장했는지를 보고자 한다면, stash의 인덱스와 함께 show 옵션을 명령하면 조회할 수 있는 것이다. 새로 추가된 stash의 인덱스가 0이며, 오래될수록 인덱스 번호가 증가하는 방식이다. 따라서 첫 stash를 조회하기 위해선 현재 상태에서 인덱스 1의 stash를 조회해야 한다. 1$ git shash show 1 git stash pop이제 다시 돌아가서 b.txt를 커밋하고자 하면, 어떻게 해야할까? 저장해둔 stash를 다시 꺼내야 할 것이다. 이 때 사용하는 옵션 명령어가 pop이다. 1$ git stash pop 1 이외에도 stash 명령어의 clear 옵션으로 stash를 비울수도 있지만, 위험해보이는 옵션명령어 같아서 앞으로 얼마나 쓸 일이 있을지 모르겠다. clear 명령을 하면 당시 staging되었던 파일이 아예 사라진다. 1$ git stash clear 이상 git stash 명령어 정리 끝!","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[{"name":"stash","slug":"stash","permalink":"http://youngjinmo.github.io/tags/stash/"}]},{"title":"String 객체 연산시 StringBuffer를 사용해야하는 이유","slug":"java-stringbuffer-better-than-string","date":"2020-05-16T00:11:06.000Z","updated":"2020-09-13T01:53:28.396Z","comments":true,"path":"2020/05/java-stringbuffer-better-than-string/","link":"","permalink":"http://youngjinmo.github.io/2020/05/java-stringbuffer-better-than-string/","excerpt":"","text":"자바 프로그래밍을 처음 배우던 시기에 문자열을 반복적으로 연산하는 방법으로 String 객체를 사용하곤 했다. 사실 StringBuffer를 알게 된 바로 지금까지도… 별을 1만개 찍는 코드로 String 객체를 사용하는것과 StringBuffer를 사용하는 것의 차이를 비교해보겠다. 12345678910public class shinningStars &#123; public static void main(String[] args)&#123; String str = &quot;&quot;; for(int i = 0; i&lt;10000; i++)&#123; str = str+&quot;*&quot;; &#125; System.out.println(str); &#125;&#125; 이렇게만 코드를 짜면 별을 1만개 찍을수는 있지만, 성능을 체크할 수 없다. 따라서 System 클래스의 currentTimeMillis()를 이용해서 성능을 체크해보겠다. System.currentTimeMillis()는 해당메서드가 호출되는 시점의 시스템 시간을 불러오는 메서드이다. 프로그램이 시작되기 전 시간과 프로그램의 종류 후 시간을 연산한다면 프로그램의 실행시간을 알 수 있을 것이다. 123456789101112131415public class shinningStars &#123; public static void main(String[] args)&#123; long startTime = System.currentTimeMillis(); String str = &quot;&quot;; for(int i = 0; i&lt;10000; i++)&#123; str = str+&quot;*&quot;; &#125; System.out.println(str); long endTime = System.currentTimeMillis(); System.out.println(&quot;실행시간 : &quot;+(endTime-startTime)); &#125;&#125; 실행할때마다 실행시간이 조금씩 다르지만 대체적으로 46초~55초가 출력되고 있다. 그럼 이제 이 코드에서 문자열 변수를 StringBuffer로 타입을 바꿔서 다시 체크해보겠다. 123456789101112131415public class shinningStars &#123; public static void main(String[] args)&#123; long startTime = System.currentTimeMillis(); StringBuffer str = new StringBuffer(); for(int i = 0; i&lt;10000; i++)&#123; str.append(&quot;*&quot;); &#125; System.out.println(str); long endTime = System.currentTimeMillis(); System.out.println(&quot;실행시간 : &quot;+(endTime-startTime)); &#125;&#125; 이번엔 실행시간이 1-2초로 대폭 줄어든걸 확인할 수 있다. 같은 내용을 출력하면서도 속도가 10배이상 향상된 것이다. 이렇게 차이가 나는 이유는 String 타입으로 문자열 변수를 연산할 경우, for문안에서 계속 새로운 String 데이터를 생산한다. 반면 StringBuffer를 사용하면, 새로운 객체 생성없이 기존의 객체에 값만 append하기 때문이다. Java API 문서를 보면, StringBuffer에 대한 설명으로 StringBuffer는 가변적인(immutable) 문자형들의 순서집합(sequence)이라고 정의했다. StringBuffer는 String과 같지만, 수정할 수 있다는 특징도 언급했다. A thread-safe, mutable sequence of characters. A string buffer is like a String, but can be modified. At any point in time it contains some particular sequence of characters, but the length and content of the sequence can be changed through certain method calls. StringBuffer는 capacity가 존재하는데, 모든 StringBuffer는 이 capacity를 초과하지 않는 문자형 시퀀스를 가지고 있다고 한다. 여기까지 읽으면 배열의 속성처럼(?) 들리는데, 배열과 달리 StringBuffer는 internal bufffer array를 초과할 경우 자동으로 capacity를 늘린다고 한다. 이게 append()를 이용해 값을 늘려나가는 immutable한 특징을 설명하는 것 같다. Every string buffer has a capacity. As long as the length of the character sequence contained in the string buffer does not exceed the capacity, it is not necessary to allocate a new internal buffer array. If the internal buffer overflows, it is automatically made larger. 그러나 String 타입에 비하면 StringBuffer는 무거운 타입의 객체이므로 immutable하게 사용할 목적이 아니라면, string을 사용하는게 전체적인 프로그램 성능에 더 도움이 될 것 같다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"string","slug":"string","permalink":"http://youngjinmo.github.io/tags/string/"},{"name":"io","slug":"io","permalink":"http://youngjinmo.github.io/tags/io/"},{"name":"stringbuffer","slug":"stringbuffer","permalink":"http://youngjinmo.github.io/tags/stringbuffer/"}]},{"title":"Java - Exception","slug":"java-exception","date":"2020-05-13T12:10:26.000Z","updated":"2020-10-08T09:10:15.836Z","comments":true,"path":"2020/05/java-exception/","link":"","permalink":"http://youngjinmo.github.io/2020/05/java-exception/","excerpt":"","text":"코딩을 하다보면, 예외처리가 필요한 순간이 있다. 위의 이미지 속 코드만 보더라도 위의 코드는 에러를 유발한다. 실제 이클립스에서 실행한 결과이다. 연산 처리에 예외상황이 발생했음을 알리는 ArithmeticException 이 발생했다. API 문서를 보니 ArithmeticException에 대해서 아래처럼 작성되어 있다. RuntimeException을 상속받는 클래스임을 알 수 있다. 다시 RuntimeException은 Exception을 상속받고 있으며, 가장 상위에는 Object 클래스를 상속받고 있다. 예외처리는 크게 2가지로 할 수 있다. 예외가 발생하는 곳에서 직접 핸들링 할 것(try-catch)이냐, 아니면 예외가 발생할 가능성이 있는 객체를 참조해서 사용하는 곳에서 핸들링할 것(throws-exception)이냐. try-catch throws-exception try - catchtry-catch는 예외처리가 발생할 가능성이 있는 객체 내부에서 처리하는 방식이다. try catch문을 적용해서 위의 코드를 다시 컴파일해보았다. 123456789101112131415public class arithmeticException &#123; public static void main(String[] args) &#123; int i = 10; int j = 0; int result=0; try &#123; result = i/j; &#125; catch(ArithmeticException e) &#123; result = 0; &#125; finally &#123; System.out.println(&quot;결과는 &quot;+result+&quot;입니다.&quot;); &#125; &#125;&#125; 이번엔 예외가 발생하지 않고 출력을 할 수 있었다. 이 때 사용한 try catch문에 대해 알아보자. try catch문은 다음과 같다. 12345678try &#123; // 예외가 발생할 수 있는 코드&#125; catch(예외클래스 변수) &#123; // 예외가 발생할 경우 대신 처리하는 코드&#125; finally &#123; // 예외 발생 여부와 상관없이 작동하는 코드 // 반드시 finally를 사용할 필요는 없다.&#125; try &#123;&#125;에는 예외가 발생할 수 있는 코드를 감싸주고,catch에는 try 구문에서 예외 상황이 발생할 경우 대신 처리할 코드를 감싸준다.finally &#123;&#125;에는 예외발생 여부와 상관없이 작동할 코드를 감싸주면 된다. Throws Exceptionthrows는 예외를 던지는 키워드이다. 즉 ‘예외가 발생한다면, 네가 예외처리를 해줘’ 라는 메세지이다. 즉 예외처리에 대한 책임을 예외처리가 발생하는 메서드를 사용할 객체에 넘기는 일이다. 이를 통해 사용하는 객체에서 어떤 예외처리가 발생할지를 미리 알 수 있다. 123456789101112131415161718192021public class arithmeticException &#123; public static void main(String[] args) &#123; arithmeticException ae = new arithmeticException(); int i = 10; int j = 0; try &#123; int result = ae.calculate(i, j); &#125; catch(ArithmeticException e) &#123; System.out.println(e.toString()); &#125; &#125; int calculate(int num1, int num2) throws ArithmeticException &#123; int result = num1/num2; return result; &#125;&#125; 위의 코드는 연산하는 부분을 따로 메서드로 분리한 코드이다. main( )에서 사용하면 ArithmeticException이 발생하는데, try catch문으로 예외를 처리해두었다. 이 예외가 발생하는 로직이 담긴 calculate( )에는 예외처리에 대한 책임을 넘기는 throws ArithmeticException을 작성했다. 이로써 throws 뒤에 exception 관련 코드가 작성되면, 해당 메서드를 사용하는 쪽에서 예외처리를 해주어야 한다는 것을 미리 알 수 있게 된 것이다. throw newthrows 키워드가 예외처리를 상위 블록으로 넘겼다면, throw new는 강제로 예외를 발생시키는 키워드이다. 123456789101112131415161718192021222324252627public class arithmeticException &#123; public static void main(String[] args) &#123; arithmeticException ae = new arithmeticException(); int i = 10; int j = 0; try &#123; int result = ae.calculate(i, j); &#125; catch(ArithmeticException e) &#123; System.out.println(e.toString()); &#125; &#125; int calculate(int num1, int num2) &#123; if(num2==0) &#123; throw new ArithmeticException(&quot;0으로 나눌수 없습니다.&quot;); &#125; int result = num1/num2; return result; &#125;&#125; 분모로 들어오는 num2가 0일 경우 ArithmeticException이 발생하므로 calculate( )에서 아예 num2가 0으로 들어올 경우, ArithmeticException을 던지도록 작성했다. 메서드에 throws 키워드를 통해 작성하는게 더 편해보이기는 하나, 이 방식으로 작성하면 조금 더 직관적으로 왜 예외가 발생한건지를 알 수 있을 것 같다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"exception","slug":"exception","permalink":"http://youngjinmo.github.io/tags/exception/"}]},{"title":"Ubuntu에서 JDK 설치하기","slug":"install-jdk-ubuntu","date":"2020-05-08T13:42:37.000Z","updated":"2020-09-13T01:53:28.648Z","comments":true,"path":"2020/05/install-jdk-ubuntu/","link":"","permalink":"http://youngjinmo.github.io/2020/05/install-jdk-ubuntu/","excerpt":"","text":"JDK를 설치하는 방법은 2가지가 있는데, default-jdk를 설치하는 경우와 add-apt-repository를 이용하여 원하는 버전의 jdk를 직접 설치하는 경우이다. JDK 설치 전, 관련 리소스 정리하기 default-jdk 설치하기 add-apt-repository 사용하여 jdk 버전 선택해서 설치 JDK 설치 전, 관련 리소스 정리하기jdk를 설치하기 전, jdk구버전을 깨끗하게 지우고 시작하는 방법부터 알아보자. openjdk라는 이름의 패키지들을 삭제하는 명령어이다. 1$ sudo apt-get remove openjdk* 마찬가지로 oracle도 삭제해준다. 1$ sudo apt-get remove oracle* openjdk와 oracle을 삭제함으로써 더이상 사용되지 않는 패키지들을 autoremove를 통해 깔끔히 제거한다. 12$ sudo apt-get autoremove --purge$ sudo apt-get autoclean default-jdkdefault-jdk를 설치하는 경우를 알아보자. 작성시점인 2020년 5월 기준, Ubuntu 18.04.3 에서 default-jdk를 설치하면 jdk 11이 설치된다. 12$ sudo apt-get update -y$ sudo apt-get install default-jdk -y 참고로 -y 옵션은 설치과정에서 묻는 [Y/n]에 대해 미리 Y를 입력하라는 옵션이다 add-apt-repository 사용하여 jdk 버전 선택해서 설치add-apt-repository는 파이썬 기반의 스크립트라고 하는데 이걸 사용하기 위해서는 software-properties-common을 먼저 설치해야한다. 1$ sudo apt install software-properties-common 이제 add-apt-repository를 사용할 수 있게 되었다. jdk 설치파일 소스 리스트를 추가해보자. 1$ sudo add-apt-repository ppa:openjdk-r&#x2F;ppa 이후 apt-get을 업데이트하면, 설치한 jdk 리스트를 조회할 수 있다. 12$ sudo apt-get update -y$ apt-cache pkgnames | grep jdk 원하는 버전의 jdk를 설치한다. 1$ apt-get install openjdk-8-jdk 버전확인을 해서 원하는 버전의 jdk가 잘 설치되었는지 확인해보자. 1$ java -version","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Linux","slug":"Dev/Linux","permalink":"http://youngjinmo.github.io/categories/Dev/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://youngjinmo.github.io/tags/ubuntu/"}]},{"title":"Java - String 클래스 메서드 정리","slug":"java-string-methods","date":"2020-05-03T07:56:04.000Z","updated":"2020-09-13T01:53:28.408Z","comments":true,"path":"2020/05/java-string-methods/","link":"","permalink":"http://youngjinmo.github.io/2020/05/java-string-methods/","excerpt":"","text":"String 클래스가 내장하고 있는 메서드들에 대해 정리해보았다. append() length() concat() substring() indexOf() lastIndexOf() charAt() isEmpty() replace() toUpperCase() toLowerCase() trim() split() toCharArray() getBytes() length()12345678/* 문자열 데이터의 길이를 반환하는 메서드이다. 파라미터는 존재하지 않는다. */String str = &quot;Hello Java&quot;;System.out.println(str.length()); // 출력결과 : 10 concat()123456789/* 문자열과 문자열을 결합하는 메서드이다. 파라미터에 추가할 String형 데이터가 온다. */String str = &quot;Hello &quot;;String lang = &quot;Java&quot;;System.out.println(str.concat(lang));// 출력결과 : Hello Java substring()123456789101112/* 문자열을 자르는 메서드이다. 파라미터에 어디부터 어디까지 자를지 문자열의 인덱스가 와야한다. 첫번째 파라미터가 시작 인덱스, 두번째 파라미터가 마지막 인덱스이며, 파라미터를 하나만 넣을경우, 입력받은 인덱스부터 마지막까지 문자열을 자른다. */String str = &quot;Hello Java&quot;;String lang = str.substring(6);System.out.println(lang);// 출력 결과 : Java indexOf()1234567891011/* 문자가 위치한 인덱스를 반환하는 메서드이다. 파라미터로 char형 문자를 입력받으며, 해당 문자와 일치하는 문자가 문자열에 존재할 경우 인덱스를 반환한다. 만약 2개 이상 문자가 발견될 경우, 가장 먼저 오는 문자의 인덱스를 반환한다. 문자가 존재하지 않는 경우엔 -1을 반환한다. */String str = &quot;Hello Java&quot;;System.out.println(str.indexOf(&#x27;a&#x27;));// 출력 결과 : 7 lastIndexOf()1234567891011/* indexOf()와 비슷한 기능을 가진 메서드이다. 문자열의 인덱스를 반환하는 것은 같으나 indexOf()와 달리 뒤에서부터 조회해서 인덱스를 반환한다는 점이 특징이다. 마지막 문자의 인덱스를 반환한다. 파라미터로 인덱스 조회를 하고자하는 char형 문자를 입력받는다. */String str = &quot;Hello Java&quot;;System.out.println(str.lastIndexOf(&#x27;a&#x27;));// 출력 결과 : 9 charAt()123456789/* indexOf()와 반대의 메서드이다. 인덱스에 위치한 문자를 반환하는 메서드이다. 파라미터로는 int형 인덱스를 입력받는다. */String str = &quot;Hello Java&quot;;System.out.println(str.charAt(1));// 출력 결과 : e isEmpty()1234567891011/* 해당 문자열이 빈 값인지 확인하는 메서드이다. 문자열의 길이가 0인지 비교하여 boolean값을 반환한다. 파라미터는 없다. 문자열의 길이가 0이면, true 문자열의 길이가 0이 아니면 false */String str = &quot;Hello Java&quot;;System.out.println(str.isEmpty());// 출력 결과 : false replace()1234567891011/* 문자열의 일부를 다른 문자열로 바꿔주는 메서드이다. 파라미터로는 2개를 가지며, 첫째 파라미터로 바꿀 문자열, 두번째 파라미터로 새로운 문자열을 입력한다. */String str = &quot;Hello Java&quot;;String newStr = str.replace(&quot;Java&quot;, &quot;Python&quot;);System.out.println(newStr);// 출력 결과 : Hello Python toUpperCase()12345678910/* 문자열을 대문자로 바꿔주는 메서드이다. 파라미터에 대문자로 바꿔줄 String 데이터를 입력한다. */String str = &quot;hello java&quot;;String strUp = str.toUpperCase();System.out.println(strUp);// 출력 결과 : HELLO JAVA toUpperCase()는 subString()과 함께 사용하면, String 클래스에는 없는 첫글자만 대문자로 바꾸는 capitalize를 구현할 수 있다. 123String str = &quot;hello java&quot;;String newStr = str.subString(0, 1).toUpperCase();// subString으로 첫글자만 가져와서 toUpperCase()를 적용한 코드이다. toLowerCase()12345678910/* 문자열로 소문자로 바꿔주는 메서드이다. 파라미터에 소문자로 바꿔줄 String 데이터를 입력한다. */String str = &quot;HELLO JAVA&quot;;String strLo = str.toLowerCase();System.out.println(strLo);// 출력 결과 : hello java trim()12345678910/* 문자열 앞뒤의 공백을 제거해주는 메서드이다. 파라미터는 없다. */String str = &quot; Hellooo Java World &quot;;String trimStr = str.trim();System.out.println(trimStr);// 출력 결과 : Hellooo Java World split()12345678910/* 문자열을 잘라서 배열로 반환하는 메서드이다. 파라미터로 자를때 기준이 되는 문자열을 입력받는다. */String str = &quot;Hello Java&quot;;String[] arr = str.split(&quot;&quot;);System.out.println(Arrays.toString(arr));// 출력 결과 : [H, e, l, l, o, , J, a, v, a] toCharArray()1234567891011/* split(&quot;&quot;)과 같은 기능이지만, 반환하는 배열의 타입이 문자열 배열이 아니라 문자형(char[]) 배열이라는 차이가 있다. 파라미터는 없다. */String str = &quot;Hello Java&quot;;char[] cArr = str.toCharArray();System.out.println(cArr);// 출력 결과 : Hello Java getBytes()12345678910/* byte 배열로 반환하는 메서드이다. 파라미터는 없다. */String str = &quot;Hello Java&quot;;byte[] bytesArr = str.getBytes();System.out.println(Arrays.toString(bytesArr));// 출력 결과 : [72, 101, 108, 108, 111, 32, 74, 97, 118, 97] 여기서 출력되는 byte코드는 아스키코드 테이블을 보면 어떤 문자열을 의미하는지 알 수 있다. 아스키코드 테이블상 H라는 문자는 10진수 72와 매칭된다. 따라서 문자열 str 변수에서 H의 문자와 매칭되는 바이트 코드는 72라는 걸 알 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"string","slug":"string","permalink":"http://youngjinmo.github.io/tags/string/"},{"name":"object","slug":"object","permalink":"http://youngjinmo.github.io/tags/object/"}]},{"title":"Oracle - Date","slug":"oracle-date","date":"2020-04-26T05:57:07.000Z","updated":"2020-09-13T01:53:28.308Z","comments":true,"path":"2020/04/oracle-date/","link":"","permalink":"http://youngjinmo.github.io/2020/04/oracle-date/","excerpt":"","text":"오라클 DBMS에선 날짜함수를 사용할 수 있다. 현재 날짜(OS 기준 날짜 출력)를 출력하고 싶다면, 아래의 명령어로 조회할 수 있다. dual 테이블에 대한 설명은 이 글을 참고바란다. 12SELECT sysdateFROM dual; 목록 날짜 연산 날짜간 월(months)수 조회 월(months) 연산 날짜를 문자열로 변환하기 문자를 날짜로 변환 날짜에서 년/월/일 추출하기 날짜에서 시/분/초 추출하기 날짜 반올림 날짜 연산날짜 데이터는 연산도 가능하다. 현재 날짜에서 1,000일 뒤의 날짜를 조회해보았다. 12SELECT sysdate, sysdate + 1000 as &quot;After 1000 days&quot;FROM dual; 이 때 연산되는 숫자는 일(day)를 기준으로 연산처리된다. 날짜와 날짜 역시 연산할 수 있다. 12SELECT hiredate, sysdate-hiredate as &quot;long service&quot;FROM emp; 그러나 연산 결과가 이상하게 출력된다. 날짜인데 왜 소숫점이 찍히는걸까. 알고보니 정수 영역은 day를 의미하며, 소숫점은 시간을 의미한다고 한다. 따라서 시간은 제외하고 순수 근속일만 계산하고자 한다면 숫자함수중 버림역할을 수행하는 trunc() 를 사용하면 된다. 12SELECT hiredate, trunc(sysdate-hiredate) as &quot;long service&quot;FROM emp; 이를 응용해서 현재의 날짜를 기준으로 내가 얼마나 산지를 조회해보았다. 123SELECT &#x27;1991/03/23&#x27; AS &quot;내 생일&quot;, trunc(sysdate - to_date(&#x27;19910323&#x27;, &#x27;YYYYMMDD&#x27;)) || &#x27;일&#x27; AS &quot;내가 산 날&quot;FROM dual; 날짜간 월(months)수 조회날짜와 날짜를 비교하여 몇개월의 차이가 발생하는지 조회할때 사용하는 날짜 함수이다. 12SELECT months_between(날짜1, 날짜2)FROM dual; 파라미터로 2개의 날짜를 입력받으며, 날짜1-날짜2의 결과를 월(months)로 조회한다. 아래 퀴즈에 대한 쿼리를 보면서 확인하자. 1emp 테이블에서 입사일(hiredate)로부터 현재(sysdate)까지 몇개월 근무했는지 조회하시오. 123SELECT empno, ename, trunc(months_between(sysdate, hiredate)) as &quot;근속 월 수&quot;FROM empORDER BY months_between(sysdate, hiredate); 월(months) 연산12SELECT add_months(날짜, 연산하고자하는 월(months))FROM dual; 기존에 날짜에 연산을 할 경우 기본으로 일(days)이 연산이되는데, add_months()는 월(months)을 기준으로 연산하도록 하는 날짜함수이다. emp 테이블에서 hiredate에 36개월을 더했다. 연산이 잘 된다면, 연도만 3년 추가될 것이다. 12SELECT ename, hiredate, add_months(hiredate, 36) as &quot;3년후&quot;FROM emp; 날짜를 문자열로 변환하기dual 테이블에서 sysdate를 조회하면, 년/월/일 포맷으로만 조회가 된다. 그러나 변환함수를 사용하면 sysdate안에 포함된 시/분/초까지 출력할 수 있다. 날짜와 관련한 변환함수가 2개인데, 먼저 소개할 변환함수는 to_char()이다. to_char() 의 형식은 다음과 같다. 1SELECT to_char(날짜, 형식) FROM dual; 위의 형식대로 작성하면, 형식에 맞춰 날짜가 조회된다. sysdate를 원하는 형식대로 조회해보겠다. 12SELECT to_char(sysdate, &#x27;YYYY:MM:DD:(MON, DY):HH:MI:SS&#x27;) as &quot;Today&quot;FROM dual; 맥OS 시간과는 차이가 있어보인다. 왜 이런 차이가 발생하는지는 모르겠다… date 포맷에 대해 알아보자. symbol description YYYY 연도 MM 월 DD 일 MON Month DY 축약된 요일 DAY 완전한 요일 HH hour HH24 24시를 기준으로한 hour PM/AM PM 또는 AM을 쿼리에 작성하면, AM/PM이 계산되어 조회 MI minute SS second 문자를 날짜로 변환to_char() 함수가 날짜 데이터를 문자열로 변환하는 변환함수였다면, to_date() 함수는 문자열 데이터를 날짜 데이터로 변환하는 변환함수이다. 1SELECT to_date(문자열, 날짜형식) FROM dual; 첫번째 파라미터로 문자열 데이터를 받아서 두번째 파라미터로 들어오는 날짜형식에 맞춰서 문자열 데이터를 날짜로 변환 조회한다. 아래 예제 쿼리를 확인해보자. 12SELECT to_date(&#x27;2020/04/02 11:45:20 AM&#x27;, &#x27;YYYY/MM/DD HH:MI:SS PM&#x27;)FROM dual; 데이터 타입이 바뀌는 것일뿐 기본적으로 to_date() 와 사용법이 같다. 첫번째 파라미터로 받는 문자열의 형식에 맞게끔 date 포맷을 작성하면 문자열을 날짜 데이터로 변환한다. 날짜에서 년/월/일 추출하기날짜에서 원하는 포맷만 출력하고 싶을땐 EXTRACT() 함수를 사용한다. 현재 날짜에서 월(month)만 추출하고 싶다면 아래의 쿼리를 입력해보면 된다. 12SELECT EXTRACT(month FROM sysdate)FROM dual; 위와 같은 방식으로 년도를 출력하고 싶다면, 12SELECT EXTRACT(year FROM sysdate)FROM dual; 일을 출력하고 싶다면, 12SELECT EXTRACT(day FROM sysdate)FROM dual; 날짜에서 시/분/초 추출하기12SELECT extract(hour from sysdate)FROM dual; EXTRACT() 함수를 사용하면 년/월/일은 추출이 가능한데, 시간/분/초는 추출이 되지 않았다. 왜냐하면 해당 날짜 데이터에 시간데이터, 즉 timestamp가 존재하지 않을수 있기 때문이다. 따라서 이 경우엔 프로그래머가 임의로 날짜 데이터를 시간 데이터로 형변환(cast)해줘야 한다. 형변환시 사용하는 함수는 cast()이며, 형식은 아래와 같다. 1cast(날짜 AS timestamp) 이를 적용하여, 다시 쿼리를 수정하면, 123SELECT extract(hour from cast(sysdate AS timestamp))FROM dualGROUP BY extract(hour from cast(sysdate AS timestamp)); sysdate와 비교하기 위하여 쿼리를 다시 수정하고 조회해보았다. 현재 오후 2시인데, 시간추출이 14로 나왔으니 제대로 출력된걸 알 수 있다! 날짜 반올림날짜는 각각(연도, 월, 일, ..)을 기준으로 round() 함수로 반올림이 가능하다. 123456789SELECT sysdate, round(sysdate, &#x27;CC&#x27;) as &quot;year 두자리 기준&quot;, round(sysdate, &#x27;YYYY&#x27;) as &quot;month 기준&quot;, round(sysdate, &#x27;DAY&#x27;) as &quot;week 기준&quot;, round(sysdate, &#x27;MM&#x27;) as &quot;day 기준&quot;, round(sysdate, &#x27;DDD&#x27;) as &quot;hour 기준&quot;, round(sysdate, &#x27;HH&#x27;) as &quot;minute 기준&quot;, round(sysdate, &#x27;MI&#x27;) as &quot;second 기준&quot;,FROM dual; round() 함수 조건으로 삽입하는 포맷보다 하나 뒤의 date 포맷을 기준으로 반올림하여 조회되는 것을 알 수 있다. 일(day)을 기준으로 반올림하고 싶다면, 일(DDD)이 아닌 월(MM)을 기준으로 반올림해야 한다. 12SELECT sysdate AS &quot;오늘&quot;, round(sysdate, &#x27;MM&#x27;) AS &quot;일 기준 반올림&quot;FROM dual; 현재 날짜가 4월보다 5월에 가까운 26일이므로 5월로 반올림되어 조회된 것을 확인할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"}]},{"title":"Oracle - LIKE 연산자","slug":"oracle-like","date":"2020-04-26T04:42:51.000Z","updated":"2020-09-13T01:53:28.264Z","comments":true,"path":"2020/04/oracle-like/","link":"","permalink":"http://youngjinmo.github.io/2020/04/oracle-like/","excerpt":"","text":"문자열을 검색할 때 사용하는 키워드이다. WHERE 조건절에 함께 사용하는 키워드이다. 123SELECT ename, empnoFROM empWHERE ename LIKE &#x27;FORD&#x27;; LIKE 키워드에 포함하는 문자열을 가진 모든 문자열을 조회하는 방법이 있다. 두번째 글자가 A인 사원의 이름을 emp 테이블에서 조회하는 쿼리이다. 123SELECT ename, empnoFROM empWHERE ename LIKE &#x27;_A%&#x27; 위 쿼리에서 LIKE 조건절만 해석해보면, _는 하나의 글자를 의미한다. 반면 %는 복수의 글자수를 이야기한다. 따라서 _를 하나만 입력했다면, 앞에 한 글자는 무슨 글자인지 모르겠으나 두번째 글자가 A가 따라오며 뒤의 글자는 어떤 글자든지(글자가 없더라도) 조회하도록 하는 쿼리이다. 그 결과로 ename의 컬럼중 두번째 글자가 A인 ename의 데이터들이 조회된 것이다. 쿼리성능을 생각하지 않는다면, %를 붙여서 사용하는게 더 많은 글자를 조회할 수 있기에 _ 연산자보다는 % 연산자만을 사용하는게 좋은 선택일지도 모르겠으나 _ 연산자가 필요한 경우도 있다. 예를들면, 문자열 속 문자로 조회하는게 아니라 문자열의 수를 통해 조회하고자 할 때이다. 1이름이 4글자인 사원의 이름(ename)과 사원번호(empno)를 조회하시오. 123SELECT ename, empnoFROM empWHERE ename LIKE &#x27;____&#x27;; _ 는 한 글자를 의미하므로 4글자로 이루어진 ename을 조회하기 위해서는 _을 4개를 입력해서 조회할 수 있다. LIKE 연산자는 문자열 뿐만 숫자 조회에서도 사용할 수있다. 123SELECT empno, enameFROM empWHERE empno LIKE &#x27;%00%&#x27;;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"}]},{"title":"main(String[] Args)에 대해 알아보자.","slug":"java-main-args","date":"2020-04-23T09:53:54.000Z","updated":"2020-09-13T01:53:28.548Z","comments":true,"path":"2020/04/java-main-args/","link":"","permalink":"http://youngjinmo.github.io/2020/04/java-main-args/","excerpt":"","text":"자바로 그 어떤 프로그램이라도 작성을 하게 되면, 반드시 작성하게 되는 메서드이자 모든 자바 애플리케이션의 시작점인 main(). 항상 입력하면서도 여기에 대해 자세히 알려고 했던적이 있었나 싶다. 한 번 쯤 정리하고 싶어서 이번에 정리하게 되었다. 우선 main 메서드는 다음과 같은 구조로 구성되어 있다. 1public static void main(String[] args) &#123; &#125; public - 접근제한자이다. 어디서나 접근가능한 메서드를 의미한다. static - main 메서드는 그 자체가 애플리케이션이라고 할 수 있을만큼 생명주기가 길기 때문에 당연히 static 키워드를 사용하여 Heap 메모리에 할당해야 한다. void - 리턴 타입이며, 반환하는 데이터가 없음을 의미한다. main - 메서드 이름이다. 여기까지는 이 글을 읽는 사람들이라면 이미 모두 알고 계실 것 같다. 이 main 메서드에서 파라미터로 받는 (String[] args)에 대해서 잘 모르고 있었는데, 이 파라미터는 &quot;&quot; 로 입력받는 문자들의 집합을 String 이라는 클래스 변수로 정의하겠음을 의미한다고 한다. 그냥 String은 아니고 String[] 인만큼 연속적인 데이터를 입력하면 문자열 배열로 인식하여 데이터를 저장한다고 한다. 테스트 코드를 작성해보았다. 간단한 코드여서 IDE를 실행하지는 않고 vim 에디터를 사용했다. 123456789class main &#123; public static void main(String[] args)&#123; System.out.println(args.length+&quot;개의 String을 입력하셨습니다.\\n&quot;); for(int i=0; i&lt;args.length; i++)&#123; System.out.println(&quot;args[&quot;+i+&quot;] : &quot;+args[i]); &#125; &#125;&#125; 터미널에서 곧바로 실행했다. main.java 파일을 컴파일하고, 실행할 때 입력값을 넣어서 실행해보았다. 12$ javac main.java$ java main 123 가나다 abc 입력값으로 전달한 문자가 args라는 이름의 문자열 배열로 저장되어 정상적으로 출력된걸 확인할 수 있다. 출처 : https://javacpro.tistory.com/11","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"Oracle - Sub Query","slug":"oracle-subquery","date":"2020-04-20T05:48:40.000Z","updated":"2020-09-13T01:53:28.232Z","comments":true,"path":"2020/04/oracle-subquery/","link":"","permalink":"http://youngjinmo.github.io/2020/04/oracle-subquery/","excerpt":"","text":"서브쿼리란 쿼리 속 쿼리를 의미한다. 서브쿼리를 사용한 쿼리는 실행시 서브쿼리를 먼저 실행된다고 한다. SQL 퀴즈를 바탕으로 어떻게 사용되는지 알아보자. 1SMITH와 같은 부서에 근무중인 사원들의 사원번호(empno), 이름(ename), 급여액(sal), 부서이름(dname)을 가져온다. ‘SMITH’ 이름을 갖는 사원의 emp 테이블과 이 사람과 같은 부서에 근무중인 사원들에 대한 emp 테이블, 그리고 부서이름을 가져올 dept 테이블이 필요하다. 따라서 FROM 조건으로 emp e1, emp e2, dept d 3개의 테이블을 조회해야 한다. 123456SELECT e2.empno, e2.ename, e2.sal, d.dnameFROM emp e1, emp e2, dept dWHERE e2.deptno = d.deptno AND e1.ename = &#x27;SMITH&#x27; AND e1.deptno = e2.deptnoORDER BY e2.empno ASC; 단순히 Join으로도 해결할 수 있는데, 이 쿼리를 서브쿼리로도 작성할 수 있다. 123456789SELECT emp.empno, emp.ename, emp.sal, dept.dnameFROM emp, deptWHERE emp.deptno = dept.deptno AND dept.deptno = ( SELECT deptno FROM emp WHERE ename = &#x27;SMITH&#x27;)ORDER BY emp.empno ASC; 완전히 동일한 결과이다. 코드 직관성은 서브쿼리가 더 나은것도 같지만, 간단한 데이터 조회여서 그런지 Join이 더 작성하기 쉽기도 했다. 구글에 서브쿼리의 장단점에 대해 검색을 해서 Techwalla라는 웹사이트의 문서를 보니 서브쿼리에 대한 장단점을 다음과 같이 정리했다. 서브 쿼리는 쿼리 구조를 이해하는데 도움이 된다. 단점으로는 테이블을 수정할 수 없고, 동일한 SQL 문에 있는 하위 쿼리 내의 동일한 테이블에서 선택할 수 없다는 것이다. 또한 database optimizer로 인하여 하위 쿼리를 Join보다 실행하는데 시간이 오래 걸릴 수 있다. 서브쿼리를 AND 키워드를 이용하여 다중사용도 가능하다. 아래의 퀴즈를 통해 확인해보자. 12CHICAGO 지역에 근무중인 사원중 BLAKE가 직속상관인 사원들의사원번호(empno), 이름(ename), 직무(job)를 가져온다. 1234567891011SELECT empno, ename, jobFROM empWHERE deptno = ( SELECT deptno FROM dept WHERE loc = &#x27;CHICAGO&#x27;) AND mgr = ( SELECT empno FROM emp WHERE ename = &#x27;BLAKE&#x27;); 지금까지는 서브쿼리에 대한 결과, 데이터 컬럼이 하나일 때만에 해당했다. 그러나 서브쿼리에 대한 결과 데이터 컬럼이 2개 이상 조회된다면 어떨까? 아래의 퀴즈를 풀어보자 123000 이상의 급여를 받는 사원들과 같은 부서에 근무하고 있는사원의 사원번호(empno), 이름(ename), 급여(sal)를 가져온다. 1234567SELECT empno, ename, salFROM empWHERE deptno = ( SELECT deptno FROM emp WHERE sal &gt;= 3000); 3천 이상의 급여를 받는 사원 과 같은 부서(deptno)를 갖는 사원 테이블을 조회하는 쿼리이다. 따라서 3천 이상의 급여를 받는 사원 테이블을 서브쿼리로 조회했고, 이 때 출력되는 결과를 deptno로 가져와서 이걸 where 조건절에 삽입했다. 그러나 결과는..? 에러 메세지를 확인해보면, “single-row subquery returns more than one row” 라며, 한 줄 이상의 데이터가 반환되어 에러가 발생함을 알 수 있다. where 조건절에선 deptno가 하나의 row만 검증하도록 쿼리를 작성했는데, 서브쿼리를 통해 반환되는 row는 2개 이상이었기 때문이다. 확인해보니까 정말 서브쿼리에서 반환되는 데이터가 3개였다. 이 중 어떤 row를 deptno와 비교할지 오라클 데이터베이스가 인식하지 못해서 발생한 에러였던 것이다. 이럴 때는 다음과 같이 in 키워드를 사용하여 서브쿼리에 대한 조건을 충족하는 데이터라면 모두 검증하도록 할 수 있다. 1234567SELECT empno, ename, salFROM empWHERE deptno in ( SELECT deptno FROM emp WHERE sal &gt;= 3000); 정상적으로 잘 출력된 걸 확인할 수 있다!","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"객체를 직접 호출하는 것과 인스턴스를 호출하는것의 차이 (메모리 주소값 비교)","slug":"java-object-instance","date":"2020-04-08T05:56:01.000Z","updated":"2020-09-13T01:53:28.452Z","comments":true,"path":"2020/04/java-object-instance/","link":"","permalink":"http://youngjinmo.github.io/2020/04/java-object-instance/","excerpt":"","text":"객체지향에 대해서 정확히 이해하고 있지 못한것 같아서 인프런에서 객체지향 프로그래밍 입문와 생활코딩에서 JAVA 객체지향 프로그래밍 수업을 정주행하다가 정리한다. 10분 짜리 영상을 정말 거의 10번 가까이 재생하면서 계속 이해하려고 노력했고, 그러고나서도 다시 포스팅하려고 하니까 더 긴 시간이 걸렸다. 하지만 이렇게 정리하고 나니까 조금 뿌듯하다 :) 그동안은 외부 클래스의 메서드를 사용하기 위하여 항상 인스턴스를 생성했었는데, 메서드가 static으로 선언되어 있다면, 인스턴스 생성없이도 해당 객체를 직접 호출해서 사용할 수 있었다. 사실 작성하고 나니 당연한 것이었는데, 그동안 별 생각없이 인스턴스만 생성해서 사용했던것 같다. 두 개의 클래스 파일을 생성해보았다. 하나는 객체를 담았고, 하나는 콘솔로 출력하기 위한 클래스이다. exam.class 1234public class exam &#123; public static String classVar = &quot;class 변수&quot;; public String instanceVar = &quot;instance 변수&quot;;&#125; classVar는 static으로 선언한 변수이고, instanceVar는 키워드 없이 생성한 변수이다. Main.class 1234567891011121314class Main &#123; public static void main(String[] args) &#123; // 인스턴스 생성 exam ex1 = new exam(); exam ex2 = new exam(); System.out.println(&quot;ex1.instanceVar : &quot;+ex1.instanceVar); System.out.println(&quot;ex2.instanceVar : &quot;+ex2.instanceVar); ex1.instanceVar = &quot; changed by instance&quot;; System.out.println(&quot;ex1.instanceVar : &quot;+ex1.instanceVar); System.out.println(&quot;ex2.instanceVar : &quot;+ex2.instanceVar); &#125;&#125; exam 클래스로부터 두개의 인스턴스를 생성했고, 그 중 ex1 인스턴스의 변수만 값을 변경해보았다. 출력 결과는 다음과 같다. 12345&#x2F;&#x2F; 출력 결과ex1.instanceVar : instance 변수ex2.instanceVar : instance 변수ex1.instanceVar : changed by instanceex2.instanceVar : instance 변수 ex1.instanceVar 값을 변경하고, ex1과 ex2의 instanceVar을 각각 출력해봤더니 ex1에만 변경된 값이 적용된걸 알 수 있다. 이를 통해 인스턴스를 생성하면 같은 객체로부터 생성되었다하더라도 바라보는 주소값이 다르다는 걸 알 수 있다. 실제로 확인해보면 다음과 같다. System.identityHashCode()는 OS(System)에서 가지는 주소값을 보여준다. 두 객체는 서로 다른 주소값을 참조하고 있기 때문에 ex1 인스턴스의 값을 변경하더라도 독립적으로 값을 유지할 수 있었다. 관련 내용 참조 : https://datamod.tistory.com/57 이번엔 객체를 그대로 호출해서 사용해보았다. 아까 작성한 exam 클래스에서 static으로 선언한 변수를 호출해보겠다. exam.class 1234public class exam &#123; public static String classVar = &quot;class 변수&quot;; public String instanceVar = &quot;instance 변수&quot;;&#125; main.class 1234567891011121314class Main &#123; public static void main(String[] args) &#123; // 인스턴스 생성 exam ex1 = new exam(); exam ex2 = new exam(); System.out.println(&quot;ex.classVar : &quot;+ex1.classVar); System.out.println(&quot;ex.classVar : &quot;+ex2.classVar); ex1.classVar = &quot; changed by class&quot;; System.out.println(&quot;ex.classVar : &quot;+ex1.classVar); System.out.println(&quot;ex.classVar : &quot;+ex2.classVar); &#125;&#125; 12345&#x2F;&#x2F; 출력 결과ex1.classVar : class 변수ex2.classVar : class 변수ex1.classVar : changed by classex2.classVar : changed by class 이번엔 다른 결과가 출력되었다. ex1.classVar의 값만 바꿨을 뿐인데, ex2의 값도 바뀐걸 알 수 있다. 왜 그럴까? 마찬가지로 이번에도 System.identityHashCode()를 사용하여 각각 인스턴스들이 어떤 주소값을 참조중인지 확인해보았다. 모든 인스턴스 값이 참조하고 있는 주소가 같은 주소를 참조하고 있는걸 확인할 수 있다. 따라서 하나 인스턴스만 바꾸더라도 모든 인스턴스에서 값이 변경되는걸 알 수 있다. static 변수을 가져와서 사용하는것과 인스턴스를 사용하는 것의 차이는 다음 그림으로 설명할 수 있다. 인스턴스를 생성해서 사용하면 사용하면 인스턴스마다 새로운 주소값을 참조하게 되기 때문에 값을 변경(=주소값 변경)하더라도 다른 인스턴스에 영향을 주지 않는다. 반면 static 변수를 사용할 경우에는 같은 주소값을 서로 참조하고 있으므로 값이 바뀌면(주소값 변경), 당연히 사용하는 모든 인스턴스의 값도 변경되는 것이다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"}]},{"title":"메모리 구조","slug":"java-memory","date":"2020-04-05T15:38:55.000Z","updated":"2020-09-13T01:53:28.476Z","comments":true,"path":"2020/04/java-memory/","link":"","permalink":"http://youngjinmo.github.io/2020/04/java-memory/","excerpt":"","text":"메모리는 Method Area - Call Stack - Heap 영역으로 구분된다. 각각의 영역이 어떤 역할을 수행하는지 알아보자. Method Area 클래스 파일의 바이트 코드가 할당되는 영역이다. class 파일의 자바 애플리케이션 코드가 JVM에 의해 기계어로 변환되어 실행이 되는데, 이 때 변환된 기계어가 바이트 코드이다. static 으로 선언된 클래스가 여기에 할당된다. Call Stack 지역 변수와 매개변수가 임시로 할당되는 영역이다. 메서드가 호출되면, 수행에 필요한만큼의 메모리를 스택에 할당 메서드가 수행을 마치고 나면 사용했던 메모리를 반환, 스택에서 제거한다.아까 지역변수와 매개변수가 임시로 할당된다고 이야기한 이유가 여기에 있다. 변수들을 호출하는 메서드가 사용되고 나면 해당 메서드의 모든 변수를 삭제하기 때문이다. 불필요한 메모리를 삭제하는 GC(Garbage Collector)가 작동되는 것으로 보인다. 호출 스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이며, 바로 아래에 있는 메서드가 현재의 메서드를 호출한 메서드이다. 일반적으로 main()가 실행되면서 애플리케이션이 실행되므로 가장 먼저 호출된 main() 이 Call Stack의 가장 아래에 위치하게 되며, 이 main()이 호출하는 메서드들이 선입후출 방식으로 Call Stack에 쌓이게 된다. **가장 나중에 실행된 메서드가 가장 먼저 종료하고, 가장 먼저 실행한 메서드가 가장 마지막으로 종료 (선입후출)**하여 자료구조에서는 이런 구조를 **스택(Stack)**이라 이야기한다. Heap 프로그램이 실행되면서 생성되는 모든 인스턴스가 할당되는 공간이다. new 키워드로 생성된 인스턴스 변수들이 할당되는 곳이라고 이해하면 된다. Heap 메모리는 메서드 호출이 끝나도 인스턴스들이 계속 유지되는데, 그러다 참조하는 주소를 잃게되면 GC에 의해 지워지면서 Heap 메모리에서도 제거된다. 사용이 끝나도 계속 유지되는 Method Area와 다른 특징이다. Method Area에 할당하는 키워드는 static, Heap에 할당하는 키워드는 new 라는게 직관적으로 이해가 될 것 같다. 정리하면,컴파일되어 생성된 클래스 파일을 JVM이 실행하면 클래스 파일을 분석하여 static 키워드의 클래스 정보만을 JVM의 메모리 영역 중 Method Area에 저장한다. Method Area는 고정적(static)이므로 프로그램 종료시까지 언제든 사용가능하다. Call Stack에서는 main() 부터 실행하여 main()에서 실행한 다른 메서드를 호출한다. 이 과정에서 생성되는 인스턴스는 Heap 메모리에 저장되고, 인스턴스라는 이름과 Heap 이라는 단어처럼 Heap 메모리에 저장된 인스턴스는 호출될 때에만 사용되고, 사용이 끝나면 바로 소멸되는 동적인(dynamic) 특징이 있다. 이는 정적인(static) Method Area와 대비되는 특징이다. 그럼 언제 인스턴스를 사용해야 하는걸까? 정적할당 vs 동적할당인스턴스의 공통적인 데이터 또는 자주 사용해야하는 데이터의 경우는 고정적(static)일 필요가 있다. 이런 데이터는 static 키워드를 선언하여 Method Area에 한 번 할당해두면, 필요할 때마다 참조만 해서 사용할 수 있다. 메모리 관리에 효율적이다. 그러나 Method Area에 할당되면 프로그램 종료시까지 메모리를 사용한다는 특징이 있다. 따라서 프로그램 종료시까지 지속적으로 필요한 데이터가 아닌 잠깐만 필요하거나 각 객체 별로 서로 다른 값을 저장하고 있어야 할 경우에는 Heap 메모리에 임시적으로 인스턴스를 생성하는 방법이 메모리 관리에 효율적이다. Heap 메모리는 Method Area와 달리 사용 후 즉시 폐기된다. One more thing. Heap 영역에서 참조타입 변수인 객체나 배열을 Null 값으로 받으면, NullPointException이라는 예외가 떠서 사용할 수가 없다. 이 때엔 초기값을 넣어서 Null값을 없애야 한다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"datastructure","slug":"datastructure","permalink":"http://youngjinmo.github.io/tags/datastructure/"}]},{"title":"JAVA - 내부클래스(innerClass또는 nestedClass)","slug":"java-nestedClass","date":"2020-04-05T13:48:25.000Z","updated":"2020-09-13T01:53:28.452Z","comments":true,"path":"2020/04/java-nestedClass/","link":"","permalink":"http://youngjinmo.github.io/2020/04/java-nestedClass/","excerpt":"","text":"클래스 안에 클래스, 즉 내부 클래스를 생성할 수 있다. 중첩되는 객체이므로 nested class라고도 하고, 그냥 inner class라고도 하는 것 같다. 내부 클래스는 크게 4가지로 분류된다. 일반 내부 클래스, 내부 static 클래스, 내부 지역 중첩 클래스, 익명 중첩 클래스가 있다. 일반 내부 클래스 내부 static 클래스 내부 지역 중첩 클래스 익명 중첩 클래스 일반 내부 클래스클래스 안에 생성되는 또 다른 클래스를 의미한다. 1234567891011121314151617181920package innerClass;public class InnerExam1 &#123; class Cal &#123; int value = 0; public void plus() &#123; value++; &#125; &#125; public static void main(String[] args) &#123; InnerExam1 ex = new InnerExam1(); InnerExam1.Cal cal = ex.new Cal(); cal.plus(); System.out.println(cal.value); &#125;&#125; main메서드에서 사용하려면 우선 외부 클래스에 대한 인스턴스를 생성하고, 내부 클래스에 대한 인스턴스를 생성해서 사용해야 한다. 12InnerExam1 ex = new InnerExam1();InnerExam1.Cal cal = ex.new Cal(); 내부 static 클래스클래스 안에서 static 키워드로 생성되는 클래스 12345678910111213141516171819package innerClass;public class InnerExam2 &#123; static class Cal &#123; int value = 0; public void plus() &#123; value=value+2; &#125; &#125; public static void main(String[] args) &#123; InnerExam2.Cal cal = new InnerExam2.Cal(); cal.plus(); System.out.println(cal.value); &#125;&#125; static 키워드로 내부 클래스를 생성했으므로 외부 클래스에 대한 인스턴스를 생성할 필요없이 바로 내부 클래스에 해당하는 인스턴스를 생성해서 사용할 수 있다. 1InnerExam2.Cal cal = new InnerExam2.Cal(); 내부 지역 중첩 클래스메서드 안에 생성되는 클래스 1234567891011121314151617181920212223package innerClass;public class InnerExam3 &#123; public void exec() &#123; class Cal &#123; int value = 0; public void plus() &#123; value++; &#125; &#125; Cal cal = new Cal(); cal.plus(); System.out.println(cal.value); &#125; public static void main(String[] args) &#123; InnerExam3 ex = new InnerExam3(); ex.exec(); &#125;&#125; 12&#x2F;&#x2F; 실행결과3 처음에 좀 이해하기 어렵고 난해하다고 생각했다. 왜 난해하다고 생각했냐면, main 메서드에서 인스턴스를 생성할 때 일반적인 내부 클래스(nested class)를 생성하듯이 InnerExam3.Cal cal = ex.new Cal(); 로 생성이 가능하다고 생각했기 때문이다. 12InnerExam3.Cal cannot be resolved to a typeCannot allocate the member type InnerExam3.Cal using its compound name when qualified by an enclosing instance. The member type name is resolved relatively to the qualifying instance type 에러 메세지를 해석해보면, 인스턴스를 InnerExam3.Cal 객체 타입을 사용할 수 없다고 하는 내용이다. 다시 보니 내부 지역 중첩 클래스는 클래스 안에 클래스인건 맞으나, 메서드 안에서 선언된 내장 객체이므로 main 메서드와 동일한 클래스에 있었기 때문에 두번 인스턴스를 생성할 필요가 없던 것이다.(쓰면서도 말이 이해하기 좀 난해한것 같지만…) 따라서 그냥 외부 클래스에 대한 인스턴스 하나만 생성해서 내부 메서드를 실행함으로써 중첩 클래스를 사용할 수 있었다. 익명클래스말그대로 이름이 없는 클래스이다. 상속받는 클래스를 굳이 만들 필요가 없을 때 사용한다고 한다. 예제 코드를 통해 알아보자. Action이라는 이름의 추상클래스와 이 Action을 상속받는 MyAction 클래스가 있다고 가정하자. Action.class 12345package nestedClass;public abstract class Action &#123; public abstract void exec();&#125; MyAction.class 123456789package nestedClass;public class MyAction extends Action &#123; @Override public void exec() &#123; System.out.println(&quot;exec&quot;); &#125;&#125; 이를 실행하는 클래스 ActionExam이다. ActionExam.class 123456789package nestedClass;public class ActionExam &#123; public static void main(String[] args) &#123; Action action = new MyAction(); action.exec(); &#125;&#125; 12&#x2F;&#x2F; 실행결과exec 여기서 MyAction 클래스는 한 번만 쓰이고 다른 어디에서도 사용되지 않는 클래스라고 가정해보자. 이 경우라면, 굳이 MyAction을 생성하기보다는 그냥 ActionExam에서 익명클래스를 선언해서 사용할 수 있다. ActionExam.class 1234567891011121314151617package innerClass;public class ActionExam &#123; public static void main(String[] args) &#123; // Action action = new MyAction(); // action.exec(); Action action = new Action() &#123; @Override public void exec() &#123; System.out.println(&quot;exec&quot;); &#125; &#125;; action.exec(); &#125;&#125; 이렇게 하면, Action클래스를 상속받는 하위 클래스(MyAction.class)를 생성하지 않아도 main 함수 내에서 익명클래스를 생성해서 사용할 수 있다. 그러나 솔직히 익명클래스를 사용하는 것보다는 한번 밖에 사용되지 않는다 하더라도 main 함수는 실행하는 코드만 남겨두고, 하위 클래스를 만들어서 사용하는게 객체지향적인 의미에서 더 낫지 않나 생각이 든다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"},{"name":"inner class","slug":"inner-class","permalink":"http://youngjinmo.github.io/tags/inner-class/"}]},{"title":"인텔리J에서 Gradle 프로젝트 인식안될때","slug":"intellij-reimport-gradle","date":"2020-04-05T07:49:27.000Z","updated":"2020-09-13T01:53:28.636Z","comments":true,"path":"2020/04/intellij-reimport-gradle/","link":"","permalink":"http://youngjinmo.github.io/2020/04/intellij-reimport-gradle/","excerpt":"","text":"인텔리J로 gradle 프로젝트를 진행하려는데, 자꾸 같은 에러가 발생했다. 분명 gradle 설정(build.gradle)에서 jpa 관련 dependency를 주석처리하고, 웹서버 실행을 했는데 아래의 에러 메세지를 출력하며 웹 서버 실행을 중단하는 것이다. 1Failed to configure a DataSource: &#39;url&#39; attribute is not specified and no embedded datasource could be configured. Reason: Failed to determine a suitable driver class&quot; 그래서 다시 gradle 설정으로 가보니 인텔리J가 build.gradle 자체를 제대로 인식하지 못하는 것 같았다. 그러다보니 빌드를 다시해도 여전히 같은 에러를 발생하고 있던 것이다. 이번에도 이동욱님 블로그(IntelliJ에서 Gradle 프로젝트 작동안될때)를 통해 도움을 받았다. 동욱님은 두가지 방법을 제시해주셨는데, 나는 Event Log에서 Import Gradle project가 보이지 않아서 두번째 방법으로 해결을 했다. 터미널에서 프로젝트 디렉토리로 가서 인텔리J 프로젝트 설정을 담은 디렉토리인 /.idea 를 삭제하고 다시 프로젝트를 빌드/실행했다. 1rm -rf .&#x2F;.idea 처음엔 이마저도 안되는듯 했는데, 두번째 반복하니까 build.gradle 파일을 제대로 인식하며 color scheme가 적용되기 시작했다. 그리고 프로젝트를 실행하니 정상적으로 웹 서버가 실행된걸 확인했다. 이런 에러가 사실 처음이 아니다. 이번이 두번째였는데, 유독 인텔리J와 gradle 프로젝트 사이에서만 발생하는지 이유를 모르겠다. 참고문서 기억보단 기록을 - Intelli J에서 Gradle 프로젝트 작동안될때","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"error","slug":"error","permalink":"http://youngjinmo.github.io/tags/error/"},{"name":"springboot","slug":"springboot","permalink":"http://youngjinmo.github.io/tags/springboot/"},{"name":"intellij","slug":"intellij","permalink":"http://youngjinmo.github.io/tags/intellij/"},{"name":"ide","slug":"ide","permalink":"http://youngjinmo.github.io/tags/ide/"},{"name":"gradle","slug":"gradle","permalink":"http://youngjinmo.github.io/tags/gradle/"}]},{"title":"Java - 인터페이스(Interface)","slug":"java-interface","date":"2020-04-04T08:49:23.000Z","updated":"2020-09-13T01:53:28.584Z","comments":true,"path":"2020/04/java-interface/","link":"","permalink":"http://youngjinmo.github.io/2020/04/java-interface/","excerpt":"","text":"객체지향의 주요 개념중 하나이다. 인터페이스는 추상 클래스의 일종이지만 추상화 클래스보다 추상화 정도가 높다. 추상화 클래스와 달리 인터페이스는 아예 몸통을 가지지 않기 때문이다. 오직 추상 메서드와 상수만을 가질 수 있다고 한다. ToC 인터페이스 작성규칙 인터페이스 다중상속 default 메서드와 static 메서드 추상 클래스와 인터페이스간 비교 인터페이스 작성규칙인터페이스는 다음과 같은 형식으로 작성한다. 1234public interface 인터페이스이름 &#123; public void 메서드명(파라미터); // 추상 메서드지만 abstract 키워드를 명시하지 않아도 사용가능&#125; 인터페이스에서 가지는 멤버 필드(변수)는 오직 상수이기 때문에 가변성을 지닌 변수를 생성하고자 한다면, 인터페이스에서 생성하지 않고, 인터페이스를 상속받는(implements) 객체에서 변수를 생성해서 사용해야 한다. 추상클래스와 마찬가지로 서브 클래스에서 인터페이스를 상속해서 오버라이딩을 통해 인터페이스의 기능을 구현해야한다. 인터페이스 작성 규칙은 다음과 같다. 모든 멤버 필드는 상수로만 작성가능하다. **모든 메서드는 추상 메서드(public abstract)**로 생성할 수 있으며, 이를 생략할 수 있다.(단, static 메서드와 default 메서드는 예외) 인터페이스 다중상속자바는 원래 다중상속(public class a extends A,B&#123;&#125;)을 지원하지 않지만, 인터페이스를 이용하면 사실상 다중상속을 사용할 수 있다. 예제코드를 통해 알아보자. 다음 예제코드는 LedTV라는 클래스가 TV라는 인터페이스와 Electronics 라는 인터페이스를 다중상속(implements)받고 있고, 이를 tvExam이라는 클래스를 통해 실행하는 예제이다. TV.java 12345678910package interfaceStudy;public interface TV &#123; public int MIN_VOLUME = 0; public int MAX_VOLUME = 100; public void turnOn(String tv); public void turnOff(String tv); public void changeVolume(int volume);&#125; Electronics.java 123456package interfaceStudy;public interface Electronics &#123; public void powerOn(); public void powerOff();&#125; LedTV.java 123456789101112131415161718192021222324252627282930package interfaceStudy;public class LedTV implements TV, Electronics &#123; @Override public void turnOn(String tv) &#123; System.out.println(tv+&quot; tv켜다.&quot;); &#125; @Override public void turnOff(String tv) &#123; System.out.println(tv+&quot; tv끄다.&quot;); &#125; @Override public void changeVolume(int volume) &#123; System.out.println(&quot;볼륨을 조정하다.&quot;); &#125; @Override public void powerOn() &#123; System.out.println(&quot;전자제품 모두 power on&quot;); &#125; @Override public void powerOff() &#123; System.out.println(&quot;전자제품 모두 power off&quot;); &#125;&#125; tvExam.java 123456789101112131415package interfaceStudy;public class tvExam &#123; public static void main(String[] args) &#123; TV tv = new LedTV(); Electronics electronics = new LedTV(); tv.turnOn(&quot;거실&quot;); tv.turnOff(&quot;안방&quot;); tv.changeVolume(10); electronics.powerOn(); electronics.powerOff(); &#125;&#125; 1234567&#x2F;&#x2F; 실행결과거실 tv켜다.안방 tv끄다.볼륨을 조정하다.채널을 조정하다.전자제품 모두 power on전자제품 모두 power off default 메서드와 static 메서드default 메서드인터페이스는 원래 추상 메서드만 가질 수 있었는데, 자바8부터 default 로 생성하면 완전한 메서드 생성이 가능하다. 12345678public interface Meter &#123; public void start(); public int stop(int distance); public default void afterMidnight()&#123; System.out.println(&quot;인터페이스는 이렇게 default 메서드 생성이 가능합니다.&quot;); &#125;&#125; deafult 메서드 생성시, public 접근제한자는 생략할 수 있다. 이에 대한 예제코드는 아래 인터페이스에서의 static 메서드에서 다뤄보겠다. static 메서드인터페이스는 static 메서드도 가질 수 있다. 접근제한자로 public을 선언해서 인터페이스에서 static 메서드 생성이 가능하다. 단 인터페이스에 생성한 static 메서드는 인스턴스 키워드를 통해 사용할 수 없고, 인터페이스 객체를 직접 호출함으로써 사용이 가능하다. (아래 스크린샷 참조) Calculator라는 인터페이스가 있고, 이 인터페이스를 상속받는 MyCal이라는 클래스가 있다고 가정하자. Calculator.java 123456789101112public interface Calculator &#123; public int plus(int a, int b); public int multiple(int a, int b); default int exec(int a, int b)&#123; return a+b; &#125; public static int exec2(int a, int b)&#123; return a*b; &#125;&#125; MyCal.java 1234567891011public class MyCal implements Calculator &#123; @Override public int plus(int a, int b)&#123; return a+b; &#125; @Override public int multiple(int a, int b)&#123; return a*b; &#125;&#125; 그리고 이를 실행하는 클래스, MyCalExam이 있다. MyCalExam.java 1234567891011public class MyCalExam &#123; public static void main(String[] args)&#123; MyCal cal = new MyCal(); System.out.println(cal.plus(3,5)); System.out.println(cal.multiple(4,5)); System.out.prinltn(cal.exec(4,9)); System.out.println(Calculator.exec2(3, 8)); &#125;&#125; 실행하면 다음과 같다. 12345&#x2F;&#x2F; 실행 결과8201324 추상클래스와 인터페이스의 비교공통점 추상클래스와 인터페이스는 선언만 있고, 구현내용이 없다. 상속받은 자식(서브 클래스)만이 객체를 생성할 수 있다. 상속받은 자식이 구현을 반드시 강제하도록 하는 것이 목적이다. 추상클래스와 인터페이스를 상속할 땐 각각의 객체 타입에 맞춰서 자식의 객체 타입도 맞춰줘야한다. 다른점 인터페이스 (Interface) 추상클래스 (Abstract Class) 구현 객체의 같은 동작을 보장하기 위함 추상클래스를 상속받아 기능을 이용하고, 확장시키기 위함 다중 상속 가능 다중 상속 불가능 추상메서드만 가능 일반메서드 + 추상메서드 가능 상수 + 추상메서드 형태 일반변수(가능) + 일반메서드(가능)+추상메서드 형태 생성자와 일반변수를 가질 수 없음 생성자와 일반변수 모두 가질 수 있음 implments extends 메서드 선언만 가능 메서드의 부분적인 구현이 가능 참고문서 프로그래머스 - [자바 입문] 인터페이스와 다른 형식의 클래스 공부해서 남 주자 - Java 인터페이스와 추상클래스이 설명과 예제","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"},{"name":"interface","slug":"interface","permalink":"http://youngjinmo.github.io/tags/interface/"}]},{"title":"JS로 텍스트 값을 바꾸는 2가지 방법","slug":"change-value-by-javascript","date":"2020-04-01T10:33:29.000Z","updated":"2020-12-03T08:35:50.389Z","comments":true,"path":"2020/04/change-value-by-javascript/","link":"","permalink":"http://youngjinmo.github.io/2020/04/change-value-by-javascript/","excerpt":"","text":"오늘 면접을 한 곳 보고왔는데, 이 때 받은 손코딩 문제중에 하나를 기억하고자 남기려고 한다. 사실 코딩 테스트라고 하기엔 좀 쉬운 문제였는데, 긴장을 해서인지 이것조차 못풀고온게 찝찝해서 정리해본다. 123456789101112131415&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;quiz1&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 이거슨 당신이 자바스크립트를 다뤄봤는지를 묻는 테스트입니다.&lt;br&gt; 아래 문장에서 java를 javascript로 바꿔보시죠.&lt;br&gt; &lt;p&gt; 당신이 공부하는 언어는 &lt;span class=&quot;quiz-text&quot;&gt;Java&lt;/span&gt;입니까? &lt;/p&gt; &lt;button id=&quot;jqueryBtn&quot; type=&quot;button&quot; onclick=&quot;changeByjQuery()&quot;&gt;Run by jQuery&lt;/button&gt; &lt;button id=&quot;jsBtn&quot; type=&quot;button&quot; onclick=&quot;changeByJS()&quot;&gt;Run by JS&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 정확한 코드는 아니고 대충 비슷한 상황을 만들어봤다.자바스크립트 코드를 이용해서 class가 할당된 html 텍스트 하나를 다른 텍스트로 변경해보는 문제였다. jQuery로 풀어도 되는줄 모르고 순수 자바스크립트로만 접근하다 결국 못풀었지만, 여기에 정리하는 방법은 jQuery를 쓰는것과 순수자바스크립트로 해결하는 것 두가지 모두 정리해보았다. * 작동하는 코드가 실행되는 화면은 아래 code.pen으로 확인할 수 있다. * jQuery 사용해서 해결1234$(&quot;#jqueryBtn&quot;).click(function()&#123; $(&quot;.quiz-text&quot;).text(&quot;Javascript&quot;); $(&quot;.quiz-text&quot;).css(&#x27;color&#x27;, &#x27;blue&#x27;);&#125;); id=&quot;jqueryBtn&quot;이 클릭되면 함수가 작동되도록 비동기로 작성한 코드이다. element 셀렉트를 jQuery($)를 이용하기만 하면 된다. 심플하기도 하고, 직관적이어서 별로 설명이 필요없다.* 작동하는 코드가 실행되는 화면은 아래 code.pen으로 확인할 수 있다. * 순수 자바스크립트로 해결jQuery를 사용하면 저렇게 쉽게 풀리는 문제였지만, 멍청하게도 jquery 라이브러리를 호출한 코드가 안보인다는 이유로 순수 자바스크립트로 접근했다. 그런데 document.getElementById()외엔 생각나지 않아서 결국 못쓰고 나왔다. 문제 속 텍스트는 class로만 명시되어 있었고 id가 명시되지 않았었다. 그래서 StackOverflow에서 찾아봤다. 순수자바스크립트로 풀수 있는 방법을.. StackOverflow에서 찾은 보고 좀 당황했었다.. 그냥 찍기라도 쓸걸 그랬나 싶을만큼…ㅋㅋㅋ document.getElementsByClassName()을 하면 element를 잡을 수 있었던 것이다… (젠장) 12345function changeByJS() &#123; let x = document.getElementsByClassName(&quot;quiz-text&quot;)[0]; x.innerText=&quot;Javascript&quot;; x.style.color=&quot;red&quot;;&#125; 여기서 특이했던건 element를 선택할 때 getElement가 아니라 getElements로 작성한것이다. 그리고 마지막에 [0]을 붙인건데, StackOverflow에서 답변한 사람의 의견을 해석하자면, id처럼 단일요소가 아닌 다중요소가 될 수 있는 class를 선택하는 것이므로 Element가 아니라 Elements이라고 한다. &quot;quiz-text&quot;의 이름을 갖는 클래스중 몇번째 클래스를 의미하는건지 명시하기 위해 배열처럼 [0]을 선언한 것이다. code.pen으로 작성한 코드. 버튼을 클릭하면 각각의 방법으로 단어를 변경한다. See the Pen YzXgOBe by DevAndy (@youngjinmo) on CodePen. 참고문서 : Changing content os class using Javascript","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://youngjinmo.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"http://youngjinmo.github.io/tags/javascript/"}]},{"title":"백준 1110번.java","slug":"baekjoon-java-1110","date":"2020-03-30T15:08:35.000Z","updated":"2020-09-13T01:53:29.388Z","comments":true,"path":"2020/03/baekjoon-java-1110/","link":"","permalink":"http://youngjinmo.github.io/2020/03/baekjoon-java-1110/","excerpt":"","text":"백준 문제 중 풀었던 문제를 다시 풀어보는중 처음 풀었을때도 고생했고, 다시 풀어도 고생한 문제를 정리해보려고 한다. 한시간 이상 풀었는데, 풀고나니까 민망하다… 그럼에도 다시 한 번 공개적으로 정리를 해야 다음번에는 술술 풀 수 있을것이란 기대를 안고 정리해본다.. 1110번 문제 링크 문제0보다 크거나 같고, 99보다 작거나 같은 정수가 주어질 때 다음과 같은 연산을 할 수 있다. 먼저 주어진 수가 10보다 작다면 앞에 0을 붙여 두 자리 수로 만들고, 각 자리의 숫자를 더한다. 그 다음, 주어진 수의 가장 오른쪽 자리 수와 앞에서 구한 합의 가장 오른쪽 자리 수를 이어 붙이면 새로운 수를 만들 수 있다. 다음 예를 보자. 26부터 시작한다. 2+6 = 8이다. 새로운 수는 68이다. 6+8 = 14이다. 새로운 수는 84이다. 8+4 = 12이다. 새로운 수는 42이다. 4+2 = 6이다. 새로운 수는 26이다. 위의 예는 4번만에 원래 수로 돌아올 수 있다. 따라서 26의 사이클의 길이는 4이다. N이 주어졌을 때, N의 사이클의 길이를 구하는 프로그램을 작성하시오. 입력첫째 줄에 N이 주어진다. N은 0보다 크거나 같고, 99보다 작거나 같은 정수이다. 1예) 25 출력첫째 줄에 N의 사이클 길이를 출력한다. 1예) 4 내가 작성한 답안123456789101112131415161718192021222324import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int init = sc.nextInt(); int firstNum = init/10; int secondNum = init%10; int num = (secondNum*10) + ((firstNum+secondNum)%10); int cycle = 1; while(init!=num) &#123; firstNum = num/10; secondNum = num%10; num = (secondNum*10) + ((firstNum+secondNum)%10); cycle+=1; &#125; System.out.println(cycle); &#125;&#125; 처음에 작성할 땐 do-while문으로 해결했는데, 이번엔 do-while을 사용할 생각을 못하고 다소 장황하게(?) 작성했다. do-while문으로 하더라도 성능은 별 차이가 없는 것 같지만, 가독성이 더 높으니 do-while문을 사용하는게 더 좋을것 같다. 이 문제를 푸는데 어려웠던건 문제를 파악하는 것이었다. 10의 자리수와 1의 자리수로 구분해서 1의 자리수를 10으로 곱하고 다시 (10의자리수+1의자리수)의 1의자리수를 더해야 새로운 수로 정의하는데, 내 머리로 받아들이는데는 좀 복잡하지 않았나 싶다… 또 %를 써야하는데 /를 쓴다던가 하는 실수때문에 IDE에서 테스트해보면 계속 무한루프에 빠지는 에러가 있었으며, while문의 조건을 잘못 작성해서 또 무한루프가 발생한다던가.. 지금 코드를 다시 봐도 어렵기는 커녕 쉬운 문제인데, 문제를 제대로 파악을 못해서 오래 걸린 것 같다.","categories":[{"name":"Quiz","slug":"Quiz","permalink":"http://youngjinmo.github.io/categories/Quiz/"}],"tags":[{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"},{"name":"baekjoon","slug":"baekjoon","permalink":"http://youngjinmo.github.io/tags/baekjoon/"}]},{"title":"쿠키, 캐시 그리고 세션.","slug":"web-session-cookie-cache","date":"2020-03-30T08:47:11.000Z","updated":"2020-09-13T01:53:28.068Z","comments":true,"path":"2020/03/web-session-cookie-cache/","link":"","permalink":"http://youngjinmo.github.io/2020/03/web-session-cookie-cache/","excerpt":"","text":"웹 개발을 하면서 빠질 수 없는 개념 이다. 그러나 대충만 알고있고 설명할 수 있는정도로 Session과 Cookie, Cache를 구분하지 못하던 차에 박재성님 강의영상을 보며 세션상태에 따라 페이지에 노출하는 리스트를 변경하는 개발을 하다가 정리하게 되었다. 클라이언트가 HTTP 프로토콜의 GET/POST 방식으로 웹 서버에 페이지를 요청하면, 웹 서버에서 응답받은 HTML 페이지를 파싱하여 렌더링을 하는데, 이렇게 클라이언트와 서버 간의 데이터 왕복과정을 **’라운드 트립(Rount-trip)’**이라고 한다. 웹은 이 라운드 트립이 최소화하도록 개발하는 것이 좋다고 한다. 이렇게 라운드 트립을 한 번 거치고 나면, 사용자가 입력한 정보들이 손실되는데 동적인 웹 애플리케이션에서는 사용자의 요청 또는 입력 정보를 유지할 필요가 있어서 이런걸 저장해두고 사용할 수 있는 기능이 존재한다. 눈치 챘겠지만, 이런 기능이 쿠키, 캐시 그리고 세션이다. 차례 차례 정리해보겠다. ToC 쿠키 캐시 세션 쿠키(Cookie)클라이언트에 대한 정보를 클라이언트(PC)에 저장하기 위해 웹 서버에서 클라이언트(브라우저)에 전송하는 정보를 이야기한다. 쿠키 안에는 사용자의 로그인 정보 및 웹 사이트에서 어떤 행동을 했는지, 몇 번 방문했는지 등 서버에서 유저를 식별할 수 있는 데이터(패킷)가 저장된다고 한다. 그리고 이 쿠키는 해당 웹 서버만 접근이 가능하다고 한다. 트위터에서 전송한 쿠키는 페이스북 서버는 접근 할 수 없다는 이야기이다. 이 쿠키 덕분에 로그인을 매 번 할 필요없이 한 번만 하면, 여러 웹페이지를 돌아다니다가 다시 접속해도 로그인 상태를 유지할 수 있다. 그러나 편한만큼 보안상 위험하기도 하다. 스파이웨어를 통해 사용자의 웹 브라우징 행동을 추적하거나 이 쿠키를 취득하여 웹 계정 접근권한을 얻을 수도 있다. 쿠키는 두가지 종류로 구분된다고 한다. 세션 쿠키 : 쿠키에 만료일이 포함되지 않으며, 램 메모리에만 저장되어 브라우저를 닫는 순간, 쿠키가 소멸(손실) 된다고 한다. 영구 쿠키 : 만료일이 포함되어 있어서 만료일까지는 브라우저를 종료하더라도 사용자의 컴퓨터에 저장되어 상태를 유지할 수 있다. 만료 시기가 되면 자동으로 삭제된다. 캐시(Cache)한 번 내려받은 데이터를 저장소에 저장해두고 재사용할 수 있도록 하는 데이터이다. 웹 사이트에 방문하면 웹 페이지를 보여주는 이미지 등의 리소스가 한 번에 로드되는데, 접속할 때마다 리소스를 내려받을 경우 웹 페이저 접속 속도가 느려질 수 있다. 따라서 한 번 로드된 리소스는 클라이언트에 저장해두고, 재요청이 들어올 때 캐시에서 로드해와서 더 빨리 로드 할 수 있도록 돕는다. 여기부터는 네트워크 공부를 선행하지 않아 잘 모르는 영역이지만, 언젠가 이해할 그 날을 꿈꾸며.. 일단 적어본다. 네트워크에도 캐시 기술을 응용할 수 있다고 하는데, 이 때 응용되는 캐시의 종류는 3가지로 분류된다고 한다. 1) 브라우저 캐시클라이언트 애플리케이션들이 내부적으로 갖는 캐시. 2) 프록시 캐시실제 서버가 있는 곳이 아닌 네트워크 관리자에 의해 네트워크 상에 설치되는 캐시로 latency와 트래픽을 줄이는데 이용된다고 한다. 3) 게이트웨이 캐시서버 관리자에 의해 설치 및 운용되는 캐시이며, 서버의 앞단에 설치되어 요청에 대한 캐시 및 효율적인 분배를 통해 서버의 응답 성능을 개선한다고 한다. 정리하면, 쿠키와 캐시는 클라이언트에 저장되는 데이터지만 목적이 다른 개념이라고 할 수 있다. 세션(Session)사용자가 웹 서버에 접속해 있는 상태를 하나의 단위로 인식하여 이를 세션이라고 하는데, 클라이언트가 아닌 웹 서버에 저장하는 데이터이다. 상태를 일정하게 유지시킴으로써 라운드 트립을 거칠 때마다 사용자가 로그인해야 할 번거로움을 없애준다. 서버에서 쿠키에 있는 로그인 데이터를 이용해서 세션상태를 유지한다고 하는데 활용한다고 한다. 예. 쿠키를 이용해서 세션을 유지하는 과정1) 클라이언트가 웹 서버에 접속하여 로그인을 요청2) 웹 서버는 클라이언트에 세션ID를 발급, 이 세션ID를 쿠키를 사용하여 저장(JSESSIONID)3) 클라이언트는 재접속시 이 쿠키(JSESSIONID)를 사용하여 세션ID값을 서버에 전달4) 서버에서는 세션ID를 통해 클라이언트를 식별하고 세션을 로그인 상태로 유지 참고 문서 Jbee - [개발상식] 10. Cookie/Session/Cache 정아마추어 - Web 쿠키와 세션의 차이, 용도, 사용법","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Web","slug":"Dev/Web","permalink":"http://youngjinmo.github.io/categories/Dev/Web/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"http://youngjinmo.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://youngjinmo.github.io/tags/session/"},{"name":"cache","slug":"cache","permalink":"http://youngjinmo.github.io/tags/cache/"}]},{"title":"JAVA - 추상 클래스/추상 메서드","slug":"java-abstract-class","date":"2020-03-28T19:17:30.000Z","updated":"2020-09-13T01:53:28.632Z","comments":true,"path":"2020/03/java-abstract-class/","link":"","permalink":"http://youngjinmo.github.io/2020/03/java-abstract-class/","excerpt":"","text":"추상 클래스란, 미완성 클래스를 의미한다. 일단 선언은 했지만, 완성되지 않아서 오버라이딩을 통해 기능을 작성해야 한다. 아래 코드를 통해 확인해보자. 123456789package devandy.java.abstraction;public abstract class Bird &#123; public abstract void sing(); public void fly() &#123; System.out.println(&quot;날다.&quot;); &#125;&#125; fly()는 정의했지만, sing()은 새의 종류에 따라 달라지므로 따로 정의하지 않았다. 이렇게 미완성된 메서드를 추상 메서드라고 한다. 그리고 단 하나의 추상 메서드라도 보유하고 있다면, 해당 클래스는 추상 클래스가 된다. 따라서 추상 메서드를 작성했다면, 클래스의 접근제한자 뒤에도 abstract 키워드를 작성해야 한다. 추상 클래스를 사용하는 방법은 위에서도 언급했듯 오버라이딩을 해야한다. 그러려면 추상 클래스를 상속받는 클래스부터 생성해야한다. 123456789package devandy.java.abstraction;public class Duck extends Bird &#123; @Override public void sing() &#123; System.out.println(&quot;꽥꽥!&quot;); &#125;&#125; Bird 클래스를 상속받는 Duck 클래스를 생성했다. Duck 클래스에서 sing()을 오버라이딩하는 메서드를 생성까지 한 코드이다. 여기서 @Override라는 어노테이션을 사용했지만, 사실 작성하지 않아도 컴파일 에러가 발생하지는 않는다. 가독성을 위해 자동으로 생성된게 아닐까 싶다. 위의 코드들을 컴파일해서 콘솔에 출력해보겠다. Bird.java 1234567891011package devandy.java.abstraction;public abstract class Bird &#123; String bird; public abstract void sing(); public void fly() &#123; System.out.println(bird+&quot;날다.&quot;); &#125;&#125; fly()에 어떤 새가 나는지를 함께 출력하기 위해 Bird 객체에 String형 멤버 필드를 추가하고, print문에도 멤버 필드를 추가해주었다. Duck.java 12345678910111213package devandy.java.abstraction;public class Duck extends Bird &#123; @Override public void sing()&#123; System.out.println(&quot;꽥꽥&quot;); &#125; public Duck(String duck)&#123; this.bird = duck; &#125;&#125; 수퍼 클래스에서 상속받는 멤버 필드에 값을 주입하는 생성자를 추가했다. DuckExam.java 12345678910package devandy.java.abstraction;public class DuckExam &#123; public static void main(String[] args) &#123; Duck duck = new Duck(&quot;오리&quot;); duck.sing(); duck.fly(); &#125;&#125; Duck 클래스 타입의 인스턴스 duck을 선언할 때 “오리”라는 String형 값을 인자값으로 넣어서 선언한다. 그럼 Duck 클래스에서 생성한 생성자에 의해 Bird 멤버필드에 값이 주입되고, 그 값이 출력될거다. 실행결과는 다음과 같다. 12꽥꽥오리 날다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"}]},{"title":"JAVA - 클래스의 형변환","slug":"java-conversion-of-class","date":"2020-03-28T15:40:37.000Z","updated":"2020-09-13T01:53:28.608Z","comments":true,"path":"2020/03/java-conversion-of-class/","link":"","permalink":"http://youngjinmo.github.io/2020/03/java-conversion-of-class/","excerpt":"","text":"클래스는 형변환이 가능하다고 하다. 보다 정확히 이야기하자면, 상속관계에서 수퍼 클래스를 서브 클래스처럼 사용할 수 있다는 이야기이다. 원래 서브 클래스는 수퍼 클래스처럼 사용할 수있다. 서브 클래스에서 선언하지 않아도 수퍼 클래스에 선언 또는 호출되어 있다면 해당 기능(메서드)를 사용할 수 있기 때문이다. 그래서 1public class Sub extends Super &#123; &#125; 위와 같은 상속관계를 Sub 는 Super이다 라고 표현할 수 있다고 한다. Super 클래스의 기능을 Sub 클래스에서 똑같이 사용할 수 있기 때문에 Sub 클래스를 Super클래스라 하더라도 맞는 표현이 될 수 있다. 12345// B는 A이다 는 아래로 표현될 수 있다.Sub sub = new Super();// 이건 에러를 유발한다.Super super = new Sub(); 반면 위와 같은 상속관계에서 Super는 Sub이다 라고 할수는 없다. Super 클래스에서는 Sub 클래스의 메서드는 사용할 수 없기 때문이다. 예제 코드를 통해 확인해보도록 하자. Car 클래스와 Bus클래스가 상속관계이며, main()에서 Bus 클래스로부터 Car 클래스 타입의 car 인스턴스를 생성했다. 1Car car = new Bus(); // Car 클래스 타입의 인스턴스 car는 새로운 Bus 객체이다. Car.class 123456789101112131415package devandy.java.conversion;public class Car &#123; public void run() &#123; System.out.println(&quot;차가 달립니다.&quot;); &#125; public void run(String name) &#123; System.out.println(name.concat(&quot;가 달립니다.&quot;)); &#125; public void run(String name, int speed) &#123; System.out.println(name+&quot;가 시속 &quot;+speed+&quot;km/h로 달립니다.&quot;); &#125;&#125; Bus.class 12345678package devandy.java.conversion;public class Bus extends Car &#123; public void run(int speed) &#123; System.out.println(&quot;버스가 시속 &quot;+speed+&quot;km/h로 달립니다.&quot;); &#125;&#125; CarExam.class 12345678package devandy.java.conversion;public class CarExam &#123; public static void main(String[] args) &#123; Car car = new Bus(); // Car 클래스 타입의 인스턴스 car는 새로운 Bus 객체이다. car.run(); &#125;&#125; 그리고 car.run()를 호출해보면, Bus 클래스엔 없는 파라미터가 없는 run()를 Car 클래스로부터 상속받아서 호출을 한다. 1차가 달립니다. 그런데 위에서 생성한 인스턴스로는 Bus 클래스에서 int형 변수를 파라미터로 받는 run()를 호출할 수가 없다. Car 클래스 타입의 인스턴스 car는 서브클래스인 Bus 클래스의 기능을 알지 못하기 때문이다. 따라서 이럴 때엔 Car클래스 타입의 인스턴스로부터 Bus 클래스 타입의 인스턴스를 생성함으로써 형변환을 통해 Bus 클래스의 메서드를 호출할 수 있다. CarExam.class 12345678910package devandy.java.conversion; public static void main(String[] args) &#123; Car car = new Bus(); car.run(); Bus bus = (Bus)car; // 클래스 타입의 형변환 bus.run(70); &#125;&#125; 위와 같이 코드를 추가하고, 실행하면 다음과 같이 원하는대로 출력이 된다. 12차가 달립니다.버스가 시속 70km&#x2F;h로 달립니다. 결론은, 서브 클래스로부터 수퍼 클래스의 인스턴스를 생성할 수 있지만, 서브 클래스의 기능을 전부 사용하지는 못한다. 따라서 이 때는 수퍼 클래스를 서브클래스로 형변환하는 일이 필요해진다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"Java - 상속 (Extends)","slug":"java-inheritance","date":"2020-03-28T10:20:17.000Z","updated":"2020-09-13T01:53:28.592Z","comments":true,"path":"2020/03/java-inheritance/","link":"","permalink":"http://youngjinmo.github.io/2020/03/java-inheritance/","excerpt":"","text":"상속은 부모 클래스를 상속받은 자식 클래스가 기능을 물려받는 걸 의미한다. 아래 예제 코드를 보자. Bus 클래스는 아무것도 선언되지 않았지만, Car 클래스를 상속받고 있으며, passenger 클래스에서 Bus 클래스의 인스턴스를 생성해서 Car 클래스의 메서드 run()을 실행하는 코드이다. Car.java 1234567package devandy.java.inheritance;public class Car &#123; void run() &#123; System.out.println(&quot; 탑승하다.&quot;); &#125;&#125; Bus.java 12345package devandy.java.inheritance;public class Bus extends Car &#123; &#125; passenger.java 12345678package devandy.java.inheritance;public class Passenger &#123; public static void main(String[] args)&#123; Bus b = new Bus(); b.run(); &#125;&#125; 실행결과는 다음과 같다. 1탑승하다. 아무것도 선언하지 않은 빈껍데기 일뿐인 Bus 클래스의 인스턴스를 생성했는데, 인스턴스에서 메서드를 호출할 수 있었다. Bus 클래스가 Car 클래스를 상속받으면서 Car 클래스에 선언된 기능(메서드)들도 사용할 수 있게된 것이다. 상속을 활용하면 중복코드를 줄일 수 있는 장점이 있다. 또 이런 특징때문에 객체지향 프로그래밍의 핵심적인 개념으로 사용되기도 한다. 추가로 서브 클래스에서 수퍼 클래스의 기능을 직접 호출하고 싶을땐 super 키워드를 통해 사용할 수 있다. 위의 코드에서 passenger 클래스에서 run()을 호출하는 것이 아니라 Bus 클래스에서 run()을 호출하고 싶다면, 아래처럼 작성하면 된다. 12345package devandy.java.inheritance;public class Bus extends Car &#123; super.run();&#125; 위의 예제코드를 활용하여 생성자를 추가하는 것으로 조금 변형을 해보았다.Bus 클래스에서 생성자를 만들어보았다. 이 생성자는 숫자를 파라미터로 받아서 number+&quot; 번 버스&quot;라는 문장을 출력한다. passenger 클래스에서 숫자를 인자값으로 넣는 인스턴스를 생성후, run()을 실행했다. Car.java 1234567package devandy.java.inheritance;public class Car &#123; void run() &#123; System.out.println(&quot; 탑승하다.&quot;); &#125;&#125; Bus.java 12345678910package devandy.java.inheritance;public class Bus extends Car &#123; int number; Bus(int number)&#123; this.number = number; System.out.print(number+&quot;번 버스&quot;); &#125;&#125; passenger.java 12345678package devandy.java.inheritance;public class Passenger &#123; public static void main(String[] args)&#123; Bus b = new Bus(1415); b.run(); &#125;&#125; 실행결과이다. 11415번 버스 탑승하다. 위의 프로그램이 JVM에서 작동하는 순서는 다음과 같다. 1Bus b = new Bus(1415); 우선 passenger 클래스의 main()이 실행되고, main()에서 호출한 Bus 클래스의 생성자가 실행된다. 1b.run(); 그리고 인스턴스의 메서드를 실행하기 위해 인스턴스의 클래스 타입인 Bus 클래스가 호출되고, 찾는 메서드가 Bus 클래스에 없으므로 수퍼 클래스인 Car 클래스에서 찾아서 호출된다. 예제코드로 확인해보자. Car.java 1234567package devandy.java.inheritance;public class Car &#123; Car() &#123; System.out.println(&quot;Super 클래스, Car 생성자입니다.&quot;); &#125;&#125; Bus.java 1234567package devandy.java.inheritance;public class Bus extends Car &#123; Bus() &#123; System.out.println(&quot;Sub 클래스, Bus 생성자입니다.&quot;); &#125;&#125; CarExam.java 1234567package devandy.java.inheritance;public class CarExam&#123; public static void main(String[] args)&#123; Bus b = new Bus(); &#125;&#125; 실행결과는 다음과 같다. 12Super 클래스, Car 생성자입니다.Sub 클래스, Bus 생성자입니다. Bus 클래스의 인스턴스를 선언했을뿐인데, Bus 클래스의 수퍼 클래스인 Car 클래스의 생성자가 먼저 호출되고, Bus 클래스의 생성자가 호출된걸 확인할 수 있다. 서브 클래스에 해당하는 객체를 호출하면, JVM에서 자동으로 해당 객체의 수퍼 클래스를 호출하는데, 이는 **JVM에서 서브 클래스에 super() 를 자동으로 생성**했기 때문이다. 위의 코드는 정확히 아래의 코드와 같다. 달라진 거라곤 서브 클래스에 해당하는 Bus 클래스의 생성자에 super() 를 추가한 것 뿐이다. 아까는 수퍼 클래스인 Car 클래스의 생성자가 기본 생성자였기 때문에 프로그래머가 super()를 생략하더라도, JVM에서 서브클래스에 자동으로 super()를 생성해주면서 수퍼 클래스의 생성자를 먼저 호출할 수 있었다. 반대로 수퍼 클래스의 생성자가 기본 생성자가 아닐 경우에는 프로그래머가 임의로 super()를 작성해주어야 한다. 1Implicit super constructor Car() is underfined. Must explicityly invoke another constructor 수퍼 클래스의 생성자를 기본 생성자에서 파라미터를 받는 생성자로 바꾸자 위와 같은 경고 메세지가 출력되었다.수퍼 클래스인 Car()가 정의되지 않았으며, 다른 생성자를 반드시 명쾌하게 적용하라고 한다. 서브 클래스인 Bus 클래스의 생성자 내부에 임의로 super()를 생성하고, 여기에 수퍼 클래스의 생성자에 주입할 수 있는 문자열을 인자값으로 넣어주었다. 그리고 서브 클래스에서 입력받은 인자값을 출력할 수 있도록 Car 클래스의 생성자 속 출력문도 수정을 해주었다. 정상적으로 출력된 걸 확인할 수 있다. 이를 통해, 수퍼 클래스의 생성자가 기본 생성자일 경우는 프로그래머가 따로 호출하지 않아도 JVM에서 서브클래스의 생성자에 super() 를 생성해주어 서브클래스를 호출하는 것만으로 수퍼 클래스까지 함께 호출할 수 있었다. 또 수퍼 클래스의 생성자가 기본생성자가 아닐 경우에는 프로그래머가 서브 클래스의 생성자 내부에 super() 를 명시함으로써 마찬가지로 수퍼클래스를 호출할 수 있었다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"}]},{"title":"Java - 오버로딩과 오버라이딩","slug":"java-overload-override","date":"2020-03-28T09:36:42.000Z","updated":"2020-09-13T01:53:28.444Z","comments":true,"path":"2020/03/java-overload-override/","link":"","permalink":"http://youngjinmo.github.io/2020/03/java-overload-override/","excerpt":"","text":"상속을 배우면서 빠질 수 없는 개념들, 오버로딩(overloading)과 오버라이딩(overriding)에 대한 부분이다. 간단히 정의하면 아래와 같다. 개념 설명 Overloading오버로딩 오버로딩은 수퍼 클래스와 같은 이름의 메서드를 서브 클래스에서 여러개 만들어서 사용할 때 쓰는 개념 Overriding오버라이딩 오버라이딩은 상속받은 서브 클래스가 수퍼 클래스의 기능(메서드)을 재정의해서 사용할때 쓰는 개념 둘의 차이는 오버로딩은 새로운 기능을 생성**하는 것이라면, **오버라이딩은 기존의 기능을 **변경**하는 것이라 할 수 있다. 오버로딩조건 메서드 이름이 같아야 한다. 파라미터의 개수 또는 반환 데이터 타입이 달라야 한다. 예제코드Car.java 1234567package devandy.java.inheritance;public class Car &#123; public void run() &#123; System.out.println(&quot;차가 달립니다.&quot;); &#125;&#125; Bus.java 123456789101112131415package devandy.java.inheritance;public class Bus extends Car &#123; public void run(int speed) &#123; System.out.println(&quot;버스가 시속 &quot;+speed+&quot;km/h로 달립니다.&quot;); &#125; public void run(String name) &#123; System.out.println(name.concat(&quot;가 달립니다.&quot;)); &#125; public void run(String name, int speed) &#123; System.out.println(name+&quot;가 시속 &quot;+speed+&quot;km/h로 달립니다.&quot;); &#125;&#125; CarExam.java 123456789package devandy.java.inheritance;public class CarExam &#123; public static void main(String[] args) &#123; Bus bus = new Bus(); bus.run(); bus.run(70); &#125;&#125; CarExam 클래스의 main()을 실행하면 결과는 아래와 같다. 12차가 달립니다.버스가 시속 70km&#x2F;h로 달립니다. Bus 클래스에는 선언되지 않았지만, 수퍼 클래스에서 선언된 파라미터를 받지않는 run()을 Bus 클래스의 인스턴스를 통해 실행할 수 있었으며, 이것과 이름은 같지만 파라미터를 주입해서 생성한, 즉 오버로딩한 run(int speed) 도 실행할 수 있었다. 이처럼 메서드 이름이 같더라도 파라미터의 갯수가 반환 데이터 타입이 다르면 서로 다른 메서드처럼 사용할 수 있으며, 이를 오버로딩이라 한다. 오버라이딩조건 이름이 같아야 한다. 파라미터까지 같아야 한다. 반환 데이터 타입도 같아야 한다. 오버로딩과 달리 오버라이딩은 수퍼클래스의 메서드와 완전히 같은 형식으로 선언될때 오버라이딩을 할 수 있다. 예제코드위의 예제코드에서 Car를 상속받는 Bus 클래스를 추가 생성했다. Car.java 1234567package devandy.java.inheritance;public class Car &#123; public void run() &#123; System.out.println(&quot;차가 달립니다.&quot;); &#125;&#125; Bus.java 1234567891011package devandy.java.inheritance;public class Bus extends Car &#123; public void run() &#123; System.out.println(&quot;버스가 달립니다.&quot;); &#125; public void run(int speed) &#123; System.out.println(&quot;버스가 시속 &quot;+speed+&quot;km/h로 달립니다.&quot;); &#125;&#125; CarExam.java 123456789package devandy.java.inheritance;public class CarExam &#123; public static void main(String[] args) &#123; Bus bus = new Bus(); bus.run(); bus.run(70); &#125;&#125; Car 클래스의 main() 실행결과는 다음과 같다. 12버스가 달립니다.버스가 시속 70km&#x2F;h로 달립니다. 수퍼 클래스인 Car 클래스의 run()에 선언된 print문에는 &quot;차가 달립니다.&quot;라고 작성되있었지만, 서브클래스에서 선언한 run()의 &quot;버스가 달립니다.&quot;로 출력된걸 확인할 수 있다. 이처럼 수퍼클래스의 메서드와 이름도, 반환 데이터 타입도, 파라미터도 같은 메서드를 서브 클래스에 선엄함으로써 수퍼클래스의 메서드를 무시하고 서브클래스의 메서드를 사용할 수 있었다. 이를 오버라이딩이라 한다. 다시 정리하면, 둘의 차이는 오버로딩은 새로운 기능을 부여하는 것이라면, 오버라이딩은 기존의 기능을 변경하는 것이라 할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"}]},{"title":"JAVA - 생성자","slug":"java-constructor","date":"2020-03-28T06:39:54.000Z","updated":"2020-09-13T01:53:28.616Z","comments":true,"path":"2020/03/java-constructor/","link":"","permalink":"http://youngjinmo.github.io/2020/03/java-constructor/","excerpt":"","text":"생성자란 인스턴스가 생성될 때 호출되는 **’인스턴스 초기화 메서드’**이다. **인스턴스를 생성하기 위해 객체를 초기화하는 메서드가 필요**한데, 생성자가 이 역할을 한다. 생성자는 기본적으로 메서드와 동일한 역할을 하는데, 메서드와 달리 아래의 두가지 조건을 필요로 한다. 생성자의 이름은 클래스의 이름과 같아야 한다. 리턴값이 없어야 한다. (리턴 타입은 생략한다.) 생성자의 조건으로 리턴값이 없어야 한다고 했다. 리턴값이 없으면 리턴 타입은 void가 되지만, 생성자를 선언할 때는 리턴 타입조차 생략된다. 어차피 생성자는 리턴값이 없기 때문에 아예 리턴 타입을 생략한다고 한다. 이는 옵션이 아닌 필수이며, 반약 void로 리턴 타입을 선언하면, 다른 클래스에서 인스턴스를 생성 할 수 없다. 생성자의 예제 코드를 보자. Car 클래스에 String형 name 이라는 필드와 int형 number 필드를 생성했다. 그리고 CarExam 클래스에서 Car 객체에 대한 인스턴스를 생성해서 필드를 출력해보았다. Car 클래스에 필드명만 선언되었지, 값은 넣어두지 않았기 때문에 null이 출력된걸 확인할 수 있다. 여기에서 Car 클래스안에는 필드명만 선언되어있지만 사실 Car 클래스안에는 기본생성자가 자동으로 생성되어 있기 때문에 CarExam 에서 인스턴스를 생성해서 사용할 수 있었다. 이처럼 프로그래머가 따로 생성자를 만들지 않으면, 클래스를 생성하면 컴파일러에서 자동으로 기본생성자를 생성한다. 기본 생성자는 위 이미지에서 필자가 작성한것처럼 파라미터도 없고 아무런 내용도 없는 생성자를 의미한다. 이렇게 컴파일러에 의해 기본생성자가 자동으로 생성될 경우 각 필드값은 데이터타입에 따라 아래처럼 초기화된다. 데이터타입 값 int 0 double 0.0 String null boolean false 단, 프로그래머가 따로 생성자를 만들면, 컴파일러는 기본생성자를 생성하지 않는다. 예제 코드를 통해 확인해보자. 파라미터를 받는 생성자를 Car 클래스에 생성하니, 아까 작성한 인스턴스 c1을 선언하는 코드에서 에러가 발생하는 것을 볼 수 있다. 1The constructor Car() is undefined 더 이상 컴파일러가 기본생성자를 생성하지 않은 것이다. 이렇게 프로그래머가 임의로 생성자를 생성해서 컴파일러가 기본생성자를 생성하지 않을 때엔 기본생성자 역시 프로그래머가 임의로 작성함으로써 사용할 수는 있다. 기본생성자대신 String형 파라미터를 받는 생성자를 이용해서 name 필드를 출력해보았다. 생성자에 String형 값을 입력하니 Car 객체의 필드에 입력되어 CarExam 에서 정상적으로 출력된걸 확인할 수 있다. 이쯤에서 생성자를 사용하는 이유를 정리해보자. 생성자를 사용하는 이유생성자를 사용하면 필수 입력값을 강제할 수 있으며, 프로그래머가 입맛대로 인스턴스를 생성(오버로딩)할 수 있게된다. 추가로, 생성자에서 this 키워드를 사용했는데, this 는 상위 scope의 객체에 접근할 때 사용하는 키워드이다. 1234567public class Car &#123; String name; public Car(String name)&#123; name = name; // 아무 값도 대입되지 않음 &#125;&#125; 이것처럼 Car 클래스의 필드 name과 생성자 Car(String name)에서 받는 파라미터의 이름이 같을 경우 컴파일러는 nam을 인자값으로 들어온 name으로만 인식하게 된다. 따라서 이 때에 this 키워드를 사용해야, 상위 scope의 필드를 적절하게 명시할 수 있게된다. 1234567public class Car &#123; String name; public Car(String name)&#123; this.name = name; &#125;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"}]},{"title":"Scope와 Static","slug":"java-scope-static","date":"2020-03-27T09:24:26.000Z","updated":"2020-09-13T01:53:28.440Z","comments":true,"path":"2020/03/java-scope-static/","link":"","permalink":"http://youngjinmo.github.io/2020/03/java-scope-static/","excerpt":"","text":"위의 이미지처럼 Car 라는 객체로부터 인스턴스를 2개를 생성해서 Car 객체의 변수 wheelCount를 사용하려고 한다. 먼저 이렇게 작성해보았다. taxi, suv라는 이름으로 각각 인스턴스를 생성했고, 각각 다른 값을 wheelCount에 입력해보았다. 출력결과는 예상대로 출력이 되었다. 이번엔 좀 다르게 해보았다. Car 객체의 wheelCount 변수를 static으로 선언했다. 출력을 했더니 위와는 다른 결과가 출력되었다. 각각 다른 값을 대입했건만 출력해보니 서로 같은 값을 갖고 있었다. 왜 이런 일이 발생했을까? CarExam에서 사용한 wheelCount 변수는 서로 다른 인스턴스에서 사용했지만, 결국 같은 메모리 주소를 참조하는 변수를 사용했기 때문에 마지막에 값을 대입한 suv.wheelCount = 4; 가 최종적으로 메모리 주소를 변경하여 taxi.wheelCount와 suv.wheelCount 모두 같은 값을 출력한 것이다. 위에서 bold를 적용한 문장 “같은 메모리 주소를 참조하는 변수“ 란 static 키워드로 선언한 변수를 의미한다. System 객체의 내장메서드 identityHashCode()를 통해 확인해보면 다음과 같다. taxi.price와 suv.price는 서로 다른 주소값을 참조하고 있음을 알 수 있다. 반면 taxi.wheelCount와 suv.wheelCount는 서로 같은 주소값을 참조하는걸 알 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"JAVA - This()","slug":"java-this","date":"2020-03-27T08:45:55.000Z","updated":"2020-09-13T01:53:28.372Z","comments":true,"path":"2020/03/java-this/","link":"","permalink":"http://youngjinmo.github.io/2020/03/java-this/","excerpt":"","text":"123456789101112131415161718public class Car &#123; String name; int number; public Car()&#123; name = &quot;undefined&quot;; number = 0; &#125; public Car(String name) &#123; this.name = name; &#125; public Car(String name, int number) &#123; this.name = name; this.number = number; &#125;&#125; 그런데 이렇게 생성자가 많아질수록 this 키워드 명령이 중복될 수 있다. 이 때엔 this()을 사용하여 중복을 제거할 수 있다. 1234567891011121314151617public class Car &#123; String name; int number; public Car()&#123; this(&quot;undefined&quot;, 0); &#125; public Car(String name) &#123; this(name, 0); &#125; public Car(String name, int number) &#123; this.name = name; this.number = number; &#125;&#125; 파라미터가 많은 생성자를 기준으로 나머지 생성자의 this 키워드를 this() 로 바꾸는 것이 가능하며, this() 안의 파라미터 개수는 가장 파라미터가 많은 생성자의 그것을 따른다. 위의 코드에서 마지막에 선언한 생성자가 두개의 필드를 정의하고 있으므로, Car 객체에서 this()를 사용할 때엔 2개의 파라미터를 갖도록 해야한다. IDE에서 this를 클릭하면, 이 this가 무엇을 가리키고 있는지 알 수 있다. 위의 예제를 통해서 생성자는 오버로딩이 가능하다는 사실을 알 수 있었다. 오버로딩이란 파라미터의 갯수를 다르게 하는 방식으로 같은 이름의 메서드를 여러개 생성할 수 있는 걸 의미한다. 다음 포스트에서 정리할 예정이다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"}]},{"title":"대입연산자=가 실제로 대입하는 것","slug":"java-assgin-reference","date":"2020-03-26T04:25:39.000Z","updated":"2020-09-13T01:53:28.628Z","comments":true,"path":"2020/03/java-assgin-reference/","link":"","permalink":"http://youngjinmo.github.io/2020/03/java-assgin-reference/","excerpt":"","text":"자바 배열 변수를 대입연산자를 통해 복사하는 것이 어떤 의미인지를 정리하기 위해 작성해보았다. 1int[][] array_2 = array1; 복사라고 하면 값을 그대로 가져다 사용하는것처럼 들릴수 있는데 사실 반은 맞고, 반은 틀리다.대입연산자 =는 값을 대입하는게 아니라 변수가 참조하는 주소 값을 대입하는 것이다. 1array_1[0][1] = 100; array_1의 값중 하나를 바꾸었다. array_1을 참조하는 배열 array_2는 어떻게 됐을까? array_1[0][1]의 값을 바꾼 후, array_2[0][1]도 값이 바뀌는지를 확인하기 위해 출력해보기로 했다. 그리고 컴파일해서 실행해보니 array_2[0][1]도 함께 바뀐 것을 알 수 있다. 위에서 주소값을 참조한다고 했는데, 주소값이란 컴퓨터 메모리(Heap)에서 값에 해당하는 주소를 의미한다. 따라서 int num = 5; 은 int형 객체 변수 num이 5에 해당하는 객체를 참조 또는 가리키고 있다고 할 수 있다. 배열을 선언할 때 new라는 키워드를 통해 선언을 했는데 이 키워드는 메모리 주소를 갖는 인스턴스를 생성할 때 사용한다. 키워드에 대한 설명은 이 글(JVM의 구조와 역할)을 참고바란다. 배열을 생성하면 프로그래머가 입력한 값을 담고있는 메모리상의 주소를 참조하는 변수가 생성된다는 것을 이해해야한다. 대입연산자 =를 통해 값을 복사한게 아니라 참조하는 주소값을 대입받았다는 말을 이젠 이해할 수 있을 것이다. 따라서 대입연산자를 사용해서 **복사하는 것이 아니라 메모리 주소값을 가리키도록 명시**하는 것으로 이해해야한다. 자바에서는 JVM에서 메모리 관리를 자동으로 해주기 때문에 프로그래머가 주소값을 명시하거나 알 필요는 없을 수 있으나 그래도 이해는 필요하다고 생각했다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"array","slug":"array","permalink":"http://youngjinmo.github.io/tags/array/"}]},{"title":"Spring Tool Suite4에서 Git 프로젝트 불러오기","slug":"eclipse-import-git-project","date":"2020-03-22T03:02:33.000Z","updated":"2020-09-13T01:53:28.952Z","comments":true,"path":"2020/03/eclipse-import-git-project/","link":"","permalink":"http://youngjinmo.github.io/2020/03/eclipse-import-git-project/","excerpt":"","text":"어쩌다가 프로젝트를 날리고 다시 해야하는 상황이 와서 하는김에 정리해보았다. Spring Tool Suite4를 다시 설치해서 Git프로젝트를 불러오는 작업이다. 먼저 IDE를 실행하고, 왼쪽 Package Explorer에서 **[import projects..]**를 클릭한다. Import할 수 있는 프로젝트 형태중 Git을 선택하고, Project from Git을 클릭한다. 그럼 로컬 레파지토리를 불러올지 원격저장소 URI를 통해 불러올지를 묻는다. 현재 나는 로컬에 프로젝트가 없으므로 Github에 있는 저장소 URI를 통해 가져와야 한다. Clone URI를 클릭한다. Location의 URI에 Github 저장소의 URI를 복사해서 붙여넣는다. 이 URI는 여기서 가져올 수 있다. Next를 클릭하면, 이런 창을 만나게 되는데 프로젝트에 따로 브랜치를 생성하지 않고 master에만 작업하다보니 가져올 수 있는 브랜치가 하나밖에 없는 걸 확인할 수 있다. 진행을 하면, 원격저장소에서 프로젝트를 가져오는 작업이 진행된다. 프로젝트를 import하는 작업이 끝나면 잠시동안 프로젝트에 빨간색 에러 표시가 보일 수 있는데, 이는 아직 Spring Tool Suite에서 프로젝트 빌드가 안끝나서 그런거다. 빌드가 완료되면 아래처럼 Spring Boot App을 실행할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"http://youngjinmo.github.io/tags/tutorial/"},{"name":"eclipse","slug":"eclipse","permalink":"http://youngjinmo.github.io/tags/eclipse/"}]},{"title":"넷플릭스를 더 유용하게 즐길 수 있는 크롬 익스텐션 4종","slug":"extensions-for-netflix","date":"2020-03-19T09:04:48.000Z","updated":"2020-09-13T01:53:28.944Z","comments":true,"path":"2020/03/extensions-for-netflix/","link":"","permalink":"http://youngjinmo.github.io/2020/03/extensions-for-netflix/","excerpt":"","text":"바이러스로 인해서 많은 분들이 재택근무를 하거나 외출을 자제하고 있다. 이러면서 덩달아 집에서 할 수 있는 다양한 활동들이 뜨고 있는데, 그중에서도 특히 넷플릭스가 역대급으로 가입자를 늘리게 되는 분기가 되지 않을까 싶다. 사회적 거리두기를 실천하면서 집에서 넷플릭스를 즐기는데 도움을 주는 익스텐션을 추천하려고 한다. 1. NflxMultiSubs : 멀티 자막 지원 NflxMultiSubs는 이름에서 직관적으로 알수있듯 다중 자막을 지원해주는 익스텐션이다. 지난해 국내 트위터 사용자들 사이에서 화제가 되던 익스텐션이기도 하다. 외국어 공부하기에 더 없이 좋은 익스텐션이라 생각한다. 크롬에 설치하러 가기 2. RateFlix : 썩은토마토지수 on 넷플릭스 넷플릭스는 공식적으로 평점을 지원하지 않는다. 그저 사용자 시청 데이터 기반으로 피드에 영상을 노출하고 있을뿐이다. 원래 넷플릭스는 추천 알고리즘으로 유명했었다. 그러나 오리지널 컨텐츠를 강화하고 있는 지금 시점에는 더 이상 유효하지 않는듯하다. 왓챠플레이와 달리 후기마저도 남길 수 없게되면서 이 영상이 정말 재밌을지 아닐지는 오직 넷플릭스만 알게된 것이다. 우스갯소리로 넷플릭스는 시청하는 시간보다 피드에서 영상 고르는 시간이 더 길다는 이야기도 있는데, 이런 분들에게 고민할 시간을 단축시켜주는 익스텐션이 될 것 같다 ㅎㅎ 크롬에 설치하러 가기 만약 왓챠 지수를 보고 싶다면, 아래의 익스텐션을 권해본다. 국내 한 개발자가 개발한듯한데, 직접 사용해보지 못해서 어떻게 작동되는지는 모르겠다. 크롬에 설치하러 가기 3. Reveal for Netflix : 모든 컨텐츠 시청 지원 넷플릭스는 국가별로 시청가능한 영상이 제한적이다. 우리가 볼 수 있는 카테고리와 달리 훨씬 더 다양한 카테고리를 갖추고 있음에도 불구하고 이를 공식 사이트에선 보여주지 않고 있다. 이를 전부 보여주는 익스텐션이다. 크롬에 설치하러 가기 4. Netflix Party : 넷플릭스보면서 채팅을 이 익스텐션은 직접 설치하지 않았지만, 트위터에서 많은 리트윗을 받아서 추천하는 익스텐션이다. 넷플릭스 관련 익스텐션 대부분이 다운로드수 10k를 넘기지 않는데, Netflix Party는 현재 1m 다운로드수를 기록하고 있다. 아마도 전세계적 사회적 거리두기 열풍에 힘입어 넷플릭스에서 모임? 파티?를 하는 것에 사람들이 흥미를 느끼고 있는게 아닐까 싶다. 크롬에 설치하러 가기 많이 힘든 시기인데 모두 이 시기를 현명하게 잘 극복하기를 바라며 얼른 이 시기가 지나가기를 바란다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Review","slug":"Life/Review","permalink":"http://youngjinmo.github.io/categories/Life/Review/"}],"tags":[{"name":"netflix","slug":"netflix","permalink":"http://youngjinmo.github.io/tags/netflix/"},{"name":"extension","slug":"extension","permalink":"http://youngjinmo.github.io/tags/extension/"},{"name":"chrome","slug":"chrome","permalink":"http://youngjinmo.github.io/tags/chrome/"}]},{"title":"Mustache로 Updateform 구현하기","slug":"create-updateform-mustache","date":"2020-03-18T06:57:27.000Z","updated":"2020-09-13T01:53:29.108Z","comments":true,"path":"2020/03/create-updateform-mustache/","link":"","permalink":"http://youngjinmo.github.io/2020/03/create-updateform-mustache/","excerpt":"","text":"Mustache로 update form을 구현할 일이 구현하면서 정리해본다. update form의 특징이라면, 사용자가 수정하기 위해서는 수정이 필요한 데이터를 먼저 보여주어야 한다. 그러려면 Model 데이터를 불러와서 input 박스의 value로 자동으로 채워넣어줘야 한다. 이 과정에서 mustache 문법이 어떻게 사용되는지를 알아보자. Hexo 에서는 mustache의 &#123; &#123;id&#125; &#125;사용할 경우 화면에 출력되지 않아 이렇게 표기를 하게되었다.. update.html로 id값 전달하기update form 페이지로 이동하기 위해서는 a 태그를 이용해서 페이지를 전달하는게 기본적이다. 개인정보 수정 기능을 하는 update form을 구현하기 위해서는 어떤 사용자의 정보를 수정하고자 하는지를 알아야 한다. 그래야 서버에서 사용자 정보를 가져와서 수정하고 다시 서버에 저장할 수 있기 때문이다. 이 때 사용되는게 id값이다. 그리고 이 id값을 전달받아야 repository에서도 사용자 정보를 꺼내어서 model을 이용해 화면에 사용자 정보를 전달할 수 있다. 그러려면 a태그의 href 속성값에 mustache 문법으로 id값을 전달해줘야 한다. 1&lt;a href=&quot;/user/&#123;&#123;id&#125;&#125;/update&quot; class=&quot;btn btn-success&quot; role=&quot;button&quot;&gt;개인정보 수정하기&lt;/a&gt; 그럼 이렇게 update form 페이지로 이동했을 때 사용자 정보를 불러와서 화면에 전달해서 보여준다. /user&#123;id&#125;/update URI 맵핑 메서드 작성a 태그를 통해 /user&#123;id&#125;/update URI를 처리해줄 메서드가 컨트롤러에서 필요하다. 1234567891011121314151617import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;@Controller@RequestMapping(&quot;/user&quot;)public class userController &#123; ... @GetMapping(&quot;/update/&#123;id&#125;&quot;) public String update(@PathVariable Long id, Model model) &#123; model.addAttribute(&quot;users&quot;, userRepository.findById(id).get()); return &quot;user/update&quot;; &#125; &#125; userController의 경우 URI에 공통적으로 /user/ 가 사용되므로 @RequestMapping(&quot;/user&quot;) 어노테이션을 사용해서 리팩토링하였다. update 메서드를 들여다보면..화면에 데이터를 뿌려줄 model 객체에 데이터를 추가하고 있는데, 이 데이터는 전체 사용자 정보가 담긴 userRepository 에서 어노테이션 파라미터로 입력된 id 에 해당하는 사용자 정보를 찾아서(findById()) 가져오는(get()) 역할을 수행하고 있다. 1model.addAttribute(&quot;users&quot;, userRepository.findById(id).get()); 그리고 마지막으로 updatem.html을 return하고 있다. 컨트롤러(class)와 화면(html)에서의 특징이 하나 있다. 이것때문에 삽질을 좀 오래했었는데….html페이지에서는 id값을 가져올 때 &#123; &#123;id&#125; &#125; 로 표기하지만, 컨트롤러에서 맵핑하는 URI에는 &#123;id&#125; 로 표기해야 정상적으로 작동한다. html 페이지에 mustache 문법 작성컨트롤러에서 가져온 사용자 정보가 담긴 model 을 가져오려면 mustache의 문법을 알아야 한다. mustache에서는 model을 가져와서 화면에 맵핑할 때 아래와 같은 형식을 사용한다. 12345&#123;&#123;#model&#125;&#125;&lt;form method=&quot;&quot; action=&quot;&quot;&gt; ...&lt;/form&gt;&#123;&#123;/#model&#125;&#125; 여기에 User에 저장한 사용자 정보의 컬럼을 &#123; &#123;id&#125; &#125; 으로 감싸서 input 박스의 value로 넣어주면 된다. 필자의 유저 컬럼은 다음과 같이 지정되어 있다. 123456789101112131415161718import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;@Entitypublic class User &#123; @Id @GeneratedValue private Long id; @Column(nullable = false) public String userEmail; public String userName; public String userPassword; ...&#125; 여기서 수정에 필요한 데이터 컬럼인 userEmail, userName, userPassword를 사용할 것이다. 이를 적용하면 수정하는 페이지(update.html)에서 작성해야할 코드는 다음과 같다. form 태그 안의 속성값(method, action)에 주목하자. /user/update.html 1234567891011121314151617181920212223242526272829303132333435&#123;&#123;#users&#125;&#125;&lt;form method=&quot;post&quot; action=&quot;/user/&#123;&#123;id&#125;&#125;&quot;&gt; &lt;!--이메일 주소 입력 칸--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userEmail&quot;&gt;이메일&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;userEmail&quot; name=&quot;userEmail&quot; value=&quot;&#123;&#123;userEmail&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;!--이름 입력 칸--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userName&quot;&gt;이름&lt;/label&gt; &lt;input class=&quot;form-control&quot; id=&quot;userName&quot; name=&quot;userName&quot; value=&quot;&#123;&#123;userName&#125;&#125;&quot;&gt; &lt;/div&gt; &lt;!--비밀번호 입력 칸--&gt; &lt;div class=&quot;form-group&quot;&gt; &lt;label for=&quot;userPassword&quot;&gt;비밀번호&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;userPassword&quot; name=&quot;userPassword&quot; &gt; &lt;/div&gt; &lt;!-- 비밀번호의 경우 value를 가져오기보다 --&gt; &lt;!-- 새비밀번호를 덮어씌워서 바로 수정이 가능하도록 하자 --&gt; &lt;!--수정완료 버튼--&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-success clearfix pull-right&quot;&gt; 정보수정 &lt;/button&gt; &lt;div class=&quot;clearfix&quot; /&gt;&lt;/form&gt;&#123;&#123;/users&#125;&#125; model로 가져온 값을 보여줄때 사용하는 mustache 문법은 마찬가지로 value를 /user/&#123;id&#125; 로 감싸서 보여준다. 여기까지 작성하면 아래 이미지를 구현할 수 있다. form 태그 안의 action은 해당 form이 실행해서 어떤 URI로 값을 전달하는지를 알려준다. 위의 코드는 /user/ &#123; &#123;id&#125; &#125; 로 값을 전달할 것이다. 따라서 해당 URI를 맵핑하는 컨트롤러를 작성해주어야 한다. /user/&#123;id&#125; URI 맵핑하는 메서드 작성지금까지 update.html 페이지를 작성하고, 여기에서 요구하는 URI를 처리하는 메서드(컨트롤러)를 만드는 방식으로 진행되고 있음을 알 수 있다. /controller/userController.class 12345678910111213141516171819202122232425262728293031323334353637package com.devandy.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import com.devandy.domain.User;import com.devandy.repository.UserRepository;@Controller@RequestMapping(&quot;/user&quot;)public class userController &#123; @Autowired private UserRepository userRepository; ... @GetMapping(&quot;/&#123;id&#125;/update&quot;) public String update(@PathVariable Long id, Model model) &#123; model.addAttribute(&quot;users&quot;, userRepository.findById(id).get()); return &quot;user/update&quot;; &#125; // 추가로 작성한 메서드 @PostMapping(&quot;/&#123;id&#125;&quot;) public String update(@PathVariable Long id, User updatedUser) &#123; User user = userRepository.findById(id).get(); // 업데이트 전의 프로필 user.update(updatedUser); // User 정보 업데이트 userRepository.save(user); // 업데이트된 user정보 userRepository에 저장 return &quot;redirect:/user/list&quot;; &#125;&#125; 아까 작성한 get요청을 처리하는 메서드 아래에 post요청을 처리하는 메서드를 작성했다. id값은 노출되도 상관이 없기 때문에 get요청으로 처리했지만, id값 외의 사용자 정보는 유출되면 안되므로 값을 노출하지 않고 전달할 수 있는 post요청으로 처리한다. 메서드 이름이 같아도 상관은없다. (진짜 상관이 없는건지는 모르겠으나 아직 문제를 발견하지 못했다.) 이번엔 User 객체의 인스턴스를 2개 생성해서 사용했다. 하나는 DB(repository)에서 가져온 사용자 정보, 즉 업데이트 전의 사용자 정보(user), 다른 하나는 화면에서 생성해서 전달받은 새로운 사용자 정보(updatedUser). 메서드의 작동과정은 다음과 같다. URI를 통해 전달받은 id에 해당하는 사용자를 DB(repository)에서 찾아서 1User user = userRepository.findById(id).get(); 아직 생성하지 않았지만, User 도메인의 update 메서드를 통해 파라미터로 전달받은 새로운 사용자정보로 수정한다. 1user.update(updatedUser); update된 사용자정보를 다시 DB(repository)에 저장한다. 1userRepository.save(user); 그리고 원래의 페이지였던 list.html로 리다이렉트 보낸다. 이제 데이터를 불러와서 수정하는 일이 끝났다. 이렇게 id값 1번에 해당하는 사용자 정보중 devandy라는 이름을 andy로 수정할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Springboot","slug":"Dev/Springboot","permalink":"http://youngjinmo.github.io/categories/Dev/Springboot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"},{"name":"mustache","slug":"mustache","permalink":"http://youngjinmo.github.io/tags/mustache/"}]},{"title":"맥에서 Xcode 설치하지 않고, Command Line Tools 설치하기","slug":"install-commandlinetools-without-xcode","date":"2020-03-16T06:38:40.000Z","updated":"2020-09-13T01:53:28.652Z","comments":true,"path":"2020/03/install-commandlinetools-without-xcode/","link":"","permalink":"http://youngjinmo.github.io/2020/03/install-commandlinetools-without-xcode/","excerpt":"","text":"맥으로 개발을 하다보면, Command Line Tools 때문에 X code를 업데이트 할 일이 종종 있다. 그런데 X code 자체가 무거운 프로그램이다 보니 업데이트 할 때에도 긴 시간이 걸리곤 하는데, xcode 없이 Command Line Tools만 따로 설치하는 방법이 있다. 1xcode-select --install 위의 명령어를 입력하면 X code를 삭제하더라도 Command Line Tools를 업데이트하며 개발할 수 있다. 참고 문서 : Back To The Mac - Xcode 없이 맥에 ‘명령어 라인 도구(Command Line Tools)’를 설치하는 방법","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Others","slug":"Dev/Others","permalink":"http://youngjinmo.github.io/categories/Dev/Others/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"},{"name":"macos","slug":"macos","permalink":"http://youngjinmo.github.io/tags/macos/"}]},{"title":"AWS 튜토리얼(2) - Ec2인스턴스에 프로젝트 배포하기","slug":"aws-tutorial-launch-ec2","date":"2020-03-15T13:32:26.000Z","updated":"2020-11-05T06:06:34.315Z","comments":true,"path":"2020/03/aws-tutorial-launch-ec2/","link":"","permalink":"http://youngjinmo.github.io/2020/03/aws-tutorial-launch-ec2/","excerpt":"","text":"이전 글 - AWS 배포하기 - EC2 생성하기 앞에서 생성한 EC2 인스턴스를 ssh로 실행할 것이다. 키페어 권한변경 ec2인스턴스 ssh진입 JDK 설치하기 프로젝트 클론하기 메이븐 빌드하기 jar 파일 실행 키페어 권한변경터미널에서 ssh로 ec2를 접속할 때 보안그룹을 생성할 때 다운받은 키페어를 사용해서 들어가야 한다. 그런데 바로 실행하면 키페어의 권한때문에 접속이 되지 않을 것이다. 키페어의 권한을 바꿔주는 명령어를 입력해두자. 1$ chmod 600 key.pem ec2인스턴스 ssh진입ec2 인스턴스 접속에 필요한 주소가 2개 있다. 우선 접속에 필요한 키페어의 경로가 필요하다. 그리고 우리가 들어갈 인스턴스의 IPv4 퍼블릭 IP 주소를 복사해두자. 아래 명령어에서 방금 복사한 퍼블릭 ip주소를 붙여넣어서 터미널에 명령하면 된다. 1$ ssh -i [키페어 경로] ec2-user@[public ip 주소] 혹시나 계속 진행할 것인지 묻는 메세지가 출력된다면 yes를 입력하고 엔터를 입력하면 위의 이미지처럼 인스턴스 내부로 진입이 완료된다. 만약 권한 이슈가 계속 발생한다면, 커맨드 명령어를 잘못입력했거나 키페어의 권한설정이 잘못되었을 수 있다. 위로 올라가서 다시 천천히 설정해보자. JDK 설치하기아마존 리눅스에는 기본적으로 jdk가 설치되어 있긴하나 1.7버전이 설치되어 있을 것이다. 따라서 명령어로 1.8 버전의 jdk를 설치하고, 사용하지 않을 구버전의 jdk는 삭제할 것이다. 먼저 1.8 버전의 jdk를 설치하자. 1$ sudo yum install -y java-1.8.0-openjdk-devel.x86_64 이제 jdk 버전을 방금 설치한 1.8버전으로 변경한다. 1$ sudo &#x2F;usr&#x2F;sbin&#x2F;alternatives --config java +가 바라보는 곳이 현재의 자바 버전이다. 변경하고자 하는 버전의 숫자를 입력하면 해당 버전으로 자바가 변경된다. 이제 사용하지 않을 버전의 jdk는 삭제하자. 1$ sudo yum remove java-1.7.0-openjdk 프로젝트 클론하기아마존 리눅스에서는 yum이라는 패키지 툴을 이용할 것이다. git을 설치하기 전 패키지 툴을 최신버전으로 업데이트하고, git을 설치할 것이다. 12$ sudo yum update$ sudo yum install git 약 10초가 조금 지나면 설치가 완료된다. 그리고 프로젝트가 저장된 깃허브 웹페이지로 가서 https주소를 가져오자. 이 주소로 ec2 인스턴스 내부에서 클론하면 된다. 프로젝트를 가져올 디렉토리를 먼저 생성하자. 필자는 /home/ec2-user 디렉토리 내부에 app 폴더를 생성해서 이 안에 프로젝트를 가져올 것이다. 1$ git clone [git-clone-https-address] 메이븐 빌드하기이 프로젝트는 빌드 툴로 메이븐을 사용한다. 메이븐을 이용해 프로젝트를 빌드해서 jar파일을 생성해보자. 메이븐도 권한을 변경하고 빌드한다. 12$ chmod +x .&#x2F;mvnw$ .&#x2F;mvnw clean package 처음 프로젝트를 빌드하는데는 시간이 좀 걸릴 것이다. 대략 2-3분 정도의 시간이 소요될 수 있다. 다음에 다시 빌드를 할 때는 이정도로 소요되지는 않는다. 빌드가 완료되면 다음과 같은 성공 메세지를 볼 수 있다. 만약 빌드에 실패한다면, jdk 이슈일 가능성이 높다. jdk가 설치되어 있지 않거나, 프로젝트에서 사용한 자바 버전과 다르기 때문일 것이다. jar 파일 실행위에서 메이븐으로 빌드했다면, jar파일은 /target 디렉토리 안에 생성됬을 것이다. 1$ java -jar target&#x2F; .jar 스프링 로고가 출력되고 마지막에 Started 프로젝트명 in seconds 메세지가 출력된다면 이제 배포가 성공적으로 마친 것이다. 웹 브라우저로 가즈아! ec2 인스턴스를 생성할 때 보안그룹설정에서 custom TCP 프로토콜에 설정한 포트로 접속하면 된다. ec2 인스턴스 퍼블릭 ip주소에 위의 포트번호를 입력하면된다. 1[public-dns-ip]:8080 그럼 브라우저에서 프로젝트를 볼 수 있을 것이다. 혹시 프로젝트가 열리지 않는다면, 포트번호 맵핑이 잘못되었을 확률이 있다. 그렇다면 보안그룹을 다시 살펴보자. EC2 대시보드에서 [작업] 버튼을 클릭해서 EC2 인스턴스와 관련된 여러가지 설정을 변경할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"DevOps","slug":"Dev/DevOps","permalink":"http://youngjinmo.github.io/categories/Dev/DevOps/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"http://youngjinmo.github.io/tags/tutorial/"},{"name":"aws","slug":"aws","permalink":"http://youngjinmo.github.io/tags/aws/"},{"name":"cloud","slug":"cloud","permalink":"http://youngjinmo.github.io/tags/cloud/"}]},{"title":"AWS 튜토리얼(1) - Ec2 생성하기","slug":"aws-tutorial-create-ec2","date":"2020-03-15T07:37:06.000Z","updated":"2020-11-05T05:58:30.256Z","comments":true,"path":"2020/03/aws-tutorial-create-ec2/","link":"","permalink":"http://youngjinmo.github.io/2020/03/aws-tutorial-create-ec2/","excerpt":"","text":"EC2 인스턴스 생성 AMI(amazon Machine Image) 선택 인스턴스 유형 선택 인스턴스 세부 정보 구성 스토리지 추가 태그 추가 보안 그룹 구성 인스턴스 시작 검토 인스턴스 생성완료 지난주쯤에 스프링부트로 개발한 그레이들 프로젝트를 AWS(EC2 인스턴스)에 배포해보면서 AWS 배포를 정리하는 포스트를 정리하고 싶었다. 그래서 이번엔 박재성님의 유튜브 영상 강의를 보면서 하고 있는 스프링부트 메이븐 프로젝트를 EC2 인스턴스에 배포하면서 그 과정을 기록하기로 하였다. 앞으로 사용하게될 용어 정리부터 하자면, **EC2 인스턴스**는 일반적으로 우리가 사용하는 컴퓨터와 같다. 램과 용량을 선택할 수 있으며, EC2 인스턴스가 인터넷에 연결되서 우리가 배포하는 프로젝트를 인터넷에서 계속 통신하도록 도와주는 역할을 한다. AWS는 이런걸 제공하는 아마존의 서비스이자, 아마존의 계열사이다. AWS를 서비스하는 아마존은 미국 시애틀에 본사를 두고 있는 회사이다. 한국에서 시애틀까지 연결하는것보다는 아무래도 한국 내에 위치한 데이터센터에 접근하는 것이 더 안정적이고 빠를 것이다. 따라서 AWS는 지역마다 **리전(Region)**을 설치해서 해당 지역에서 더 빠르게 접근할 수 있도록 지원하고 있다. 서울도 지난 2016년부터 서울 리전이 가동되어 한국의 다양한 스타트업들이 AWS를 이용하고 있다고 한다. 참고문서 : AWS - 리전, 가용 영역 및 로컬 영역 **프리티어(Free tier)**는 AWS에 가입시 1년 동안 무료로 사용가능한 범위를 말한다. 이 범위를 초과하면 비용이 초과되는데, 이 범위 내에서는 무료로 이용이 가능하다. 이 포스트는 프리티어 내에서 진행된다. 본 글은 AWS에 회원가입에 대해서는 정리하지 않았다. EC2 인스턴스 생성AWS 콘솔에 로그인하여 서비스에서 [EC2]를 클릭한다. 그리고 상단 메뉴에서 리전을 서울 리전으로 선택한다. 아마 위치를 인식하여 자동으로 잡힐 수도 있지만, 그렇지 않다면 서울로 잡아주어야 한다. 속도차이가 발생하기 때문에 자신이 있는 곳에서 물리적으로 가장 가까운 곳의 리전을 선택해서 사용해야 한다. [EC2]에서는 [인스턴스] 메뉴를 클릭한다. 이제 본격적으로 인스턴스를 생성하게 된다. AMI(amazon Machine Image) 선택 AMI는 아마존 머신 이미지라고 하는데, EC2를 구성하는 템플릿을 선택하는 창이다. 일반적으로는 개발에 용이하게 소프트웨어가 구성된 Amazon Linux AMI 2018.03.0을 선택해서 사용한다. 인스턴스 유형 선택 프리티어 사용이 가능하다고 마킹되어 있는 t2.micro 인스턴스를 생성한다. 인스턴스 세부 정보 구성 여기부터는 계속 넘어가도 좋다. 스토리지 추가 스토리지는 기본으로 8기가가 설정되어 있지만, 프리티어는 최대 30기가까지 사용이 가능하다. 태그 추가 기본적으로는 태그가 아무것도 생성되어 있지 않은데, Name 태그를 부과해서 인스턴스의 이름을 지정하도록 하자. 보안 그룹 구성 지금까지의 과정중 AMI을 선택하는 것만큼 중요한 과정이다. 보안그룹은 해당 인스턴스를 어떻게 사용할 것인지를 결정하는 과정이다. 지금 빠뜨리고 못한 설정은 나중에 보안그룹 수정을 통해서 추가하거나 제거할 수 있다. updated.보안 그룹을 위에서처럼 하면 퍼블릭 DNS로 연결이 되지 않는다. 커스텀IP를 추가해서 8080 포트를 입력해주어야한다. 기본으로 SSH만 보안 그룹으로 구성되어 있을텐데, HTTP와 HTTPS를 [규칙추가]를 통해 추가하도록 하자. SSH는 터미널에서 사용이 가능하도록 하는 설정이다. 어디서나 SSH가 개방되어 있으면 보안상 위험할 수 있으므로 [사용자지정]을 클릭하여 [내 IP]로 지정하도록 하자. 그럼 자동으로 본인의 IP를 가져올 것이다. 그럼 해당 IP에만 접근이 가능하다. 현재 인스턴스를 생성하고 있는 IP가 아닌 다른 IP에서 인스턴스에 접근하려면 보안 그룹을 수정해서 지금과 같은 방법으로 규칙을 추가해서 접근할 수 있다. 인스턴스 시작 검토 지금까지의 과정중 가장 중요한 과정이다! 키 페어가 있다면, 기존의 키페어를 사용해도 좋고 아니면 새로 생성해도 상관없다. 나는 새 키페어를 생성해서 프로젝트 폴더에 다운로드 해두었다. 여기서 주의해야할 점은 여기서 다운로드받게 될 키페어(.pem)는 절대 어디서도 공개되어서는 안되는 키이다. 재발급이 불가능하고, 유출되면 안되므로 git이 추적되지 못하도록 gitignore를 사용하여 트래킹되지 못하게 해야한다. 인스턴스 생성완료 이 화면을 보고 있다면 성공적으로 인스턴스를 생성한 것이다. 다음 글에선 터미널로 EC2 인스턴스에 접속해서 배포에 필요한 EC2 설정하는 법을 알아보겠다. 다음글 - AWS 배포하기 - ec2인스턴스에 프로젝트 배포하기","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"DevOps","slug":"Dev/DevOps","permalink":"http://youngjinmo.github.io/categories/Dev/DevOps/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"http://youngjinmo.github.io/tags/tutorial/"},{"name":"aws","slug":"aws","permalink":"http://youngjinmo.github.io/tags/aws/"},{"name":"cloud","slug":"cloud","permalink":"http://youngjinmo.github.io/tags/cloud/"}]},{"title":"터미널 녹화기 Asciinema","slug":"asciinema","date":"2020-03-15T03:01:04.000Z","updated":"2020-09-13T01:53:29.520Z","comments":true,"path":"2020/03/asciinema/","link":"","permalink":"http://youngjinmo.github.io/2020/03/asciinema/","excerpt":"","text":"터미널 화면을 녹화하는 Asciinema 패키지를 알게되서 정리하게 되었다. Asciinema를 사용해서 녹화한 화면은 아래와 같다. 설치 회원 가입 녹화 설치Ubuntu 123sudo apt-add-repository ppa:zanchey&#x2F;asciinemasudo apt-get updatesudo apt-get install asciinema MacOS (Homebrew) 1brew install asciinema 회원가입asciinema를 통해 생성되는 파일(.cast)은 일반적인 미디어 플레이로 재생할 수 없다. 재생하려면 asciinema를 통해서만 가능한데, 이를 asciinema에 업로드하면, embed링크를 통해 어디서나 재생할 수 있게된다. 따라서 회원가입을 하는것을 추천한다. 웹에서 회원가입이 끝났다면, 터미널로 다시 돌아가서 asciinema 로그인 상태를 전달하자. 1$ asciinema auth 그럼 url이 하나 생성되는데, 생성된 url로 웹브라우저로 접속해서 로그인하면, 앞으로 터미널에서 asciinema를 통해 녹화되는 영상을 클라우드(asciinema.org)로 업로드할 수 있게 된다. 녹화터미널을 녹화하는 커맨드 명령어를 알아보자. 저장할 때 파일의 명령을 지정하면서 저장하는 명령어는 다음과 같다. 1$ asciinema rec -t &quot;new-file&quot; 녹화를 중지하고 싶으면 exit를 입력하면 된다. 1$ exit 그럼 녹화 영상을 asciinema.org로 업로드할지, 로컬에 저장할지를 묻는다. 업로드를 원한다면, Enter 로컬에만 저장을 원한다면 ctrl+c를 입력하면 된다. 로컬에 저장했을 때. 업로드했을 때. 위 링크로 접속하면 방금 녹화한 영상을 확인할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Others","slug":"Dev/Others","permalink":"http://youngjinmo.github.io/categories/Dev/Others/"}],"tags":[{"name":"python","slug":"python","permalink":"http://youngjinmo.github.io/tags/python/"}]},{"title":"Hexo 블로그에 카카오페이 후원버튼 삽입하기","slug":"hexo-donation-card","date":"2020-03-14T08:18:32.000Z","updated":"2020-09-13T01:53:28.796Z","comments":true,"path":"2020/03/hexo-donation-card/","link":"","permalink":"http://youngjinmo.github.io/2020/03/hexo-donation-card/","excerpt":"","text":"얼마 전에 도움이 되는 블로그 포스트를 읽고 포스트를 작성해주신 개발자분께 후원하고자 Buymeacoffee를 시도했는데, 결제에 실패해서 후원을 할 수 없었다. 무슨 이유였는지 모르겠지만, 현대카드를 통한 해외결제가 되지 않았다. 다른 후원방법이 없었기에 결국 그 분께 후원을 하지 못했다. 그래서 더 쉬운 후원이 없을까 고민하다가 내 블로그엔 페이팔 송금하기 기능을 이용해 후원버튼을 달아놓았었다. (뭐.. 아직까진 어떤걸 달아놓아도 아무일도 발생하지 않는다….) 그러다 최근 친구들과의 저녁식사자리에서 내가 먼저 결제를 하고, 친구들로부터 남은 금액을 송금받는 과정에서 카카오페이를 통해 들어오는 돈이 가장 많았던 경험이 생각났고, 카카오페이에서 iOS앱을 개발하고 있기도 한 콘의 도움으로 카카오페이 송금코드를 활용한 후원버튼을 만들었다. 카카오페이와 토스를 사용하는 사용자라면 누구나 송금을 받을 수 있는 QR코드를 발급받을 수 있다. 이 QR코드를 통해 다른 사용자들이 스캔해서 쉽게 돈을 송금할 수 있다. 나는 이 QR코드를 블로그를 후원하는 기능으로 활용해보았다. 카카오페이 송금코드 발급받기카카오톡 앱 하단의 마지막 탭 [더보기]를 들어가면, 카카오페이를 사용할 수 있는 버튼이 내장되어 있다. 여기에서 빨간색 원안의 버튼을 클릭하면 이미지처럼 송금코드를 발급받을 수 있다. 송금받고자하는 금액을 작성하면 최종적으로 이미지로 저장할 수 있는 QR코드 발급이 완료된다. 정말 쉽다! 그리고 이 QR코드를 사용하여 아티클 페이지에서 보여줄 카드를 만들었다. 후원버튼 이미지 만들기내 블로그 글을 읽는 사람 모두에게 QR코드를 보여줄 필요는 없다. 후원을 원하는 사람에게만 보여주려면 위에서 만든 버튼 이미지를 클릭했을때만 QR코드를 보여주면 된다. 그럼 후원버튼을 클릭했을때 QR코드 이미지를 보여주는 창으로 넘어가도 될 것이다. 그러나 이렇게하면 페이지를 벗어나게되고, 결과적으로 블로그를 이탈하게 된다. 후원 그 자체가 목적인 블로그는 아닌만큼 버튼을 클릭할 때만 QR코드를 보여주고, 또 버튼으로 QR코드를 사라지게 해주는 것이 내가 원하는 구현이다. 후원을 원하시는 멋지고 아름다우며 감사한 분들이 클릭할 수 있는 버튼 이미지를 만들자. 후원버튼은 카카오페이의 분위기(?)가 나는 버튼 이미지를 만들기 위해 카카오의 CI에서 배경색상(fffacd04)과 폰트색상(ff1e1e1e)을 가져와서 만들었다. 후원버튼/송금코드 HTML 작성광고배너 코드만을 따로 모아둔 Hexo 폴더(ads)내에 donation.ejs라는 파일을 생성했다. 버튼을 보여주는 코드를 먼저 작성한다. 123456&lt;!-- 후원하기 버튼 --&gt;&lt;div class=&quot;donation-toggle-button&quot;&gt; &lt;a onclick=&quot;showQR_kakaopay()&quot;&gt; &lt;img src=&quot;...&quot;&gt; &lt;/a&gt;&lt;/div&gt; 이미지 태그 바깥을 a 태그로 감싸서 클릭했을때 QR코드를 보여주는 함수가 작동되도록 설계했다. 123456&lt;!-- QR코드 --&gt;&lt;section class=&quot;donation_card&quot; align=&quot;center&quot; style=&quot;width: 100%;&quot;&gt; &lt;div id=&quot;qr_kakaopay&quot; style=&quot;display: none;&quot;&gt; &lt;img src=&quot;...&quot;&gt; &lt;/div&gt;&lt;/section&gt; QR코드는 후원버튼을 클릭할 때만 보여지려면, 버튼을 클릭할 때까진 보이지 않아야 한다. 그러기 위해 display: none; 을 스타일 속성을 부여했다. js 함수 작성하기이제 onclick() 속성에서 명시한 자바스크립트 함수를 작성할 차례이다. 버튼을 클릭했을때, QR코드가 화면에 출력(style.display=&quot;block&quot;)되어 있으면 닫는 기능을, 출력되어 있지 않으면(style.display=&quot;none&quot;) 출력되도록 할 것이다. 123456789101112&lt;script type=&quot;text/javascript&quot;&gt;var donationKakaopay = document.getElementById(&#x27;qr_kakaopay&#x27;); // 후원버튼 클릭했을 때 QR코드 불러오는 함수function showQR_kakaopay()&#123; if(donationKakaopay.style.display==&quot;none&quot;)&#123; donationKakaopay.style.display=&quot;block&quot;; &#125; else &#123; donationKakaopay.style.display=&quot;none&quot;; &#125;&#125;&lt;/script&gt; 위의 코드들을 하나의 ejs파일로 만들어서 이를 article.ejs(layout/common/article.ejs)의 footer영역에 삽입하면 완성된다. donation.ejs 1234567891011121314151617181920212223&lt;div class=&quot;donation-toggle-button&quot;&gt; &lt;a onclick=&quot;showQR_kakaopay()&quot;&gt; &lt;img src=&quot;...&quot;&gt; &lt;/a&gt;&lt;/div&gt;&lt;section class=&quot;donation-card&quot; align=&quot;center&quot; style=&quot;width: 100%;&quot;&gt; &lt;div id=&quot;qr_kakaopay&quot; style=&quot;display: none;&quot;&gt; &lt;img src=&quot;...&quot;&gt; &lt;/div&gt;&lt;/section&gt;&lt;script type=&quot;text/javascript&quot;&gt; var donationKakaopay = document.getElementById(&#x27;qr_kakaopay&#x27;);function showQR_kakaopay()&#123; if(donationKakaopay.style.display==&quot;none&quot;)&#123; donationKakaopay.style.display=&quot;block&quot;; &#125; else &#123; donationKakaopay.style.display=&quot;none&quot;; &#125;&#125;&lt;/script&gt; article.ejs 1234567 ...&lt;footer class=&quot;article-footer&quot;&gt; &lt;div class=&quot;donation-button&quot; style=&quot;text-align: center;&quot;&gt; &lt;%- partial(&#x27;ads/donation&#x27;) %&gt; &lt;/div&gt;&lt;/footer&gt; ...","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://youngjinmo.github.io/categories/Dev/Hexo/"}],"tags":[]},{"title":"암호화폐, 제대로 알고 투자하시는건가요?","slug":"do-you-know-crypto-currency","date":"2020-03-13T11:30:19.000Z","updated":"2020-09-13T01:53:29.028Z","comments":true,"path":"2020/03/do-you-know-crypto-currency/","link":"","permalink":"http://youngjinmo.github.io/2020/03/do-you-know-crypto-currency/","excerpt":"","text":"본 글은 2018년 1월, Ripple을 송금한 이후, 브런치에 작성한 글을 가져온 글이다. 얼마 전, 암호화폐 송수신을 경험했다. 친구로부터 토큰을 전송받는 일이었는데, 그 동안 매매는 몇 차례 해봤지만 정작 송금은 해보지 못했기에 궁금한마음에 해본 일이었다. 꽤 신기했고 재미있었다. 그리고 이 경험을 통해 든 암호화폐에 대한 개인적인 생각을 조금 정리해볼까 한다.(쓰다보니 길어졌다..) 친구의 거래소 지갑에서 내 거래소 지갑을 통해 토큰을 수신받았다. 송금수수료가 상당히 저렴했고, 은행보다 간편했다. 물론 암호화폐 월렛의 private key를 챙기는 일이 OTP나 공인인증서를 챙기는 일보다 어렵다는 사람에게는 해당되지 않을수도 있다. 불과 6개월 전까지만 하더라도 비트코인이 무엇인지도 몰랐던 지인들이 수십가지의 암호화폐를 섭렵하며, 너도나도 투자를 하고 있다. 그러나 정작 대부분은 본인들이 거래하는 토큰이 정확히 무엇인지, 그 암호화폐의 네트워크가 무엇이고, 왜 탄생하였고 무엇이 매력있는지에 대해 알고있지않다. 급상승하는 가격이 모든 것을 잠재우는 느낌이다.. 상식적으로는 이해할 수 없으나, 직접 암호화폐 매매도 하고, 송금도 해보는 과정에서 그들의 투기에 대해 어느정도 이해할 수 있게 되었다. 암호화폐를 거래소에서 매매하는 일은 암호화폐를 경험하는 일이 아니다. 이 것이 최근 대부분의 사람들의 암호화폐의 블록체인 네트워크에 집중하기보다 가격에 집중하는 이유라고 생각된다. 그들의 경험은 사고파는 매매 행위에 불과하기 때문에 그 본질적 가치보다는 가격상승 여부가 전부일 수 밖에 없다. 주식을 사고파는 행위만 해서는 그 주식회사가 어떤 사업을 하는지, 그 사업의 가치는 무엇인지 절대 알수 없는 것과 같다. 아마존 주식($AMZN)의 매력은,주식을 싸게 사서 비싸게 파는매매만으로는 알 수 없다.Amazon.com에 접속하거나아마존 오프라인 스토어에 가봐야한다. 현재 암호화폐를 거래하는 사람들은 어떤 사람들일까. 이 네트워크를 경험해본 사람들일까. 네트워크가 매력적이라서 토큰을 구입하는 것일까? 아마 대부분은 아닐거라고 생각한다. 네트워크 거래 처리속도가 얼마나 빠른지, 이 네트워크가 왜 존재해야 하는지, 기존 은행과의 관계는 어떻게 되는지, 기관들과의 제휴 소식이 어떤 의미를 갖는지에 대해서 알지도, 심지어 관심마저 없는듯하다. 그래서 오해할 수 있는 부분에 대해 조금 정리해보았다. 123본인은 암호화폐 전문가가 아니다.약 8개월 동안 책 몇권읽고, 관련 기사 조금 팔로우업한게 전부다 보니 부족할 수 있다.또 어떤 부분은 잘못된 부분이 있을 수 있는데, 그런 부분은 코멘트로 피드백 주시면 본문에 반영하고, 필자가 스터디하는데에도 도움이 될 것 같다. 가격 변동성(Variability)이 너무 커서 화폐로서 작동할 수 없다? 변동성(Variability)으로 인해 실제 화폐로 대체될 가능성이 없다는 이야기에 대해선 어느정도 안정적인 가격으로 형성된다면, 그러니까 변동성이 줄어들게 된다면, 그 땐 충분하지 않겠느냐고 되물어볼 수 있다. 그러나 가격이 언제 안정될지, 또 어느 가격대에서 안정이 될지는 누구도 알 수 없다. 어쩌면 이런 이유로 비트코인은 화폐(Currency)보다 자산(Asset)으로서 활용될지도 모른다. 실제로 미국은 비트코인 선물상품이 시카고상품거래소(CME)에 상장하면서 금융자산으로 분류하는듯 하다.(그러나 여전히 논란은 있다.) 은행 금리나 주식시장 등 다양한 경제 지표의 영향을 받아 가격이 변동하는 금은 직접적으로 거래하는 화폐보다는 자산으로 이용되고 있다. 그러나 본질적으로 현 상황에서는 이 질문이 옳은 질문인지 틀린 질문인지, 또 이 질문에 정답이 존재하긴 하는지조차 우린 알 수 없다. 변동성이 이렇게 크게 발생하는 원인(We are still don&#39;t know what this is)도 여기에 있으니까. 암호화폐의 실제 내재 가치는 없다?암호화폐가 실제 내재가치가 있냐없냐의 이슈는 현재 가격이 버블이냐 아니냐만큼 어려운 이슈인 것 같다. 그러나 이 질문에도 반문하자면, “그럼 우리가 현재 사용하고 있는 현금은 어떤 근거로 내재 가치가 있다고 하는가?” 라고 물을 수 있을 것 같다. 우리가 내재 가치가 있다고 생각하는 현금이야말로 사실은 현실에 존재하지 않는 현금일 수 있기 때문이다. 예를 들고자 2017년 여름 카카오뱅크의 사례를 언급하고자 한다. 카카오뱅크가 출범한지 1년도 안되어 컨소시엄으로부터 추가 자금조달을 받았다. 왜 그럴까? 예치금(input) 대비 대출액(output)이 예상범위를 초과했기 때문이라고 한다. 좀 더 자세히 알아보자. 위 링크 속 기사에 의하면, 2017년 8월 11일 기준, 초기자본금 3천억으로 출범한 카카오뱅크는 예적금을 통해 약 1조 2천억원을 유치하고, 대출액은 약 9천억원이라고 한다. 그런데 대출신청이 많아서 이를 위해 추가로 5천억원을 조달한 것이다. 정리하면, 카카오뱅크의 자본금은 초기자본금 3천억에 추가 자본금을 더해도 5천억인데, 대출액은 이를 1천억 초과하는 9천억원인 것이다. 어떻게 가능한걸까? 그렇다면 예적금자들의 돈은 어디갔을까? 카카오뱅크 자본금과 수신금을 합쳐 총 1조 5천억중 9천억을 대출해주었으니 이제 카카오뱅크에 남은 돈은 6천억 뿐이다. 그럼 카카오뱅크 예적금자들의 돈도 1조 2천억에서 6천억으로 절반으로 줄어든걸까? 아니다. 여전히 카카오뱅크 사용자들 통장엔 예,적금한 만큼 정상적으로 찍혀있고, 지금 당장 은행에가서 출금을 시도해도 전액 출금이 가능할 것이다. 사실 카카오뱅크는 실제 돈을 굴리는 것이 아닌 우리가 ‘돈’이라고 믿는 믿음을 부풀려 장사를 하고 있는 것이다. 은행을 이용하는 모든 사람은 은행에 돈을 예치하고도 예치금의 대부분을 은행에 계속 보관해둘뿐 전액을 인출하는 일은 거의 없다. 때문에 은행은 이 예치금을 그대로 보관하지 않고, 돈이 필요한 사람에게 이자를 받기로 계약하고 대출해주는 것이다. 그리고 사용자들은 그 예치금에 비례해서 그 이자의 일부를 공유받는 것이다. 일반적으로 은행은 수신금의 90%까지를 대출해줄 수 있다고 한다. 바꿔말하면 사용자들이 평균적으로 100만원을 은행에 입금하면, 실제 사용하는 금액은 10만원 내외라는 이야기이다. 은행은 이를 활용하여 사용하지 않는 90만원을 굴려서 돈을 버는 것이다. 이 것이 은행의 수익모델이자 금융이 일반인들에게 복잡하고 어려운 이유이다. 금융시장에서 내재 가치란 이용자들의 신뢰라고 생각한다. 우리가 가치있다고 믿으면, 가치가 존재하게 되는 것이다. 따라서 어떤 암호화폐의 토큰이 가치있다고 믿는 커뮤니티에서는 해당 토큰이 거래가 될 수 있을 것이다. 지금 암호화폐가 거래되는 시장 역시 그런 사람들이 모여모여 만들어진 것이다. 예를들어,구내식당이 있는 A라는 회사가 있다고 가정하자. A회사의 구내식당을 이용할 수 있는 식권을 지구 반대편의 B라는 회사에 가져다주면 그 식권은 그저 종이조각에 불과하다.그러나 A사 직원들 사이에선 식권을 가지고 거래가 가능할 것이다. A사 직원들은 이 식권이 점심으로 교환할 수 있다는 신뢰가 형성되어 있기 때문이다. 암호화폐가 모든 사람들에게 내재가치가 있는 상품으로 인식되려면 결국 가격이 아닌 기술적인 부분이 입증되어야 할 것이다. 블록체인의 탈중앙화(Decentralization) 방식은 안전하다?다시 이야기하지만 암호화폐의 블록체인 네트워크는 네트워크에 참여하는 모든 사람들이 거래장부를 나눠갖기 때문에 이런 시스템을 해킹하려면, 어느 한 사람의 거래장부를 훔치는 일이 아닌 네트워크 전부를 훔치고 암호화(hashed)처리된 거래장부를 전부 해독해야 가능하다. 사실상 불가능한 일이다. 따라서 블록체인 네트워크의 이러한 탈중앙화 방식은 거래에 보다 높은 신뢰도를 구축할 수 있고 당연히 해킹 등 외부위협에도 안전할 수 있다. 그러나 정작 대부분의 사람들은 거래소에 암호화폐를 보관하고 있기에 암호화폐 네트워크는 탈중앙화(Decentralization)일지언정, 다수의 이용자들의 암호화폐는 거래소에 중앙화(centralization) 관리되고 있다고 볼 수 있다. 이렇게 되면 암호화폐의 블록체인 네트워크는 안전할지언정 거래소의 보안은 독립적인 요소이기에 거래소의 보안에 따라 사용자들의 암호화폐의 보안도 결정된다고 볼 수 있다. 한창 비트코인 열풍이 뜨겁던 2017년 말, 국내 거래소 한 곳이 해킹으로 인해 암호화폐 자산을 잃고, 파산한 이유도 암호화폐의 네트워크가 안전하지 못해서 발생한 일이 아닌, 대리 보관중인 거래소의 보안에 문제가 생겨 발생한 일이다. 비트코인은 물론 이하 알트코인 가치도 폭등하며, 전체 암호화폐의 시가총액은 지난 한 달간 큰 폭으로 상승하였다. 곧 세상에서 가장 비싼 기업인 애플의 시가총액마저 따라잡을 기세다. 그러나 거래량에 비해 실제 이 네트워크를 경험하는 사람의 비율은 얼마나 되는지 궁금해진다. 3년전 비트코인이 전 세계 개발자 및 일부 트렌드에 밝은 사람들에게 주목받았다면, 이번 폭등으로 이제 개발자가 아니더라도 누구나 비트코인에 대해 알 수 있을만큼 대중성을 얻었다고 생각한다. 그러나 가격상승에 시선을 뺏겨 이에 대한 기술적 검증은 또 다시 몇년이 걸릴지 알 수 없다. 현재 비트코인을 포함한 모든 암호화폐는 아직 시장에 출시하지 않은 베타 제품과 같다고 생각한다. 따라서 현재 상황에서 평가하기보다는 이 기술이 어디에 어떻게 적용될 수 있는지, 미래의 가능성에 대해 생각해볼 필요가 있다. 벌써 수백가지의 암호화폐가 시장에서 거래되고 있다는데, 이들중 상당수는 결국 선택받지 못하고 사라질 수 있고, 또 일부는 기술적 검증에 실패하여 많은 투자자를 실망시킬 수 있다. 가격 상승을 예측하는 무모한 일 대신 현재 시점에서 암호화폐를 활용해볼 수 있는 상황을 찾아보고 직접 경험해보는 일이 필요할 것 같다. 가격상승이라는 환상에 젖어 기술적 검증이 뒤로 밀리는 일은 안타깝기만하다. 2020년 03월 14일. 미국에 있는 친구와 처음으로 Ripple(리플)이라는 블록체인 토큰을 송금한 이후, 느낀걸 작성한 글이다. 다만 토큰을 송금하는 경험에 대한 상세한 리뷰를 작성하지 않은건 조금 아쉽다. 미국으로 한국에서 외화송금을 하면 최대 일주일 이상이 소요되기도 했는데, 리플 송금은 무려 30-40분만에 송금이 완료되었다. 또한 송금을 보낼때 발생하는 해시주소를 통해 마치 택배 송장주소를 통해 내 택배가 어디쯤 도착했는지 보는것만큼 간편하게 확인할 수 있었다.송금속도도 빨랐고, 내가 보낸 토큰이 어떻게 처리되고 있는지를 볼 수 있는점이 흥미로웠다. 리플의 전송과정은 다음과 같다. 내가 보유하고 있는 거래소 A의 지갑에서 친구가 보유하는 해외 거래소 B의 지갑에 보내는 일이었다. 그럼 거래소 A가 보유하고 있는 리플 월렛에서 내가 출금 신청한 만큼의 리플이 친구로부터 받은 지갑 주소로 전송을 시작한다. 리플 네트워크 안에서의 트랜잭션 속도는 30분이 채 되지 않았다. 그러나 문제는 여기서부터 발생한다. 리플 네트워크에서 트랜잭션이 끝나도 실질적으로 친구가 리플을 받은건 아니다. 친구가 사용하려면 거래소 지갑으로 송금이 완료되서 입금이 되어야 하는데, 거래소 네트워크 안에서 처리하는 속도가 느리다보니 리플 네트워크에서 트랜잭션이 마쳤다는 이메일을 받고도 1시간이 지나서 친구의 계좌로 송금되기도 했다. 이런 경험을 하고나니 주변 사람들을 포함하여 우리가 거래하는 방식은 블록체인이 지향하는 탈중앙화 방식이 아니라는걸 깨닫게 되었다. 그래서 이에 대한 위험성이나 블록체인에 대해 조금 더 알릴 수 있는 글을 쓰고 싶다는 생각이 되어 당시 이 글을 작성하게 됬었다. 이 글을 쓴지 2년이 지났고, 엄청난 태풍이었던 저 당시랑은 180도로 분위기가 달라져서 지금은 대부분의 블록체인 서비스들이 자취를 감추거나 사업을 축소하고 있다. 그럼에도 난 여전히 블록체인 서비스가 필요하다고 생각하고, 언젠간 사용자에게 필요한 기능, 서비스를 제공하는 DApp(Decentralized Application)이 등장할거라고 믿고 있다. 국내에서 테라가 그 역할을 잘 수행하고 있다고 생각되는데, 금융/결제 영역을 벗어난 다른 영역에서도 혁신적인 블록체인 서비스를 만나기를 기대한다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Review","slug":"Life/Review","permalink":"http://youngjinmo.github.io/categories/Life/Review/"}],"tags":[{"name":"blockchain","slug":"blockchain","permalink":"http://youngjinmo.github.io/tags/blockchain/"}]},{"title":"구글 딥마인드 AlphaGo와 이세돌 9단 대국 리뷰(주관적)","slug":"2016-alphago","date":"2020-03-11T10:48:25.000Z","updated":"2020-09-13T01:53:29.880Z","comments":true,"path":"2020/03/2016-alphago/","link":"","permalink":"http://youngjinmo.github.io/2020/03/2016-alphago/","excerpt":"","text":"이 글은 2016년 5월 11일, 알파고와 이세돌의 대국을 2국까지 마치고 나서 Medium에 작성한 글을 가져온 글이다. 15년~16정도 된 것같다. 바둑 대국을 관전한 것이. 중간에 기원에서 아마추어 바둑을 관전한 적은 몇 번 있지만, 프로 대국은 정말 오랜만에 관전하게 되었다. 인간계 최강이라 불리우는 이세돌 9단과 구글 딥마인드팀이 개발한 딥러닝 프로그램, AlphaGo와의 대국이었다. 이 대결은 현존하는 인공지능의 기술이 인간에 대항해 어디까지 진화해왔는지 볼 수 있는 흥미로우면서도 역사적인 매치업으로 전세계인의 주목을 받고있다. 어릴적 2년간을 바둑에 미치다싶을정도로 몰입을 했었으며, 현재는 인공지능(이하 AI)에 관심이 생기게된 나도 이 경기를 한 달 전부터 기다리며, 오랜만에 프로 바둑 대국을 관전하게 되었다. 대국이 시작하기 전까지 수 많은 언론매체에서 프로바둑인들과 IT업계인들의 서로 다른 예상을 보도하였다. 과거엔 바둑을, 지금은 IT기술에 관심이 많은 나는 두 분야에 대해 비슷한 수준으로 이해하고 있다보니 감히 누가 이길 것 같다고 예상하기 힘들었다. 우선 주위에 계신 IT업계 분들의 의견과는 달리 AlphaGo가 이세돌 9단을 쉽게 이기지 못할거라고 예상한 배경에는 바둑이라는 게임의 룰에 있었다. 이번 대결을 앞두고 이세돌 9단은 제한시간 2시간, 초읽기 1분 3회로 구글과 계약했다고 밝혔다. 이는 다시 말해 총 2시간 3분을 대국에 사용할 수 있다는 이야기이다. 물론 초읽기 시간마저 다 쓴다면 시간패가 선언된다.(그래서 초읽기에서 성급한 판단으로 실수가 나는 경우가 잦다고 한다.) 워낙 오래전 기억이지만, 내 기억에 바둑의 승패를 알 수 있는 정도는 보통 200수를 넘어가면서 부터였다. 대략 200수에서 대국이 종료된다고 가정하면*(이세돌9단과 AlphaGo의 제 1대국도 200수정도에서 마무리되었다.)*, 각 플레이어당 착수하는 수는 100수로 예상 할 수 있다. 이를 제한시간으로 나누면 돌 하나를 착수하는 데에 평균적으로 72초를 사용해야한다는 계산이 나온다. 그렇다면 한 수를 두는데는 대체 얼마나 많은 경우의 수를 생각해야할까. 바둑판의 규격은 19x19므로 단순 계산하면 초수를 두는데에 고려해야 할 경우의수는 361가지이다. 그런데 바둑을 둘 때엔, 내가 어디에 돌을 놓을지만 판단하고 두지 않는다. 내가 어디에 착수하면, 상대가 어떻게 대응할 것이며, 그 이후의 전개까지도 고려해야 한다. 이를 수읽기라고 한다.아마추어인 나의 경우는 기껏해야 5수 정도를 내다봤지만, 프로바둑기사는 10수~20수까지도 내다본다고 한다. 이번 매치업은 프로 바둑 대국이었으므로 프로수준으로 계산하면, AlphaGo와 이세돌 9단도 최소 10수를 수읽기 할 것으로 예상했다. 그럼 한 수를 착수하기까지 10수를 수읽기하므로, 이를 바둑판에서의 경우의 수로 다시 계산해보면 361x360x359x358… 너무 길다.. 쉽게 풀어보자.. 대략적으로 한 수를 두는 데 경우의 수를 3x10²로 가정하면, 수읽기(10수)까지 고려한 착수에 대한 경우의 수는 3¹⁰x10²⁰으로 예상 할 수 있다. 종합해보면, 어떻게 읽어야 할 지도 모르는 이 방대한 양의 수*(3¹⁰x10²⁰)*를 단 72초만에 연산해야 겨우 한 수를 둘 수 있다는 계산이다. 여기까지만 읽으면, ‘연산속도’가 인간보다 압도적으로 빠른 컴퓨터, 즉 AlphaGo가 이세돌 9단을 쉽게 이길 수 있을 것으로 생각할 수 있다. 그러나 뒤집어보면, 컴퓨터는 그 존재가 탄생한 이래로 단 한 순간도 인간보다 연산속도가 느렸던 적이 없다.(당연하게도 그러도록 개발했으니까..) 그렇다면 왜 기존의 AI 바둑은 프로 바둑기사를 넘어 설 수 없었을까. AI는 커녕 컴퓨터에 대해 잘 모르는 내가 감히 예상해보자면, 한 수를 착수하는데 필요한 72초의 시간동안 컴퓨터의 연산속도가 인간만이 보유한 ‘직관’을 뛰어넘지 못했기 때문으로 예상한다. 예를 들어 컴퓨터가 1부터 100까지의 모든 경우의 수를 빠르게 계산한다면, 인간은 1부터 100까지 모든 경우를 계산하지 않는다. 본인이 직접 경험하고, 학습하며 생성된 ‘직관’이라는 능력을 통해 100가지 경우의 수 중 몇가지만 끄집어내서 계산하고 판단한다. 모든 경우의 수를 꼼꼼히 계산하지 않았음에도 인간의 이런 직관은 놀라운 성공률을 보여왔다.(대표적인 분야가 ‘바둑’이라고 생각하며, 이때문에 구글 딥마인드가 AlphaGo의 인간에 대항한 첫 번째 종목으로 바둑을 선택한 것 같다.) 지금까지 컴퓨터는 없고, 인간만이 보유한 이 ‘직관’은 인간조차 설명할 수 없는 놀라운 능력이었다. 그저 천억개가 넘는 뉴런이 보여주는 놀라운 퍼포먼스를 우리는 이유도 모른채 감사하게 사용할 뿐이다.(참고로 현존하는 슈퍼컴퓨터는 약 백만개의 뉴런정보를 파악하고 동작할 수 있다고 한다. 하지만 이마저도 아직 완벽한 수준은 아니라고..) 그래서 단순히 연산속도를 빠르게 하는 것만으로는 지금까지 AI가 바둑판에서 인간을 넘어설 수 없었던 것이다. 그러나 구글 딥마인드 팀이 개발한 AlphaGo는 지금까지의 AI와는 달랐다. 딥러딩(Deep Learning)을 통해 인간만이 보유한 ‘직관’이라는 능력에 도전장을 던진 것이다.(딥러닝은 빅데이터에서 발전한 기술로써, 컴퓨터 프로그램이 사람처럼 스스로 학습하는 것을 의미한다.. 정확한 설명은 위의 링크 참조) 바둑대국 이후 인간과의 두번째 매치업으로 구글 딥마인드팀이 선정한 종목은 ‘스타 크래프트’이다. 스타 크래프트 역시 엄청난 경우의 수와 전략이 필요하다는 특성을 생각하면, 이 역시 ‘직관’을 활용하는 게임이라고 생각한다. 결국 구글 딥마인드가 보여주고 싶은 것은 자사가 개발한 AI가 이 만큼 빠른 연산속도를 지녔다는 것이 아닌, 인간만이 보유한 직관을 흉내내는, 혹은 그 이상을 실행하는 진정한 AI를 개발하고 있음을 홍보/테스트하고 싶음을 예상할 수 있다. 이 때문에 난 이번 구글 딥마인드 이벤트가 승패따위의 결과에 상관없이 인류 역사에 중요한 Memorable day가 될 것 같다. 인간이 개발한 인공지능이 드디어 인간만큼의 퍼포먼스를 보여준다는 것을 우리 눈으로 확인한 역사적인 순간이라고 평가한다. 추가로 경기에 대해서 조금 더 떠들어 보자면..이세돌 9단과의 경기 이후, AlphaGo의 몇 수에 대해 ‘실수인가’, ‘의도된 실수인가’ 혹은 ‘상대의 실수를 유발한 고도의 한 수인가’ 하는 말이 많다. 당시 경기를 프로기사 해설과 함께 시청하며 AlphaGo의 수를 이해하려 하고*(물론 실패..)*, 생각해봤는데 우선 컴퓨터가 인간과는 다르게 정확한 근거에 실행한다는 점을 고려하면, 그것이 어떤 수이든 실수는 아니었을 것으로 생각한다. 그러나 감정이 주입된 인격체가 아니므로 상대의 실수를 유발하려고 하는 심리전은 펼치지 못했을 것으로 생각한다. 그렇다면 생각해볼 수 있는 것은..Alphago의 바둑능력이 인간의 그것을 초월한 것으로 생각한다. 제 2대국이 종료되고 나서는 몇몇 언론에서 패인도 모른채, 이세돌9단이 불계패하였다는 기사를 보도하였다. 실제로 프로바둑기사가 해설하는 방송에서도 AlphaGo의 묘수에 대해 뚜렷히 정의하지 못하고 있었다.(참고로 사람간의 바둑대국이 종료되면,승자와 패자가 함께 복기하기 때문에 해석 못할 수는 존재하지 않았다.) (추가) 알파고가 이런 플레이를 할 수 있었던건 인간은 가지고 있지만, 컴퓨터는 가지지않은 ‘고정관념’이라는 특성도 한 몫하지 않았을까 생각한다. 어쩌면 그래서 복기를해도 AlphaGo의 묘수를 이해하지 못하는 것일지도.. 내가 어렸을 때 바둑학원에서 선생님께 가장 많이 들은 말씀이 있다.바둑에서는 모양이 중요하다는 말씀이다. 바둑이란, 결국 땅따먹기 싸움이기 때문에 소규모 전투에서부터 전체 형국을 아우르는 바둑알들의 모양이 분위기와 승패에 영향을 미친다고 배웠다. 바둑을 모르시는 분들은 어떻게 하면 ‘신의 한 수’를 두는건지 궁금해 하시기도 하지만, ‘신의 한 수’란 대국이 종료된 후, 복기하는 과정에서 평가하는 수이지, 대국중에 ‘신의 한 수’로 평가할만한 수를 둘 수는 없다. 인간은 전체결과를 예측하고 두지 못하기 때문에 적어도 인간에게는 대국중에 ‘신의 한 수’를 둘 만한 능력이 없다. 그렇기 때문에 ‘모양’으로 결과를 만들어나가고자 하는 것이라고 생각한다. 그런데 AlphaGo가 보여주는 바둑은 이와 정면으로 대치하는듯 보인다.모양이 아닌 오직 ‘정확한 결과’에만 초점을 맞추어 철저히 계산하고, 착수를 하는듯 하였다.(제 2대국에서 초반 30수까지 보여준 플레이는 결과적으로 인간이 두는 포석과 같았지만, 그 순서(과정)가 인간과 달랐다고 한다.) 앞서 나는 한 돌을 착수하는데 있어 3¹⁰x10²⁰의 경우의 수가 만들어진다고 했다. 그러나 인간은 이 경우의 수를 모두 따지지 않는다고도 했다. 그래서 ‘직관’이라는 능력을 믿고, 추상적인 결과를 그려가며 대국을 진행한다.반면 프로기사들의 의견에 따르면, AlphaGo는 인간처럼 10~20수를 수읽기하는 것에서 그치지 않고, 전체 결과를 예측하고 한 수, 한 수를 둔 것같다고 분석하였다.(과거형으로 쓴 이유는 경기중에는 어떤 기사들도 이런 의견을 내놓지 못했기 때문이다. 모두 경기 이후 분석에서 쏟아져 나온 의견이다.) 인간이 지금까지 해왔던 바둑과 전혀 다른 스타일의 바둑을 보여주는 AlphaGo는 당장 바둑 역사를 획기적으로 바꿀 존재가 된 것은 분명해보인다.(대회 종료 이후, 세계 유수의 바둑연구가들이 Alphago를 중심으로 새로운 바둑연구를 많이 진행하지않을까…) 오늘날의 이런 결과에 AI에 대한 공포심을 가질 필요는 없다고 생각한다. AI를 개발하는 주체가 인간이며, AI는 인간이 입력한 목적대로 실행 할 뿐이다. 이세돌9단이 2연속 불계패하자 SNS에서는 영화 터미네이터에 나왔던 ‘스카이넷‘이 언급되고 있지만, 아직 이를 걱정하거나 논하기에는 너무 이를뿐더러 AlphaGo가 보여준 능력과는 다른 차원이라고 생각한다. AI가 스스로 인간의 통제에서 벗어나기 위해서는*(인간이 입력하지 않은 다른 차원의 행동)* 지금 수준의 딥러닝정도가 아니라 ‘감정’ 이 필요할 것으로 생각된다.AI에게 감정을 입히는 것이 가능한건지, 만약 가능하다면 언제쯤 현실이 될지 궁금하다. 또한 그 존재가 인류에게도 도움이 되는 존재가 될지 역시도 궁금하다.. 이제 2국까지 종료하였고, 앞으로 3국이 남았다. 앞으로의 대국 관점 포인트는 무엇이 될까. 이세돌 9단도 이 같은 사실을 완전히 모르지는 않을 것이다. 그는 인류를 대표하여 AI에 싸우고 있는 것이 아닌, 인류를 대표하여 AI를 바둑이라는 게임으로 테스트중이라고 생각한다. 그 역시 구글 딥마인드 팀만큼 AlphaGo의 능력이 궁금할 것이며, 이기기위해 이 이벤트에 참가하지는 않았을 것 같다. 승패보다는 AlphaGo가 보여주는 퍼포먼스를 더 중요하게 볼 필요가 있지 않을까. 이세돌 9단의 인터뷰를 들어보면, ‘5:0 승리가 아니면 의미없다.’ 라는 인터뷰를 들을 수 있는데, 이는 결코 이세돌 9단의 오만한 생각이 아니라고 생각한다. AI와 바둑, 그리고 이 대국이 갖는 의미를 이해한다면, 충분히 공감할 인터뷰라고 생각한다.남은 대국에서도 이세돌 9단과 AlphaGo가 흥미로운 대국을 보여주길 기대한다. 2020년 03월 11일. 4년 전의 내가 쓴 글이다. 그땐 개발을 하게 될지도 몰랐는데, 새삼 신기하다. 또 한편으론 중간중간 민망한 글 또는 표현때문에 글을 닫고 싶었다. 그래도 일부러 수정하기 보다 현재의 블로그에 박제를 하기로 했다. 이 글을 썼던 이유는 중간에서 언급했듯 두고두고 기억할만한 이벤트 직후의 내 생각을 글로 남기고 싶었기 때문이다. 다시 읽으면서 민망하긴 했지만 그래도 ‘이런 이벤트 때에 내가 이런 생각을 했었구나’ 라고 회고할 수 있어서 좋았다. 앞으로도 이런 일이 생기면 글을 공개적으로 남겨야겠다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Review","slug":"Life/Review","permalink":"http://youngjinmo.github.io/categories/Life/Review/"}],"tags":[{"name":"alphago","slug":"alphago","permalink":"http://youngjinmo.github.io/tags/alphago/"},{"name":"leesedol","slug":"leesedol","permalink":"http://youngjinmo.github.io/tags/leesedol/"},{"name":"go","slug":"go","permalink":"http://youngjinmo.github.io/tags/go/"},{"name":"ai","slug":"ai","permalink":"http://youngjinmo.github.io/tags/ai/"}]},{"title":"SpringBoot에서 H2 데이터베이스 사용하기","slug":"h2-database","date":"2020-03-11T04:43:53.000Z","updated":"2020-09-13T01:53:28.840Z","comments":true,"path":"2020/03/h2-database/","link":"","permalink":"http://youngjinmo.github.io/2020/03/h2-database/","excerpt":"","text":"h2데이터 베이스란 컴퓨터에 내장된 램(RAM)메모리에 의존하는 데이터베이스를 말한다. 램에 의존하기 때문에 테스트 또는 지금의 나처럼 실습을 위해서는 간편하고 빠르기 때문에 좋은 옵션이 될 수 있다. 다만, 램에 데이터를 저장하다보니 웹서버를 재부팅하면 기존의 데이터가 사라진다는 단점이 있다. 따라서 이 때엔 테스트에 필요한 데이터를 미리 sql로 작성해두고 웹서버 재부팅시마다 데이터를 인위적으로 주입하여 테스트 해볼 수 있다. 스프링부트 프로젝트에서 h2 데이터 베이스를 사용하는 방법은 다음과 같다. 의존성 설정Maven 12345678910111213&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.200&lt;/version&gt;&lt;/dependency&gt; Gradle 12// https://mvnrepository.com/artifact/com.h2database/h2testCompile group: &#x27;com.h2database&#x27;, name: &#x27;h2&#x27;, version: &#x27;1.4.200&#x27; application.yml 설정12345678spring.h2.console.enabled=truespring.h2.console.path=/h2-consolespring.datasource.url=jdbc:h2:mem:devandy;spring.datasource.driverClassName=org.h2.Driverspring.datasource.username=saspring.datasource.password=spring.jpa.database-platform=org.hibernate.dialect.H2Dialect 이제 데이터베이스가 사용가능하며, localhost:8080/h2-console 에서 대시보드를 이용할 수도 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Springboot","slug":"Dev/Springboot","permalink":"http://youngjinmo.github.io/categories/Dev/Springboot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://youngjinmo.github.io/tags/springboot/"},{"name":"databse","slug":"databse","permalink":"http://youngjinmo.github.io/tags/databse/"}]},{"title":"GetMapping 어노테이션으로 다중맵핑하기","slug":"get-mapping-annotation","date":"2020-03-10T13:24:21.000Z","updated":"2020-12-02T10:12:14.079Z","comments":true,"path":"2020/03/get-mapping-annotation/","link":"","permalink":"http://youngjinmo.github.io/2020/03/get-mapping-annotation/","excerpt":"","text":"@GetMapping 어노테이션은 HTTP GET 요청을 처리하는 메서드를 맵핑(@RequestMapping) 하는 어노테이션이다. 메서드(url)에 따라 어떤 페이지를 보여줄지 결정하는 역할을 한다. 참고로 스프링부트에서는 어떤 HTTP 메서드를 사용할지에 따라 RequestMapping 어노테이션을 아래의 어노테이션으로 구분해서 제공한다. RequestMapping 어노테이션으로 사용가능하지만, 목적에 따라 아래 어노테이션으로 대체사용이 가능하다는 이야기이다. @GetMapping : GET 요청을 하는 API의 어노테이션. 데이터를 가져올 때 사용한다. @PostMapping : POST 요청을 하는 API의 어노테이션 데이터를 게시할 때 사용한다. @PutMapping : PUT 요청을 하는 API의 어노테이션 데이터를 수정할 때 사용한다. @DeleteMapping : DELETE 요청을 하는 API의 어노테이션 데이터를 삭제할 때 사용한다. @PatchMapping : PATCH 요청을 하는 API의 어노테이션 데이터를 수정할 때 사용한다. PUT과 PATCH가 데이터를 수정한다는 측면에서는 비슷하나, PUT이 데이터 전체를 갱신하는 HTTP 메서드라면, PATCH는 수정하는 영역만 갱신하는 HTTP 메서드이다. 12345678910import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GepMapping;@Controllerpublic class homeController &#123; @GetMapping(&quot;/main&quot;) public String index()&#123; return &quot;index&quot;; &#125;&#125; 지금까지는 위의 코드처럼 @GetMapping 어노테이션으로 하나의 메서드만 처리했는데, 다중맵핑이 가능하다는 사실을 처음 알았다. 파라미터안에 value = &#123; , &#125; 형식으로 작성하면 다중맵핑이 가능했다. 웹 애플리케이션의 메인 페이지로 이동하는 3개의 키워드를 모두 index.html로 넘기고 싶어서 작성한 코드이다. 12345678910import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping;@Controllerpublic class homeController &#123; @GetMapping(value = &#123;&quot;/&quot;, &quot;/index&quot;, &quot;/main&quot;&#125;) public String index()&#123; return &quot;index&quot;; &#125;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Springboot","slug":"Dev/Springboot","permalink":"http://youngjinmo.github.io/categories/Dev/Springboot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"},{"name":"http","slug":"http","permalink":"http://youngjinmo.github.io/tags/http/"}]},{"title":"본문 읽는 시간 보여주기","slug":"hexo-reading-time","date":"2020-03-06T06:36:17.000Z","updated":"2020-09-13T01:53:28.788Z","comments":true,"path":"2020/03/hexo-reading-time/","link":"","permalink":"http://youngjinmo.github.io/2020/03/hexo-reading-time/","excerpt":"","text":"Medium을 이용하다보면, 해당 아티클을 읽는데 몇 분이 소요되는지 알려주는 아이콘이 있는데, 이걸 내 블로그에도 적용시켜보고 싶었다. 그러다 우연히 Eric Han님의 블로그에서 방법을 찾게되어 허락을 구하고 공유하게 되었다. 순서는 아래와 같다. 플러그인 설치 _config.yml 설정 코드 작성 플러그인 설치1$ npm install hexo-symbols-count-time --save 블로그 메인 디렉토리에 있는 _config.yml 설정12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true article.ejs에 코드 작성아티클 내 메타 데이터 아래에 아래 코드를 작성한다. date와 tag를 불러오는 코드 아래에 작성하는게 좋다. 1&lt;span class&#x3D;&quot;reading-time&quot;&gt;⏱ &lt;%- symbolsTime(post.content, 4, 300, &#39;분&#39;) %&gt;&lt;&#x2F;span&gt; 여기서 symbolsTime()안에 들어가는 파라미터들은 다음과 같다. post.content : 현재 포스트 4 : 평균단어길이 (AWL, Average Word Length) 300 : 분당 읽는 단어 (WPM, Word Per Minutes) &#39;분&#39; : 시간 단위명 단어길이를 바꿀 수도 있고, WPM(분당 읽는 단어)을 바꿀 수도 있다. 이렇게 해서 각자 읽는 속도 계산을 변경할 수 있다. 출처 : Hexo 글자 수와 리딩 타임 추가하기","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://youngjinmo.github.io/categories/Dev/Hexo/"}],"tags":[]},{"title":"맥에서 파이어폭스를 완전히 삭제하는 법.","slug":"how-to-completely-remove-firefox","date":"2020-03-04T09:00:48.000Z","updated":"2020-09-13T01:53:28.740Z","comments":true,"path":"2020/03/how-to-completely-remove-firefox/","link":"","permalink":"http://youngjinmo.github.io/2020/03/how-to-completely-remove-firefox/","excerpt":"","text":"기사를 읽다가 파이어폭스에서 Brave브라우저로 갈아타야겠다는 생각을 하게되었다. 지난해부터 보안이 가장 강력한 브라우저로 Brave로 알고는 있었지만, 대신 크롬/파이어폭스 대비 편의성이 떨어진다고 생각했었는데 막상 설치해서 이것저것 만져보니 별로 불편하지 않았다. 특히 Brave는 크롬 익스텐션을 지원하기 때문에 기존에 파이어폭스에서 사용하던 익스텐션을 가져다 올 수 있었다. (파이어폭스는 크롬과 다른 익스텐션 스토어를 운영하지만, 파이어폭스 익스텐션은 대부분 크롬 익스텐션으로도 존재한다.) 아무튼 새로운 브라우저를 사용하게 되었으므로 이제 파이어폭스를 완전히 삭제해야 하는 일이 남았다. 파이어폭스가 브라우저를 재설치해도 식별자정보를 그대로 가져다온다고 하는데 그렇다는 이야기는 컴퓨터에 리소스를 남기기 때문에 가능할 거라고 생각했다. 이것까지 완벽하게 삭제해야 새로운 브라우저로 이주가 끝나는 것이다. 우선 터미널을 열고 Firefox 앱부터 삭제한다. 1sudo rm -rf Application&#x2F;Firefox.app 다음은 Library에 있는 파일들을 삭제할 것이다.(들어간 김에 안쓰는 앱이나 프로그램의 파일들이 남아있다면 이것들도 다 삭제하다.) 123sudo rm -rf &#x2F;Users&#x2F;User&#x2F;Library&#x2F;Application Support&#x2F;Firefox&#x2F;sudo rm -rf &#x2F;Users&#x2F;User&#x2F;Library&#x2F;Caches&#x2F;Firefoxsudo rm -rf &#x2F;Users&#x2F;User&#x2F;Library&#x2F;Preferences&#x2F;org.mozilla.firefox.plist Preferences에는 이것말고도 다른 파일들이 남아있을 수 있는데 Firefox 또는 Mozila의 파일이나 디렉토리가 있다면 이것도 남김없이 삭제하자. 그리고 아래의 파일들도 삭제하자. 12sudo rm -rf &#x2F;Users&#x2F;admin&#x2F;Library&#x2F;Preferences&#x2F;org.mozilla.firefox.plistsudo rm -rf &#x2F;Users.bill&#x2F;Library&#x2F;Preferences&#x2F;org.mozilla.firefox.plist 자 이제 완전히 끝났다! 이제 Brave 브라우저를 써보고 나중에 또 후기를 남겨보겠다 :)","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Review","slug":"Life/Review","permalink":"http://youngjinmo.github.io/categories/Life/Review/"}],"tags":[{"name":"security","slug":"security","permalink":"http://youngjinmo.github.io/tags/security/"}]},{"title":"시간에 따라 광고배너 다르게 노출하기","slug":"hexo-conditional-ads","date":"2020-03-03T11:25:27.000Z","updated":"2020-09-13T01:53:28.816Z","comments":true,"path":"2020/03/hexo-conditional-ads/","link":"","permalink":"http://youngjinmo.github.io/2020/03/hexo-conditional-ads/","excerpt":"","text":"광고배너를 삽입(포스트: hexo블로그에 쿠팡광고 적용하기)해보면서 Hexo 프레임워크에 대해 훨씬 더 이해를 하게되었다. ejs 파일 형식에 대해 잘 모르지만, ejs 파일들을 보니 자바스크립트 코드로 구성되어 있었다. 짧게 구글링해보니 ejs는 Embedded JavaScript의 약자로 자바스크립트가 내장된 템플릿엔진이라는 설명을 보았다. 그래서 &lt;% %&gt; 안에 자바스크립트를 넣어서 사용할 수 있었다. 음 자바스크립트를 적용할 수 있다면 광고배너도 여러가지를 넣어두고 조건에 따라 배너를 노출시킬 수 있지않을까? 라는 생각이 들었다. (자본주의 러버) 현재 블로그엔 광고 배너 3개를 노출하고 있다. 두개는 사이드바에, 하나는 아티클 안에서 노출하고 있는데, 시험삼아 사이드 상단에 노출되는 광고를 시간에 따라 다르게 출력해보려고 한다. 퇴근시간 전에는 책과 사무용품을 보여주는 광고를 출력하고, 퇴근시간 이후에는 뽐뿌를 부르는 애플제품을 노출하기로 했다. 사이드바 상단의 광고는 layout/common/sidebar.ejs에 작성하면 된다. 각 영역별 코드는 이렇게 된다. 따라서 이 사이(빨간색으로 마크한 영역)에 광고코드를 작성하면 된다. 자바스크립트에서는 Date() 함수를 통해 현재 시간을 가져올 수 있다. Date() 함수엔 시각(시간/분), 요일 등을 가져올 수 있는 함수를 내장하고 있는데, 시간을 가져올것이므로 여기서는 getHours를 사용하면 현재 시간을 가져올 수 있다. localhost에서 테스트해보니 원하는대로 광고가 출력됨을 확인할 수 있었다. 지난해에 hexo 블로그를 시작하면 처음에 번거로웠던 기억이 나는데, 노출이 쉽지않다는점을 제외하면 혼자 독학하며 운영하기엔 괜찮은 블로그 툴이라고 생각한다. 언젠가 비개발자들도 따라할 수 있는 hexo 프레임워크 강좌를 유튜브에 올려볼까 한다..^^ (언젠가…)","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://youngjinmo.github.io/categories/Dev/Hexo/"}],"tags":[]},{"title":"Hexo 블로그에 쿠팡광고 적용하기","slug":"hexo-coupangads","date":"2020-03-02T09:36:17.000Z","updated":"2020-09-13T01:53:28.812Z","comments":true,"path":"2020/03/hexo-coupangads/","link":"","permalink":"http://youngjinmo.github.io/2020/03/hexo-coupangads/","excerpt":"","text":"구글 애드센스를 일주일정도 적용해보았는데 클릭당 $ 0.1 이 수익으로 발생하는 것 같았다. 이 정도로는 지나치게 작은 수익을 위해 블로그의 분위기를 해치는(?) 광고를 삽입하는 것 같아서 다른 광고를 찾아보았다. 그래서 찾은게 쿠팡 파트너스이다. 쿠팡 파트너스는 구글 애드센스와 달리 클릭만으로는 수익을 지급하는 것과 달리 광고배너를 통해 접속한 유저가 실제로 구입하면 구매금액의 3% 정도가 지급된다고 한다. 애드센스 광고를 클릭하는것보다 차라리 쿠팡 광고를 통해 제품 하나 팔리는게 훨씬 이익이라고 생각했다. 또한 일정금액($100)을 초과해야 수익을 출금할 수 있는 애드센스와 달리 쿠팡은 캐시를 지급받아서 바로 쿠팡 쇼핑시에 사용할 수 있다는 장점이 있다. 100원만 수익을 내더라도 당장 다음 쇼핑때 사용할 수 있다는 이야기다. 쿠팡 파트너스 가입/승인받기 광고 배너 생성하기 hexo에 적용하기 위한 ejs 파일 생성하기 원하는 위치에 배너 적용하기 쿠팡 파트너스 가입/승인받기쿠팡 계정이 있어도 파트너스 가입은 따로 필요하다. 양식대로 기입을 하고, 승인을 기다려야 한다. 쿠팡 광고를 개재할 수 있는 블로그인지 여부를 파악하는 과정이다. 혹시나 불법적인 웹사이트에서 쿠팡 광고가 악용될경우 자사의 평판을 해칠 수 있기 때문에 하는 일련의 과정이라고 생각한다. 하루 이틀정도면 승인이 되었던 것 같다. 쿠팡 파트너스 가입시 추천인코드를 입력하면 첫 30일동안 1%의 수수료를 더 지급한다고하니 추천인코드를 입력하시길 바란다. 추천인코드 : AF1391980 광고 배너 생성하기 [링크 생성하기] - [다이내믹 배너]**로 접속한다. **[배너생성] 버튼을 클릭한다. 그럼 이런 화면을 볼 수 있다. 이제 여기서부터 광고를 직접 만들수 있다. 필자의 블로그는 개발자들이 접속할 것이므로 생활용품 광고를 보여주기보다는 개발자들의 눈길을 끌만한 제품이 필요하다고 생각했다. 지난해 말 아이폰이 역대급 판매를 기록했으므로 아이폰에 필요한 악세서리들을 노출하는 광고배너를 만들어보자. 배너타입에서 **[상품 직접 선택]**을 선택하면 배너에 노출시킬 제품을 직접 선택할 수 있다. 최대 20개까지 상품을 선택할 수 있으므로 카테고리에 맞는 제품을 채우고 [배너 만들기] 버튼을 클릭하면 블로그나 웹사이트에 심을 수 있는 코드가 생성된다. 생성된 코드를 복사해두자. hexo에 적용하기 위한 ejs 파일 생성하기이제 hexo 소스코드가 저장된 저장소로 가자. /themes/사용자테마/layout 으로 이동하여 광고 소스코드만 저장할 폴더를 생성한다. 앞으로 쿠팡 배너든 모든 광고관련 소스코드는 해당 폴더에 저장하도록 하자. 그리고 방금 생성한 코드를 저장할 파일을 생성하고, 아까 복사해둔 코드를 붙여넣는다. 이 때 파일의 형식은 .ejs여야 한다. ejs는 자바스크립트가 내장된 html 파일이라고만 알아두자. coupang-ad.ejs 1234&lt;script src=&quot;https://ads-partners.coupang.com/g.js&quot;&gt;&lt;/script&gt;&lt;script&gt; new PartnersCoupang.G(&#123;&quot;id&quot;:your_coupang_partners_id,&quot;subId&quot;:null&#125;);&lt;/script&gt; 원하는 위치에 배너 적용하기 이제 광고배너를 삽입할 위치를 결정할 차례다. 블로그의 index에서 navigation이 있는 하단부에 광고를 설치하고 싶다. 저 곳에 광고코드를 심으려면 어디에 심어야 할까? 파이어폭스의 요소검사(크롬에선 개발자도구)를 통해 포스트 썸네일이 출력되는 부분이 archive 라는 것을 알 수 있었다. 광고 코드는 이 archive의 하단부에 삽입하면 될 것 같다. /layout/common 디렉토리 내에 archive.ejs있다. 여기서 id가 page-nav 인 nav 아래에 광고코드를 심으면 될 것 같다. 광고코드는 이미 /layout/ads/coupang-ad.ejs 에 작성되었으므로 이 파일을 가져오면 될 것 같다. 위 이미지처럼 &lt;%- partial(&#39;&#39;) %&gt; 코드를 통해 해당 코드를 가져올 수 있다. 여기에 쿠팡 광고코드가 담긴 파일의 경로를 입력하면 된다. 그리고 로컬호스트(hexo server)로 확인해보자. 광고가 잘 삽입되었음을 알 수 있다. 이제 누군가가 이 배너를 통해서 제품을 구입할 수 있기를 바래보자…^^","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://youngjinmo.github.io/categories/Dev/Hexo/"}],"tags":[]},{"title":"커밋 메세지 더 잘 작성하기 (A.k.a. Gitmessage)","slug":"gitmessage","date":"2020-03-02T08:06:54.000Z","updated":"2020-09-13T01:53:28.840Z","comments":true,"path":"2020/03/gitmessage/","link":"","permalink":"http://youngjinmo.github.io/2020/03/gitmessage/","excerpt":"","text":"최근 몇개월간 진행한 프로젝트 스터디를 마무리했다. 뿌듯함보단 아쉬움이 남는 스터디였다. 프로젝트를 시작하고 나서 부족한 실력때문에 몇번씩 좌절감을 맛보았던게 아직도 기억이 난다. 그래도 포기하지않고, 어찌어찌 마무리한건 다행이다. 프로젝트를 진행하며 버전관리로 git을 이용했는데, 처음 시작할때 메세지를 잘 작성하자고 약속했지만, 막상 이를 지키지 못했다. 그러다 프로젝트를 끝난 시점에 커밋 메세지 템플릿을 만들수 있다는 것을 알았다. 템플릿을 이용하면 커밋 메세지를 작성할 때마다 템플릿에서 작성할 수 있기 때문에 서로의 약속을 지키기 더 원활할 것으로 기대한다. 나중에 다시 프로젝트를 하게 될 때 유용할 것 같아서 적용해보았다. 먼저 운영체제의 루트 디렉토리에서 gitmessage 를 만들어야 한다. 이 파일이 곧 커밋 템플릿이 되며, 앞으로 커밋을 작성할 때마다 콘솔에서 출력될 것이다. gitmessage.txt 생성 vim을 git editor로 지정 위에서 작성한 gitmessage를 템플릿으로 지정 gitmessage.txt 생성1$ vim ~&#x2F;.gitmessage.txt vim 에디터가 열리면 여기서 템플릿을 만들면 된다. 필자는 이렇게 작성했다. 123456789101112131415161718192021222324# 제목은 최대 50글자까지 아래에 작성: ex) &lt;feat&gt;: Add OAuth2# 본문은 아래에 작성# 꼬릿말은 아래에 작성: ex) Github issue #23# --- COMMIT END ---# &lt;타입&gt; 리스트# feat : 기능 (새로운 기능)# fix : 버그 (버그 수정)# refactor: 리팩토링# style : 스타일 (코드 형식, 세미콜론 추가: 비즈니스 로직에 변경 없음)# docs : 문서 (문서 추가, 수정, 삭제)# test : 테스트 (테스트 코드 추가, 수정, 삭제: 비즈니스 로직에 변경 없음)# chore : 기타 변경사항 (빌드 스크립트 수정 등)# ------------------# 제목 첫 글자를 대문자로# 제목은 명령문으로# 제목 끝에 마침표(.) 금지# 제목과 본문을 한 줄 띄워 분리하기# 본문은 &quot;어떻게&quot; 보다 &quot;무엇을&quot;, &quot;왜&quot;를 설명한다.# 본문에 여러줄의 메시지를 작성할 땐 &quot;-&quot;로 구분# ------------------ 다시 한 번 언급하지만 이 템플릿이 열리며 커밋 메세지를 작성하기 때문에 커밋 메세지 작성에 대한 규칙을 여기에 명시하면 된다. 내가 아닌 다른 사람들이 보고 쉽게 작성할 수 있도록 최대한 명료하게 작성하는게 중요하다. vim을 git editor로 지정1$ git config --global core.editor vim 다른 에디터(emacs)를 사용하는 사람이라면, 위 커맨드 명령어중 vim을 다른 명령어로 교체하면 된다. 위에서 작성한 gitmessage를 템플릿으로 지정1$ git config --global commit.template ~&#x2F;.gitmessage.txt 이제 커밋(git commit)을 명령하면, gitmessage 템플릿에서 작성할 수 있게 된다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"Hexo 블로그에 Utterances 적용하기","slug":"hexo-utterances","date":"2020-02-26T07:16:52.000Z","updated":"2020-09-13T01:53:28.780Z","comments":true,"path":"2020/02/hexo-utterances/","link":"","permalink":"http://youngjinmo.github.io/2020/02/hexo-utterances/","excerpt":"","text":"Hexo 블로그를 운영하며, 댓글 라이브러리로 Disqus를 사용했었는데, 현재 내 블로그를 접속하는 사람들은 아마도 개발자들일 것이고, 개발자들이라면 Github UI가 익숙할 것 같다는 생각이 들었다. 그래서 Disqus대신 Github UI를 경험할 수 있는 Utterances 라이브러리를 블로그 댓글로 사용해보기로 결정하였다. 아웃사이더님의 블로그 글(페이스북 댓글을 utterances로 교체했습니다)에 의하면 Utterance는 Github의 이슈검색 API를 사용한다고 한다. Utterances를 사용하기 위해서는 Github에 댓글을 위한 repo를 만들어야 하는데, 댓글이 작성되면 이 repo에 이슈로 등록이 된다. Github에서 repo를 만들었다면, 아래 Utterances 코드([ENTER REPO HERE])에 해당 저장소 주소를 작성하면 된다. 그리고 아래 Utterances 코드([ENTER REPO HERE])에 해당 저장소 주소(예: youngjinmo/hexo-utterances)를 작성하면 된다. 1234567&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;[ENTER REPO HERE]&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async&gt;&lt;/script&gt; hexo는 레이아웃에 따라 코드가 분리되어 있다. utterances는 댓글에 해당하므로 댓글 라이브러리들이 저장되어 있는 디렉토리에 utterances 코드를 저장해야 한다. utterances.ejs 생성12345678910&lt;!-- utterance comment --&gt;&lt;% if (config.utterances.enable == true) &#123; %&gt;&lt;script src=&quot;https://utteranc.es/client.js&quot; repo=&quot;[ENTER REPO HERE]&quot; issue-term=&quot;pathname&quot; theme=&quot;github-light&quot; crossorigin=&quot;anonymous&quot; async&gt;&lt;/script&gt;&lt;% &#125; %&gt; 이 코드를 hexo 블로그 디렉토리내 /themes/[your theme]/layout/comment/ 에 파일을 만들어서 저장하는데, 이 때 파일명은 utterances.ejs 로 저장한다. _config.yml에서 utterances의 enable 상태가 true로 전환일 때만 utterances가 사용되는 코드이다. _config.yml에 utterances 설정 추가123456# Utterances for commentutterances: enable: true repo: [ENTER REPO HERE] issue-term: title theme: github-light hexo 블로그가 저장되어 있는 디렉토리에 가면 _config.yml 파일이 있다. 여기서 가장 아래쪽에 utterances 설정을 담은 코드를 작성해주자. post.ejs에 utterances 추가12&lt;!-- Comment - utterances --&gt;&lt;%- partial(&#x27;comment/utterances&#x27;) %&gt; 이제 게시글을 작성할때 utterances가 적용되어야 하므로 /themes/[your theme]/layout/ 에 있는 post.ejs 파일에 위의 코드를 추가한다. &lt;%- partial(&#39;&#39;) %&gt;에 넣는 주소는 utterances.ejs가 저장되어 있는 경로를 의미한다. 여기까지 마무리하고 hexo g 를 통해 블로그에 최종적용하면 된다. 테스트로 이 포스트에 댓글을 작성해보았다. 댓글을 작성하면 아래처럼 Github을 통해 알람을 확인할 수 있다. 그리고 댓글 저장소에는 이 댓글이 이슈로 등록이된다. utterances로 댓글 적용 완료!","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://youngjinmo.github.io/categories/Dev/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://youngjinmo.github.io/tags/hexo/"}]},{"title":"Ubuntu에서 Wget으로 파일 다운로드하기","slug":"wget","date":"2020-02-11T03:41:47.000Z","updated":"2020-09-13T01:53:28.032Z","comments":true,"path":"2020/02/wget/","link":"","permalink":"http://youngjinmo.github.io/2020/02/wget/","excerpt":"","text":"우분투를 GUI가 아니라 CLI로 사용다가 파일을 다운받아야 할 상황이 발생하곤 하는데, 이 때 사용하는 패키지가 wget 이다. 1$ sudo apt-get install wget 1. 우분투로 전송받을 파일을 구글 드라이브에 업로드한다. 업로드된 파일의 공유가능한 링크를 클립보드로 가져온다(복사) 클립보드에 담긴 url중 **id부분**만 아래의 명령어에 붙여서 명령어를 완성한다.wget https://drive.google.com/uc?id=[from-gdrive] 위 명령어로 바로 명령하면, 파일 이름이 id값으로 이상하게 다운받아진다. 파일의 이름을 지정하면서 다운받고자 한다면 -O 키워드를 사용하여 이름을 지정한다.wget -O aws-keypair.zip https://drive.google.com/uc?id=[from-gdrive] 다운로드가 완성되면 unzip 키워드로 압축파일을 해제한다.unzip aws-keypair.zip 만약 unzip 패키지가 설치되지 않았다면, 이것도 설치하면 된다. 1$ sudo apt-get install unzip wget로 aws-key 라는 이름의 파일을 성공적으로 가져왔다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Linux","slug":"Dev/Linux","permalink":"http://youngjinmo.github.io/categories/Dev/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"http://youngjinmo.github.io/tags/ubuntu/"}]},{"title":"Github - SSH 등록하기","slug":"github-ssh","date":"2020-02-02T11:56:27.000Z","updated":"2020-10-01T12:03:16.222Z","comments":true,"path":"2020/02/github-ssh/","link":"","permalink":"http://youngjinmo.github.io/2020/02/github-ssh/","excerpt":"","text":"이전에 작성한 쉘에서 SSH 키를 생성한 후, 이를 Github에 저장해서 사용하는 방식이다. 위키백과에 의하면, SSH(Secure Shell)는 네트워크 상의 다른 컴퓨터에 로그인하거나 Github과 같은 원격 시스템에 명령을 실행하고 다른 시스템으로 파일을 복사할 수 있는 프로토콜이라고 한다. SSH는 암호화되어 통신하기 때문에 통신이 노출되더라도 안전하다고 한다. 먼저 쉘에서 SSH 키를 생성해보겠다. 터미널에서 아래 명령어를 입력한다. 1$ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; 그럼 key pair가 생성된다. 1&gt; Generating public&#x2F;private rsa key pair. 이후에 프롬프트(Terminal)에 입력을 요구하는 메세지가 출력된다. 1&gt; Enter a file in which to save the key (&#x2F;Users&#x2F;you&#x2F;.ssh&#x2F;id_rsa): [Press enter] 엔터를 입력하고, 12&gt; Enter passphrase (empty for no passphrase): [Type a passphrase]&gt; Enter same passphrase again: [Type passphrase again] 기억할 수 있는 문장을 두번 입력한다. 그리고 터미널에 아래의 명령어를 입력하여 ssh-agent 를 실행한다. 12$ eval &quot;$(ssh-agent -s)&quot;&gt; Agent pid 59566 pid는 리눅스, 맥 등의 유닉스 관련 대부분의 OS 커널에서 사용하는 Process ID라고 한다. (출처) 그리고 시에라 버전 10.12.2 이상의 맥을 사용한다면, ~/.ssh/config 를 수정해주어야 한다. 1234Host * AddKeysToAgent yes UseKeychain yes IdentityFile ~&#x2F;.ssh&#x2F;id_rsa 그리고 SSH 키를 ssh-agent에 연결하고 기억할 수 있는 문장(passpharase)를 키체인에 저장한다. ssh-agent는 리눅스 또는 유닉스 계열의 OS에서 로그인이 필요할 때 자동으로 config 를 도와준다고 한다. 1$ ssh-add -K ~&#x2F;.ssh&#x2F;id_rsa 이제 Github 설정에서 방금 생성한 SSH 키를 등록할 것이다. 생성한 키(~/.ssh/id_rsa.pub)를 복사한다. (클립보드에 저장된다.) 1$ pbcopy &lt; ~&#x2F;.ssh&#x2F;id_rsa.pub 그리고 Github 설정의 왼쪽 메뉴바에서 **[SSH and GPG key]**를 클릭한다. [New SSH key] 를 클릭한다. Title은 입력하고 싶은 이름을 입력해두고, Key에 아까 복사해뒀던 키를 붙여넣기해주면 된다. 출처 Github Help - Generating a new SSH key and adding it to the ssh-agent Github Help - Adding a new SSH key to your Github account","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"Github 라이센스 정리","slug":"github-licenses","date":"2020-02-01T07:10:00.000Z","updated":"2020-11-20T03:18:45.380Z","comments":true,"path":"2020/02/github-licenses/","link":"","permalink":"http://youngjinmo.github.io/2020/02/github-licenses/","excerpt":"","text":"깃헙에서 오픈소스 레파지토리를 보면 항상 보던게 있다. 오픈소스에 해당하는 라이센스의 최소한의 기준을 정의하기 위해 OSD(Open Source Definition)를 정의해두고 이 정의에 따라 인증, 관리 및 촉진시키고 있다고 한다. License List GNU General Public License(GPL) 2.0 GNU Lesser GPL(LGPL) 2.1 Berkeley Software Distribution(BSD) License Apache license Mozilla Public License(MPL) MIT License GNU General Public License(GPL) 2.0GPL은 현재 가장 많은 오픈소스 소프트웨어가 채택하고 있는 라이센스이다. 오픈소스 라이센스들 중에서 가장 많이 알려져 있고 의무사항들도 타 라이센스에 비해 엄격한 편이다. 소프트웨어를 배포하는 경우 저작권 표시, 보증책임이 없다는 표시 및 GPL에 의해 배포된다는 사실 명시 소프트웨어를 수정하거나 새로운 소프트웨어를 병합(Dynamic linking 포함)시키는 경우 GPL에 의해 소스 코드 제공 GPL 소프트웨어를 배포하는 경우, 소스 코드 그 자체를 함께 배포하거나 또는 소스코드를 제공받을 수 있는 방법에 대한 정보를 함께 제공 GNU Lesser GPL(LGPL) 2.1GPL 라이센스를 사용하기만 해도 소스코드를 공개해야 한다는 부담 때문에 단순한 라이브러리와 모듈로의 링크를 허용한 라이선스이다. 원래는 한정된 라이브러리에만 적용하려는 의도로 ‘Library GPL’이라는 이름을 붙였으나, 모든 라이브러리에 적용된다는 오해를 사 2.1 버전으로 ‘Lesser GPL’로 변경됐다. 소프트웨어를 배포하는 경우 저작권 표시, 보증책임이 없다는 표시 및 LGPL에 의해 배포된다는 사실 명시 LGPL Library의 일부를 수정하는 경우 수정한 Library를 LGPL에 의해 소스코드 공개 Berkeley Software Distribution(BSD) LicenseBSD 라이센스는 GPL/LGPL보다 덜 제한적이기 때문에 허용 범위가 넓다. 가장 큰 차이점은 소스코드를 공개하지 않아도 된다는 점이다. 소프트웨어를 배포하는 경우 저작권 표시, 보증책임이 없다는 표시 수정 프로그램에 대한 소스 코드의 공개를 요구하지 않기 때문에 상용 소프트웨어에 무제한 사용가능 Apache License아파치 소프트웨어 재단에서 자체적으로 만든 소프트웨어에 대한 라이센스 규정이다. 아파치 라이센스는 아파치 재단(ASF: Apache Software Foundation)의 모든 소프트웨어에 적용되며 BSD 라이센스와 비슷하여 소스코드 공개 등의 의무가 발생하지 않는다. 다만 “Apache”라는 이름에 대한 상표권을 침해하지 않아야 한다는 조항이 명시적으로 들어가 있고, 특허권에 관한 내용이 포함되어 BSD 라이센스보다는 좀더 법적으로 완결된 내용을 담고 있다. 특히 GPL 2.0으로 배포되는 코드와 결합되는 것이 어렵다는 문제가 었었는데, GPL 3.0에서는 이 문제를 해결하여 아파치 라이센스로 배포되는 코드가 GPL 3.0으로 배포되는 코드와 결합하는 것이 가능해졌다. Mozilla Public License(MPL)MPL은 Netscape 브라우저의 소스코드를 공개하기 위해 개발된 라이센스이다. MPL에서는 링크 등의 여부에 상관없이 원래의 소스코드가 아닌 새로운 파일에 작성된 소스코드에 대해서는 공개의 의무가 발생하지 않는다. 소프트웨어를 배포하는 경우 저작권 표시, 보증책임이 없다는 표시 및 MPL에 의해 배포된다는 사실을 명시 MPL 코드를 수정한 부분은 다시 MPL에 의해 배포 MPL 코드와 다른 코드를 결합하여 프로그램을 만들 경우 MPL 코드를 제외한 결합 프로그램에 대한 소스코드는 공개할 필요가 없음 소스코드를 적절한 형태로 제공하는 경우, 실행파일에 대한 라이센스는 MPL이 아닌 다른 것으로 선택가능 특허기술이 구현된 프로그램의 경우 관련 사실을 ‘LEGAL’파일에 기록하여 배포 MIT LicenseMIT 라이센스는 미국 매사추세츠공과대학교(MIT)에서 해당 대학 소프트웨어 공학도들을 돕기 위해 개발한 라이센스이다. 라이센스와 저작권 관련 명시만 지켜주면 되는 라이센스이다. 이 소프트웨어를 누구라도 무상으로 제한없이 취급해도 좋다. 저자 또는 저작권자는 소프트웨어에 관해서 아무런 책임을 지지 않는다. 출처 : 오픈소스 소프트웨어 라이센스의 종류와 제약","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[{"name":"github","slug":"github","permalink":"http://youngjinmo.github.io/tags/github/"},{"name":"license","slug":"license","permalink":"http://youngjinmo.github.io/tags/license/"}]},{"title":"Git - 원격 저장소(Upstream)의 브랜치, Fork해서 로컬에서 사용하기","slug":"git-pull-upstream-branch","date":"2020-02-01T05:45:22.000Z","updated":"2020-09-13T01:53:28.876Z","comments":true,"path":"2020/02/git-pull-upstream-branch/","link":"","permalink":"http://youngjinmo.github.io/2020/02/git-pull-upstream-branch/","excerpt":"","text":"원격 저장소를 fork해서 사용하다보면, 다른 사람의 브랜치가 필요할 때가 있다. 이제 그 과정을 따라가보자. 현재 원격 저장소를 fork해두고, fork한 저장소를 로컬로 clone한 상황이다. 이 상태에선 원격 저장소의 브랜치 목록을 확인할 수 없다. git remote -v 명령어로 깃 저장소를 확인해보면, 로컬 저장소만 가리키고 있다. 따라서 먼저 원격 Upstream 저장소를 가리킬 수 있도록 해야한다. 1$ git remote -v add upstream http:&#x2F;&#x2F;github.com&#x2F;devandy&#x2F;lectureSearchOrigin.git 그럼 이제 원격 저장소의 브랜치 목록을 확인할 수 있다. 현재 * 가 있는 곳이 내가 바라보고 있는 브랜치이다. 초록색깔로 표시되는 브랜치가 로컬에 생성된 브랜치인데, 이제 막 clone한 프로젝트여서 아무런 브랜치를 생성하지 않은 상태이다. 원격 저장소의 브랜치는 빨갛게 표시되는데, 앞에 remotes/ 로 시작하므로 구분하기 쉽다. 이제 저기 원격 저장소에서 remotes/origin/search_giyun 이라는 브랜치를 가져다 사용하려고 한다. 이 때 사용하는 명령어는 git checkout -t origin/branch 이다. 이 명령어는 뒤에 작성한 Upstream의 브랜치와 똑같은 이름의 브랜치를 생성하면서 바로 브랜치를 이동하는 명령어이다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"Hexo에서 Highlight 변경하기","slug":"hexo-code-highlight","date":"2020-01-23T07:16:37.000Z","updated":"2020-09-13T01:53:28.840Z","comments":true,"path":"2020/01/hexo-code-highlight/","link":"","permalink":"http://youngjinmo.github.io/2020/01/hexo-code-highlight/","excerpt":"","text":"블로그를 사용하다가 코드를 문법에 맞춰 가독성있게 표시해주는 코드 하이라이트 테마가 맘에들지 않았다. 처음 설정때부터 Androidstudio 테마를 사용하고 있었는데, 흰 블로그 배경에 다소 어두운 테마가 들어가다보니 이질감도 있고, 별로 가독성이 좋다고 생각하지 않았다. 평소에도 가독성 있는 텍스트는 흰 배경에 어두운 글자여야 한다는 생각을 갖고 있다. 알고보니 변경 방법이 어렵지 않아서 왜 이제야 바꿨나 싶다. 먼저 하이라이트 파일(.styl)을 다운받아야 한다. 그러나 사실 이미 theme 폴더를 확인해보면 수십개의 하이라이트 파일이 있는걸 확인할 수 있다. 1&#x2F;themes&#x2F;hueman&#x2F;source&#x2F;css&#x2F;_highlight hexo 블로그 디렉토리에서 위의 경로로 들어가서 맘에 드는 하이라이트 파일을 찾거나 다운받은 하이라이트 파일을 이곳에 넣어둔다. 그 다음엔 [themes] 디렉토리 바로 하위에 있는 _config.yml 파일을 열어보자. 여기서 cutomize: highlight: 에서 바꾸고자 하는 테마로 수정만 하면된다. 1234567891011121314# Customizecustomize: logo: width: 180 height: 70 url: images/logo-3.png theme_color: &#x27;#ff7f50&#x27; # coral highlight: github # 여기를 바꾸면 된다. sidebar: left thumbnail: true favicon: images/favicon.jpg social_links: linkedin: https://www.linkedin.com/in/youngjinmo/ github: https://github.com/devyoungjin 어떤 테마로 바꿔야할지 모르겠다면 highlight.js 에 들어가서 구경하고 결정하면된다. 각 하이라이트 스타일별 언어가 어떻게 스타일링(?) 되는지 볼 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://youngjinmo.github.io/categories/Dev/Hexo/"}],"tags":[]},{"title":"맥에서 5분만에 윈도우 컴퓨터 만들기 (A.k.a AWS)","slug":"window-server-aws","date":"2020-01-23T05:50:03.000Z","updated":"2020-09-13T01:53:27.972Z","comments":true,"path":"2020/01/window-server-aws/","link":"","permalink":"http://youngjinmo.github.io/2020/01/window-server-aws/","excerpt":"","text":"한국에서 맥을 사용하는 사람들이라면 누구나 어떻게 윈도우를 사용할지에 대해 고민해봤을 것이다. 맥을 사용하면서 왜 다른 운영체제를 쓰려고 한단 말인가. 우리가 사는 이곳이 한국이기 때문이다. 더 이상 설명하지 않겠다. 대부분은 부트캠프나 패러럴즈를 이용하리라 생각된다. 그러나 두가지 방식 모두 비용이 발생하거나 맥의 램 또는 하드웨어 용량을 적지않게 차지하는 활동이다. 그리고 무엇보다 간단하지 않다. 최근에 AWS를 공부하면서 이를 엄청 간단하게 해결할 수 있음을 배워 기록해둔다. 이를 실행하기 앞서 필요한 준비물(?)이 있다면, 컴퓨터와 AWS 계정 그리고 Microsoft Remote Desktop이다. ToC AWS에서 윈도우서버 인스턴스 생성하기 Microsoft Remote Desktop으로 윈도우 접속하기 AWS에서 윈도우서버 인스턴스 생성하기AWS 콘솔에서 EC2 생성하기 보안을 위해 이전에 생성해둔 인스턴스의 이름과 ID는 모두 가렸다. 그 다음 단계에서 인스턴스를 생성하는 AMI로 Microsoft Windows Server를 찾아서 선택한다. 그리고는 디폴트 설정으로 계속 넘어간다. 단계5에서 태그를 추가할 수 있는데, 인스턴스의 이름을 설정할 수 있다. 안해도되는 선택사항이긴 하지만 그냥 알아는 두자. 중요한 부분이다. 인스턴스에 접속할 때 필요한 비밀번호이다. 이 비밀번호는 암기가 불가능할만큼 어려우며, .pem 포맷으로 파일이 저장된다. 해당 파일을 분실하면 다시는 해당 인스턴스를 사용할 수 없게되므로 관리에 철저히 해야한다. 유출되어서도, 분실되어서도 안되는 존재이다. 그럼 이제 모든 과정을 마치고, 인스턴스가 생성되었음을 확인할 수 있다. Microsoft Remote Desktop으로 윈도우 접속하기이제 윈도우에 접속해야할 단계이다. 마지막 단계에서 [인스턴스 보기]를 누르거나 EC2 콘솔에 접속하면 방금 생성한 인스턴스를 확인할 수 있다. 여기서 연결을 클릭하자. 여기서 클릭할 수 있는 버튼이 2개가 있는데, 우선 **[암호 가져오기]**를 먼저 클릭하자. 그럼 아래처럼 넘어가는 것을 볼 수 있다. 접속하려고 하는 인스턴스가 어떤 키페어(.pem)와 연결되었는지 알려주는데, 해당 키페어를 불러와서 암호를 해독한다. 그럼 짧게 한 줄로 해독이 되는데 물론 이 암호도 간단한 암호는 아니다. 일단 이 암호를 복사해서 클립보드에 저장해둔다. 그리고 위의 [원격 데스크톱 파일 다운로드] 를 클릭한다. 그럼 윈도우서버 인스턴스에 접속할 수 있는 파일이 로컬에 저장된다. 그리고 설치된 파일을 실행하면 아까 해독한 암호를 입력하라는 창이 출력된다. 클립보드에 저장해둔 암호를 붙여넣기 한다. 끝! 이걸로 맥에서 순식간에 윈도우 컴퓨터를 생성해냈다. 맥 사용자가 윈도우가 필요한 순간은 아마도 공인인증서가 필요한 상황이 아닐까 싶다. 이 실습은 AWS라는 클라우드 컴퓨팅환경에서 이뤄졌으므로 여기에서 금융거래를 하는 건 위험한 행동이 아닐까 싶다. 그러므로 필요한 최소한의 활동만 하고, 만약 금융거래를 했다면, 반드시 인스턴스를 종료하고 삭제하도록 하자. 별책. IE Enhanced Security Config 해제하기윈도우 메뉴에서 [Server Manager] 에 접속한 뒤, [Local Server]에 들어가서 IE Enhanced Security Configuration을 on에서 off로 바꿔두면, 보안은 위험해지지만 IE 웹서핑시 더 이상 경고문고를 받아보지 않아도 된다. 보안과 편의를 맞바꾸는 딜이지만, 사실 2020년에 아직도 IE를 이용하는 것 자체가 이미 위험한 액션이긴 하다. (MS는 IE10의 보안 업데이트를 2020년 1월 종료한다고 발표했다.)","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"DevOps","slug":"Dev/DevOps","permalink":"http://youngjinmo.github.io/categories/Dev/DevOps/"}],"tags":[{"name":"tutorial","slug":"tutorial","permalink":"http://youngjinmo.github.io/tags/tutorial/"},{"name":"aws","slug":"aws","permalink":"http://youngjinmo.github.io/tags/aws/"},{"name":"cloud","slug":"cloud","permalink":"http://youngjinmo.github.io/tags/cloud/"}]},{"title":"Git에서 변경사항 단위(Hunk)로 스테이징하기","slug":"git-add-p","date":"2020-01-22T06:00:43.000Z","updated":"2020-09-13T01:53:28.924Z","comments":true,"path":"2020/01/git-add-p/","link":"","permalink":"http://youngjinmo.github.io/2020/01/git-add-p/","excerpt":"","text":"위에서 작성된 스테이징 방식(git add file)이 파일 단위라면, 여기서 언급되는 스테이징 방식은 작업의 변경사항 단위로 스테이징하는 방법이다. 하나의 파일 안에서도 변경한 부분이 몇 가지가 될 수 있는데, 이 때 git add file 을 사용하면 파일이 통째로 스테이징된다. 그러나 git add -p 를 사용하면 변경사항 단위로만 스테이징 할 수 있다. 더 편하고 더 분명하게 버전관리 할 수 있다고 생각된다. 이 때의 변경사항 단위를 Hunk라고 한다. test 폴더를 만들어서 실습을 해보았다. 생성한 파일(test.html)에 세 줄의 코드를 추가하고, 명령어 git add -p 를 입력하였다. 여기서 s 는 split을 의미한다. 세 줄을 한 꺼번에 스테이징하기 보다 더 세분화해서 스테이징하기 위해 split을 하는거다. split을 한 결과는 다음과 같다. git add -p 에서 응답할 수 있는 명령어는 아래 정리해두었다. 하나의 hunk가 3개의 hunk로 쪼개져서 각각 스테이징 할 수 있었다. 세 줄의 코드중 마지막 줄 코드만 스테이징 하지 않기로 했다. 다시 git add -p 을 입력해보니 아까 스테이징 하지 않은 한 줄의 코드만 스테이지 여부를 묻고, 나머지 코드는 스테이징 되었음을 확인할 수 있었다. 이처럼 git add -p 를 사용하면, 변경사항 단위로 더 세분화해서 스테이징 하는 것이 가능하다. git add -p 에서 응답할 수 있는 명령어는 ? 을 입력하면 볼 수 있는데, 다음과 같다. 주로 쓰이는 명령어는 y, n, q 이다. y : 해당 hunk를 스테이징한다. n : 스테이징하지않고 건너뛴다. q : add 과정을 종료한다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"HTTP 상태코드","slug":"http-codes","date":"2020-01-15T08:02:59.000Z","updated":"2020-09-13T01:53:28.688Z","comments":true,"path":"2020/01/http-codes/","link":"","permalink":"http://youngjinmo.github.io/2020/01/http-codes/","excerpt":"","text":"현재 진행중인 프로젝트를 하다가 에러페이지를 다루는 과정에서 한 번 정리해볼 필요가 있을것 같아서 작성하게되었다. ToC 1xx 100 101 102 2xx 200 201 202 204 3xx 301 302 304 4xx 400 401 403 404 405 406 409 429 5xx 500 502 503 504 1xx - 정보응답 (Information Responses) 100 : Continue 진행중임을 나타내는 응답코드이며, 지금까지 상태가 OK임을 의미. 클라이언트가 계속 요청하거나 이미 요청을 완료한 경우에 무시해도 되는 것을 알려준다. 101 : Switching Protocol 클라이언트가 보낸 업그레이드 요청 헤더에 대한 응답으로 보내진다. 서버에서 프로토콜을 변경할 것임을 알려준다. 102 : Processing (WebDAV) 서버가 요청을 수신하였으며 이를 처리하고 있지만, 아직 제대로된 응답을 알려줄 수 없는 상태임을 알려준다. 2xx - 성공응답 (Successful Responses) 200 : OK 요청이 성공적으로 되었음을 나타내는 응답코드. HTTP 메서드에 따라 무엇을 성공했는지 의미가 달라진다. GET : 리소스를 불러와서 메세지 바디에 전송 HEAD : 개체 헤더가 메세지 바디에 존재 PUT or POST : 수행 결과에 대한 리소스가 메세지 바디에 전송 TRACE : 메세지 바디는 서버에서 수신한 요청 메세지를 포함 201 : Created 요청이 성공적이었으며, 그 결과로 새로운 리소스가 생성. 일반적으로 POST 요청 또는 일부 PUT 요청 이후에 따라온다. 202 : Accepted 요청을 수신하였지만 그에 응하여 행동할 수 없다. 이 응답은 요청 처리에 대한 결과를 이후에 HTTP로 비동기 응답을 보내는 것에 대해서 명확하게 명시하지 않는다. 다른 프로세스에서 처리 또는 서버가 요청을 다루고 있거나 배치 프로세스를 하고 있는 경우를 위해 만들어졌다. 204 : No Content 요청에 대해서 보내줄 수 있는 컨텐츠가 없지만, 헤더는 의미있을 수 있다. user-agent는 리소스가 캐시된 헤더를 새로운 것으로 업데이트할 수 있다. 3xx - 리다이렉션 메시지 (Redirection Message) 301 : Moved Permanently 이 응답 코드는 요청한 리소스의 URI가 변경되었음을 의미한다. 새로운 URI가 응답에서 주어질 수 있다. 302 : Found 클라이언트가 요청한 리소스가 헤더에 주어진 URL로 일시적으로 이동되었음을 가리키는 상태코드이다. 301과 다른 점은 302 상태코드는 검색엔진에서 페이지랭킹 또는 링크에 대한 점수를 새로운 URL로 옮기지 않고, 기존의 URL을 그대로 유지한다는 점이다. 즉 기존의 URL로 페이지랭킹 점수를 유지하면서도 컨텐츠만 새로운 URL에서 조회되도록 할 때 302 리다이렉트를 사용할 수 있다. 참고 포스트 304 : Not Modified 캐시를 목적으로 사용된다. 클라이언트에게 응답이 수정되지 않았음을 알려주며, 그래서 클라이언트는 계속해서 응답의 캐시된 버전을 사용할 수 있다. 4xx - 클라이언트 에러응답(Client Error Responses) 400 : Bad Request 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미한다. 따라서 서버가 클라이언트가 누구인지를 모르는 상태이다. 401 : Unauthorized 비인증(unauthorized)을 의미한다. 클라이언트는 요청한 응답을 받기 위해서 반드시 스스로를 인증해야한다. 403 : Forbidden 클라이언트가 컨텐츠에 접근할 권리가 없음을 의미한다. 401과 다른 점은 서버가 클라이언트가 누구인지는 알고 있다는 점이다. 404 : Not Found 서버는 요청받은 리소스를 찾을 수 없다. 브라우저에서 알려지지 않은 URL을 의미한다. 서버는 인증받지 않은 클라이언트로부터 리소스를 숨기기위하여 403대신 404을 응답할 수도 있다. 405 : Method Not Allowed 요청한 메서드는 서버에서 알고있지만, 제거되어서 더이상 사용할 수 없음을 의미한다. 필수적인 메서드인 GET과 HEAD는 제거될 수 없으며 이 에러 코드를 리턴할 수 없다. 406 : Not Acceptable 이 응답은 서버가 서버 주도 컨텐츠 협상을 수행한 이후, 사용자 에이전트에서 정해준 규격에 따른 어떠한 컨텐츠도 찾지 않았을때, 웹서버가 보낸다. 409 : Conflict 요청이 현재 서버의 상태와 충돌될 때 보내진다. 429 : Too Many Requests 사용자가 지정된 시간에 너무 많은 요청을 보냈을 때 응답된다. 5xx - 서버 에러응답 (Server Error Responses) 500 : Internal Server Error 서버가 처리방법을 모르는 상황을 의미한다. 502 : Not Implemented 서버에서 지원되지 않아서 처리할 수 없는 상태이다. 서버가 지원해야 하는 유일한 방법은 GET과 HEAD이다. 이 코드는 반환하면 안된다. 503 : Service Unavailable 서버가 요청을 처리할 준비가 되지 않았을 때 응답된다. 일반적으로 유지보수를 위해 서버 작동이 중단되거나 과부하가 걸렸을때 응답된다. 이 때는 사용자 친화적인 페이지를 전송시켜서 어떠한 이유로 503 상태인지를 설명해야한다. 이 응답은 임시조건에 사용되어야 하며, 일시적인 조건 응답을 캐시하지 않아야 하므로 이 응답과 함께 전송되는 캐싱 관련 헤더에 대해서도 주의해야한다. 504 : Gateway Timeout 이 오류 응답은 서버가 게이트웨이 역할을 하고 있으며 적시에 응답을 받을 수 없을때 주어진다. 출처 : MDN - HTTP 상태 코드(https://developer.mozilla.org/ko/docs/Web/HTTP/Status) https://www.kahena.com/wp-content/uploads/2013/12/seos-guide-to-http-status-codes.gif","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Web","slug":"Dev/Web","permalink":"http://youngjinmo.github.io/categories/Dev/Web/"}],"tags":[{"name":"http","slug":"http","permalink":"http://youngjinmo.github.io/tags/http/"}]},{"title":"정규표현식(Reg)","slug":"reg","date":"2020-01-12T10:31:24.000Z","updated":"2020-09-13T01:53:28.216Z","comments":true,"path":"2020/01/reg/","link":"","permalink":"http://youngjinmo.github.io/2020/01/reg/","excerpt":"","text":"정규표현식프로그래머스 정규표현식 강의를 들으면서 작성한 노트이다. 강의는 파이썬으로 진행되었다. ToC 숫자 대표문자 (한 글자만) 글자 대표문자 (한 글자만) 문자 여러개 0개 이상 x가 있을수도 있고, 없을 수도 있고 x 또는 y가 있을수도 있고, 없을 수도 있고 특정 글자 수의 문자만 조회 글자 수 조건 추가하여 문자 조회 특정 문자만 조회 소문자 알파벳 전체를 조회하기 한글단어 조회 기타 대표문자 자바 정규표현식 숫자 대표문자 (한 글자만) \\d : 숫자를 대표하는 정규표현식 (d:digit) 강의에서 계속 아래의 예제코드를 사용하게 된다. 123456789regex = r&#x27;\\d&#x27;search_target = &#x27;&#x27;&#x27;Luke Skywarker 02-123-4567 luke@daum.net다스베이더 070-9999-9999 darth_vader@gmail.comprincess leia 010 2454 3457 leia@gmail.com&#x27;&#x27;&#x27;import reresult = re.findall(regex, search_target)print(&quot;\\n&quot;.join(result)) 출력결과 result 라는 변수가 print 함수에 의해 출력되었는데, result 함수를 뜯어보면, search_target 에서 regex 가 일치하는 부분만 뽑아서 한글자씩 저장이 된거다. 여기서 내가 작성한건 regex 변수 정의하는 부분에서 \\d 를 채워넣었다. 여기서 \\d 는 숫자(digit)를 대표하는 정규표현식이라고 한다. 글자 대표문자 (한 글자만) \\w : 글자를 대표하는 정규표현식 (w:word) a, b, c와 같은 알파벳 문자와 가,나,다 와 같은 한글문자, 1,2,3 같은 숫자까지 포함. 특수문자는 포함안되더라도 _ 는 포함된다고 한다. 출력결과 숫자 대표문자 \\d 와 마찬가지로 변수 regex에 \\w 를 작성하고 실행했다. search_target 에서 regex 에 일치하는 결과물을 출력하는 코드이다. 스크린샷에서는 다 출력하지 못했지만, 숫자와 한글까지 다 정확히 출력된걸 확인할 수 있었다. 문자 여러개 \\d는 숫자 한 글자씩만 찾는 한계가 있다. 한 글자로 이루어진 단어뿐 아니라 여러 글자로 이루어진 단어로 찾을땐 \\d+ 를 이용한다. 출력결과 숫자로 이루어진 글자를 한글자씩 떼네어 잘 출력이되었다. \\w+ 로 조회해보면, 마찬가지로 문자를 한 글자가 아닌 한 단어씩 조회가 된다. 0개 이상 * 은 특정 조건으로 최소한 1개 이상의 수를 조회한다. [1-9]\\d* : 앞자리 숫자가 1과 9중 하나가 반드시 나오는 수를 조회한다. 즉 자연수를 찾는 방법이다. \\d*[9] : 뒤에다 붙이면, 뒷자리 숫자가 9인 숫자를 조회한다. 출력결과 x가 있을수도 있고, 없을 수도 있고 x? : x가 있을수도 있고, 없을수도 있는 조건을 포함시켜 조회할 때 사용한다. [x]? 로 작성할 수도 있다. 강의에서 사용한 예제는 전화번호이다. 찾고자 하는 전화번호가 같은번호임에도 - 여부에 따라 021234567 일수도있고, 02-123-4567 일수도 있다.이때 -? 를 포함시켜 조회하면, - 가 있거나 없거나 모두 조회하게 된다. 전화번호 형태의 숫자를 조회해보았다. 전화번호(xxx-xxx-xxx)는 숫자(\\d+) 3개 사이에 각각 - 가 포함될수도있고, 그렇지 않을수도 있기 때문에 정규표현식으로 작성해보면 \\d+ , -?, \\d+, -?, \\d+ 를 이어붙인걸로 작성될 수 있다. \\d+-?\\d+-?\\d+ 출력 결과 x 또는 y가 있을수도 있고, 없을 수도 있고 [x,y]? : x 또는 y가 있을수도 있고, 없을 수도 있다. 전화번호 예제를 계속 사용해보면, 사실 - 뿐 아니라 그냥 공백으로 전화번호를 구분하는 표기법도 있다. 그럼 위의 정규표현식 \\d+-?\\d+-?\\d+ 로는 공백으로 구분한 전화번호는 조회되지 않는다. 이땐 ? 앞에 - 대신 [- ] 를 작성하면, -또는 이 있을수도 있고, 없을 수도 있는 조건이 추가되어 조회된다. 출력 결과 특정 글자 수의 문자만 조회 \\d&#123;n&#125; : n개로 이루어진 숫자 단어를 조회할 때 사용 전화번호 형태가 최근 가장 많이 쓰이는 휴대전화번호인 xxx-xxxx-xxxx 라면 위에서 사용한 정규표현식(\\d+[- ]?\\d+[- ]?\\d+)만으로는 부족할 것이다. \\d+ 는 글자수와 상관없이 한 단어로 구성된 모든 숫자를 조회하기 때문이다. 이때 \\d&#123;&#125; 를 사용하면, 원하는 글자 갯수로 구성된 단어만을 조회할 수 있다. 일반적으로 많이 사용하는 휴대전화번호 포맷인 xxx-xxxx-xxxx를 조회하기 위해서는 정규표현식을 \\d&#123;3&#125;[- ]?\\d&#123;4&#125;[- ]?\\d&#123;4&#125; 로 수정해야 한다. 출력 결과 글자 수 조건 추가하여 문자 조회 \\d&#123;x, y&#125; : x또는 y개로 구성된 숫자 단어 조회 전화번호 포맷이 xxx-xxxx-xxxx 일 수도 있지만, xx-xxx-xxxx 이거나 xxx-xxx-xxxx 라면 \\d&#123;n&#125; 만으로는 전체 전화번호 조회가 불가능하다. 따라서 찾고자 하는 단어의 갯수의 조건을 추가해야 한다. 앞자리 숫자가 3자리 일수도 있고, 2자리일수도 있으니 \\d&#123;2,3&#125;중간 숫자는 3자리 일수도 있고, 4자리 일수도 있으니 \\d&#123;3,4&#125;마지막 숫자는 4자리 수이므로 그냥 \\d&#123;4&#125; 중간에 - 또는 공백이 있을수도 있고, 없을수도 있는 정규표현식([- ]?)까지 채워넣으면 최종적으로 아래의 정규표현식이 완성된다. \\d&#123;2,3&#125;[- ]?\\d&#123;3,4&#125;[- ]?\\d&#123;4&#125; 출력 결과 특정 문자만 조회 [xyz] : x, y, z만 조회한다. 소음자 모음(a,e,i,o,u)문자만 조회를 해보았다. 출력 결과 소문자 알파벳 전체를 조회하기 [a-z] : a부터 z에 해당하는 소문자 알파벳 전체를 조회한다. [a-z]+ : 소문자로만 이루어진 단어 조회 출력결과 한글단어 조회 [가-힣] : 한글의 첫 글자는 가이고, 마지막 글자는 힣라고 한다. 한글로 구성된 단어를 찾을 땐 [가-힣]+ 로 조회할 수 있다. 출력 결과 기타 대표문자 \\s : 공백문자 (스페이스, 탭, 뉴라인) \\S : 공백문자를 제외한 문자 \\d : 숫자 대표문자 \\D : 숫자를 제외한 문자 \\w : 글자 대표 문자 \\W : 글자 대표 문자를 제외한 문자 (특수문자, 공백) 출력 결과 숫자를 제외하고 조회 글자 대표문자 제외하고 조회 자바 정규표현식자바에서는 정규표현식을 작성할때 앞에 \\ 을 더 붙여줘야 한다. 자바에선 기본적으로 \\ 이 escape를 의미하기 때문이다. 따라서 3글자 숫자로만 구성된 단어를 조회한다면, 작성할 수 있는 정규표현식은 다음과 같을 것이다. \\\\d&#123;3&#125; Python에서는 re 를 import하고, re.findall() 로 조회를 했다. 자바에서는 Pattern 클래스와 Matchers 클래스를 사용한다. 12345678910111213141516import java.util.regex.Pattern;import java.util.regex.Matchers;public class study_regex &#123; public static void main(String[] args)&#123; String target = &quot;Luke Skywarker 02-123-4567 luke@daum.net\\n다스베이더 070-9999-9999 darth_vader@gmail.com\\nprincess leia 010 2454 3457 leia@gmail.com&quot;; // 숫자를 포함한 단어(\\w) 조회 Pattern pattern = Pattern.compile(&quot;\\\\w+&quot;); Matcher matcher = pattern.matcher(target); while(matcher.find())&#123; System.out.println(matcher.group(0)); &#125; &#125;&#125; 출력 결과","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Others","slug":"Dev/Others","permalink":"http://youngjinmo.github.io/categories/Dev/Others/"}],"tags":[{"name":"reg","slug":"reg","permalink":"http://youngjinmo.github.io/tags/reg/"}]},{"title":"Js코드로 User-Agent 알아보기","slug":"check-useragent","date":"2020-01-02T15:29:41.000Z","updated":"2020-12-03T08:36:03.287Z","comments":true,"path":"2020/01/check-useragent/","link":"","permalink":"http://youngjinmo.github.io/2020/01/check-useragent/","excerpt":"","text":"갑자기 접속한 브라우저와 운영체제 등 정보가 담긴 user-agent를 확인이 필요해서 코드를 찾아봤다. Javascript의 navigator 객체를 이용하여 user-agent를 출력할 수 있다. Navigator에 대해서는 생활코딩에서 더 알아볼 수 있으며, navigator 객체의 여러가지 프로퍼티에 대해서 설명한 포스트도 있다. 출처 : 꿀벌개발일지 - User Agent 파헤치기 (navigator.userAgent) 코드는 다음과 같다. 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Check UserAgent&lt;/title&gt;&lt;/head&gt;&lt;body&gt;UserAgent &lt;button onclick=&quot;myFunction()&quot;&gt;확인&lt;/button&gt;&lt;p id=&quot;your-userAgent&quot;&gt;&lt;/p&gt;&lt;script&gt;function myFunction() &#123; var userAgent = &quot;User-agent header sent: &quot; + navigator.userAgent; document.getElementById(&quot;your-userAgent&quot;).innerHTML = userAgent;&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 실제로 동작하는걸 확인해볼 수 있다. See the Pen check your user-agent by DevAndy (@youngjinmo) on CodePen.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://youngjinmo.github.io/tags/javascript/"}]},{"title":"JAVA - IO(BufferedReader/BufferedWriter)","slug":"java-buffer-io","date":"2019-12-11T03:57:05.000Z","updated":"2020-09-13T01:53:28.620Z","comments":true,"path":"2019/12/java-buffer-io/","link":"","permalink":"http://youngjinmo.github.io/2019/12/java-buffer-io/","excerpt":"","text":"코딩테스트? 퀴즈를 풀면서 해결한 이후엔 다른 사람의 코드와 비교해보곤 하는데, 대부분의 사람들이 io에 buffer를 이용한걸 확인했다. 이전에도 코딩테스트에서는 Scanner 객체를 사용하는대신 buffer를 이용해야 효율이 좋다는 이야기를 들었고, 빡빡하게 진행하는 데에서는 아예 Scanner나 print를 사용하면 아예 통과하지 못한다고도 들은바는 있었다. 그러나 buffer를 잘알지 못하다보니 당장은 문제를 해결하기 위한 로직에만 집중하자며, 미뤄두었는데 이제서야 buffer를 좀 정리해보려고 한다. 먼저 buffer를 왜 사용해야하는지부터 알아보자. 왜 버퍼(buffer)를 사용해야 할까?buffer를 사용하지 않을 경우엔 사용자가 입력하는 키가 곧바로 프로그램에 전달된다. 이렇게 되면 사용자가 길게 입력할수록 키보드에서 프로그램으로 전달되는 횟수가 증가하며 프로그램의 성능저하를 유발할 수 있다. 반면 buffer를 사용할 경우엔, 일단 사용자가 입력을 마칠 때까지 buffer에 임시로 담아뒀다가 입력이 끝나면, 한꺼번에 buffer에 있는 값을 프로그램으로 전달한다. 여기서 버퍼란 데이터를 어떤 지점에서 다른 지점으로 전송하는 동안 일시적으로 데이터를 보관하는 메모리의 영역을 말한다. 버퍼의 또 다른 이름은 큐(Queue)라고 한다.출처 : 위키 StreamReader과 Buffer 그동안 사용했던 Scanner 는 사실 원래 존재하지 않던 객체이다. Java 1.5에서 처음 적용되었으며, 좀 더 간편하게 콘솔에 문자를 출력하기 위해 개발되었다고 한다. Stream이 Scanner에 비하면 불편할 수 있지만, 원래 오리지널 방식의 입출력 객체라는 이야기이다. Stream을 사용하기 위해서는 예외처리를 반드시 해주어야 한다. 출력할 때마다 try catch() 를 사용할 수도 있지만, main 메서드에 IOException 을 처리해두면 편하게 사용할 수 있다. 이 IOException 클래스도 java.io 에 내장되어 있다. 12345678import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.io.IOException;class devandy &#123; public static void main(String[] args) throws IOException &#123; // buffer 사용 준비 완료! &#125;&#125; InputStreamReader 로는 한글자씩밖에 입력받지 못한다고 한다. 그래서 몇자를 입력해도 한 글자만 출력한다. InputStreamReader과 OutputStreamWriter만 사용해서 IO를 시도할 경우, 다음과 같은 결과를 확인할 수 있다. 입력으로 “12345” 를 입력했지만 정작 출력되는 1과 왜 출력된지 알 수 없는 %뿐이다. 이번엔 BufferedReader 와 BufferedWriter를 사용해서 입력과 출력을 해보겠다. 한글자밖에 입력받지 못했던 InputStreamReader를 BufferedReader로 감싸서 객체를 생성하니 문자열 그대로를 가져와서 출력까지 성공했다. (여전히 %는 왜 출력되는지 모르겠다.) 원리는 다음과 같다. `InputStreamReader(System.in)` : 콘솔에서 입력한 문자를 문자 스트림으로 변환, 주의할 점은 InputStreamReader는 정수형 데이터만 입력받는다. 위의 경우처럼 다른 데이터타입으로 입력받으려면 InputStreamReader 객체를 다른 형변환해주는 객체로 감싸줘야 한다. 12InputStreamReader isr = new InputStreamReader(System.in);String number = String.valueOf(isr.read()); Buffer를 이용하여 입출력을 할 때는 String만 입출력이 되므로 다른 데이터를 입출력하고자 한다면, 형변환해서 사용해야 한다. buffer이용한 io 실습간단하게 코드를 작성해보자. 백준의 문제중 2908번 문제를 활용해보겠다. 문제를 요약하면, 두 수(세자리 수)를 한 줄로 입력받아 각각의 수의 백의자리 숫자와 일의자리 숫자의 위치를 바꾼 후, 두 수의 크기를 비교하여 더 큰 수를 출력하는 문제이다. 이 문제에 대해 내가 작성한 코드는 다음과 같다. 12345678910111213141516171819202122232425262728import java.util.Scanner;class Main &#123; int changeValue(String num)&#123; String[] temp = num.split(&quot;&quot;); String changed = &quot;&quot;; changed += temp[2]; changed += temp[1]; changed += temp[0]; return Integer.parseInt(changed); &#125; public static void main(String[] args)&#123; Main m = new Main(); Scanner sc = new Scanner(System.in); String nums = sc.nextLine(); sc.close(); String[] divide = nums.split(&quot; &quot;); if(m.changeValue(divide[0])&gt;m.changeValue(divide[1]))&#123; System.out.println(m.changeValue(divide[0])); &#125; else &#123; System.out.println(m.changeValue(divide[1])); &#125; &#125;&#125; 그러나 이 코드는 Scanner 객체를 사용하여 프로그램 성능이 떨어진다. 이 코드에서 io에 해당하는 코드를 buffer를 이용한 io 방식으로 바꿔보겠다. 1234567891011121314151617181920212223242526272829303132333435363738394041import java.io.InputStreamReader;import java.io.OutputStreamWriter;// StreamReader는 한글자씩밖에 저장을 할 수 없다고 한다.// 그래서 BufferedReader를 객체로 생성해서 입력받은 문자를 buffer에 저장한다.import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.IOException;class Main &#123; int changeValue(String num)&#123; String[] temp = num.split(&quot;&quot;); String changed = &quot;&quot;; changed += temp[2]; changed += temp[1]; changed += temp[0]; return Integer.parseInt(changed); &#125; public static void main(String[] args) throws IOException &#123; Main m = new Main(); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out)); String nums = br.readLine().trim(); br.close(); // BufferedReader 종료 String[] divide = nums.split(&quot; &quot;); if(m.changeValue(divide[0])&gt;m.changeValue(divide[1]))&#123; bw.write(String.valueOf(m.changeValue(divide[0]))); bw.flush(); // buffer에 남아있는것 모두 클라이언트로 전송후, 비운다. &#125; else &#123; // 출력을 위해서 String으로 변환해서 출력 bw.write(String.valueOf(m.changeValue(divide[1]))); bw.flush(); // 위와 마찬가지 &#125; bw.close(); // BufferedWriter 종료 &#125;&#125; 바꾼 코드로 다시 제출해봤다. IDE에서 코딩하지 않고, 마크다운 에디터(Typora)에서 코딩하고 확인업싱 바로 제출하느라 두번의 컴파일 에러가 있었다. 정상적으로 제출한 코드의 결과를 보니 시간이 100ms에서 80ms로 20%의 효율이 발생한 것을 확인할 수 있었다. 오늘은 조금 간략하게 정리했는데, 더 Stream에 대해 더 공부하고 파일 입출력과 함께 정리해보겠다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"io","slug":"io","permalink":"http://youngjinmo.github.io/tags/io/"}]},{"title":"Length와 Length() 그리고 Size()의 차이","slug":"java-length-size","date":"2019-12-08T13:12:38.000Z","updated":"2020-09-13T01:53:28.552Z","comments":true,"path":"2019/12/java-length-size/","link":"","permalink":"http://youngjinmo.github.io/2019/12/java-length-size/","excerpt":"","text":"자바에서 길이를 반환할 때 사용하는 메서드 또는 프로퍼티로 length, length() 그리고 size() 가 있다. 이것들의 차이를 제대로 이해하지 못한 상태에서 사용하다보니 Intelli J같은 IDE에서야 실수할 일이 없지만, vi 에디터로 코딩할 때엔 어떤걸 써야할지 헷갈리곤 한다. 그래서 정리하고자 이번 포스트를 작성하게 되었다. 일단 용도를 구분하면 다음과 같다. 함수 길이를 반환하는 데이터 타입 length 배열 length() 문자열 (String Object) size() 컬렉션 프레임워크 타입 (ArrayList, ..) 스택오버플로우에서 찾은 답변이 좋을 것 같아서 여기에 정리한다. 배열과 문자열은 immutable한 특징을 갖는다. 그리고 모든 최상위 Collection의 하위 클래스는 mutable한 특징을 갖는다. 그래서 “length” 라는 것을 봤다면, 그건 constant(=immutable) 변수일 것이다. 이와 반대일 때 “size”를 볼 수 있다. 가장 많이 vote된 답변을 rough하게 해석했는데, 눈여겨볼 점은 immutable한 특징이 될 것 같다. 영어로 “변경될 수 없다.”라는 뜻인데, 배열이 더 이상 변경되지 않는다는 점은 알겠는데 문자열이 변경되지 않는다고? 그래서 또 구글링을 해봤다.. Immutable이란 생성후 변경불가능한 객체를 의미한다고 한다. 대표적인 Immutable 클래스로는 String, Boolean, Integer, Float, Long 등이 있다. 그런데 여기서 말하는 Immutable이란 값 자체를 변경못한다라는게 아니라 heap 메모리에서의 변경이 불가능하다는 것이다. 즉 String str = &quot;a; 에서 str = &quot;b&quot;; 로 변경하는 값을 변경하는 것은 가능하지만, str 이 heap 메모리에서 가리키는 주소값이 바뀌는 것이 아니라는 이야기이다. 흠.. 아직 정확히 이해가 가진 않는다. Call by Reference와 Call by Value에 대한 이해가 필요해보인다. 출처 : #ashcode - 자바에서 Immutable이 뭔가요? 일단 length, length(), size() 의 역할을 정리하긴 했지만, 아직 정확히 이해하지 못했다. 추후 자바의 정석과 헤드퍼스트 책을 읽어보며 알아봐야겠다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"string","slug":"string","permalink":"http://youngjinmo.github.io/tags/string/"}]},{"title":"JAVA - String 객체간 비교","slug":"boolean-string","date":"2019-12-08T11:59:40.000Z","updated":"2020-09-13T01:53:29.340Z","comments":true,"path":"2019/12/boolean-string/","link":"","permalink":"http://youngjinmo.github.io/2019/12/boolean-string/","excerpt":"","text":"Java에서 String형 데이터의 비교방법이 두가지가 있다. 하나는 값만 비교하는 equals()함수이고, 다른 하나는 산술연산자 ==를 이용한 비교이다. 각각의 비교가 서로 어떻게 다른지 비교해보겠다. 12String str1 = new String(&quot;string&quot;);String str2 = &quot;string&quot;; 이렇게 2개의 String형 변수를 선언했고, 이제 이 변수들을 2가지 방법으로 비교할 것이다. 12345String str1 = new String(&quot;string&quot;);String str2 = &quot;string&quot;;System.out.println(str1.equals(str2));System.out.println(str1==str2); 123&#x2F;&#x2F; 출력 결과truefalse equals() 함수를 통한 비교는 예상한대로 true를 반환하여 출력했는데, str1==str2은 false가 반환되어 출력되었다. 이유는 equals() 함수는 값만 비교를 했지만, 산술연산자 == 는 객체 주소값을 비교했기 때문이다. str1과 str2의 객체 주소값을 확인하는건 System.identityHashCode()를 통해서 알 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"string","slug":"string","permalink":"http://youngjinmo.github.io/tags/string/"}]},{"title":"Github - Credential 저장","slug":"git-credential","date":"2019-12-03T07:29:58.000Z","updated":"2020-09-13T01:53:28.896Z","comments":true,"path":"2019/12/git-credential/","link":"","permalink":"http://youngjinmo.github.io/2019/12/git-credential/","excerpt":"","text":"Github Credential이란 Github의 계정정보를 말한다. 저장소에 push/pull 하거나 private 저장소를 clone하기 위해서는 해당 저장소를 이용할 수 있는 권한이 필요한데 이 때 credential에 계정 정보를 저장해두면 저장소 이용시마다 로그인할 필요가 없다. 터미널 명령어는 다음과 같다. 1234git config credential.helper storegit push https:&#x2F;&#x2F;github.com&#x2F;repo.gitUsername : your github emailPassword : your github password credential과는 무관하게 author와 email을 저장할 수도 있다. 12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;dev.youngjinmo@gmail.com&quot; 위의 명령어는 디렉토리 상관없이 전역(global)에서 사용할 수 있는 author와 email을 설정한 것이다. 설정해두면, 해당 운영체제 또는 컨테이너에서 커밋을 생성할 경우 해당 커밋에 author과 email이 기록된다. 출처 : https://git-scm.com/docs/git-credential-store","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"배열에서 사용할 수 있는 Fill()","slug":"java-string-arrays-fill","date":"2019-11-26T06:26:26.000Z","updated":"2020-09-13T01:53:28.440Z","comments":true,"path":"2019/11/java-string-arrays-fill/","link":"","permalink":"http://youngjinmo.github.io/2019/11/java-string-arrays-fill/","excerpt":"","text":"백준 알고리즘 문제를 풀다가 알게된 메서드 하나를 indexOf()에 이어 또 정리해본다. fill() 은 두 개의 파라미터를 요구하는 함수이다. 하나는 배열(모든 타입), 다른 하나는 해당 배열을 채울 데이터이다. 이 때 배열을 채울 데이터는 당연하지만, 배열의 데이터타입과 일치해야 한다. String[]이 파라미터로 주어졌다면, 이 배열을 채울 데이터 또한 String이어야 한다는 이야기이다. 12345678910111213141516171819import java.util.Arrays;class devandy&#123; public static void main(String[] args)&#123; // 배열 선언 String[] strArr = new String[5]; char[] charArr = new char[5]; int[] intArr = new int[5]; // 배열에 값 채우기 Arrays.fill(strArr, &quot;abc&quot;); Arrays.fill(charArr, &#x27;z&#x27;); Arrays.fill(intArr, 7); System.out.println(Arrays.toString(strArr)); System.out.println(Arrays.toString(charArr)); System.out.println(Arrays.toString(intArr)); &#125;&#125; 결과","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"string","slug":"string","permalink":"http://youngjinmo.github.io/tags/string/"},{"name":"array","slug":"array","permalink":"http://youngjinmo.github.io/tags/array/"},{"name":"fill","slug":"fill","permalink":"http://youngjinmo.github.io/tags/fill/"}]},{"title":"문자열에 사용할 수 있는 indexOf()","slug":"java-string-arrays-indexof","date":"2019-11-26T05:23:32.000Z","updated":"2020-09-13T01:53:28.432Z","comments":true,"path":"2019/11/java-string-arrays-indexof/","link":"","permalink":"http://youngjinmo.github.io/2019/11/java-string-arrays-indexof/","excerpt":"","text":"백준 알고리즘 문제를 풀다가 알게되어 정리해본다. String name = &quot;devandy&quot;; 에서 알파벳 a가 문자열 name에서 몇번째 인덱스에 있는가? 이 질문에 대해 그냥 풀어보면 이렇게 작성해볼 수 있을 것 같다. 12345678910111213141516171819class devAndy &#123; int searchIndexOf(String str, char c)&#123; String[] arr = str.split(&quot;&quot;); int indesx = -1; for(int i=0; i&lt;arr.length; i++)&#123; if(arr[i].equals(String.valueOf(c)))&#123; index = i; &#125; &#125; return index; &#125; public static void main(String[] args)&#123; devandy d = new devandy(); String name = &quot;devandy&quot;; char c = &#x27;a&#x27;; System.out.println(d.searchIndexOf(name, c)); &#125;&#125; 대략 20줄 내외의 코드가 필요하다. 인덱스를 찾는 메서드만 하더라도 딱 10줄이다. 그런데 indexOf() 를 사용하면 이렇게 길게 작성할 필요가 없어진다. 1234567class devandy &#123; public static void main(String[] args)&#123; String name = &quot;devandy&quot;; char c = &#x27;a&#x27;; System.out.println(name.indexOf(c)); &#125;&#125; char형 뿐만 아니라 String 데이터도 찾아준다. 공식문서를 보면, 문자열 데이터에서 parameter로 받은 문자(specified character)가 첫번째로 등장하는 인덱스를 반환하는 함수라는 설명이다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"string","slug":"string","permalink":"http://youngjinmo.github.io/tags/string/"},{"name":"indexof","slug":"indexof","permalink":"http://youngjinmo.github.io/tags/indexof/"}]},{"title":"스프링부트 웹 서버 실행시 자동으로 DB 삽입하기","slug":"springboot-import-sql","date":"2019-11-18T09:36:30.000Z","updated":"2020-10-25T12:40:57.873Z","comments":true,"path":"2019/11/springboot-import-sql/","link":"","permalink":"http://youngjinmo.github.io/2019/11/springboot-import-sql/","excerpt":"","text":"유튜브에서 박재성님이 올려놓으신 Spring-Boot, JPA로 질문/답변 게시판 구현과정을 보며 게시판 만드는 연습을 하고 있다. 4-2 영상에서 import.sql 파일을 생성해서 서버 실행시마다 자동으로 데이터를 주입하는 방법을 알려주셨는데, 처음에 잘 안되서 몇시간 삽질을 하다가 정호영님이 남겨놓으신 댓글을 통해 해결을 해서 여기에 정리해본다. 우선 현재 이 프로젝트는 H2 데이터베이스를 사용해서 연습을 하고 있다. H2 데이터베이스는 In-Memory 방식이기 때문에 서버가 재실행할 때마다 DB가 초기화되는 특징이 있다. 이렇기 때문에 연습하기에 좋기도 하지만, 단 회원 DB를 다루기 위해서 매번 프로그래머가 임의로 회원 DB를 생성하는 일은 번거로웠다. 그런데 resources 디렉토리에 import.sql 이라는 파일명의 sql 파일을 저장하면 sql파일 안의 쿼리를 읽어들여서 DB에 자동으로 주입해준다고 한다. 이렇게 resources 디렉토리 바로 하위에 import.sql을 생성하고, 파일 안에 유저정보를 추가하는 쿼리를 추가했다. 123INSERT INTO USER (USER_EMAIL, USER_NAME, USER_PASSWORD) VALUES(&#x27;user1@email.com&#x27;, &#x27;user1&#x27;, &#x27;12345678&#x27;);INSERT INTO USER (USER_EMAIL, USER_NAME, USER_PASSWORD) VALUES(&#x27;user2@email.com&#x27;, &#x27;user2&#x27;, &#x27;12345&#x27;);INSERT INTO USER (USER_EMAIL, USER_NAME, USER_PASSWORD) VALUES(&#x27;user3@email.com&#x27;, &#x27;user3&#x27;, &#x27;3456789&#x27;); 여기서 처음에 삽질했던 포인트 하나. sql 쿼리의 테이블 컬럼으로 도메인에 있는 User 객체의 컬럼명으로 입력했는데, 에러가 발생하면서 sql을 정상적으로 긁어오지 못했다. 그래서 아래의 h2-console에 접속해서 테이블 컬럼을 확인하고 다시 입력했다. 하지만 이렇게까지 해도 에러가 발생한다. 1org.hibernate.tool.schema.spi.CommandAcceptanceException: Unable to execute command 뭐 이런 에러가 발생하는데 실행하려는 명령어를 제대로 인식하지 못한다는 에러로 보여진다. 위에 sql 쿼리에 따로 ID 컬럼을 작성하지 않았는데, 이는 User.java에서 id 필드에 @GeneratedValue 어노테이션을 했기 때문에 입력하지 않아도 자동으로 입력되는줄 알았기 때문이다. 이 때 호영님의 댓글덕분에 해결할 수 있었다. @GeneratedValue 어노테이션에 속성값으로 (strategy = GenerationType.IDENTITY)를 입력하니까 ID 컬럼을 입력하지 않아도 자동으로 ID를 부여했다. 12345678910111213import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;@Entitypublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; ...&#125; 이클립스에서 확인해보니 GenerationType의 IDENTITY는 DB 컬럼에 사용되는 primary key를 명시하는 기능(?)으로 추정된다. 이제 서버 재실행을 할 때마다 유저정보가 자동으로 입력된다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Springboot","slug":"Dev/Springboot","permalink":"http://youngjinmo.github.io/categories/Dev/Springboot/"}],"tags":[{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"},{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"}]},{"title":"SpringSecurity에서 패스워드 암호화하기(A.k.a.passwordEncoder)","slug":"springsecurity-passwordencoder","date":"2019-11-18T09:36:20.000Z","updated":"2020-09-13T01:53:28.092Z","comments":true,"path":"2019/11/springsecurity-passwordencoder/","link":"","permalink":"http://youngjinmo.github.io/2019/11/springsecurity-passwordencoder/","excerpt":"","text":"SpringBoot로 프로젝트를 하면서 비밀번호를 암호화하는 작업을 배웠다. 기록을 위해 남겨둔다. 사용자는 패스워드를 평문 문자로 회원가입/로그인을 한다. 여기서 평문 문자(Plain text)란 암호화되지 않은 문자열 데이터를 말한다. 사용자의 패스워드는 서버에 저장되는데, 이 때 평문 문자로 저장이 되면, 서버를 관리하는 사람이 임의로 사용자들의 비밀번호에 접근할 수 있을뿐더러 서버가 해킹되었을시 비밀번호가 대량유출되면서 큰 피해를 입을 수 있다. 따라서 이를 방지하기 위해 암호화(encode) 작업이 필요하다. 비밀번호를 암호화하기 위해서는 스프링 시큐리티의 PasswordEncoder()를 사용한다. 인텔리J에서 PasswordEncoder() 를 사용하면 라이브러리를 불러오면서 라이브러리 경로를 볼 수 있는데, 이 때 PasswordEncoder()의 경로는 org.springframework.security.crypto.password 였다. 스프링 시큐리티의 내장 함수로 추정된다. 암호화를 위한 작업을 진행할 패키지와 PasswordEncoding이라는 클래스를 생성했다. 그리고 Spring Security의 PasswordEncoder를 상속(implement)받았다. 123456789101112131415161718192021222324import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;public class PasswordEncoding implements PasswordEncoder &#123; private PasswordEncoder passwordEncoder; public PasswordEncoding() &#123; this.passwordEncoder = new BCryptPasswordEncoder(); &#125; public PasswordEncoding(PasswordEncoder passwordEncoder) &#123; this.passwordEncoder = passwordEncoder; &#125; @Override public String encode(CharSequence rawPassword) &#123; return passwordEncoder.encode(rawPassword); &#125; @Override public boolean matches(CharSequence rawPassword, String encodedPassword) &#123; return passwordEncoder.matches(rawPassword, encodedPassword); &#125;&#125; BCryptPasswordEncoder()가 실제로 문자를 암호화해주는 메서드이다. 이 메서드는 암호화할 때마다 새로운 값을 생성해서 보안수준을 높혀준다. 이렇게 하면 서버에 저장된 비밀번호(encoded)를 분실해도 복호화(decode)하는 것이 사실상 불가능해진다. 잠시만, 그럼 로그인할 때 사용자가 비밀번호를 맞게 입력했는지 어떻게 알 수 있을까? 로그인할 때 사용자는 평문 문자를 입력한다. 그럼 서버에서 사용자가 입력한 평문 문자와 아이디(또는 이메일 주소)에 맞는 암호화된 비밀번호를 비교해서 회원여부를 검증한다. 정확히는 사용자가 입력한 비밀번호를 암호화해서 아이디에 맞는 암호화된 비밀번호를 서로 비교하는건데, 선뜻 이해가 가지않는다. 앞서 비밀번호는 암호화되서 생성된다고 했기 때문이다. 이 때 사용하는게 위에 PasswordEncoding 클래스에서 오버라이딩하여 작성한 matches()를 사용한다. matches()는, 아직 암호화되지 않은 평문문자와 암호화된 비밀번호를 서로 비교해준다. 이 비교방식은 복잡한 알고리즘이기 때문에 어떤 원리로 비교하는지는 알 수 없다. 테스트 코드를 작성해보았다. 1234567891011121314151617public class testPassword &#123; public void test()&#123; PasswordEncoding passwordEncoding = new PasswordEncoding(); String rawPassword1 = &quot;12345678&quot;; String rawPassword2 = &quot;12345678&quot;; String newPassword1 = passwordEncoding.encode(rawPassword1); String newPassword2 = passwordEncoding.encode(rawPassword2); System.out.println(&quot;newPassword1 : &quot;+newPassword1); System.out.println(&quot;newPassword2 : &quot;+newPassword2); System.out.println(&quot;boolean : &quot;+newPassword1==newPassword2); System.out.println(&quot;matches : &quot;+passwordEncoding.matches(rawPassword2,newPassword1)); &#125;&#125; rawPassword1과 rawPassword2는 정확히 같은 문자열을 갖고있다. 이 둘을 암호화해서 newPassword1과 newPassword2에 각각 저장했다. 그리고 이 둘을 직접 비교하는 코드를 작성했고, 다음줄에는 이 둘의 비교를 PasswordEncoding.java에 있는 matches()를 사용하여 비교해보았다. rawPassword1과 rawPassword2가 각각 어떻게 암호화되었는지 확인할 수 있으며, 같은 패스워드를 갖고있었던 두 변수들이 암호화되어 생성된 newPassword1과 newPassword2의 boolean 비교는 false였고, matches()로 암호화되기 전의 boolean 결과는 true였다. 이는 임의의 랜덤의 수를 생성해서 암호화하는 것이 아니라 입력받은 값에 따라 정해진 알고리즘에 의해 패스워드가 생성된다고 할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Springboot","slug":"Dev/Springboot","permalink":"http://youngjinmo.github.io/categories/Dev/Springboot/"}],"tags":[{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"},{"name":"spring-security","slug":"spring-security","permalink":"http://youngjinmo.github.io/tags/spring-security/"}]},{"title":"URI와 URL","slug":"http-uri-url","date":"2019-11-12T06:52:47.000Z","updated":"2020-09-13T01:53:28.688Z","comments":true,"path":"2019/11/http-uri-url/","link":"","permalink":"http://youngjinmo.github.io/2019/11/http-uri-url/","excerpt":"","text":"그래도 웹 개발로 취업을 준비하면서 HTTP에 대해 지나치게 무지한게 아닐까 생각하여 정리하게 되었다. URI와 URL에 대해 다뤄보았다. URI는 Uniform Resource Identifier의 약자이다. 인터넷에 있는 자원을 나타내는 고유한 주소를 나타내는 규약이다. URL은 Uniform Resource Locator의 약자이다. 네트워크상에서 자원이 어디있는지 정확한 위치를 알려주는 규약의 형태이다. 즉, URI가 보다 넓은 범위의 개념이고, URL은 URI의 하위개념이라 볼 수 있다. URL이 가장 흔한 형태의 URI 규약 형태이기 때문에 일반적으로 URI라고 하면, URL이라고 생각해도 무방한듯하다. 참고로 이 글의 URL 주소를 뜯어보면(?). https:// : 리소스에 접근하기 위해 사용되는 프로토콜. 스킴이라고 한다. youngjinmo.github.io : 인터넷 주소 또는 호스트 주소를 의미한다. /2019/11/http-uri-url : 웹 서버상에서의 리소스 주소를 의미한다. URL과 같은 규약의 형태로 URN도 존재한다. URN은 Uniform Resources Name의 약자이며, 객체의 절대위치를 가리키는 규약의 형태이다. URN은 URL을 보완하기 위해 등장한 것으로 보인다. URL의 경우 가라키는 파일이 이동했을 경우 더 이상 URL이 유효하지 않게 되는데, URN은 객체의 이름을 가리키므로 가리키는 파일의 경로가 이동되도 URN은 유효하다는 특징이 있다고 한다. References honeysuckle - URL vs URI","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Web","slug":"Dev/Web","permalink":"http://youngjinmo.github.io/categories/Dev/Web/"}],"tags":[{"name":"http","slug":"http","permalink":"http://youngjinmo.github.io/tags/http/"}]},{"title":"Duet 디스플레이 한 달 사용후기","slug":"review-duet","date":"2019-10-23T10:37:12.000Z","updated":"2020-09-13T01:53:28.204Z","comments":true,"path":"2019/10/review-duet/","link":"","permalink":"http://youngjinmo.github.io/2019/10/review-duet/","excerpt":"","text":"\u0019지난달에 구입하여 한 달 조금 넘게 사용한 Duet 디스플레이에 대한 후기를 공유한다. 1. Price 앱스토에서 12,000원에 구매했다. 앱스토어가 이제 한화결제를 지원하기 때문에 국내 신용카드로 편하게 결제를 했던 기억이 난다. 모바일 앱이 12,000원이 저렴하다고 볼 순 없으나 일반적으로 앱스토어에서 인기있는 유료 아이패드앱들의 평균가격이 $10 달러 선임을 고려하면 비싸다고도 볼 수 없는 가격이다. 특히 이 제품으로 아이패드를 맥/윈도우의 외장 모니터로 만들 수 있기 때문에 휴대용 외장모니터를 이 가격에 살 수 있다면 오히려 가격 메리트가 있다고 생각한다. 2. Resolution사실 이 앱을 알게된지 몇 년이 되었음에도 아직까지 구입하지 않은 이유 중 하나이다. 유명한 앱이긴 하나 직접 본적이 없다보니 혹시나 저화질로 재생이 미러링이 된다면, 12,000원이 아까울 것 같았기 때문이다. 그러나 지금은 후회하고 있다. 처음 이 앱을 알았을 때 바로 질렀어야 한다. 앱스토어 후기는 구매내역 삭제를 요구하는 리뷰를 제외하곤 믿을만한 곳이었다. 일반 외장모니터만큼 깨끗하다고 볼 수는 없으나 후회전혀 없을만큼 아주 좋다. 3. Input Leg화질도 화질이지만 걱정했던건 혹시나 딜레이가 발생하진 않을까 싶었지만, 그런것도 없었다. 혹시나 Duet 구매를 고민하고 있는 분이라면 아래 녹화영상을 보고 판단바란다. 4. My opinion아주 훌륭하지만, 당신이 맥을 사용하고 있고, 아이패드가 iOS13을 지원한다면 구매할 필요는 없다. 애플은 2019년 소프트웨어 업데이트를 통해 맥OS의 새로운 버전 Catalina와 아이패드의 새로운 운영체제, iOS13에서 사이드카 기능을 추가했다. 사이드카는 아이패드와 맥을 미러링하는, 그러니까 Duet과 완전히 같은 기능이다. 역으로 맥 사용자가 아니거나, 아이패드가 iOS13을 지원하는 모델이 아니라면, Duet 구매를 추천한다. 12,000원이 후회되지 않을거다. 난 지금도 이 글을 작성하면서 Duet으로 유튜브 영상을 보면서 작성하고 있다. ^^","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Review","slug":"Life/Review","permalink":"http://youngjinmo.github.io/categories/Life/Review/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://youngjinmo.github.io/tags/ios/"},{"name":"ipad","slug":"ipad","permalink":"http://youngjinmo.github.io/tags/ipad/"}]},{"title":"Java - Date","slug":"Java-Date","date":"2019-10-23T03:33:46.000Z","updated":"2020-09-13T01:53:29.836Z","comments":true,"path":"2019/10/Java-Date/","link":"","permalink":"http://youngjinmo.github.io/2019/10/Java-Date/","excerpt":"","text":"스프링으로 웹 애플리케이션을 개발해보는중 ‘매 접속시마다 내가 현재 창을 언제 리프레쉬 한건지 알 수 있었으면 좋겠다’ 싶었다. 그래서 인텔리J 콘솔에 웹 서버를 실행한 시점의 시간을 출력하도록 작성해보았는데 이 과정에서 사용한 Date 클래스를 간략하게 공유해본다. Date 객체 이용하여 날짜 출력하기12345678import java.util.Date;class date_tutorial &#123; public static void main(String[] args)&#123; Date date = new Date(); System.out.println(date); &#125;&#125; 위의 코드는 다음과 같은 날짜를 출력한다. 포맷 바꿔서 Date 출력하기위의 방식은 Date 객체를 그대로 출력했다. 하지만 포맷을 내가 원하는대로 출력할 수도 있다. java.text.SimpleDateFormat 을 import해서 Date 객체의 인스턴스를 인자로 사용하는 format 객체를 이용하면 포맷을 내가 커스터마이징 할 수 있다. 123456789101112131415import java.util.Date;import java.text.SimpleDateFormat;class date_tutorial &#123; public static void main(String[] args)&#123; Date day = new Date(); SimpleDateFormat date = new SimpleDateFormat(&quot;yyyy년 MM월 dd일&quot;); SimpleDateFormat clock = new SimpleDateFormat(&quot;a hh시 mm분 ss초&quot;); System.out.println(&quot;서버 실행한 날짜는 &quot;+date.format(day)); System.out.println(&quot;서버 실행한 시각은 &quot;+clock.format(day)); &#125;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"터미널에서 디렉토리 한눈에 보기(feat.Tree)","slug":"package-tree","date":"2019-10-22T07:13:35.000Z","updated":"2020-09-13T01:53:28.220Z","comments":true,"path":"2019/10/package-tree/","link":"","permalink":"http://youngjinmo.github.io/2019/10/package-tree/","excerpt":"","text":"터미널에서 디렉토리를 보는 방법은 ls -al 또는 똑같은 명령어인 ll 로 보는 방법이 있다. 그러나 이 방법으로는 현재 디렉토리가 어떤 계층구조로 디렉토리 트리가 구성되어 있는지 알기어렵다. 한 번에 다른 디렉토리로 이동하기 어렵다는 이야기이다. 이를 해결할 수 있는 패키지가 Tree 패키지이다. 패키지 설치Tree 패키지를 설치하려면 Homebrew를 우선 설치해야 한다. 그리고 Homebrew를 이용해 간단히 설치할 수 있다. 1$ brew install tree Tree 로 디렉토리 확인","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Linux","slug":"Dev/Linux","permalink":"http://youngjinmo.github.io/categories/Dev/Linux/"}],"tags":[{"name":"homebrew","slug":"homebrew","permalink":"http://youngjinmo.github.io/tags/homebrew/"}]},{"title":"자바 실행환경 훑어보기(MacOS)","slug":"explore-java-environment","date":"2019-10-22T04:25:52.000Z","updated":"2020-10-14T05:53:06.132Z","comments":true,"path":"2019/10/explore-java-environment/","link":"","permalink":"http://youngjinmo.github.io/2019/10/explore-java-environment/","excerpt":"","text":"생활코딩의 자바야학을 통해서 알게되어 작성하게되었다. 현재 사용중인 맥OS에서 자바의 실행환경을 훑어보는 방법이다. 1) jdk 설치 경로 확인터미널을 열어서 아래 명령어를 입력하면 jdk가 설치된 경로를 출력해준다. 1$ /usr/libexec/java_home 2) 해당 경로로 이동홈 디렉토리로 이동한다. 1$ cd ~ 여기서부터 콘솔에 출력된 경로를 붙여넣기해서 이동한다. 1$ cd &#x2F;Library&#x2F;Java&#x2F;JavaVirtualMachines&#x2F;jdk1.8.0_202.jdk&#x2F;Contents&#x2F;Home&#x2F;bin 3) bin 디렉토리 확인그동안 허접했지만 vi에디터로 작성해서 터미널에서 바로 컴파일하며 사용했던 패키지 javac 가 이곳에 있는걸 알 수 있다. 자바를 실행할 수 있는 모든 자원들이 이 디렉토리에 있는 것이다. 자바의 실행환경은 이 jdk의 폴더에서도 bin 폴더를 참조?(환경변수)해서 자바의 실행환경을 구성하게된다. 윈도우 사용자는 처음 자바를 설치할 때 환경변수 설정을 수동으로 해야하지만, 맥이나 리눅스 계열은 개발자가 특별히 환경변수를 만질 필요가 없다. 그러나 만약 jdk가 제대로 실행되지 않는다면, 아래의 방법을 따라가면서 환경변수를 설정할 수 있다. 4) 환경변수 설정홈 디렉토리에 .bash_profile 파일을 생성해서 환경변수를 설정한다. .bash_profile 파일 생성 1$ vim ~&#x2F;.bash_profile 환경변수 설정 그러나 맥에서는 환경설정을 할 필요가 없다는 사실을 다시 한 번 알아두자.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"WeeklyReview - 10월 3주차","slug":"WeeklyReview-2019-Oct-Third","date":"2019-10-21T05:33:58.000Z","updated":"2020-09-13T01:53:29.652Z","comments":true,"path":"2019/10/WeeklyReview-2019-Oct-Third/","link":"","permalink":"http://youngjinmo.github.io/2019/10/WeeklyReview-2019-Oct-Third/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 읽었는가 무엇을 보았는가 다음주엔 무엇을 하겠는가 무엇을 했는가TIL을 매일 하는데 실패하고 있다. 주말이 관건이다.. 일주일에 딱 한번 데이트를 하곤 하는데, 아침에 원격으로 스터디를 하고 바로 노원에서 데이트를 하고 집에오니 이 시간동안 TIL을 하기 어려웠다는 불필요한 핑계를 나도 모르게 늘어놓고 있다…. 지난주 TIL까지는 위클리 리뷰에 적어두곤 했는데, 이렇게하니까 내가 언제 무엇을 공부했는지 알기 어려웠다. 그래서 나만의 개발 지식맵(?)을 만들어 나갈겸 깃헙에 레포를 새로 만들어두고 카테고리별로 해두고 커밋단위로 TIL을 진행하는 것으로 바꾸었다. 이렇게 하면 각 영역별로 내가 무엇을 얼마나 아는지도 알 수 있고, 커밋 메세지를 통해 언제 무엇을 공부했는지도 알 수 있기 때문이다. 지난주 위클리 리뷰에서 주말 스터디에 대한 걱정을 했는데, 일단 첫 원격 스터디는 무사히 진행이 되었다. 어처구니 없는 일이 하나 있었는데, 하필 원격 스터디가 예정된 날의 바로 전날 밤(토요일 밤)에 집의 인터넷이 고장나버렸다. 일요일 아침에 원격으로 스터디를 하고, 바로 여자친구에게 가야하는데, 하필 이런 날 집에서 인터넷 사용이 어려워져서 아침부터 부리나케 카페를 가야만했다. 참고로 4명중 한명은 C# 개발자로 취업하면서 스터디를 나갔다. 그래서 앞으로 3명이서 해야하는데, 나머지 한 명이 회사 사정으로 참석을 못하면서 이번엔 2명이서 원격으로 진행했다. 카페에 도착해서 행아웃을 걸었지만, 이미 예정된 시간보다 15분이 늦었다. 여기에 상대가 마이크 이슈로 인해 셋팅을 이것저것 만져보느라 또 다시 15분이 늦어지며 예정된 시간보다 30분이 지연된채로 원격 스터디는 진행되었다. 결과적으로 나쁘지는 않았다. 함께 스터디를 한 사람이 용인에 사는 사람인데 그동안 강남쪽으로 부르는게 부담스러웠는데 서로 편하고 좋았다. 또 기취업자기 때문에 회사경험을 사례로 이야기를 해준덕분에 미취업자인 나한텐 도움이 될 것 같다. 다만 앞으로 2명이서 스터디할 날이 왠지 많아질 것 같은 느낌이 들곤하는데, 2명보다는 자주 참석할 수 있는 한 명이 더 있으면 좋겠다라는 생각은 든다. 행아웃으로 진행하기 때문에 완전히 모르는 사람을 모셔오면 서로 어려울것 같고, 기존 학원 멤버들 중에 스터디에 흥미있는 사람을 더 데려올 수 있으면 좋을 것 같다. 백준 알고리즘에서 문제를 풀고있는데, 배열에서 좀 막히고 있다. 어려운 문제가 아님에도 시간이 오래걸리거나 충분한 시간을 두었음에도 불구하고 끝내 해결못할 때도 발생하다보니 좀 지치는 것 같다. 다음주에 윈터코딩 코딩테스트가 있는데 걱정이다. 그리고 웹 서버 개발을 위해 도커환경에서 우분투를 개발해봤는데, 재밌었다. apt-get 패키지 매니저로 필요한 패키지들을 설치하고 셋팅했는데, 일단 단순한 정적 페이지를 출력하는데는 실패했다. 포트 번호 때문에 그런것 같다. 이후 같은 과정을 AWS로 해봤는데 개발속도가 훨씬 빨랐다. 생산성이 높았다. 도커는 도커대로 계속 연습을 해보고, AWS도 짬짬히 계속 만져봐야겠다. 무엇을 읽었는가 박재성 - 목적의식 있는 연습을 통한 효과적인 학습 1기때 지원했다가 떨어졌었던, 평소 유튜브에서 재미있게 보고있는 우아한테크코스의 진행자(?) 박재성님의 블로그 포스팅 글이다. 최근에 유튜브에서 재성님께서 올리신 영상으로 스프링부트를 공부하다가 우연히 보게 된 글이다. 재성님은 익숙해질때까지 반복하라고 말씀하셨다. 일반적으로 일정 수준에 도달하기 위해서는 *”더 시간이 필요하다”*라고 이야기 하곤 하는데, 사실 시간은 아무것도 해결하지 않는다. 박재성님이 반복적으로 말씀하시는 *”반복”*이야말로 다음 스텝으로 넘어갈 수 있는 결정적인 key라고 생각한다. 평소 학습량이 부족하다고 느끼지는 않으나 학습속도(?)가 더디다는 생각이 들다보니 조바심이 들곤 하는데, 시간이 조금 더 걸릴지언정 계속 반복하고 최소한 내가 공부한 영역에서는 한 스텝이라도 올라갈 수 있도록 노력해야겠다. starla - 40+20 작업법 포모도로 기법으로 시도를 하니까 분명 생산성이 높아지는듯 하나 25분 + 5분은 나에게 좀 애매한 시간분리였다. 그런데 이 글에서 제안한 40분 + 20분은 집중력을 유지하기에도 충분하고, 휴식도 충분한 시간이 주어졌다. 그래서 아침에 이 글을 읽고 오늘 바로 적용해서 해봤는데, 아직 깔끔하게 수행하고 있지는 못하나 이전보다는 40분 + 25분이 더 편했다. 의식적으로 지키기위해 노력해봐야겠다. 무엇을 보았는가. 개발왕루피 - 우아한테크코스 2기? 지원하세요. 비전공자 크루가 직접 들려주는 이야기 1편 우아한테크코스에 관심이 많은데, 어떤 분이 어떻게 합격해서 공부하고 있을까 궁금하던 차에 발견한 유튜브 채널이다. 루피님은 우아한테크코스에서 우아한형제들의 도서관리시스템을 개발하셨다고 한다. 이 영상을 보니 더 하고싶은 마음이 커지면서도 자신감이 떨어지기도 했다…ㅋ 어쨋든 계속 구직은 미룰수 없는 상황이기 때문에 우아한테크코스에 지원해보고 불합격되면 바로 구직에 나설 생각이다. 합격하면 개발자로서의 가능성, 성장을 할 수 있도록 최선을 다해 볼 생각이다. 다음주엔 무엇을 하겠는가이번주엔 스프링부트 스터디에서 진행하고 있는 프로젝트의 개발을 본격적으로 진행할 생각이다. 그 동안 프로젝트에 필요한 개념/이론 공부를 진행했는데, 이제 개발을 할 때가 된 것 같다. 이와 함께 도커에서 그리고 AWS EC2 인스턴스에서 우분투 컨테이너 위에서 웹 애플리케이션을 구동시켜보는 것까지 테스트 해보고싶다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Vim 에디터 주요 명령어","slug":"commands-of-vim","date":"2019-10-15T14:01:22.000Z","updated":"2020-09-13T01:53:29.212Z","comments":true,"path":"2019/10/commands-of-vim/","link":"","permalink":"http://youngjinmo.github.io/2019/10/commands-of-vim/","excerpt":"","text":"우분투를 쓸 일이 늘어나면서 vi 에디터를 가끔 사용하게 되는데, 이 때 익힌덕분에 코딩문제 풀 때 무거운 IDE 열지않고 그냥 iTerm 열어서 vim에디터로 코드를 작성하곤 하고 있다. 기왕쓰는거 자주사용하는 유용한 명령어를 정리해두고 사용하면 좋을 것 같아서 이 글을 작성해보았다. 목차 입력 명령어 커서 이동 명령어 파일 상태 변경 명령어 입력 명령어 입력키 작업 i 현재 커서의 위치에서 입력 시작 a 현재 커서보다 한 칸 뒤에서 입력 시작 A 현재 커서 위치에서 줄의 끝에서 입력 시작 o 현재 커서의 다음 줄에서부터 입력 시작 u 직전 작업 되돌리기 U 전체 변경사항 되돌리기 ESC 입력모드 종료 dd 커서가 있는 한 줄 삭제 3dd 3 줄 삭제 dw 커서가 있는 단어 삭제 4dw 4 단어 삭제 D 현재 커서부터 뒤의 컨텐츠 삭제 (한 줄 단위) x 한 문자형(char) 삭제 r 한 문자형 변경 yw 현재 커서 위치의 단어 복사 y$ 현재 커서 위치부터 줄의 끝까지 복사 yy 현재 커서가 있는 줄 전체 복사 yj 현재 커서의 줄과 다음 줄을 복사 yk 현재 커서의 줄과 앞의 줄을 복사 p 붙여넣기 커서 이동 명령어 입력키 작업 k ↑ j ↓ h ← l → 파일 상태 변경 명령어 입력키 작업 :w 파일 저장 :q 종료하기 :wq 저장하고 종료하기 References Vim Text Editor with Commands: Linux/Unix Tutorial Vim 에디터 사용법","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Linux","slug":"Dev/Linux","permalink":"http://youngjinmo.github.io/categories/Dev/Linux/"}],"tags":[{"name":"vim","slug":"vim","permalink":"http://youngjinmo.github.io/tags/vim/"}]},{"title":"WeeklyReview - 10월 2주차","slug":"WeeklyReview-2019-Oct-Second","date":"2019-10-13T11:16:52.000Z","updated":"2020-09-13T01:53:29.676Z","comments":true,"path":"2019/10/WeeklyReview-2019-Oct-Second/","link":"","permalink":"http://youngjinmo.github.io/2019/10/WeeklyReview-2019-Oct-Second/","excerpt":"","text":"목차 한 주 간의 TIL 한 주간 무엇을 했는가 무엇을 읽었는가 무엇을 보았는가 다음주엔 무엇을 하겠는가 한 주 간의 TIL 2019.10.08 Math 클래스를 안쓰고 반올림하는 방법 Math클래스를 쓰는것보다 복잡해서 생산성은 떨어지는 방식이지만, 반올림에 대한 메카니즘(?)을 이해할 수 있었다. 자바에서 문자열 String은 클래스였다. 원래 String형 변수를 선언할 때에 객체를 생성하듯이 new 키워드(예약어)를 사용해야 하지만 생략이 가능하다. String str1 = new String(&quot;abc&quot;); String str2 = &quot;abc&quot;; boolean test = str.equals(str2); // true git checkout 은 branch가 아니라 head를 변경한다. 정확히는 head의 방향! git reset 은 head가 가리키는 branch를 변경 git에선 아무것도 삭제하지 않다. 모든 기록을 저장할 뿐. git reflog를 통해 모든 활동을 확인할 수 있다. merge, checkout 등. auto-merge 되는 커밋이 많을 수록 버전관리가 잘되고 있는 것이다. 프로그래머가 직접 merge하는 일은 코드의 양이나 파일의 양에 따라 매우 어려운 일. 3-way-merge 두 개의 커밋이 동일한 파일을 변경한 상태에서 merge 할 경우 어떤 변경사항을 새로운 커밋에 담을지 git에서 물어보는데, 이 때 두 커밋이 공통으로 바라보는 원래의 커밋 즉 BASE를 기준으로 match하는 코드와 match하지 않는 코드를 비교. git config --global merge.conflictstyle diff3 웹 페이지에서 데이터 긁어오는 법 (a.k.a curl) CLI에서 web browser가 아니어서 데이터를 못 긁어올 경우, 클라이언트 정보를 추가해서 입력할 경우 서버를 속여서 가져올 수 있음. curl -H \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/44.0.2403.89 Safari/537.36\" 2019.10.09 자바에서 문자열 비교시엔 == 대신 equals() 를 써야 한다. 자바에서 String 은 단순 데이터 타입이 아니라 클래스인데 여기서 비교 연산자 == 를 사용하면 값을 비교하기 앞서 클래스를 비교하기 때문에 의도한 값이 반환되지 않을 수 있다. 그러나 equals() 를 사용하면 클래스 비교없이 값만을 비교할 수 있다. 배열도 문자열 처럼 비교할 수 있다. Arrays.equals(arr1, arr2) 2019.10.10 git add -f 강제로 staging area에 올리고 싶은 파일이 있을 때, -f 사용. .gitignore 를 생성했는데 sourceTree에서 파일이 안보이길래 명령어 강제해서 stagaing area에 올림. 2019.10.11 42 Seoul 설명회 참석 예전에 NHN Next를 떠올리게 할만큼 매력적인 교육기관이다. 다른 것은 강사가 없고 강의가 없다는 것이다. 매주 과제가 주어지고 이를 학생들 스스로가 해결하는 과정이다. 교육비X, 강사X, 교재X 전통적인 교육방식의 대학과는 완전히 다른 기관이다. 정부지원으로 운영되며, 파리에 있는 에꼴42의 프로그램을 그대로 가져오는 프로그램이다. 이름에서 알 수 있듯 이들 독립적으로 운영되는게 아니라 이들 네트워크가 활용될 것으로 예상된다. 2년의 교육과정과 내 나이를 고려했을 때, 솔직히 초반만 하더라도 \"내가 여기 참여했을 때 충분한 가치를 얻어올 수 있을까?\" 라는 질문에 시원하게 YES를 못하고 있었는데 이 과정이 전달하고자 하는 가치가 수료증이 아니라 교육 그 자체에 있으며, 이로인해 열정 있는 학생들과 성장할 수 있다는 점이 내게 엄청 큰 베네핏으로 다가왔다. 현재 실력으로 SI 중소기업에 입사하는 것보다 이 과정을 이수하며 좋은 동료를 얻는 것이 비교할 수 없는 큰 가치라고 생각했다.되든 안되든 무조건 지원해볼 생각이다. wget 도커로 우분투 컨테이너를 생성해서 우분투 환경에서 웹서버를 구축중이다. 이과정에서 알게된 명령어인데, apt-get 과는 좀 다른 명령어이다. apt-get 이 우분투 기본 패키지 매니저라면, wget 은 웹 상에서 파일을 다운받아올 때 쓰는 명령어라고 한다. 참고 문서 : ask ubuntu - Apt-get vs Wget Way to install java in ubuntu check ubuntu version uname -a get download link from oracle old version install java via wget from command line wget --header \"Cookie: oraclelicense=accept-securebackup-cookie\" https://download.oracle.com/otn/java/jdk/8u202-b08/1961070e4c9b4e26a04e7f5a083f551e/jdk-8u202-linux-x64.tar.gz ask ubuntu - install specific java version for 12.04 2019.10.12 생활코딩 강의를 통해 배운 리눅스 명령어들 --help & man --help는 궁금한 커맨드의 뒤에 붙여서 입력하면 현재 입력창에서 간단히 볼 수 있는 설명서 man은 궁금한 커맨드의 앞에 붙여서 입력하면 다른 창으로 넘어가서 더 상세한 설명서를 볼 수 있음. 문서에서 키워드 검색하기 /뒤에 찾고 싶은 키워드를 입력하면 현재 보고있는 문서에서 키워드를 검색해서 보여준다. 여기서 N을 입력하면 이동하면서 다음 키워드를 보여준다. 디렉토리 계층구조 생성 mkdir -p [directory1/directory2] 디렉토리를 이동하지 않고도 디렉토리 내 파일확인하기 ls -l [directory] 내가 자주 사용하는 리눅스 명령어 조회 history | awk '&#123;a[$2]++&#125;END&#123;for(i in a)&#123;print a[i] \" \"i&#125;&#125;' | sort -rn |head -10 개발에 필요한 패키지 설치한 도커 이미지 생성하여 배포함 도커헙에 있는 우분투 공식 이미지는 거의 패키지가 없다시피한 기본 이미지였다. 즉시 개발하기엔 필요한 apt-get, sudo, git, vi 등이 없어서 개발에 필요한 이들 패키지들을 설치 후, 도커 이미지로 생성하여 도커헙에 배포해두었다.앞으로 우분투 웹 서버가 필요할 때 이 이미지를 불러와서 개발하면 편할 것 같다. 무엇을 했는가 자바의정석 뽀개기(?) 중 자바를 좀 제대로 공부하기 위해서 책을 정독…까지는 아니지만 거의 정독에 이를만큼 다시 읽고있다. 이전에는 백과사전처럼 두고 필요한것만 빼서 읽곤 했는데 그러니까 지식이 듬성듬성 채워진것 같아서 예제 코드까지 함께 상세하게 읽고 있는데 아직 챕터 3까지밖에 정리하진 못했지만 이 부분에서도 새로 알게된것들이 있어서 도움이 되고 있다. 책의 뒷부분에서는 아는 것보다 모르는 부분이 더 많기 때문에 더 도움이 될 것 같다. 이고잉님의 지옥에서 온 Git 오프라인 강의 참여 이고잉님이 주최하신 지옥에서 온 Git 오프라인 강의를 참석하고 왔다. 그래도 평소에 Git에 어느정도 안다고 자부했지만, 막상 강의를 들으니까 이 또한 작은 오만이었음이 금방 드러났다. 3-way-merge를 배웠는데 아직 익숙치 않은 개념이다. 하지만 지금까지 merge할 때 충돌이 발생할 것을 우려해 최대한 충돌을 피하거나 reset을 하곤 했는데, merge가 어떻게 이뤄지는지 다시 배우게 된 것 같다. 42서울 설명회 참석 프랑스의 에꼴42를 벤치마킹한 프로그램이 한국에서도 진행한다고해서 설명회를 다녀왔다. 강사도, 교재도, 수업비도 없는 프로그램이며, 매주 과제를 수행하며 과제를 수행하기 위해 스스로 또는 협력해서 학습을 해야한다고 했다. 정해진 커리큘럼에 종속되기보다 자주적으로 학습하는 걸 좋아하는 내게 좋은 기회라는 생각이 들었다. 수능을 마친 학생들도 와서 설명회를 듣는걸보니 조금 더 이른 나이에 이런 기회가 있었으면 좋았겠다라는 생각도 들었다. 그러나 일단 지나간 시간은 어쩔수 없고, 지나간 시간 동안에도 배운게 많으므로 앞으로의 미래를 생각해보면, 1년에서 2년정도를 이 프로그램에 투자하는건 투자대비 아웃풋이 더 큰 프로그램이 될 것 같았다. 무엇보다 문턱이 낮지않기 때문에 열정적인 사람들을 많이 만날 수 있을것 같았다. 이들과 함께 성장하고 네트워크를 형성하는 일은 돈을 주고도 못하는 일이기 때문에 1-2년 투자는 아깝지 않은 투자라는 생각이 든다. 그래서 지원해보려고 한다. 주말 스터디 개편(?) 지난 주말 스터디가 열리지 않았다. 모든 멤버들로부터 스터디 약속시간의 1시간 전에 일시에 불참 통보를 받으면서 캔슬이 되었다. 솔직히 이 스터디가 유지될것 같지않았고, 여기에 리소스를 투입하는 것이 후회스러울 것 같았다. 그래도 한 번만 더 노력해보자라고 생각을 돌려보았다. 학원에서 면접 할 때 받을 수 있는 질문 중 하나로 “어려움을 어떻게 극복하였는가” 라는 질문을 받을 수 있다고 알려주셨는데, ‘과연 이 스터디도 쉽게 포기한다면 이 질문에 내가 어떻게 답할 수 있을까’ 생각해보니 내가 할 수 있는한 최선을 다해보고, 그래도 안되면 결과를 받아들이는 것으로 생각을 바꾸었다. 현 스터디의 문제 그리고 해결방안. ❗️우선 우리의 스터디는 테헤란로에서만 진행하고 있는데, 이곳이 접근성이 좋다기보다는 그나마 상충한 지역이 여기밖에 없었기 때문이다. 기취업자 두 사람은 대중교통 기준 테헤란로에서 1시간 거리에 거주하고 있다. 때문에 평일까지 회사일을 마치고 토요일 아침에 1시간 가량의 거리를 오는 것은 쉬운 일이 아닐거라고 판단했다. 💡 오프라인을 고집하기보다 온라인 미팅을 제안했다. 오프라인만큼 학습 효율이 있을지는 모르지만 오프라인이기 때문에 발생할 수 있는 이동시간, 식사시간 등의 낭비를 절약할 수 있을거라고 생각했다. OS 제약이 없고, 무료이며 N:N 화상미팅 및 스크린 공유가 가능한 서비스가 필요했고, 이 모든 조건을 충족하는 Hangout을 솔루션으로 결정했다. 다음주 주말 스터디는 Hangout으로 원격으로 진행해보기로 했다. ❗️또 하나는 시간대였다. 앞서 설명했듯 평일까지 일을 마치고 주말 오전에 일시에 오는 피로감을 모르지 않다. 때문에 기취업자들을 고려하여 토요일 오전 대신 일요일 오전으로 시간대를 변경하기로 했다. 상대적으로 여유가 있을 거라고 생각했다. 💡 토요일 오전 대신 일요일 오전으로 변경했다. 토요일 오전에 몰려오는 피로감을 피할 수 있고, 오전에 스터디를 마침으로써 오후엔 개인시간을 편하게 쓸 수 있다는 점 때문에 일요일로 결정했다.개인적으로 평일로 제안했지만, 현재 기취업자들의 회사 특성상 랩탑 소지가 불가능하고, 회사에서 집까지의 거리를 고려했을 때 평일 회의참여 시간이 저녁 10시를 넘기는 것이 불가피하고 이는 스터디에도, 다음날 출근에도 영향을 미칠 수 있다고 판단하여 일요일 오전으로 결정했다. ❗️스터디의 방향이 불명확한 것이 동기부여에 영향을 주었다고 생각했다. 백기선님 영상을 보면서 스터디의 목표를 분명하게 하는 것이 좋겠다는 생각이 들었다. 리더가 없는 스터디를 효과적으로 진행하기 위해서는 각자가 분담해서 공부한걸 리뷰하기 보다는 모두 같은 영역을 공부해서 서로 리뷰하면 토론도 할 수 있고, 이를 통해 더 단단히 배울 수 있을거라고 의견이 모였다. 💡 그래서 서로 같은 영역을 공부할 수 있는 책을 선정해서 스터디를 하기로 했으며, 책은 토비의 스프링으로 결정했다. ❗️스터디에 불참하면 다른 스터디원들에게 미안해하고, 스터디에 참석한 사람들은 불참한 사람들 때문에 학습기회를 상실하는 지난 주의 경험이 다시 발생하지 않도록 하기 위해 스터디에 대한 책임을 아예 없애보려고 한다. 스터디에는 자유롭게 참석이 가능하되, 스터디에 참여하는 것이 이익이 되게끔 방향을 바꾸어보려고 한다. 💡 그래서 책을 읽어보고 각자 추가로 공부를 해와서 이에 대한 리뷰를 공유하고, 한 주간 새로배운 지식을 공유하는 시간도 가져보려고 한다. 이를 통해 스터디에 참석하면 얻어가는 것이 있고, 참석하지 않으면 이를 포기하는 프레임을 갖춰보려고 한다. 무엇을 읽었는가 IT썸남썸녀 - 자바 예약어/키워드 정리 자바의 정석을 다시 읽어보면서 자바 예약어나 키워드를 정리하면 좋겠다라는 생각이 들었는데, 역시 구글링해보니까 누가 정리해주신 글이 있었다. 일단 이 글을 보면서 책을 읽었는데 나중엔 내가 작성해서 블로그에 정리해볼 생각이다. 로지스팟 - 코드리뷰의 진짜 목적은 따로있다. 코드리뷰에 대해 쓴 글인데, 코드리뷰를 왜 해야하는가에 대한 고찰에 가까운 글이다. 코드 리뷰는 모두가 코드를 함께 리뷰함으로써 문제를 일찍 파악하는데에 그치지않고 코드에 대한 책임을 작성자 한 사람에게만 향하지 않고, 리뷰에 참여한 모두에게 향한다는 문화를 만들 수 있다고 한다. 문화뿐 아니라 코드 리뷰를 통해 다른 사람이 작성한 코드와의 중복을 방지할 수 있다고 한다. 또 다른 사람의 코드를 리뷰함으로써 ‘이렇게 작성할 수 있구나’ 하며 배우는 부분도 크다고 한다. 코드리뷰를 시작하기 앞서 주의해야 할 점은 경력이 높은 사람이 경력이 낮은 사람을 일방적으로 알려주려고 하기보다는 모두가 똑같이 다른 사람의 코드를 통해 배울 수 있음을 인지하고 오픈된 시각에서 코드 리뷰를 해야함을 강조했다. 무엇을 보았는가. 백기선 - 내가 컨퍼런스에 다니는 이유 동기부여에 대한 이야기였다. 백기선님 말씀대로 정말 컨퍼런스에 다니는 사람들은 “코딩안하고 놀러다니는” 사람들이 아니라 새로운 것을 배우고, 사람들을 통해 배우려는 열망이 큰 사람들이다. 아직 큰 컨퍼런스에 참여해본적은 없지만 나도 코엑스에서 열리는 큰 컨퍼런스에 참여해서 사람들을 만나보고 싶다. 우아한Tech - [10분 테크토크]희봉의 웹서버 vs WAS 영상 중 여기서부터 웹 어플리케이션과 WAS가 어떻게 동작하는지 방법을 알 수 있었다. 항상 우아한Tech로부터 많이 배우는 것 같다. 여기 크루분들도 크루들과 함께, 그리고 유튜브에 올라가는 영상을 위해 준비하면서 정말 많이 배우겠다라는 생각이들었다. 다음주엔 무엇을 하겠는가이번주에 알고리즘 문제를 많이 못풀었다. 이달 말에 프로그래머스에서 주관하는 윈터코딩 테스트에 신청했으니 여기에 맞춰 조금 더 많이 풀어봐야겠다. 문제만 풀기보다는 이번주부터 알고리즘을 같이 공부하면서 풀어보려고 한다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Weekly Review - 10월 1주차","slug":"WeeklyReview-2019-Oct-First","date":"2019-10-07T08:55:56.000Z","updated":"2020-09-13T01:53:29.676Z","comments":true,"path":"2019/10/WeeklyReview-2019-Oct-First/","link":"","permalink":"http://youngjinmo.github.io/2019/10/WeeklyReview-2019-Oct-First/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 읽었는가 무엇을 보았는가 다음주엔 무엇을 하겠는가 무엇을 했는가평일 스터디를 통해 도커 이미지를 생성하고 배포하는 방법을 배웠다. 그동안 도커 이미지를 가져와 쓰기만 해보았는데, 우분투 컨테이너에서 개발환경을 셋업하고 이미지를 배포하니까 신기했다. 아직 이를 활용하진 못했는데, 이걸 활용할 수 있는 일이 있을것 같다. 평일 스터디에서 Elastic Search라는 검색관련 기술을 쓰게될 것 같은데 아마 이 때 우리가 직접 이미지를 만들어볼 수 있을것 같다. *’자바에 대해 내가 잘아는 것이 맞나’*라는 생각이 들어 자바의 정석 책을 정독하면서 이를 정리하는 작업을 하고 있다. 잘 안다고 생각했던 부분도 책을 읽어보니 이해가 부족했던 부분들이 있어서 도움이 되고 있다. 자바의 정석을 다 정리하고 나면 토비의 스프링 책도 읽어볼 예정이다. 주말 스터디에서 일이 발생했다. 국비지원 교육을 함께하면서 얼굴을 익힌 사람들과 하게된 스터디였는데, 이 때문인지 평일 스터디에 비해선 느슨한 감이 없지 않았다. 그런데 이번 주말 약속시간이 한 시간도 안남은 상황에서 나를 제외한 모든 멤버들로부터 불참을 통보받았다. 스터디는 자기 자신을 위해서 하는 것이므로 불참한다고 해서 누군가에게 미안할 필요는 없으나 스터디 장소에 도착해서 멤버들로부터 불참 통보를 받으니 아쉬웠던게 솔직한 감정이다. 평일 스터디에 비하면 주말 스터디는 이미 기취업자가 있다는 특징도 있다. 현재 2명이 취업상태이고, 구직을 미룬 나를 제외한 나머지 한 친구도 곧 취업을 하게 될 것 같다. 오직 스터디에만 몰두할 수 없다는건 알지만 현재 우리의 스터디가 회사와 병행 불가능한 정도는 아니라고 판단했기 때문에 난 주말 스터디에 참여하고 있는 멤버들의 동기부여가 3주도 안되어 떨어졌다고 판단했다. 그래서 어떻게 이들에게 동기부여를 할 수 있을지를 잠깐 고민했고, 고민 결과 이를 고민하지 않기로 결정했다. 스터디는 자기 자신의 목표 달성을 위해 참여하는 액티비티라고 생각한다. 회사의 일정에, 주말의 휴식에 스터디의 우선순위가 밀린다면 그 사람이 게을러서가 아니라 그만큼 이 스터디가 본인에게 가치를 전달하지 못하다고 느끼기 때문이라고 생각한다. 간절했다면 어떤 이유에서건 참여했을거라고 생각한다. 따라서 스터디의 리더도 아닌 내가 이들에게 특별히 동기부여를 제공하기 위해 노력할 필요는 없다라는 결론에 이르렀다. 동기부여에 대한 고민대신 스터디의 존속여부에 대해 다음주에 논의해야 할 것 같다. 무엇을 읽었는가 rinae - [번역] 내가 StackOverflow를 사용하는방법 jbee - 나는 어떻게 개발 공부를 했나, 2편 박준우블로그 - TIL을 1년동안 진행하며 이번주에 읽은 글들은 학습방법에 관한 글들이었다. &lt;내가 StackOverflow를 사용하는 방법&gt;이라는 번역 글은 자신이 알고있는 지식을 공유함으로써, 그러니까 오픈 소스에 기여함으로써 자신을 더 나은 프로그래머로 만들어주고, 이는 커리어 향상에 도움이 된다고 하였다. 구체적으로는 다음과 같은 특징을 언급했다. 두뇌 훈련 디버깅 기술 향상 새로운 언어를 배우고 자신의 진도 확인 온라인 평판 온라인 노출도 영어 공부 이 글을 읽고부터 StackOverflow에서 답변을 찾지만 말고, 답변을 해야겠다라고 마음먹게 되었다. 답변을 하지 않고, 답변을 해야겠다고 마음 먹은 이유는 이 글을 읽고, StackOverflow에 접속하여 답변할 질문이 있는지 키워드 검색을 해본 결과 내가 답변할만할 질문이 없었기 때문이다…ㅋㅋ 오히려 질문과 답변을 통해 내가 더 학습해야할 것들을 확인했을뿐이다.. 아무튼 Github처럼 StackOverflow계정을 관리할 필요성을 느끼게 한 글이었다. 아직 부족하지만 앞으로는 답변가능여부와 상관없이 자주 접속해서 질문을 구경해야겠다. jbee님은 **배출(Output)**에 대한 글을 작성하셨다. 배운 것을 토대로 토이 프로젝트라도 만들어서 깃헙 저장소에 업로드하거나 블로그에 정리하는게 학습에 도움이 된다는 조언이었다. 공감이 가는 글이었다. 이런 조언은 나 역시 개발 공부를 시작하면서 가장 많이 받았던 조언이었다. 올 초까지는 프로젝트를 진행할만한 실력이 되지 않는다고 판단해서 Node.js 기반 블로그 프레임워크인 Hexo를 사용해서 깃헙 블로그를 만들어서 운영하고 있다. SEO(Search Engine optimization)를 어떻게 하는지 몰라서 이 글을 읽고 플러그인만 설치해두었는데, 반년 넘게 운영했음에도 조회수는 거의 발생하지 않고 있다..ㅋㅋ 그러나 가끔 몇 분이 들어오시시고 하시고, 무엇보다 내가 보고 확인하기 때문에 소홀히 작성하진 않고 있다. ‘누군가 볼 수 있다’ 라는 것만으로 에버노트에 작성하는 것보단 긴장되고 더 시간을 써서 작성하게 되는데 이 과정에서 조금 더 공부하게 된다. 국비교육과정이 끝나고는 내가 쓸 수 있는 무언가를 만들겠다는 작은 목표로 Fitbit Clock Face를 개발해서 깃헙 저장소에 올려두었다. 날씨와 미세먼지 지수까지 보여주고 싶은데, 빠른 시일(?)내에 만들어보고싶다. 그리고 그 땐 스토어에 등록까지 해보고 싶다. 박준우님은 **TIL(Today I Learned)**에 대해서 작성하신 글이었다. 이 글도 jbee님의 글의 연장선상에 있는 글이다. *’학습하고 배출하라.’*가 jbee님 글의 메세지였다면, 박준우님의 글은 *’꾸준히 하라’*가 메세지였다. 개인적으로는 GitBingo앱을 활용해서 올 초에 ‘일일커밋’을 시도해본 적이 있다. 1월 25일부터 시작했는데, 주말에 커밋을 하지못하는 일이 계속 발생했다. 4월부터 느슨해지면서 5월부터는 사실상 일일커밋을 포기하기에 이르렀다. 의도한건 아니었지만 Hexo 프레임워크로 블로그를 관리하는 과정에서 의미없는 커밋이 발생하기도 했다. 일일커밋때엔 색이 짙어지는 잔디밭을 보면서 뿌듯하기도 했지만, ‘매일 어떤걸 커밋해야하나’라는 부담도 있었다. 준우님의 글을 읽으면서 준우님의 경험뿐 아니라 다른 사례들도 많이 볼 수 있었는데 이 덕분에 다시동기부여를 얻게 된 것 같다. TIL을 곧 시작해보도록 해야겠다. 실패하더라도 우선 시작을 해보아야겠다. 무엇을 보았는가. 백기선 - 걱정보다는 응원을! 열등감을 극복해 온 이야기 개발 공부를 하면서 약간의 열등감이 있었다. 공부할수록 ‘과연 내가 할 수 있을까’, ‘도대체 무슨 소리지..’ 하는 생각을 많이하곤 했다. 최근 지인으로부터 좀 더 자신감을 갖고, 목표를 낮추지 말라는 조언을 듣기도 했다. 이런 조언을 해주는 분이 있다는 게 얼마나 큰 도움이 되는지 모른다. 백기선님의 영상을 보면서 남도 아닌 나 스스로에게 지나치게 걱정하거나 열등감을 갖는대신 스스로를 응원하고 더 공부하고, 더 노력을 해야겠다. 백기선님 영상을 보면서 늘 뼈를 맞곤 했는데, 오늘은 cheering을 받은것 같아서 좀 힘이 나는 것 같다. 오늘은 어제보다, 내일은 오늘보다 더 노력하자! 그리고 스스로를 응원하자! 다음주엔 무엇을 하겠는가블로깅할 때 이미지를 사용하곤 하는데 이미지를 따로 로컬에 저장하지 않고 구글포토에 업로드되는 또는 unsplash에서 이미지 주소를 참조해서 쓰곤하는데, 이게 문제임을 최근에서야 알았다…(8개월정도 운영했는데..) 구글포토가 계속 이미지 주소를 바꾸는 바람에 내가 포스팅한 시점 이후에 블로그를 처음 방문한 사람은 내가 올린 이미지를 볼 수 없었다. 내가 8개월의 시간동안 몰랐던건 보통 블로그를 랩탑 웹 브라우저로 확인하는데, 여기서는 캐시 이미지를 가져왔기 때문에 내 웹브라우저에선 정상적으로 이미지를 불러오는것 같았기 때문이다. 이미지 주소가 바뀌지 않으면서, 사용료가 무료, 무료로 제공되는 저장소 용량이 충분한 새로운 저장소가 필요했는데, 구글링해서 이 조건에 부합하는 저장소를 찾았다. MediaFire라는 서비스인데, 10GB까지 무료로 사용가능하고, 구글포토처럼 이미지주소가 임의로 바뀌는 시스템이 아닌 것 같다.(써봐야 알겠지만..) 일단 다음주엔 이걸로 이미지를 전부 옮기고 그동안의 포스트에 참조한 이미지 주소를 다 변경해야 할 것 같다.. 스프링 개발을 하기 전, Servlet을 다시 공부하고 정리하고 싶다. 유튜브에서 뉴렉처라는 채널을 알게되었다. 이 분이 Servlet에 대해 강의하신 영상이 있길래 이걸 보면서 다시 복습을 하려고 한다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Docker - 이미지 생성/배포하기","slug":"docker-image","date":"2019-10-02T09:15:29.000Z","updated":"2020-09-13T01:53:28.968Z","comments":true,"path":"2019/10/docker-image/","link":"","permalink":"http://youngjinmo.github.io/2019/10/docker-image/","excerpt":"","text":"목차 배포할 도커 이미지 생성하기 도커 이미지 배포하기 이전 포스트에서 도커 이미지는 컨테이너를 생성하고 실행하기 위해 필요한 요소라고 했습니다. 이번 포스트에서는 도커 이미지를 직접 생성하고 배포하는 것을 해보겠습니다. 배포할 도커 이미지 생성하기아직 도커를 어떻게 쓰면 좋을지 모르기 때문에 책을 참고하여 이미지를 생성해보았습니다. 우분투를 설치해서 ubuntu 환경에 변경사항을 만들고 이를 이미지로 생성해보겠습니다. 적용할 변경사항은 아래와 같습니다. apt-get 업데이트 git 설치하기 github 프로젝트 clone 하기 먼저 우분투를 이미지를 설치하겠습니다. 1$ docker pull ubuntu 컨테이너를 생성하겠습니다. 컨테이너와 호스트OS간 82번 포트로 마주보는 “custom_ubuntu”라는 이름의 컨테이너를 생성했습니다. 1$ docker create -it --name myubuntu -p 82:82 ubuntu 이제 생성한 컨테이너를 실행하고, bash shell 모드로 컨테이너 내부로 들어가겠습니다. 12$ docker start custom_ubuntu$ docker exec -it custom_ubuntu bash 혹시 여기서 -it 의 의미가 기억나지 않으신다면 여기서 다시 확인하실 수 있습니다 ​​🙂 지금부터는 컨테이너 내에 변경사항을 만드는 작업입니다. 이 부분을 건너뛰고 바로 이미지 생성하는 부분이 궁금한 분들은 여기를 클릭해주세요. 현재 컨테이너에서 git을 설치하려면 apt-get을 업데이트 해야합니다. 여기서 apt-get(Advanced Packaging Tool)이란, 우분투에서 사용가능한 패키지 매니저입니다. 1&#x2F;# apt-get update 패키지 매니저인 apt-get을 최신화 했으니 이제 git을 설치할 수 있습니다. 1&#x2F;# apt-get install git 이제 마지막으로 Github에서 저장소를 하나 불러오겠습니다. 123&#x2F;# mkdir project_folder &#x2F;&#x2F; 폴더 생성&#x2F;# cd mkdir &#x2F;&#x2F; 디렉토리 이동 &#x2F;# git clone https:&#x2F;&#x2F;github.com&#x2F;autho&#x2F;project.git &#x2F;&#x2F; git clone 원하는 변경사항을 모두 만들었으므로 현재 상태에서 이미지를 생성하겠습니다. 먼저 컨테이너에서 빠져나와서 아래 명령어를 입력해보겠습니다. 아래의 명령어는 다음과 같은 구조로 구성되어 있습니다. 1$ docker commit &lt;option&gt; container &lt;repository&gt;:&lt;tag&gt; 12345$ docker commit \\-a &quot;devandy&quot; \\-m &quot;created&quot; \\custom_ubuntu \\custom_ubuntu:first 위의 명령어는 \\ 를 통해 줄을 띄어써서 작성한 것입니다. 아래의 명령어와 정확히 일치하는 명령어입니다. 1$ docker commit -a &quot;devandy&quot; -m &quot;created&quot; custom_ubuntu custom_ubuntu:first 이제 생성된 도커 이미지를 확인해보겠습니다. 저는 위에서 언급한 변경사항을 두번으로 나눠서 적용하면서 커밋을 두번해서 두번째 TAG를 second로 두었습니다. 어쨋든 원래의 도커 이미지였던 ubuntu와 IMAGE ID도, SIZE도 다른 새로운 이미지가 생성되었음을 확인할 수 있을겁니다. 두 이미지의 용량이 다른 이유는 저희가 git을 설치하기도 했고, git 저장소를 컨테이너 내부에 설치했기 때문에 차이가 발생하고 있습니다. 생성한 이미지에서 다시 새로운 이미지를 생성하려면, 또 커밋을 하면 됩니다만 변경사항이 있을 때에만 커밋을 할 수 있습니다. 컨테이너 내부에 파일 하나라도 변경사항이 있을 때에만 커밋을 해서 새로운 이미지를 생성하는 것이 가능합니다. 저는 현재 상태에서 apt-get으로 vim을 설치하고 다시 커밋을 해보았습니다. 12345$ docker commit \\-a &quot;devandy&quot;-m &quot;updated&quot;custom_ubuntucustom_ubuntu:third vim을 설치하고 새로 생성한 이미지의 용량이 이전의 이미지 대비해서 더 커졌음을 확인하였습니다. 삭제하고 싶은 이미지가 있다면 IMAGE ID를 통해 삭제할 수 있습니다. 1$ docker rmi &lt;IMAGE ID&gt; 이미지를 생성할 때 마다 sha256: 로 시작하는 16진수 해시값이 콘솔창에 출력하는데 docker inspect &lt;IMAGE NAME&gt; 을 통해 “Layers” 를 확인해보면, 각 버전 모두에서 공통되는 해시값이 있고, 각 버전마다 하나씩의 해시값이 생성되었음을 알 수 있습니다. 도커 이미지 배포하기배포는 아니지만 현재의 이미지를 파일로 추출하는 방법도 있습니다. 1$ docker save -o myubuntu.tar custom_ubuntu:third 이렇게 하면 .tar 를 확장자로 갖는 압축파일이 생성됩니다. 디렉토리를 설정하지 않았을 때 저의 경우(Mac OS: Catalina)는 /Documents 에 압축파일이 생성되었습니다. 이 파일로 도커 이미지를 불러오려면 아래의 명령어로 불러올 수 있습니다. 1$ docker load -i myubuntu.tar 이제 진짜 **이미지를 배포**해보겠습니다. 도커 이미지를 배포하는 방법으로는 도커 허브(dockerhub.com)를 이용하는 것과 사설 레지스트리를 이용하는 방법이 있다고 합니다. 사설 레지스트리의 경우 회사 내부망을 의미하는 것 같습니다. 저는 도커 허브를 통해 도커 이미지를 배포해보겠습니다. 도커허브에 접속해서 create repository를 클릭하면 다음과 같은 창을 볼 수 있습니다. 저는 위 이미지에서 볼 수 있듯 Github 계정 연동을 다시 해야하는 상황이어서 먼저 Github 계정을 다시 연동하고 도커허브 저장소를 생성했습니다. 도커허브에 저장소가 생겼다면, 도커 허브에 올릴 이미지를 생성해야 합니다. 형식에 맞춰 명령어를 작성해야 합니다. 1$ docker tag custom_ubuntu:third youngjindev&#x2F;testrepo_ubuntu:0.0 IMAGE ID를 보면 완전히 같은 이미지면서 이름만 다른 이미지가 생성되었음을 알 수 있습니다. 이제 도커 허브 서버에 로그인합니다. 1$ docker login 도커 허브에서 가입할 때 사용한 이메일과 비밀번호를 입력하면 로그인에 성공합니다. 도커 로그인 정보는 /&lt;username&gt;/.docker/config.json 파일에 저장됩니다. 이제 도커허브의 원격 저장소에 이미지를 배포하는 명령어를 입력하겠습니다. 1$ docker push youngjindev&#x2F;testrepo_ubuntu:0.0 도커 허브에서 확인해보면 다음과 같이 변한걸 확인할 수 있습니다. 성공적으로 이미지가 배포되었습니다. 이제 docker pull 명령어를 통해 이를 설치할 수 있습니다. 지금까지 생성한 이미지를 모두 지우고, 터미널을 통해 제가 방금 배포한 이미지를 검색해보았습니다. 반가운 이미지..!! 이제 당겨오겠습니다. 1$ docker pull youngjindev&#x2F;testrepo_ubuntu 이렇게 하니까 이런 에러 메세지를 출력합니다.. 1Error response from daemon: manifest for youngjindev&#x2F;testrepo_ubuntu:latest not found: manifest unknown: manifest unknown 버전을 찾을 수 없다는 내용이므로 버전까지 명확하게 입력해서 다시 시도했습니다. 1$ docker pull youngjindev&#x2F;testrepo_ubuntu:0.0 제가 생성하고 배포한 이미지를 성공적으로 가져온걸 확인했습니다! 테스트로 아파치 웹서버를 우분투환경에서 설치해서 이미지를 도커 허브에 배포해놓았습니다. 참고 문서 및 도서 &lt;시작하세요! 도커&gt; 위키북스, 용찬호","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"DevOps","slug":"Dev/DevOps","permalink":"http://youngjinmo.github.io/categories/Dev/DevOps/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://youngjinmo.github.io/tags/docker/"}]},{"title":"Weekly Review - 9월 4주차","slug":"WeeklyReview-2019-Sep-Fourth","date":"2019-09-30T03:39:13.000Z","updated":"2020-09-13T01:53:29.636Z","comments":true,"path":"2019/09/WeeklyReview-2019-Sep-Fourth/","link":"","permalink":"http://youngjinmo.github.io/2019/09/WeeklyReview-2019-Sep-Fourth/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 보았는가 다음주엔 무엇을 하겠는가 무엇을 했는가지난주 위클리뷰에서 스프링에 집중하기로 했다고 했다. 이렇게 하나만 집중하기로 마음먹으니 오히려 마음이 더 편해진것 같다. 스프링부트 스터디와 스프링 개념 스터디 두 가지 스터디에 참여하고 있는데, 스프링부트 스터디에서는 프로젝트 개발을 앞두고 개념을 같이 정리하고 있다. 이번주에는 도커의 간략한 사용법과 Git, 그리고 IoC/DI에 대해 각자 준비해서 리뷰했다. 나는 이번주에 도커를 준비해갔다. 다음주에는 도커 포트 연결하는 방법과 이미지 생성하는 법을 정리하기로했다. Git은 그나마 조금 공부했다고 생각했는데도 깊히 파는 스터디원들과 이것저것 해보고, 의견나누는 과정에서 새로운걸 배웠다. Fork한 레파지토리를 오리지널 저장소와 동기화하는 방법은 몰랐는데, 이번에 알게되어 이것도 블로그에 정리했다. IoC/DI에 대해서는 설명을 들었지만 명확하게 이해하지는 못했다. 제어가 역전되는건 대충 알겠는데, “의존성”에 대해서 아직 정리가 되지 않았다. 다음주에 더 정리해준다고 하셨는데 다음 스터디 전까지 개인적으로도 공부를 해야겠다는 생각이 들었다. 국비학원 출신으로 구성된 Java/스프링 스터디(이하 주말 스터디)에서는 이번에도 많이 해보진 못했다. 준비가 부족하다는 생각이 들었다. 개인적으로는 스프팅부트 스터디가 좀 빡쌔다보니 이 스터디는 좀 설렁설렁하려고 한게 아니었나하는 반성이 들었다. 그래서 스터디의 방향을 좀 바꿔보기로 했다. 예제 수준의 10분짜리 강의영상을 2-3개 보고와서 리뷰하는 것보다 개념을 하나씩 정해서 한 주동안 공부하고 리뷰하기로 했다. 나는 다음주까지 PSA를 정리해서 리뷰하기로 하였다. 이외에도 각자 한 주간 공부하면서 알게된 팁들을 10분에서 15분간 리뷰하는 시간도 갖기로 했다. 취업자는 회사에서 배우는게 있고, 미취업자도 취업을 준비하는 과정에서 공부하게 되는게 있으니 이를 공유하면 좋겠다는 취지에서 다음주부터 시행해보기로 했다. 구직에 대해 조급한 마음이 있었는데, 이번주를 거치면서 구직을 잠시 중단하기로 했다. 급한마음에 아무데나 지원하기보다 조금 더 천천히 준비를 하고, 제대로 준비된 상황에서 자신감을 갖고 다시 구직을 해보려고 한다. 무엇을 읽었는가 Deep Play - 데이터베이스 정규화 1NF, 2NF, 3NF, BCNF주말 스터디에서 다른 스터디원이 데이터베이스의 정규화에 대해 설명해주시면서 공유한 문서(블로그)이다. 중복을 제거한다는 모호한 의미만 이해하고 있었는데, 이 문서에 있는 이미지와 설명을 들으니 보다 명확하게 이해가 되었다.데이터베이스 정규화는 이상현상을 제거하고 유지보수에 유리하도록 테이블을 작게작게 쪼개는 작업이다. 여기서 이상현상은 이전에 블로그에 정리한 바 있다. kazupon/git-commit-message-convention 사실 이 글은 지난주에 읽은 글이었는데, 위클리리뷰에서 정리하지 않아 이번주에 정리해본다.커밋 메세지를 작성할 때의 규칙을 정리한 문서인데, 스프링 부트 스터디에서 이 문서를 함께 읽어보면서 향후 커밋 메세지 작성할 때 우리만의 규칙을 만들기로 하였다.일단 우리는 단순하게 커밋 메세지의 첫 단어는 대문자로 시작하는, 동사로 작성하고 두번째 단어에서 어떤 변경사항을 나타내는지 짧은 단어로 정리하기로 했다. 예를들면, Add readme.md 이렇게. 무엇을 보았는가. 노마드 코더 - 네, 파이썬은 C언어보다 느립니다. 컴파일 기초개념 잡아드림이 영상을 보고 구글링을 더해서 컴파일러와 인터프리터를 정리해보았다.정리하면, Java같은 컴파일러 언어는 컴파일러가 소스코드를 통째로 해석하고 실행파일을 생성, 이를 실행하기 때문에 생산속도는 느리지만, 실행속도가 빠르다는 특징 있다.반면에 인터프리터 언어는 실행하면 그 때 실시간으로 해석하고 실행 결과를 출력하기 때문에 컴파일러 언어대비 생산속도는 빠르지만, 실행속도는 느리다는 특징이 있다. 다음주엔 무엇을 하겠는가 스프링부트 스터디에서 약속한 도커 이미지 생성법과 포트 사용법에 대해 정리할 예정이다. Intelli J에서 커밋메세지를 작성하고 Git을 사용할 수 있는데 아직 한 번도 써본적이 없다. 이번주에 이걸 배워서 스터디에서는 터미널대신 인텔리J에서 커밋을 해보려고 한다. 주말 스터디 과제로 스프링의 주요 개념중 하나인 PSA 정리","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Scanner 클래스의 hasNext()","slug":"scanner-hasnext","date":"2019-09-28T08:25:16.000Z","updated":"2020-09-13T01:53:28.180Z","comments":true,"path":"2019/09/scanner-hasnext/","link":"","permalink":"http://youngjinmo.github.io/2019/09/scanner-hasnext/","excerpt":"","text":"10951번 문제를 풀다가 hasNextInt()라는 메서드를 처음 알게되었다. Buffer를 이용해서 해결하려고 했는데, 도저히 해결할 수 없었고, 구글링해서 hasNextInt() 라는 함수를 알게되었다. hasNext()는 Scanner의 내장 함수인데, 스캐너 객체로 데이터가 들어왔는지 여부를 반환하는 함수이다. 문제에 대한 정답 코드이다. 123456789public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while(sc.hasNextInt())&#123; int a = sc.nextInt(); int b = sc.nextInt(); System.out.println(a+b); &#125;&#125; 스터디에서 코드 리뷰를 해봤는데 아직 sc.nextInt() 에 값이 안들어왔음에도 while문이 어떻게 동작할 수 있었는가 라는 질문이 나왔다. 그래서 인텔리J에서 함수를 클릭하여 어떻게 동작하는지를 살펴보았다. 먼저 hasNextInt()이다. 123public boolean hasNextInt()&#123; return hasNextInt(defaultRadix);&#125; 위 함수는 boolean 값을 반환하는데 여기서 반환되는, 파라미터를 갖고있는 hasNextInt()라는 함수를 찾아보면 또 다음과 같다. 123456789101112131415public boolean hasNextInt(int radix) &#123; setRadix(radix); boolean result = hasNext(integerPattern()); if (result) &#123; // Cache it try &#123; String s = (matcher.group(SIMPLE_GROUP_INDEX) == null) ? processIntegerToken(hasNextResult) : hasNextResult; typeCache = Integer.parseInt(s, radix); &#125; catch (NumberFormatException nfe) &#123; result = false; &#125; &#125; return result;&#125; 어떤 데이터타입이든 일단 데이터가 hasNextInt() 로 들어오게 되면, try catch문을 통해 예외처리를 하는 것 같다. 다시 처음 위의 hasNextInt() 함수에서 반환되는 boolean값의 파라미터인 defaultRadix를 확인해보면 다음과 같다. 12// The default radix for this scannerprivate int defaultRadix = 10; Scanner 객체의 기본 정수형 인자(?)인것 같다. 아직 키보드가 입력받지 않았음에도 스캐너 객체가 생성될 수 있었던 이유가 defaultRadix가 10이었기 때문이었다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"algorithms","slug":"algorithms","permalink":"http://youngjinmo.github.io/tags/algorithms/"}]},{"title":"Git - PR하기(local->Upstream), Fetch&merge하기(upstream->Local)","slug":"git-sync-forked-repo","date":"2019-09-26T05:02:46.000Z","updated":"2020-09-13T01:53:28.852Z","comments":true,"path":"2019/09/git-sync-forked-repo/","link":"","permalink":"http://youngjinmo.github.io/2019/09/git-sync-forked-repo/","excerpt":"","text":"Fork한 레파지토리(local)에서 변경사항이 발생해서 이를 오리지널 원격 저장소(upstream)에 pull request하는 방법과 오리지널 원격 저장소의 업데이트를 자신의 레파지토리(local)에 동기화하는 방법 2가지를 정리했다. 목차 pull request fork한 레파지토리의 변경사항을 원격 저장소에 반영하고 싶을 때 merge upstream/branch 원격 저장소의 최신사항을 fork 저장소에 반영하고 싶을 때. 한 가지 상황을 예로 들어보겠다. A가 만든 원격 저장소를 B가 Fork하고, 자신의 Local repository에 Clone까지 한 상태이다. 이 상태를 기반으로 2가지 상황에 대해 정리했다. 1) 로컬 저장소(forked) ➡️ 원격 저장소(upstream)로컬에서 변경사항이 발생했고, 이를 오리지널 원격 레파지토리에 반영하고 싶다 = pull request우선 로컬 레파지토리를 최신화한다. 커밋이 정리되었다면, 이제 원격 저장소에 동기화해야 한다. 이 때 로컬 레파지토리의 커밋 객체들이 동기화되는 대상은 위 사진 속에서 “B Remote Repo”에 해당한다. 즉 B가 A의 레파지토리를 Fork해서 생성된 B의 원격 저장소에 최신 커밋을 동기화(push)하고, 이를 원래의 저장소인 A의 원격 저장소에 pull request 를 해야한다. “A Remote Repo”에 접근권한이 B가 Fork해서 생성한 저장소에 최신 커밋을 발생시켜 이를 원격 저장소에서 받아(pull)달라고 요청(request)하는 것이다. 최종적으로 A가 Merge하면 B가 작성한 커밋들이 “A Remote Repo”에도 반영된다. 1. 내 저장소에서 PR 요청Github에 접속하면 Pull Request가 활성화되어있는 걸 확인할 수 있다. 그 왼쪽의 메세지를 읽어보면, *’이 브랜치에 10개의 커밋이 [Upstream Owner:branch]를 바라보고 있다’*고 알려주고 있다. 이는 Upstream에 PR을 보낼 수 있는 10개의 커밋이 있다는 이야기이다. 2. Upstream 저장소의 브랜치와 내 저장소의 브랜치를 맞추고 PRUpstream 저장소의 어떤 브랜치에 내 커밋을 병합(merge)할 것인지, 또 내가 보낼 커밋은 어떤 브랜치의 커밋인지를 맞춘뒤 Create pull request 버튼을 클릭하면 Merge 커밋메세지를 작성할 수 있다. Upstream의 오너가 이를 수용해서 merge하면 내가 작성한 커밋이 한꺼번에 Upstream의 브랜치에 반영된다. 2) 원격 저장소(upstream) ➡️ 로컬 저장소(forked)원래의 저장소(A Remote Repo)의 최신사항을 Fork한 저장소에 반영하고 싶을 때 = merge upstream/branch이번엔 반대로 A Remote Repo에서 발생한 최신사항을 B가 사용중인 Local Repo로 최신화를 하려고 한다. 위의 명령어를 입력해서 현재 로컬 깃 저장소가 가리키는 원격 저장소를 보면 A Remote Repo가 아니라 B Remote Repo만 가리킬 것이다. B Remote Repo에서 Clone해온 저장소이기 때문이다. 따라서 현재 이 저장소의 원래 저장소가 A Remote Repo임을 가리켜야 한다. 1git remote -v add upstream http:&#x2F;&#x2F;github.com&#x2F;GiyunPark&#x2F;lectureSearch.git 이제 다시 로컬 깃 저장소가 어딜 바라보는지 확인해보자. 2개의 원격 저장소를 바라보고있는걸 확인할 수 있다. 그럼 이제 남은건 로컬 저장소(B Local Repo)에서 원격 저장소(A Remote Repo)의 최신사항을 동기화하는 일만 남았다. 먼저 upstream 레파지토리(A Remote Repo)에서 최신사항이 있는지 fetch 명령어로 확인한다. 1git fetch upstream upstream 저장소에 최신사항이 있음을 확인했다. 이제 이를 가져오려면 먼저 최신사항을 가져올 브랜치로 이동해야 한다. 현재 브랜치에서 원격 저장소(A Remote Repo)의 최신사항을 동기화하려면 브랜치 이동을 할 필요가 없다. 1git checkout master 본인은 로컬 깃 저장소의 master 브랜치에서 원격 저장소의 최신사항을 동기화하고 싶기 때문에 로컬 깃 저장소의 브랜치를 master 로 이동했다. 이제 진짜 동기화를 시작하겠다. 1git merge upstream&#x2F;master 이제 git log 로 커밋 히스토리를 출력해보면 원격 저장소(A Remote Repo(의 커밋들이 내 로컬 깃 저장소(B Local Repo)에 반영되어있음을 알 수 있다. 관련 포스트 Git - Upstream 원격 저장소의 브랜치, 로컬로 불러오기 참고 문서 https://help.github.com/en/articles/syncing-a-fork","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"Docker 시작하기","slug":"docker-intro","date":"2019-09-25T11:03:13.000Z","updated":"2020-09-13T01:53:28.964Z","comments":true,"path":"2019/09/docker-intro/","link":"","permalink":"http://youngjinmo.github.io/2019/09/docker-intro/","excerpt":"","text":"스터디원들과 공유하기 위해 여러 문서와 책을 참고하여 작성한 도커 입문서. 나도 아직 잘 모르기 때문에 시간이 되는대로 조금씩 공부해볼 생각. 목차 Docker? 가상머신 vs 도커 그래서 왜 도커? 도커 엔진 종류 도커 설치 도커 이미지, 그리고 컨테이너 생성 bash모드로 컨테이너 진입하기 Docker? 도커란, 리눅스 컨테이너에 여러 기능을 추가하여 컨테이너로 애플리케이션을 쉽게 사용할 수 있도록 만들어진 오픈소스 프로젝트. Go 언어로 작성되어 있으며, 2013년 3월 첫 번째 배포가 시작되었습니다. 도커 관련한 프로젝트는 Docker Compose, Docker Machine, Kitematic 등이 있지만 일반적으로 도커라고 하면, Docker Engine 또는 도커 관련 모든 프로젝트를 의미한다고 합니다. 도커의 프로젝트들이 도커 엔진을 더 효율적으로 사용하기 위한 프로젝트이므로 도커 = 도커 엔진이라고 해도 무방할 것 같습니다. 가상머신 vs 도커 가상머신가상 머신은 Virtual Box, VM Ware 등이 대표적인데, 이런 가상 머신은 Host OS(운영체제) 위의 하이퍼바이저 위에서 독립적이고 완전한 운영체제(Guest OS)를 설치함으로써 Host OS와는 완전히 독립적인 공간과 시스템 자원을 할당받아 사용할 수 있습니다. 여기서 **하이퍼바이저(Hypervisor)**란, 컴퓨터의 운영체제와 애플리케이션을 물리적 HW에서 분리하는 프로세스를 말한다고 합니다. 쉽게 말해 Host 컴퓨터 1대에서 다수의 운영체제를 동시에 실행할 수 있도록 하는 소프트웨어입니다. 따라서 가상 머신의 이미지는 Guest OS를 완전히 실행가능한 라이브러리, 커널 등을 전부 포함하게 되는데 이 때문에 이미지의 크기가 크다는 단점이 있습니다. 도커이에 반해 도커 컨테이너는 프로세스 단위의 격리환경을 만들기 때문에 성능 손실이 거의 없다고 합니다. 또한 가상 머신처럼 독립적이면서 완전한 OS 구축을 위한 많은 자원을 필요로 하지 않고, Host OS의 컴퓨팅 리소스를 공유받기 때문에 이미지 용량이 작습니다. 따라서 이미지를 만들어 배포하는 시간이나 설치 시간이 가상 머신보다 빠르다는 장점이 있습니다. ⭐️도커의 장점!도커의 장점을 요약해보면, 컨테이너를 이미지로 만들어 배포하는 시간이 가상머신을 통해 배포하는 것보다 빠르고 간편하며, 완전한 OS를 구축하는 것이 아닌 개발환경만을 구축할 수 있기에 팀 단위의 개발환경에서 사용이 용이하다는 장점이 있습니다. 또한 가상화 공간을 사용할 때 성능손실이 거의 없다는 것입니다. 도커의 단점?굳이 찾자면 보안의 약점을 꼽을 수 있습니다. 하이퍼바이저로 구동되는 가상 머신의 경우, 컴퓨팅 리소스를 완벽히 독립하여 사용하기 때문에 게스트 OS중 하나가 취약해지더라도 나머지 Guest OS는 영향을 받지 않습니다. 그러나 도커를 사용할 경우에는 Host OS의 컴퓨팅 리소스를 도커 엔진을 통해 컨테이너들이 공유하기 때문에 Host OS가 취약해지면, 컨테이너들도 위험에 노출되게 됩니다. 가상 머신과 도커를 비교하면 다음 이미지와 같습니다..ㅎ 그래서 왜 도커?개발을 하다보면 서로 다른 운영체제 버전, IDE버전, Java 버전 등 각기 다른 개발환경으로 인해 개발환경을 공유하거나 맞추는 일 또한 쉽지 않습니다. 도커는 컨테이너에 필요한 애플리케이션을 설치해서 개발에 필요한 환경을 구축하고, 이 컨테이너를 이미지로 만들어 공유할 수 있습니다. 여기서 이미지는 버전관리 측면에서 볼 때 Commit과 같은 작업으로 봐도 무방할 것 같습니다. 이미지와 컨테이너에 대한 설명은 아래에 추가했습니다. 그리고 이를 도커 헙(Docker Hub)을 통해 공유함으로써 마치 프로젝트를 Github에 올리거나 clone할 수 있는 일을 수행할 수 있습니다. 위의 내용을 정리하면서 이를 알기 쉽게 요약한 영상이 있어 공유합니다. 도커 엔진 종류2017년 3월부터 도커 엔진은 Docker EE(Enterprise Edition)과 Docker CE(Community Edition)으로 배포되고 있습니다. Docke EE는 기업용 솔루션이며 각종 기술 지원 및 상용 서비스 개발에 필요한 다양한 부가기능을 도커 엔진과 함께 포함하고 있습니다. Docker CE는 무료로 제공되는 도커 엔진이며 별도의 기술지원 서비스를 지원하지는 않지만 도커 엔진의 핵심 기능을 무료로 사용할 수 있는 장점이 있습니다. Docker EE와 Docker CE 모두 3개월마다 stable 버전이 릴리즈 되며, Docker CE는 edge 버전이 한 달 단위로 릴리즈됩니다. 도커 설치 도커가 리눅스 컨테이너 기반 때문인지 도커의 기능을 완전하게 사용하기 위해서는 리눅스에서 사용하는 것이 가장 좋다고 합니다. 윈도우나 맥에서 사용하기 위해서는 각각의 운영체제에서 지원하는 가상화 기술을 통해 도커를 사용할 수 있습니다. 이외에도 AWS의 EC2 인스턴스를 사용해서 클라우드 환경(우분투)에서 도커를 구축할 수 있다고 합니다. 출처 : Introduction to Linux Containers 여기서 잠깐, 리눅스 컨테이너란 리눅스는 운영체제 레벨에서 가상화를 제공한다고 합니다. 그런데 운영체제를 통째로 가상화하는 방식이 아니라 리눅스 커널 레벨에서 제공하는 격리된 공간으로 가상화를 제공한다고 합니다. 운영체제를 설치하지 않았기 때문에 커널 레벨에서 제공하는 이 격리된 공간을 컨테이너라고 부르는 것입니다. 커널(Kernel)**이란 컴퓨터의 가장 기본적인 각 장치들을 관리하고 제어하기 위한 소프트웨어라고 합니다. 컴퓨터가 부팅되면서 GRUB과 같은 부트로더에 의해서 메모리로 로딩되어 **컴퓨터가 꺼질 때까지 항상 메모리에 상주해서 컴퓨터의 각 장치들을 관리하고 제어하는 역할을 합니다. (출처 : WEBDIR) 리눅스 컨테이너는 격리된 공간만 제공할뿐 서버 운영에 필요한 부가기능이 부족했는데, 도커는 리눅스 컨테이너를 기반으로 편리하게 이미지를 관리하고 배포할 수 있도록 도와주는 것입니다. 도커를 실행한 후 터미널에서 docker version을 입력하면 설치한 도커의 클라이언트/서버 버전을 확인할 수 있습니다. 도커 이미지 그리고 컨테이너 생성도커 이미지는 컨테이너를 생성하고 실행하기 위해 필요한 요소입니다. MySQL에서 배포한 도커 이미지가 그 예입니다. 해당 이미지를 통해 컨테이너를 생성하면, MySQL를 사용할 수 있는 환경이 구축되는 것입니다. 도커 이미지 하나로 프로젝트에 따라 여러 개의 컨테이너를 생성하여 운영할 수도 있습니다. 1$ docker search &lt;image:tag&gt; 도커를 실행한 상태에서 터미널에서 위의 명령어를 실행하면 이름에 해당하는 이미지를 찾아서 콘솔에 리스트를 출력합니다. 위의 명령어는 mysql이미지의 최신버전(tag)을 찾는 명령어입니다. star가 많은 이미지일수록 신뢰가 높은 이미지라고 생각할 수 있습니다. 1$ docker pull &lt;image:tag&gt; 설치하고 싶은 이미지를 찾았다면 내려받으면 됩니다. 1$ docker images 내려받은 도커 이미지 리스트를 출력합니다. 1$ docker rmi &lt;image&gt; 이미지를 삭제하고 싶을 때 사용합니다. 1$ docker run -i -t --name &lt;container_name&gt; -p 80:80 &lt;image:tag&gt; 내려받은 이미지를 통해 컨테이너를 생성, 실행합니다. 이 때 --name 키워드를 통해 컨테이너의 이름을 지정할 수 있습니다. --name : 컨테이너의 이름을 지정합니다. -i : interactive, 컨테이너의 입력 및 출력 등 상호작용하겠다는 키워드 -t : pseudo-tty로 터미널과 같은 환경을 사용하겠다는 키워드 -p : Host의 포트를 컨테이너의 포트로 오픈합니다. (listen) -p &lt;host-port&gt;:&lt;container-port&gt; Host의 포트를 지정하지 않으면 임의의 포트로 할당됩니다. 도커 컨테이너는 이미지와 독립적이므로 이미지를 통해 생성한 컨테이너 A, B, C가 있다고 가정해보도록 하겠습니다. 이 때, 컨테이너 A에서 변경사항이 발생해도 컨테이너 B와 C에서는 컨테이너 A에서의 변경사항이 적용되지 않습니다. 또한 Host OS에도 영향을 주지 않는다고 합니다. 데이터베이스와 웹 서버를 구축할 때 하나의 컨테이너에서 구축할 수도 있지만, 도커는 한 컨테이너에 프로세스 하나만 실행하도록 하는 것이 철학이라고 합니다. 각각의 프로세스 단위로 컨테이너로 구분하는 것이 도커의 방향인 것 같습니다. 혹시 컨테이너의 개념이 헷갈린다면 여기를 다시 읽어보시길 바랍니다! 현재 실행중인 컨테이너 목록을 출력합니다. 1$ docker ps 생성된 모든 컨테이너 목록을 출력합니다. 1$ docker ps -a 생성한 컨테이너를 시작하고, 종료하는 명령어입니다. 12$ docker start &lt;container_name&gt;$ docker stop &lt;container_name&gt; 컨테이너를 삭제합니다. 1$ docker rm &lt;container_name&gt; bash모드로 컨테이너 진입하기1$ docker exec -it &lt;container_name&gt; bash 컨테이너를 실행(docker start)한 뒤에 위의 명령어를 입력하면, bash shell 모드로 컨테이너 내부로 들어갈 수 있습니다. 이제 여기부터는 리눅스 쉘 명령어(bash)가 필요합니다. 여기서 -it 는 여기서 정리한바 있습니다. 해당 컨테이너의 os 정보를 콘솔에 출력합니다. 1&#x2F;# cat &#x2F;etc&#x2F;issue exit 를 입력면 컨테이너에서 빠져나올 수 있습니다. 컨테이너 내부에 들어가지 않고도 컨테이너 외부에서 컨테이너 내부로 명령어를 실행할 수도 있습니다. 1$ docker exec &lt;container_name&gt; echo &quot;Hello World!&quot; 콘솔창에 Hello World가 출력됨을 확인할 수 있습니다. 참고 문서 및 도서 &lt;시작하세요! 도커&gt; 위키북스, 용찬호 pyrasis.com - Docker 기본 사용법 도커 기초 확실히 다지기, Eric Han 서비스 배포의 끝판왕, 도커의 개요 대해서 알아보자!, 안경잡이 개발자","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"DevOps","slug":"Dev/DevOps","permalink":"http://youngjinmo.github.io/categories/Dev/DevOps/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://youngjinmo.github.io/tags/docker/"}]},{"title":"컴파일러 언어와 인터프리터 언어","slug":"interpreter-vs-compiler","date":"2019-09-23T02:13:06.000Z","updated":"2020-09-13T01:53:28.632Z","comments":true,"path":"2019/09/interpreter-vs-compiler/","link":"","permalink":"http://youngjinmo.github.io/2019/09/interpreter-vs-compiler/","excerpt":"","text":"목차 컴파일러 언어 인터프리터 언어 결론 컴파일 언어와 인터프리터 언어는 어떤 차이를 가지고 있을까?컴파일 언어는 C, C++, Java 등이 대표적이다. 인터프리터는 Python이 대표적이다. 그런데 사실 Java는 컴파일 언어면서 인터프리터이기도 한 언어인데, Java가 어떻게 동작하는지 알면 이유를 알 수 있다. 우선 컴파일러의 과정을 살펴보도록 하자. 위의 과정을 Java 언어에서 설명하자면, 우선 개발자가 작성한 소스코드(.java)를 JVM이 컴파일링하여 바이트코드(.class)로 변환한다. 이 때 컴파일러는 개발자가 작성한 소스코드를 통째로 해석하여 바이트 코드를 생성하게 되는데, 문서 번역가라고 비유해도 좋을 것 같다. 이 때문에 생산속도가 느리다는 단점이 있다. 바이트 코드로 전환된 코드는 JVM에 의해 자바 애플리케이션을 실행된다. 일단 바이트 코드(.class)로 변환되었다면 에러없이 빠르게 애플리케이션이 실행된다. 그리고 바이트코드가 애플리케이션으로 실행되는 이 과정이 인터프리팅에 해당하기 때문에 위에서 Java가 컴파일러 언어이면서 동시에 인터프리팅 언어이기도 하다고 한 것이다. 종합해보면 컴파일러 언어는 생산 속도가 느리지만, 실행 속도가 빠르다는 특징이 있다. 인터프리팅 과정은 다음과 같다. 컴파일 언어와 비교했을때, 컴파일링 과정만 빠졌을뿐 거의 일치한다. 컴파일 과정을 거치지 않기 때문에 인터프리터 언어는 생산속도가 빠르다는 특징이 있다. 컴파일러 언어가 통째로 소스코드를 읽고, 바이트 코드를 만들어낸다면 인터프리터는 통째로 읽지않고, 프로그램 실행 명령시, 해석과 실행을 동시에 한다. 따라서 이는 문서 번역가와 같은 컴파일러 언어와 비교하여 동시 통역가와 같은 특징이라고 할 수 있다. 그러나 이 때문에 실행속도가 느리다는 단점이 있다. 정리하면, 인터프리터 언어는 생산속도가 빠르지만, 실행 속도가 느리다는 특징이 있다. 결론 그래서 결론은 컴파일러 언어는 컴파일 과정 때문에 생산 속도는 느리지만, 실행 속도가 빠르다는 특징이 있고, 인터프리터 언어는 컴파일 과정이 없기 때문에 생산 속도가 빠르지만, 실행 속도가 느리다는 특징이 있다. 참고로 위에서 언급한 C,C++과 Java, Python의 실행 속도 순서는 C,C++ &gt; Java &gt; Python 순이다. 인터프리터 언어인 Python보다 컴파일러 언어인 Java가 실행 속도가 빠르고, Garbage Collector가 없어서 개발자가 수동으로 메모리를 관리해야하는 C계열 언어가 학습이 어려운대신 메모리를 자동으로 관리하는 Java보다 실행 속도가 빠른 것이다. 참고 문서 STechies - Difference Between Compiler and Interpreter 노마드 코더 - 네. 파이썬은 C언어보다 느립니다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"compiler","slug":"compiler","permalink":"http://youngjinmo.github.io/tags/compiler/"},{"name":"interpreter","slug":"interpreter","permalink":"http://youngjinmo.github.io/tags/interpreter/"}]},{"title":"WeeklyReview - 9월 3주차","slug":"WeeklyReview-2019-Sep-Third","date":"2019-09-22T12:24:50.000Z","updated":"2020-09-13T01:53:29.616Z","comments":true,"path":"2019/09/WeeklyReview-2019-Sep-Third/","link":"","permalink":"http://youngjinmo.github.io/2019/09/WeeklyReview-2019-Sep-Third/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 보았는가 다음주엔 무엇을 하겠는가 무엇을 했는가몇 번의 면접을 거치면서 스스로 자신감이 부족하다는 생각이 들었다. 솔직히 말하건대 정말 함께하고 싶은 그런 기업들이 아니었음에도 그런 기업들에서조차 난 면접에서 자신감이 부족했다. 결국 실력때문이라는 생각이 들었다. 실력을 더 키우기 위해 더 열심히 준비해야하는건 당연한데, 혼자하기보다 함께 할 사람들이 필요했다. 서로가 서로에게 동기부여가 될. 그래서 이번주에만 2개의 스터디에 참여를 결정했다. 하나는 직접 스프링 개념및 이론 목적의 스터디이고, 하나는 스프링을 활용해서 포트폴리오용 웹 어플리케이션을 만드는 프로젝트 스터디이다. 일단 한 번씩 모임이 있었기 때문에 더 해봐야 알겠지만, 함께 할 사람들을 찾았다는 것에 만족하는 한 주였다. 무엇을 보았는가. 그동안 Git을 다루면서 불필요한 커밋이 생성되곤 했었는데, 이걸 해결하는 방법을 배웠다. Git CLI에서 `git rebase -i 커밋ID` 를 입력하면, 해당 커밋ID부터 뒤의 커밋 전부의 커밋을 관리할 수 있는 화면으로 접속한다. 해당 화면에서 커밋의 순서를 바꾸거나 커밋을 합병할 수 있다. 다음주엔 무엇을 하겠는가자바와 스프링에 조금 더 집중하려고 한다. 하나에만 온전히 집중해도 어려운데 내 호기심과 조급함이 더해져 이것저것하니 정작 무엇하나 완전하게 학습하는게 어려운 것 같다. 그래서 앞으로는 자바와 스프링에만 집중하고, 그외는 교양수준으로 경험하려고 한다. (예를 들면 Django) 대신 코딩테스트에 대비해서 알고리즘 문제는 매일 한문제라도 풀어보려고 할 것이다. 백준 알고리즘 사이트에서 생기초 단계부터 풀어보며 연습하고 있는데 가끔 풀어보는 실전 문제는 지금 풀어보는 문제와는 수준이 다른 문제다. 결국은 기본적인 논리로 해결하는게 아니라 알고리즘이나 자료구조에 대한 이해가 필요하기 때문에 이것들도 천천히 준비를 해야겠다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Git - 원격저장소 Url 변경하기","slug":"git-change-remote-branch-url","date":"2019-09-17T12:29:01.000Z","updated":"2020-09-13T01:53:28.912Z","comments":true,"path":"2019/09/git-change-remote-branch-url/","link":"","permalink":"http://youngjinmo.github.io/2019/09/git-change-remote-branch-url/","excerpt":"","text":"이럴 일이 어느 상황에서 발생할 수 있는지 잘 모르겠으나 개인적으로는 원격 저장소와 로컬의 히스토리간의 충돌이 발생했을 때 종종 사용했다. 한 2번..? 정도 사용해본 것 같은데, 일단 알아두면 유용할 것 같아서 남겨본다. 로컬 저장소가 바라보고 있는 원격 저장소의 url을 보는 방법은 다음의 명령어로 확인가능하다. 1git remote -v 그게 현재 로컬 저장소가 바라보는 원격 저장소의 url인데 이걸 바꾸려면 다음의 명령어로 바꿀 수 있다. 1git remote set-url origin https://github.com/youngjinmo/youngjinmo.github.io.git 저장소를 처음만들고, 원격 저장소에 지정할 때의 명령어는 아래와 같다. 아직 지정해둔 원격 저장소가 없을 때엔 remote와 origin 사이에 add를, 지정해둔 원격 저장소 주소를 바꾸고 싶을 땐 set-url을 붙이는 차이가 있다. 1git remote add origin https://github.com/youngjinmo/youngjinmo.github.io.git 그리고 변경사항을 푸쉬하면 제대로 이동되었음을 확인할 수 있다. 1git push -u origin master","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"알고리즘 - 문자열 변환 연습","slug":"Algorithms-changeLetter","date":"2019-09-15T10:28:21.000Z","updated":"2020-09-13T01:53:29.880Z","comments":true,"path":"2019/09/Algorithms-changeLetter/","link":"","permalink":"http://youngjinmo.github.io/2019/09/Algorithms-changeLetter/","excerpt":"","text":"ToC 짝수/홀수 인덱스에 따라 대소문자 변환 대소문자 서로 바꾸기 문자열 알파벳 순서대로 정렬하기 문자열 알파벳 역순으로 정렬하기 짝수/홀수 인덱스에 따라 대소문자 변환문자열을 argument로 받아서 짝수번째 문자는 대문자로, 홀수번째 문자는 소문자로 바꾸어서 다시 문자열로 반환해보았다. 대소문자 서로 바꾸기이번엔 문자열을 받아서 대문자는 소문자로, 소문자는 대문자로 바꾸는 메서드를 작성했다. 문자열 알파벳 순서대로 정렬하기문자열을 받아서 정렬을 하기 위해서 배열로 변환해야하는데, 문자형 배열(char[])로 하던, 문자열 배열(String[])로 하던 상관없다. 위의 출력 결과를 보면 HWdellloor은 10글자인데, length()를 확인해보면 11로 출력되는걸 알 수 있다. 원래 data에 포함되어 있던 5번째 인덱스의 space 값이 가장 앞에 포함되어 있기 때문이다. 정렬 기준은 ASCII코드 테이블에 의해 정렬되는데, space 값은 32번째 ASCII코드로써 위의 문자열 문자중 가장 앞선 순서를 갖는다. 문자열 알파벳 역순으로 정렬하기문자열을 배열로 변환해서 역순으로 정렬, 다시 문자열로 반환하는 방법도 위의 문자 순서 정렬과 비슷하다. 다만 Arrays.sort() 에 argument로 Collections.reverseOrder() 를 추가해야 한다. 그럼 자동으로 역순으로 정렬된다. 간편하다! Collections 객체에 내장되어 있는 reverseOrder()를 열어서 확인해보니 아래와 같이 정리되어 있었다. 1234// reverseOrder in Collections.javapublic static &lt;T&gt; Comparator&lt;T&gt; reverseOrder() &#123; return (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;&#125;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Algorithm","slug":"Dev/Algorithm","permalink":"http://youngjinmo.github.io/categories/Dev/Algorithm/"}],"tags":[{"name":"casting","slug":"casting","permalink":"http://youngjinmo.github.io/tags/casting/"},{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"}]},{"title":"HTML - Section, Article, Div..","slug":"HTML-Section-Article-Div","date":"2019-09-13T05:39:31.000Z","updated":"2020-12-03T08:33:27.074Z","comments":true,"path":"2019/09/HTML-Section-Article-Div/","link":"","permalink":"http://youngjinmo.github.io/2019/09/HTML-Section-Article-Div/","excerpt":"","text":"구름Edu에서 인스타그램 클론 코딩 강의를 구입하여 클론 코딩을 진행중이다. CSS에 대해 깊히 알지못하다보니 CSS 파트를 따라치는 것도 쉽지는 않다. 특히 마크업 구조가 복잡해지면서 &lt;div&gt; 태그만 사용하면, 내가 작성한 코드임에도 불구하고 마크업의 구조를 파악하기 어려워졌다. 그러다 문득 프론트엔드 개발자의 유튜브 영상을 보게 되면서 HTML 작성법에 대해 다시 한 번 생각하게 되었다. 먼저 마크업 랭귀지는 브라우저에서 인식하는 언어라고 한다. 따라서 어떻게 작성하느냐에 따라 브라우저에서 받아들이는(해석) 것이 달라질수 있고, 더 나아가 검색엔진에서의 검색 결과에 영향을 미치기까지 하다. 따라서 무분별한 &lt;div&gt; 태그 남발보다는 컨텐츠에 맞춰 &lt;section&gt;, &lt;article&gt;, &lt;nav&gt; 등의 태그를 사용하는 것이 좋다. 사용하려고보니 각각의 태그 사용법이 모호하여 이를 정리해본다. header 문서의 header를 나타낼때 사용한다. 해당 웹 페이지가 어떤 웹 페이지인지를 정의하는 문서영역이 이 영역에 해당한다. nav 현재 문서의 메뉴에 해당하는 영역이다.다른 문서로의 이동이 필요한 링크가 이 영역에 포함될 수 있다. div아무 목적 없이 그냥 영역을 나눌때 사용할 수 있는 태그이다. 그렇기 때문에 편하게 사용가능하지만 되도록 목적을 갖는 영역 또는 컨텐츠 영역은 단순히 &lt;div&gt; 태그로 묶기 보다는 아래의 &lt;section&gt;, &lt;article&gt; 태그를 이용하는 것을 권한다. 그래야 브라우저와 검색엔진이 어떤 컨텐츠인지를 올바르게 인식할 수 있다. section 같은 성격/유형의 컨텐츠를 묶는 태그 방식이다.header와 footer를 제외하면 큰 틀에서 section이 가장 큰 태그가 아닐까 싶다. article section처럼 같은 성격/유형의 컨텐츠끼리 묶을 떄 사용하는 태그이다. 따라서 section태그와 헷갈릴수 있지만, article만의 특징은 독립성을 이야기할 수 있다.article 태그 안의 컨텐츠만으로 독립이 가능한 영역이면 article 태그로 묶는다. aside 한 마디로 사이드바 영역이다.section이나 article보다는 nav와 비슷한 영역이 아닐까 싶다. footer header가 문서를 정의하는 영역이었다면, footer는 문서 작성자에 대한 정보가 담기는 영역이다.기업 홈페이지라면 이 영역에 사업자번호와 사업자대표, 사업장위치 등이 포함된다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"}],"tags":[{"name":"markup","slug":"markup","permalink":"http://youngjinmo.github.io/tags/markup/"}]},{"title":"Java - 배열 형변환","slug":"java-casting-array","date":"2019-09-10T07:43:50.000Z","updated":"2020-09-13T01:53:28.616Z","comments":true,"path":"2019/09/java-casting-array/","link":"","permalink":"http://youngjinmo.github.io/2019/09/java-casting-array/","excerpt":"","text":"알고리즘 문제를 풀다가 찾게되어 정리한다. String 형을 문자열 배열(String[])로 변환하는 법. String 형을 문자 배열(Char[])로 변환하는 법. 문자열 배열(String[])을 다시 String 형으로 변환. 문자열String ➡️ 문자열 배열String[]문자열(String)을 문자열 배열(String[])로 변환하는 법은 비교적 간단하다. 내장 메서드인 split(&quot;&quot;) 를 사용하면 파라미터의 &quot;&quot; 안에 넣은 값으로 구분하여 데이터를 쪼개어 배열로 반환된다. 아래 코드에서는 &quot;&quot; 안에 아무것도 넣지않았으므로 문자 하나하나 쪼개어 배열로 반환할 것이다. 만약 다른 기호나 문자를 파라미터 안에 포함시키면 해당 값으로 기준으로 쪼개어 배열로 반환된다. 확인하기 위해 출력하는 방법은 두가지로 구현해보았다. deepToString()배열을 출력하는 방법이 또 하나가 더 있다. 내장 메서드인 deepToString() 메서드인데, toString() 과 비슷하지만 조금 다르다. toString()은 2차배열을 제대로 저장하지 못하지만, deepToString()은 2차배열까지도 저장할 수 있다. 예제 코드를 보자. 문자열String ➡️ 문자열 배열 String[], 문자 배열char[] 문자열을 문자 배열로 변환하는건 toCharArray() 만으로 가능하다. 문자열과 달리 문자 배열은 어차피 문자 단위의 데이터 타입이기 때문에 더 단순한것 같다. 문자열 배열String[] ➡️ 문자열String 문자열 배열을 문자열로 바꾼 것이지만, 같은 방식으로 문자 배열(char[])또한 문자열로 간단히 바꿀수 있다. 이걸 활용해서 문자를 바꾸는 기초 알고리즘 연습을 해보았다. 다음 포스트에서 볼 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Algorithm","slug":"Dev/Algorithm","permalink":"http://youngjinmo.github.io/categories/Dev/Algorithm/"}],"tags":[{"name":"casting","slug":"casting","permalink":"http://youngjinmo.github.io/tags/casting/"}]},{"title":"Weekly Review - 8월 4주차","slug":"WeeklyReview-2019-Aug-Fourth","date":"2019-08-28T03:24:27.000Z","updated":"2020-09-13T01:53:29.772Z","comments":true,"path":"2019/08/WeeklyReview-2019-Aug-Fourth/","link":"","permalink":"http://youngjinmo.github.io/2019/08/WeeklyReview-2019-Aug-Fourth/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 읽었는가 무엇을 보았는가 그래서 이번 한주동안 무엇을 배웠는가 Things I did in this week.주말 양일간 스프링러너에서 진행하는 Mastering Spring Web 101 Workshop을 듣고왔다. 처음 알게된 행사였는데, 지인으로부터 추천받아서 듣게되었다. 딱히 자격요건은 없는것 같지만, 스프링이라는 주제 특성상 재직자 대상임을 추측할 수 있었다. ‘아직 구직중인 비전공자 초짜 개발자인 내가 들어도 되나’ 했지만, 10명 모집인원중 5명까지는 EarlyBird 50% 할인이 되길래 일단 질러서 참여하게 되었다. 결론만 이야기하면 쉽지 않았다. 다른 분들은 재직자시기도 했고, 주말 본인의 시간과 비용을 들이면서까지 이런 세미나에 참석하시는 분들의 특성상(?) 실력있는 분들이 많이 계셨나보다. 쉽지 않았음에도 튜터로 행사를 주도하신 용권님의 말씀처럼 스프링의 키워드를 접하고 경험할 수 있었던 좋은 경험이었다고 생각한다. 나에겐 쉽지 않은 세미나였지만, 스프링러너101은 바닥부터 시작해서 스프링의 주요 컴퍼넌트를 경험하는 세미나라고 하셨다. 이번이 3기였고, 이후 연말쯤 이 다음버전의 스프링러너201을 기획하신다고 하셨다. 혹시나 이 글을 읽으시는 분들 중 관심있는 분들은 스프링러너를 들을 수 있는 기회가 있다면 놓치지 마시라고 하고싶다. Fitbit 앱을 개발하고 있다. Fitbit 앱은 자바스크립트로 개발해야 하는데 이것때문에 생활코딩에서 자바스크립트 기초강의를 이동중에 듣고 있다.(유튜브 프리미엄 무료체험 이후 아이패드의 활용도가 훨씬 높아졌다!) 유튜브에서 Fitbit 앱을 만드는 라이브스트림 영상을 보며 따라치고 있는데, 내가 만든 앱이나 클락 페이스를 손목위에서 보게되는 날이 벌써 기다려진다. Things I read in this week. 조인석 Chris - 애자일이 무엇인가요? 이것 역시 스프링러너를 추천한 지인(블로그)으로부터 추천받아 읽게된 글이다. 애자일(Agile)에 대해서 자주 들어보긴 했지만, 방법론은 그동안 비개발자인 나랑은 상관없다고 해서 그동안 미뤄두고 있던 개념이었는데 이 글 하나로 애자일에 대한 개념을 보다 쉽게 이해하고 정리할 수 있었다. 글의 본문에서 저자는 애자일에 대해 간략하게 한 문장으로 이렇게 소개한다. 애자일은 기존에 소프트웨어 개발을 할 떄 사용하던 ‘구닥다리 일하는 방식’ 을 오랜 기간에 걸쳐 소프트웨어 제품을 만들어 오던 거장들이 소프트웨어의 소프트 한 면을 살려서 정의 한 일종의 **’유연하게 일하는 방식’**이라고 볼 수 있겠다. 애자일이란 용어 자체가 ‘기만한’, ‘재빠른’, ‘민첩한’ 이라는 뜻을 가지고 있는 것을 보았을 때, 이름 하나는 기가 막힌다. Things I watched in this week. - 10만명이 쓰는 앱을 대학생때 만든 썰 프로그래밍을 빠르게 배우거나 지금보다 더 잘하기 위해서는 어떻게 해야할까? 늘 고민하는 부분인데, 입문자들의 이런 질문에 숙련자들은 “프로젝트를 하세요” 라는 대답을 항상 하곤 한다. 그럼 입문자들은 또 이렇게 질문한다. “모르는데 어떻게 해요?” . 나도 이런 입문자 중 한 사람이었는데, 영상 속 개발자는 ‘무엇이든 시작하시라’, ‘모르는건 구글이알려준다’ 라고 설득한다(?). 그래서 영상을 보다가 문득 생각했다. ‘뭘 개발해볼까..?’ 그 때 손목 위의 Fitbit이 들어왔고, 유튜브에 “How to make fitbit app” 이라는 키워드로 검색하여 나온 한시간이 넘는 영상을 보며 개발을 시작했다. 아직까지 개발중이지만, 내가 사용할 클라이언트 서비스를 개발하니 괜히 재밌다. 이제 시작한지 얼마 안되어 아직도 ‘내가 완성할 수 있을까’ 라는 불확실함이 존재하지만 그래도 재밌으니까 계속해보고 싶다. Things I learned from this week.스프링러너를 통해 스프링 주요 컴포넌트를 많이 접했다. 대부분 쓴적도없고, 모르는 것 투성이지만 이 때 배운걸 정리하려고 한다. 스프링 컴포넌트뿐 아니라 잘 정리가 되지 않았던 자바 클래스에 대해서도 함께 정리하고자 한다. 그리고 또 하나.스프링러너에서는 스프링 빌드 시스템으로 Gradle을 사용했는데, 내가 학원에서 배운건 Maven이었다. Gradle은 Maven 보다 최신 빌드 시스템이라고 하는데, 난 이걸 이제서야 경험한거다. 이뿐만 아니라 스프링러너에서는 JSP가 오래된 기술이어서 실무에서 더 이상 사용하지 않는다고 했다. 내가 그동안 학원에서 배운게 길게는 8년이나 된 오래된 기술들이었고, 해당 기술을 사용하는 기업과 사용하지 않는 기업들이 명확하게 구분되는 순간이었다… 생활코딩 유튜브 채널을 구독과 알림설정을 하고 있는데, 며칠 전 꿀팁이 배달되어 왔다. 평소 터미널을 자주사용하면서 딱 하나 아쉬운점으로 길게 작성한 명령어를 수정하는 일이었다. 길게 작성한 명령어에서 오타가 발견되었는데 그 오타가 중간지점에서 발생하면 여지없이 다시 작성해야했는데 이제 그럴 필요가 없게 되었다. 이고잉님 말씀처럼 인생의 시간을 절약하게 될 것 같다 :)","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Java - 형변환","slug":"Java-casting","date":"2019-08-20T02:23:41.000Z","updated":"2020-09-13T01:53:29.808Z","comments":true,"path":"2019/08/Java-casting/","link":"","permalink":"http://youngjinmo.github.io/2019/08/Java-casting/","excerpt":"","text":"이것 역시 계산기를 만들어보다가 형변환 일이 있어서 구글링을 했는데, 아예 형변환에 대해 정리해두면 좋을 것 같아 작성해보았다. 목차 To integer Double to integer String to integer Char to integer To double Integer to double To char Integer to char String to char String to char Array To String Integer to String Double to String Char to String ➡️ Integer 그냥 단순히 (int)b 로 명시적 형변환을 하면, 값이 손실된다. 따라서 Math 클래스 내부함수(ceil(): 반올림)를 이용하여 형변환 해야한다. String을 Integer로 바꾸는 형변환은 두 가지를 사용했다. Integer.parseInt(str)와 Integer.valueOf(str).intValue(). 그런데 위 두함수를 출력함수에 직접 넣어서 출력하면 int형으로 형변환되지 않는것으로 보인다. Integer.parseInt(c)+10 이 100으로 출력되어야 하지만, 9010으로 출력됨을 알 수 있다. 그래서 int형 변수를 만들어서 형변환 함수 결과를 저장하고 이를 출력하면 연산에 사용할 수 있었다. char형을 int로 형변환하면 char형에 담겨있는 데이터를 ASCII 코드테이블에 따라서 decimal(십진법)로 변환해준다. ➡️ double 이 경우엔 단순히 변수 앞에 (double)을 붙여서 강제 명시적 형변환을 해서 바꿀 수 있다. 그러나 원래 데이터 타입만 바뀌었을 뿐, 원래 데이터와 똑같은 값을 가지는걸 알 수 있다. ➡️ char int형을 char형으로 변환하면, int형 값 ASCII 코드 테이블에 따라 decimal에 대입하여 symbol을 출력한다. String을 char로 변환할 때엔 문자열을 인덱스마다 나눠서 char형으로 저장한다. c.charAt(index) 를 이용하면 index에 따라 문자열을 문자형으로 바꿔서 가져올 수 있다. 또 문자열 전체를 문자형(char) 형태로 변환하고자 한다면 문자형 배열을 만들어서 저장하는 방법이다. Arrays.toString(char.toCharArray()) ➡️ String 문자열(String)로 형변환할 때엔 String.valueOf() 를 사용한다. 잘 바뀌었는지 확인하기 위해 문자형(char) 데이터와 문자열(String) 데이터와 비교하여 boolean 값을 출력하는 테스트를 해보았다. 문자열로 형변환한 데이터와 &quot;d&quot;와 비교했을때 true, &#39;d&#39;와 비교했을 때 false를 출력한걸로 보아 성공적으로 형변환되었음을 확인하였다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"casting","slug":"casting","permalink":"http://youngjinmo.github.io/tags/casting/"}]},{"title":"Java - Math Class","slug":"java-math","date":"2019-08-19T11:28:28.000Z","updated":"2020-09-13T01:53:28.516Z","comments":true,"path":"2019/08/java-math/","link":"","permalink":"http://youngjinmo.github.io/2019/08/java-math/","excerpt":"","text":"간단하게 계산기 만들어보는중에 Math 클래스를 사용할 일이 있어서 여기에 정리해보려고 한다. 각각의 함수를 오라클 공식 도큐먼트와 링크해두었다. 자주 사용하는 Math 클래스의 내부 함수이다. Math.abs( ) abs 함수는 모든 숫자 데이터타입을 지원한다. (int, long, float, double) 절대값을 구하는 함수 Math.ceil( ) 반올림 함수 Math.floor( ) 내림 함수 Math.round( ) 올림 함수 max( arg1, arg2 ) 두 수중 큰 수 구하는 함수 min( arg1, arg2 ) 두 수중 작은 수 구하는 함수 pow( arg1, arg2 ) num1의 num2 제곱 random( ) 1부터 10까지 수중 랜덤 수 출력하는 함수","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"math","slug":"math","permalink":"http://youngjinmo.github.io/tags/math/"}]},{"title":"Weekly Review - 8월 3주차","slug":"WeeklyReview-2019-Aug-Third","date":"2019-08-19T11:05:30.000Z","updated":"2020-09-13T01:53:29.748Z","comments":true,"path":"2019/08/WeeklyReview-2019-Aug-Third/","link":"","permalink":"http://youngjinmo.github.io/2019/08/WeeklyReview-2019-Aug-Third/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 읽었는가 무엇을 보았는가 그래서 이번 한주동안 무엇을 배웠는가 Things I did in this week.월요일에 7개월간의 국비지원 교육이 끝이 났다. 처음 시작할 때엔 뭔가 대단하게 많이 배우고 실력이 엄청나게 상승할줄 알았지만, 그러지 못했다. 교육과정이 끝나갈 무렵이 되니까 마음이 다소 무거웠다. 7개월간 이것저것 많이 공부하고 나름 열심히 한다고 했지만 아쉬움이 많이 남았다. 파이널 프로젝트에서 게시판을 하나 만들었는데 이 또한 아쉬운 결과였다. 게시판 하나만 구축해보았고, 그나마 게시판도 더 하고싶은 기능이 있었지만 기한 내에 다 구현하지 못했다.ㅜㅜ 이미 프로젝트는 끝났지만, 프로젝트 레파지토리를 fork해두고 못다한 기능을 구현해야할 것 같다. 화요일엔 학원에서 진행했던 실전면접의 결과로 SI업체로부터 2차 면접을 제안받아 처음으로 개발자 면접을 보고왔다. 아직 면접 결과가 나오지 않았기 때문에 상세하게 작성할 순 없기 때문에 나중에 정리하도록 하겠다. Things I read in this week. 부스트 캠프 2019 참여 후기 나도 지원했었던 부스트캠프에 대한 후기였다. 이 분이 작성한 후기를 읽으니까 내가 왜 떨어졌는지, 그리고 앞으로 알고리즘을 정말 정말 준비해야겠다는 생각을 다시 한 번 들게끔 한 글이었다. 부스트캠프의 합격한 크루들은 알고리즘 실력들이 상당하다고 한다. 참고로 글을 작성한 분의 다른 글을 읽어보니 카페24 코딩테스트에도 통과해서 신입사원 교육 프로그램도 이수중이셨던 것 같은데, 프로그램 이수를 포기하고 부스트캠프에 지원, 합격하셔서 이수한 분이다. 이 분의 글을 보면, 카페24 코딩테스트가 *’굉장히 쉬웠다’*라고 표현할만큼 실력이 있는 분이신 것 같은데, 이 분의 시선에서 실력있는 분들이 많이 계시다고 하니 어느정도 일지 감이 안선다. 후. 알고리즘.. 알고리즘.. 해야할게 점점 더 쌓이는 느낌이다. Things I watched in this week. David Jung - 정규화 학원에서 진행된 실전 면접에서 받았던 데이터베이스 정규화에 대해 알아보고자 유튜브에서 영상을 찾아보았다. 그러다 코드스쿼드의 정호영님이 정리한 영상이 있어 이걸로 공부를 했다. Things I learned from this week.데이터베이스 정규화를 해야하는 이유에 대해 배웠다. 정규화는 데이터의 중복 발생을 방지하고, 이상현상(abnormaly)을 방지하는 작업이다. 이상현상에는 삽입이상, 삭제이상, 갱신이상이 있다고 한다. 정규화는 크게 7단계로 구성되는데 일단 4단계까지만 생각하면, 1정규형, 2정규형, 3정규형 그리고 BCNF라고 한다. 지금은 이정도로만 정리하고, 다음에 정규화에 대해 더 정리해보아야겠다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Oracle - 테이블 복사 및 이름변경","slug":"oracle-rename-table","date":"2019-08-16T01:58:20.000Z","updated":"2020-09-13T01:53:28.248Z","comments":true,"path":"2019/08/oracle-rename-table/","link":"","permalink":"http://youngjinmo.github.io/2019/08/oracle-rename-table/","excerpt":"","text":"본 포스트는 행복안테나님의 JavaRa 블로그 포스트를 참고 및 인용하여 작성했습니다. 오라클 데이터베이스를 연습해보면서 테이블을 생성할 일이 많은데, 이 때마다 데이터를 insert 하는게 여간 귀찮은일이 아니다. 그래서 알아보니 테이블을 복사하는 방법이 있었다. 먼저 데이터를 넣을 테이블부터 생성. 123456789CREATE TABLE test01 ( id NUMBER, name VARCHAR2(100)); INSERT INTO test01(id, name)VALUES(1, &#x27;DevAndy&#x27;);INSERT INTO test01(id, name)VALUES(2, &#x27;JavaProgrammer&#x27;); 위에서 생성한 test01 테이블과 똑같은 test02 테이블을 생성하겠다. 12345CREATE TABLE test02AS ( SELECT * FROM test01); 이렇게만 하면 test01 의 스키마 구조1와 데이터를 test02 테이블이 모두 가져와서 생성된다. 이외에도 테이블을 복사하는 방법은 몇 가지 더 있다. 테이블의 스키마 구조만 복사하고 싶을 때. 123456CREATE TABLE test03AS ( SELECT * FROM test01 WHERE 1=0); WHERE 조건이 false가 되기때문에 데이터는 못가져오고 스키마 구조만 가져올 수 있다. 이미 만들어진 테이블에 다른 테이블에서 데이터만 가져오고 싶을 때. 12INSERT INTO test03SELECT * FROM test01; 테이블의 이름을 변경하고자 할 때 12ALTER TABLE test03RENAME TO test03_new; 1 스키마(Scheme) : 데이터베이스의 구조와 제약조건(Constraint)에 관한 전반적인 명세.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"Oracle - 데이터 컬럼명(Attribute) 수정","slug":"oracle-rename-column","date":"2019-08-15T08:50:34.000Z","updated":"2020-09-13T01:53:28.252Z","comments":true,"path":"2019/08/oracle-rename-column/","link":"","permalink":"http://youngjinmo.github.io/2019/08/oracle-rename-column/","excerpt":"","text":"오라클에서 데이터 컬럼명(Attribute name)을 수정할 땐, 직접 컬럼명을 수정하는게 아니라 새로운 이름의 Attribute를 생성하고, 바꾸려고 하는 Attribute의 데이터(turple)를 새로운 Attribute으로 덮어씌우는 방식을 사용한다. 마지막으로 이전의 attribute를 삭제하면된다. 새로운 이름의 Attribute 생성 12ALTER TABLE [테이블 이름]ADD [새컬럼명 데이터타입] 이전의 튜플을 새로운 Attribute의 튜플로 붙여넣기 12UPDATE [테이블 이름]SET [새컬럼] = [구컬럼] 이전 Attribute 삭제 12ALTER TABLE [테이블 이름]DROP COLUMN [구컬럼] 조회해서 확인해보기 1DESC [테이블 이름] 만약 컬럼명이 아니라 컬럼의 데이터 타입을 바꾸려면 어떻게 해야할까? 1234ALTER TABLE [테이블 이름]MODIFY ( [컬럼] [신규 데이터타입]);","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"Oracle - 기본 CRUD 쿼리","slug":"oracle-crud","date":"2019-08-14T02:20:10.000Z","updated":"2020-09-13T01:53:28.316Z","comments":true,"path":"2019/08/oracle-crud/","link":"","permalink":"http://youngjinmo.github.io/2019/08/oracle-crud/","excerpt":"","text":"테이블을 생성하는 것부터 시작해서 기본적인 데이터 삽입/조회/수정/삭제 등의 쿼리를 정리해보았다. 목차 오라클 계정내 테이블 전체조회 테이블 생성하기 테이블 조회하기 시퀀스 생성하기 데이터 삽입하기 데이터 추가하기 데이터 수정하기 데이터 삭제하기 계정 내 테이블 전체 조회123456SELECT table_name, ownerFROM all_tablesWHERE owner=&#x27;TUTORIALS&#x27;; 테이블 생성하기12345CREATE TABLE books_bought( id NUMBER, title VARCHAR2(100), author VARCHAR2(100), writtenDate DATE); 테이블 조회하기1234SELECT *FROM books_bought; 시퀀스 생성하기1234567DROP SEQUENCE books_bought_SEQ;CREATE SEQUENCE books_bought_SEQSTART WITH 1INCREMENT BY 1MAXVALUE 1000MINVALUE 1NOCYCLE; 테이블에 데이터 삽입하기12INSERT INTO books_bought(id, title, author, writtenDate)VALUES(1, &#x27;Everybody Lies&#x27;, &#x27;Seth Stephens Davidowitz&#x27;, TO_DATE(&#x27;2003/05/03 21:02:44&#x27;, &#x27;yyyy/mm/dd hh24:mi:ss&#x27;)); 시퀀스 사용해서 데이터 추가하기1234INSERT INTO books_boughtVALUES(books_bought_SEQ.nextval, &#x27;82년생 김지영&#x27;, &#x27;조남주&#x27;, &#x27;2018/07/30&#x27;);INSERT INTO books_boughtVALUES(books_bought_SEQ.nextval, &#x27;90년생이 온다&#x27;, &#x27;임홍택&#x27;, &#x27;2019/07/31&#x27;); 데이터 수정하기123456UPDATE books_boughtSET writtenDate = (TO_DATE(&#x27;2019/08/01&#x27;, &#x27;yyyy/mm/dd&#x27;));UPDATE books_boughtSET id=3WHERE author=&#x27;임홍택&#x27;; 데이터 삭제하기12DELETE FROM books_boughtWHERE id=1; 추가로 하나 더. 123-- 마지막으로 insert한 데이터 조회하기select max(id)FROM books_bought;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"데이터베이스 - 정규화","slug":"database-normalization","date":"2019-08-13T05:57:11.000Z","updated":"2020-09-13T01:53:29.100Z","comments":true,"path":"2019/08/database-normalization/","link":"","permalink":"http://youngjinmo.github.io/2019/08/database-normalization/","excerpt":"","text":"기술 면접을 준비하던 중 데이터베이스 정규화에 대해 알아보다가 유튜브에서 정호영님의 영상을 보고 정리한 글. 이것만으로는 명확하게 이해하지 못한 것 같아 일단 이렇게 rough하게 정리하고 계속 공부해야겠다. 목차 이상 현상 정규형 이상현상데이터베이스의 설계가 잘못될 경우 데이터의 중복 발생 이상현상(anormaly) 발생 삽입 이상 삭제 이상 갱신 이상 삽입 이상 DNUMBER, DNAME, DMGRSSN 컬럼에 해당하는 데이터를 삽입하려고 하나 실패한다. 해당 테이블의 primary key인 SSN 의 컬럼의 데이터가 비어져 있기 때문이다. 데이터를 삽입하는 과정에서 primary key를 추가하지 않아서 발생하는 문제. 데이터베이스 설계를 잘못해서 발생하는 현상. 삭제 이상 EMP_DEPT 에서 사원 데이터 한 명만을 삭제하고 하더라도 위와같이 설계가 잘못이루어졌을 경우, 사원 데이터 한 명만 삭제되지 않고 사원데이터의 외래키(foreign key) 참조하는 EMP_DEPT 까지 삭제되는 정보의 손실이 발생할 수 있다. 갱신 이상 위와 같이 설계된 데이터베이스에서 부서이름(DNAME)을 바꾸려면, 커럼 하나만 바꿔서 될게 아니라 전체를 하나하나 일일히 바꿔줘야 한다. 정규화를 제대로 하지 않았기 때문에 발생한 현상. 단계별 데이터베이스 정규화이상현상(abnormaly)이 잘 발생하지 않는 좋은 테이블이 갖추어야할 조건 1정규형 2정규형 3정규형 BCNF 아직 명확하게 이해하지 못했지만, 데이터 베이스 정규화의 단계별 작업을 설명한 이미지를 첨부한다. 추가 트위터에서 발견하고 여기에 남겨본다. &quot;정규화는 중복을 없애 디스크 공간을 절약하기 위한 것이었으며, 예전에는 디스크 공간이 비쌌기 때문입니다. 그러나 이제는 상황이 달라졌습니다. 쿼리에 걸리는 시간 최적화가 중요하며, 비정규화가 이를 달성하기 위한 직접적인 방법입니다.&quot;https://t.co/IPtGQ7mmr0&mdash; 씨언 (@if1live) October 7, 2019","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"normalization","slug":"normalization","permalink":"http://youngjinmo.github.io/tags/normalization/"}]},{"title":"WeeklyReview - 8월 2주차","slug":"WeeklyReview-2019-Aug-Second","date":"2019-08-10T06:01:32.000Z","updated":"2020-09-13T01:53:29.768Z","comments":true,"path":"2019/08/WeeklyReview-2019-Aug-Second/","link":"","permalink":"http://youngjinmo.github.io/2019/08/WeeklyReview-2019-Aug-Second/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 읽었는가 무엇을 보았는가 그래서 이번 한주동안 무엇을 배웠는가 What I did in this week.지난주 실전 면접 피드백을 받았다. 자신감있게 대답한 부분은 좋았지만 기술면접에 대해 조금 더 준비하라는 피드백을 받았다. 면접 때 *”static과 void에 대해 설명하시오.”*라는 질문에 어이없게 반만 대답을 했다. 긴장을 안한다고 생각했는데 막상 면접 중반부터 긴장을 해서인지 static에 대해서는 *”static은 자주 사용하는 객체를 메모리에 미리 할당해놓고, 인스턴스 생성없이 사용할수 있도록 할당하는 것”*라고 대답해놓고 void는 모른다고 대답했다. 첫 인터뷰인걸 감안하고 앞으로 이를 바탕으로 준비를 더 잘해야겠다. 아무튼 생각한것보다는 면접관이 잘봐줘서인지 2차 면접을 제안받았고, 응하기로 결정했다. 실전 면접때 질문을 하지 못해서 2차 면접에서는 질문도 하고 싶다. 결과와 상관없이 이런 면접 경험이 향후 구직에 도움이 될 것으로 기대한다. 항상 도움을 받고있는 ios개발자 동건님으로부터 스프링러너 Mastering Spring Web 101 Workshop 라는 워크샵을 추천받았다. 이틀간 스프링 부트를 학습하는 기회인데, 교육비용이 30만원이라 부담스러웠는데 얼리버드는 50%할인이라고 해서 일단 결제했다. 좋은 기회라고 생각했는데 잘 따라갈수 있을지 걱정이 드는것도 사실이다. 과정 마치는대로 부족한 부분을 채우면서 준비해야겠다. What I read in this week. 삐멜 - 컴퓨터공학에 접근하는 방법 프로젝트가 막바지에 치닫는 가운데 본격적인 구직준비도 해야해서 시간날때마다 기술면접 대비해서 글을 읽곤 하는데 최근에 이를 준비할 수 있는 최고의 글을 알게 되었다. 트위터에서 팔로우하고 있는 삐멜님이 정리해주신 글인데 나처럼 비전공자들에게 더 없이 좋은 자료라고 생각된다. 구직하면서 다 학습하지 못하더라도 최소한 자료구조/네트워크/데이터베이스만이라도 이해하고 준비할 수 있도록 해야겠다. What I watched in this week. 노마드코더 - yes, python is slower than C. 파이썬이 C언어보다 느린 이유라고 제목을 달았지만, 영상의 내용은 **인터프리팅 언어(Interpretation)**와 **컴파일러 언어(Compilation)**의 차이를 설명해주는 영상이다. 영상만의 내용으로는 정리하기에 부족할 것 같아 삐멜님의 블로그 포스트를 참고하여 정리 정리하면 다음과 같다. 번역기란 개발자가 작성한 프로그래밍 언어를 기계어로 번역하는 것을 말하는데 JDK(Java), Python(Python), gcc(C) 등이 여기에 해당한다. 인터프리팅 방식으로 구동되는 언어를 스크립트 언어라고 하는데, Python, Javascript, Php가 대표적인 스크립트 언어이다. 컴파일러로 구동되는 언어는 Java와 C가 있다. 기계어로 번역하는 방식에 따라 인터프리터와 컴파일러로 나뉘는데 둘의 차이는 다음과 같다. 인터프리터는 코드를 line by line으로, 실시간으로 기계어로 번역한다. 코드를 실행할때마다 번역하는 특징이 있다. 컴파일러는 최초 번역시에 전체 코드를 번역해서 하나의 바이너리 코드를 만들어낸다. 이후부터는 코드를 번역할 필요없이 생성된 바이너리 코드를 실행한다. 코드를 실행할때마다 번역을 해야하는 인터프리터와 비교해서 바이너리 코드를 실행하는 컴파일러의 실행속도가 상대적으로 빠르다는 장점이 있으며, 인터프리터의 경우 번역시에 에러를 발견하면 실행할 때에도 에러가 발생할 수 있으나 컴파일러 언어는 최초 번역시에 에러가 없다면 에러없는 코드로 바이너리 코드가 생성되기 때문에 실행시에 에러가 발생할 일이 없다는 장점 역시 존재한다. - 우아한Tech - [10분 테크토크]👩🏻‍💻👨🏻‍💻해리&션의 MVC 패턴 지난 4월 나도 지원했다가 코딩테스트의 문턱을 넘지 못했던 우아한 테크코스 ㅋㅋㅋ 어떤 분들이 합격하셔서 어떻게 코스를 진행중인지 궁금했는데, 유튜브 계정으로 학습내용을 공유해줘서 감사한마음으로 구독중이다. 기술 면접을 준비하면서 MVC패턴에 대해서도 정리가 필요했는데 이 영상으로 간단히 준비할 수 있었다. 영상 속의 발표자들이 정리해주신 내용은 대략 다음과 같다. MVC 패턴의 정의 모델1과 모델2(MVC)의 정의와 차이 MVC 흐름 클라이언트 -&gt; 웹 어플리케이션 -&gt; 컨트롤러 -&gt; 뷰 -&gt; 컨트롤러 -&gt; 모델 -&gt; DB -&gt; 모델 -&gt; 컨트롤러 -&gt; 뷰 -&gt; 클라이언트 MVC 패턴에서 Model, View, Controller의 역할 Model은 값과 기능을 갖는 객체이며, 비즈니스 로직를 수행하는 역할을 한다. View은 모델에 포함된 데이터를 시각적으로 보여주는 역할을 한다. Controller는 모델 객체로의 데이터 흐름을 제어하며 뷰와 모델의 역할을 분리한다. MVC 패턴을 사용할 때의 이점 컴포넌트의 코드 결합도를 낮추기 위해 코드의 재사용성을 위함 구현자들 간의 효율성을 높이기 위함 What I learned from this week. 노마드코더의 영상덕분에 컴파일러와 인터프리터의 차이를 다시 한 번 정리할 수 있었다. 이외엔 프로젝트 수행시에 하나 배운 것이 있다. sql문을 제어하는 DaoImpl 파일에서 공통적으로 사용하는 sql 제어문을 &lt;sql&gt;로 캡슐화할 수 있다. 이렇게 캡슐화한 제어문은 &lt;include refid=&quot;&quot;/&gt; 명령어를 통해 사용할 수 있다. 내가 프로젝트에서 사용한 코드이다. 123456789101112131415161718192021222324252627&lt;sql id=&quot;selectBoard&quot;&gt; SELECT boardno, tag, title, product, content, writer, hit, price, writtendate, (SELECT COUNT(*) FROM UsedComment_KG WHERE boardno = UsedBoard_KG.boardno) commentCnt, (SELECT min(usedimgno) FROM UsedImg_KG WHERE boardno = UsedBoard_KG.boardno ) AS fileno FROM UsedBoard_KG&lt;/sql&gt; &lt;sql id=&quot;selectSearch&quot;&gt; SELECT rownum rnum, B.* FROM ( &lt;include refid=&quot;selectBoard&quot; /&gt;&lt;/sql&gt; &lt;select id=&quot;selectPageSearch&quot; parameterType=&quot;web.util.Paging4used&quot; resultType=&quot;web.dto.UsedBoard&quot;&gt; SELECT * FROM ( &lt;include refid=&quot;selectSearch&quot; /&gt; ) R WHERE rnum BETWEEN #&#123;startNo &#125; AND #&#123;endNo &#125; &lt;/select&gt; 기본 게시판을 조회하는 sql제어문을 selectBoard 라는 id값으로 sql문을 만들었고, 이를 사용하는 코드에서 &lt;include refid=&quot;&quot; /&gt; 문으로 사용했다. 이렇게 코드를 작성하니 xml에서 sql제어문도 객체지향적으로 정리할 수 있겠다라는 생각이 들었다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Weekly Review - 8월 1주차","slug":"WeeklyReview-2019-Aug-First","date":"2019-08-06T11:26:50.000Z","updated":"2020-09-13T01:53:29.804Z","comments":true,"path":"2019/08/WeeklyReview-2019-Aug-First/","link":"","permalink":"http://youngjinmo.github.io/2019/08/WeeklyReview-2019-Aug-First/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 읽었는가 무엇을 보았는가 그래서 이번 한주동안 무엇을 배웠는가 What I did in this week.SQL강의를 들으면서 프로젝트를 동시에 하다보니 조금씩 SQL이 익숙해지고 있다. 실전 모의 인터뷰가 있어서 기술 인터뷰 대비하여 이론관련한 부분을 정리를 조금했다. 실전 모의 인터뷰를 했는데 긴장하지 않고 들어갔는데 막상 들어가서 생각하지 못했던 질문을 받으니까 긴장이 되고 대답이 잘안되었다. 잘하진 못했지만 면접관에서 배려해주시고 피드백해주신 덕분에 면접경험을 좋았다고 평가하고 싶다. 개발자로서 처음 해본 면접이었는데 덕분에 어떻게 인터뷰를 준비해야하는지를 가늠할 수 있었다. What I read in this week. 컴퓨터공학 정원 증대에 대한 트윗 타래 매일 경제 컴퓨터공학 정원 5배로 늘려야 한다. 기사에 대한 트윗 타래를 읽었다. 학원 출신의 비전공 개발자로써 아마도 저연봉의 SI 업계에서의 첫 출발이 점쳐지는 가능성이 높은 상황에서 이런 글을 읽으니 기분이 남다르다. 이 업계에는 이상한 모순이 존재한다. 처우에 대한 불만이 있는 노동자가 많음에도 업계에선 사람이 부족하다는 말이 오래전부터 끊임없이 나오고 있다. 사람은 있지만, 사람이 부족하다? 피라미드와 같은 구조에서 하위 구조엔 사람이 많지만, 상위구조엔 수요에 비해 공급이 부족하다는게 내 생각이다. 그리고 위 트윗 타래를 작성한 트위터리안이자 개발자님도 같은 생각이신 것 같다. 개발자는 많지만, 고급인력은 부족한 현실. 구직을 앞둔 상태에서 이런 글을 읽으니 기분이 남달랐다. 내 커리어의 시작은 아마도 이 바닥의 피라미드 구조에서 하위 계층에서 시작할 가능성이 높다. 여기에만 계속 있는다면 업계에 도움이 되지 못할 것이다. 언젠간 피라미드 상위로 올라가서 개발자가 부족하다는 업계에 도움이 되는 개발자로 성장하고 싶다. 커리어 내내 이 부분을 계속 생각하면서 일을 하고 싶다. What I watched in this week. 요즘 프로젝트 하면서 드는 생각이었는데, 딱 나처럼 고민을 하는 사람이 있었나보다. 덕분에 조언을 들을 수 있었다. 프로젝트 막바지인 지금, 이제 곧 구직을 해야하는 시기가 오는데 ‘내가 과연 일을 잘 할 수 있을까?’ 라는 고민이 계속 들었는데, 회사들어가서 어떻게 업무에 적응해야 하는지를 생각해볼 수 있었다. What I learned from this week.면접을 앞두고 객체지향의 특징에 대해 다시 정리했다. 객체지향 언어의 4대 특징 추상화_Abstraction 우리가 구현하는 객체들이 가진 공통적인 데이터와 기능을 도출해 내는 것을 의미한다. 캡슐화_Encapsulation 동일한 기능, 속성을 묶어서 유지보수에 용이하게 만드는 기법이다. 객체지향에서 캡슐화하는 데이터 구조와 데이터를 다루는 방법을 결합시켜 묶는 것을 말한다. 상속성_Inheritance 상위 객체의 속성을 하위 객체가 물려받는 것을 말한다. 상속이 있기 때문에 객체지향이 가능해진다. 다형성_Polymorphism 객체의 동일한 이름이지만 parameter를 다르게 함으로써 완전히 다른 객체로 사용할 수 있는 특징을 말한다. 마찬가지로 기초적인 질문일 수 있으나 프레임워크와 라이브러리의 차이이다. 이 개념의 핵심은 제어의 흐름, 제어권이 누구에게 있느냐에 있는 것 같다. Framework vs Library Framework 프레임워크는 컨테이너같은 개념이다. 개발자는 해당 컨테이너에서 필요한 부품만 개발해서 컨테이너에 장착해서 사용하면 된다. Java를 사용하는 Spring Framework, Python을 사용하는 Django 등이 이에 해당한다. 라이브러리와 다른 특징으로는 해당 어플리케이션의 흐름의 제어권이 어디에 있느냐로 구분할 수 있다. 라이브러리는 주도권이 개발자에 있지만, 프레임워크는 개발자가 부품을 채워넣을뿐 개발의 주도권은 프레임워크에 있다. 이를 **제어의 역전(IoC, Inversion Of Control)**이라고한다. 프레임워크의 함수(메서드)가 사용자 코드를 호출한다는 이야기이다. Library 라이브러리는 부품이다. 필요한 부품을 개발자가 가져와서 사용하면 된다. 현재 프로젝트에서 사용하고 있는 스마트 에디터 라이브러리, SummerNote가 여기에 해당한다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Oracle - GROUP BY, HAVING","slug":"oracle-groupby","date":"2019-08-04T04:27:05.000Z","updated":"2020-10-03T03:11:10.722Z","comments":true,"path":"2019/08/oracle-groupby/","link":"","permalink":"http://youngjinmo.github.io/2019/08/oracle-groupby/","excerpt":"","text":"select문 통해 조회한 결과를 정해준 기준(GROUP BY) 에 따라 그룹으로 분류하는 쿼리이다. EMP 테이블에서 부서별 평균 급여를 조회하고자 한다면, 다음과 같은 쿼리로 조회할 수 있다. 123SELECT deptno, avg(sal)FROM empGROUP BY deptno; 부서별 평균 급여가 2,000 이상인 부서의 평균 급여를 조회하려면 어떻게 해야할까? 이 경우엔 WHERE 절을 이용할 수 없다. 부서별 평균급여가 2,000 이상이라는 조건이 GROUP BY 에 조건을 걸어서 조회해야 하기 때문이다. 이 경우 사용하는 키워드가 HAVING 이다. 위의 퀴즈에 대한 sql 코드는 다음과 같다. 1234SELECT deptno, round(avg(sal))FROM empGROUP BY deptnoHAVING avg(sal)&gt;=2000;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"Weekly Review - 7월 3,4주차","slug":"WeeklyReview-2019-Jul-Fourth","date":"2019-07-30T02:18:02.000Z","updated":"2020-09-13T01:53:29.728Z","comments":true,"path":"2019/07/WeeklyReview-2019-Jul-Fourth/","link":"","permalink":"http://youngjinmo.github.io/2019/07/WeeklyReview-2019-Jul-Fourth/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 읽었는가 그래서 이번 한주동안 무엇을 배웠는가 What I did in this week.지난주에 3주차 Weekly Review를 작성하지 못했다 ㅠㅠ 그래서 3주차와 4주차를 한번에 작성한다… 현재 이수중인 국비지원 학원에서 취업지원을 위해 이력서 작성을 요구받았다. 정말 오랜만에 이력서를 그것도 다른 포지션으로 작성해보니 ‘6개월정도 공부했는데 이정도 밖에 안되나.’ 싶어서 살짝 자괴감도 들었다..ㅎ 그런데 학원에서 제공한 이력서 양식이 오래된 양식이어서 좀 놀랐다. ‘아직도 이런 양식으로 이력서를 작성하는구나’ 싶으면서도 이 양식으로 나라는 사람을 매력적으로 포장할 수 있을지 자신이 없었다. 그래서 내가 생각하는 이상적인 이력서를 새로 만들어보려고 한다. 그러면서 동시에 블로그에도 About 페이지를 만들어서 간단한 resume(프로필 수준?)를 올려보려고 한다. 지난주부터 스프링으로 게시판을 만들고 있는데, 생각한만큼 잘 되지 않는다. 현재 게시판에서 이미지를 첨부하고, 첨부한 이미지를 게시글에서 보여주고, 수정/삭제에서 이미지를 DB에서 삭제하는 부분을 하고 있는데, 이 중에서 DB에서 이미지를 처리하고 있지 못해서 수정/삭제를 구현하지 못하고 있다. ㅠㅠController와 DB에서 이미지를 일반 컨텐츠와 구분해서 관리하고 있는데, 다른 수강생분께 도움을 받아서 이렇게 시작했지만 아직 명확하게 이해하고 있지 못하고 있다ㅠㅠ 프로젝트를 하면서 Ajax에 대한 이해가 부족하다고 느껴서 Udacity에서 다시 Ajax 강의를 듣고 있다. What I read in this week.지난주에 오랜만에 이력서를 작성하고, 또 다음주로 예정되어 있는 실전면접을 앞두고, 이력서 작성하는 법과 인터뷰 관련한 자료를 조금 읽어봤다. 아직 얕게만 찾아봐서 코딩을 하다 짬짬히 봐야할 것 같다. 개발자의 포트폴리오, 이력서 작성법, 면접을 잘보는 법 Interview_Question_for_Beginner Development Common Sense What I learned from this week.국비지원 학원이 막바지에 이르고 있다. 이제 수료까지 한 2주 정도 남은 것 같은데, 매일 접하는 에러에 숨이 막힐 지경이다… 후..ㅋㅋ 처음 스프링 프로젝트를 시작할땐 금방 할 수 있을 것 같았다. 게시판 하나쯤이야 뚝딱하고, 다른 조원들을 돕고 싶었는데, 현실은 내 임무 하나 해결하기도 힘이든다.. 스프링 개발시에 모르는 컴포넌트가 있을때마다 Declaration을 열어서 인터페이스 내용을 파악하고 있는데 이게 도움이 되는 것 같다. 내가 작성하는 코드가 스프링 프레임워크에 의해서 어떻게 개발되는지를 알 수 있다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"리눅스에서 권한 변경하기 (A.k.a. Chmod)","slug":"linux-permission","date":"2019-07-17T00:44:51.000Z","updated":"2020-09-13T01:53:28.328Z","comments":true,"path":"2019/07/linux-permission/","link":"","permalink":"http://youngjinmo.github.io/2019/07/linux-permission/","excerpt":"","text":"각 권한별 명령어 디렉토리/파일 별 명령어 도커를 사용하다가 DB 때문에 리눅스를 만질일이 잠깐 있었다. TABLESPACE를 사용하기 위해서 오라클 11g가 설치된 도커 컨테이너의 Ubuntu에서 임의의 폴더를 생성후 DATAFILE의 경로로 설정했는데, 다음과 같은 에러(ORA-01119)가 발생했다. ORA-01119 는 DB TABLESPACE 에러라고 한다. 그리고 아래 Permission denied 라는 메세지가 출력된걸로 보아 해당 경로의 접근권한이 차단되어 TABLESPACE 에러가 발생했음을 유추하였다. 파일 디렉토리를 확인해보니 이런게 있었다. 빨간색 체크박스 안에 있는게 리눅스에서 권한(Permission)을 의미하는 퍼미션 정보라고 한다. /finalProject 폴더의 권한은 원래 아래 위의 다른 디렉토리와 같은 상태였다. 그럼 그 상태 메세지를 뜯어보자(?) drwxrwxrwx 앞에서부터 d 는 해당 파일 또는 디렉토 리의 파일형태를 의미한다. d는 directory를 의미, -는 일반파일을 의미한다. 멘 앞의 문자가 파일형태를 의미했다면 뒤의 문자 형태는 모두 권한을 의미한다. 문자의 위치에 따라 세글자씩 끊어서 파일형태 소유자-그룹-공개 로 구분하며 각 사용자에 따라 정의되어 있는 권한은 다음으로 해석할 수 있다. 각 권한별 명령어 사용자 owner : 소유자에 대한 퍼미션 지정 group : 소유그룹에 대한 퍼미션 지정 public : 모든 사용자들에 대한 퍼미션 지정 권한 r : 파일/디렉토리의 읽기(read) 권한 (4) w : 파일/디렉토리의 쓰기(write) 권한 (2) x : 파일/디렉토리의 실행(execute) 권한 (1) 위의 정보를 바탕으로 다시 빨가체크박스 속 권한을 해석하면 다음과 같다. 파일형태와 권한을 분리하고 각각의 사용자에 따라 -로 구분하면 다음과 같다. d rwx-rwx-rwx 즉 /finalProject 는 디렉토리 즉 폴더이며, 소유자와 그룹, 공개 모두 rwx로 퍼미션이 정의되어있는걸로 보아 접근권한으로 읽기, 쓰기, 실행 모두 허용되어있음을 알 수 있다. 그럼 마지막으로 접근권한은 어떻게 바꿀수 있을까? 위의 [권한](#permission)에서 권한에 따라 숫자가 정의되어있음을 알 수 있다. 리눅스 명령어를 입력할땐 영어문자 대신 저 숫자를 입력하여 권한을 변경해야 한다. 접근권한을 모두 공개하려면 각각의 사용자에 따라 읽고(r:4), 쓰고(w:2), 실행(x:1)하는 권한을 모두 허용해야 한다. 각각의 사용자에 맞춰 권한을 숫자로 바꿔 더해서 입력하면된다. rwx-rwx-rwx는 (4+2+1) + (4+2+1) + (4+2+1)로 변환할 수 있으며, 최종적으로 명령어로 바꾸면 chmod 777 이 된다. 정리하면 다음과 같다. 디렉토리/파일 별 명령어 디렉토리일 경우. (하위 디렉토리 전체 파일의 권한 지정) chmod -R [권한지정] [디렉토리이름] 파일일 경우. chmod [권한지정] [디렉토리이름] 그럼 일반 디렉토리를 위의 빨간 체크박스 속 권한처럼 바꾸려면 다음과 같은 명령어가 필요함을 알 수 있다. chmod -R 777 finalProject","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Linux","slug":"Dev/Linux","permalink":"http://youngjinmo.github.io/categories/Dev/Linux/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"}]},{"title":"Git - CLI에서 커밋 그래프 확인하기","slug":"git-graph-log","date":"2019-07-16T00:32:02.000Z","updated":"2020-09-13T01:53:28.896Z","comments":true,"path":"2019/07/git-graph-log/","link":"","permalink":"http://youngjinmo.github.io/2019/07/git-graph-log/","excerpt":"","text":"Sourcetree같은 git 전용 클라이언트를 사용하면 쉽게 커밋 그래프를 확인할 수 있다. CLI 환경에서 이와같은 그래프를 확인하려면 어떻게 해야할까? 1$ git log --oneline --graph --all --decorate 커밋 객체가 타임라인 순으로 보여진다. 브랜치명을 이름으로 구분해놓고 작업중이어서 개인정보 보호차원에서 가려놨지만 브랜치까지도 구분해서 확인할 수 있음을 알 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"Weekly Review - 7월 2주차","slug":"WeeklyReview-2019-Jul-Second","date":"2019-07-14T10:17:48.000Z","updated":"2020-09-13T01:53:29.720Z","comments":true,"path":"2019/07/WeeklyReview-2019-Jul-Second/","link":"","permalink":"http://youngjinmo.github.io/2019/07/WeeklyReview-2019-Jul-Second/","excerpt":"","text":"목차 한 주간 무엇을 했는가 무엇을 읽었는가 무엇을 보았는가 그래서 이번 한주동안 무엇을 배웠는가 What I did in this week.한 주간 오라클 강의를 들으며 강의 속 문제를 SQL 쿼리로 바꾸는 연습을 했는데, 이 덕분에 SQL 쿼리가 익숙해지기 시작했다. 다음주까지 계속 강의도 듣고, 책을 찾아보면서 관계형 데이터베이스까지 익히고 싶다. 지난주에 강의를 들으면서 동시에 블로그에 정리를 하려니 학습이 느리다고 판단해서 이번 한 주간은 강의를 일단 빠르게 듣고 다시 기억하고 싶거나 중요한 부분을 정리하는 방식으로 바꿨더니 학습이 확실히 빨라졌다. 빠르게 강의를 듣고 무엇을 정리할지 판단하니 이전보다 정리노트의 퀄리티도 더 나아지는것도 같다. 국비지원 학원에선 스프링으로 게시판 만드는 작업을 하고 있는데, 다른 수강생들보다 조금 느리게 작업을 하고 있다. 확실히 익히고자 코드 복붙없이 내가 직접 타이핑하면서 한 줄, 한 줄 의미를 이해하고 넘어가려고 하고 있다. 목요일이 지나면서 조급함이 들기 시작했다. 빠르게 하려면, 작동되는 코드를 복붙하고 작동하는걸 보며 이해해도 되겠지만, 그게 정말 좋은 학습법인지 회의적이기에 조금 늦더라도 직접 코드를 타이핑하려고 한다. 곧 이어서 파이널 프로젝트가 시작하기 때문에 스프링을 익히기에 더 없이 좋은 시기라는 생각이 든다. 3월에 강의들은 DB를 지금 다시 공부하는 것처럼 다시 스프링을 공부하지 않으려면 지금 확실히 해보려고 한다. 물론 고작 게시판 하나 만든다고 해서 스프링을 완전히 이해할 수는 절대 없다. 그러나 이미 했던 부분을 공부하는게 아니라 스프링에 대해 더 깊히 공부하려면 지금하는 부분을 확실히 이해하고 넘어가고싶다. 뭐 그렇다..ㅋㅋ 파이널 프로젝트를 앞두고 Slack과 Github 셋팅을 했다. Slack을 하는덕분에 자료 관리나 커뮤니케이션이 더 용이해졌다. 사실 Slack을 적용하는게 쉽지않다. 대부분의 조원들이 이제 막 졸업한 분들인데 대학생들은 Slack은 물론 이런 비즈니스 툴에 익숙하지 않다보니 필요성조차 못느끼고 있었다. 필요성을 못느끼는 사람들에게 Slack을 가입시키는게 어렵다보니 내 나름대로 Notion으로 메뉴얼을 만들어서 배포도 해봤는데 가입만 하고 실제 사용하는 사람의 비율은 반이 안되는것 같다. 지금도 프로젝트 조원들중 Slack을 매일 접속하는 사람은 6명중 나를 포함한 2명..? 밖에 안되는것 같다. 앞으로 어떻게 될지 궁금하다..ㅎ Github에서는 내가 가장 익숙하게 다루는 사람이다보니 브랜치 관리와 github 사용에 대해서 조장과 함께 리드를 하고 있다. Git에 대해서 나도 더 공부가 필요하지만 조원들 모두 Git의 원리를 모른채 add/commit을 하고있다보니 프로젝트 과정에서 함께 정리할 시간이 필요할 것으로 보인다. What I read in this week.이번 주엔 두 개의 글을 리뷰하려고 한다. 학원출신 취업, 면접 그리고 미래.. 초보 프로그래머에게 (남궁성의 초보코드스터디) 지금 딱 나와 같은 상황의, 국비지원 수료중인 비전공자 들을 위한 조언이다. 글에서 언급한대로 이제 6개월 정도를 공부한 지금, 정말 평생을 할 수 있는 일인지 생각해보았다. 올 초 제주도에서 참여한 카카오 코딩캠프 참여하면서 자신감이 붙은 상태에서 육지에 오자마자 바로 국비지원 교육을 이수하게 되었다. 수료가 끝나갈즈음엔 이 과정의 수료자중에서 내가 가장 실력자가 되고 개발자로서 보다 큰 자신감을 얻을 수 있을줄 알았다. 그러나 딱 6개월이 지난 지금은 기대와 달라졌다. 지금의 나는 현재 수료생중에서도 중간이 될까 싶을만큼 실력자와는 거리가 멀다. 강의 직후 곧바로 이해하고 프로젝트에 적용하는 전공자와 달리 난 몇 번은 더 코드도 봐야하고, 관련 블로그 포스트나 책, 강의를 한 번 더 봐야한다. 그것도 부족해서 코딩할때엔 강사나 다른 수강생들에게 질문을 하지 않으면 혼자서 게시판 하나 짜기도 힘든 상태이다. 6개월을 했음에도 왜 이것밖에 안될까 싶고 그래서 스스로에게 아쉽고 부끄럽지만 그래도 지난 6개월간 많은 것을 공부할 수 있었고, 실력은 부족하지만 공부하는게 힘들거나 지겹게 느껴지지 않는다. 오히려 새로운걸 계속 학습하고 싶고 함께 배우고자 하는 의지는 수료 초반과 크게 달라지지 않았다. 글에서 마지막에 언급한 것처럼 누구나 알만한 네임드 기업에서 높은 보수를 받는 나이스한 엔지니어가 되지 못하더라도 이 바닥에서 불행히 일하지 않을 자신은 있다. 그래서 포기할 마음이 없다. 계속 항해해보고 싶다. 이 글을 읽고나니 스스로 실력이 부족하다고 느끼는건 어쩌면 조급함의 결과가 아닐까도 싶었다. 4년을 공부한 사람들과 고작 6개월 공부한 나를 직접 비교하는건 애초부터 무리였을지도 모른다. 그러나 국비교육과정이 끝나면, 이들과 동등하게 구직을 준비하게 된다. 준비 기간이 부족해서 실력이 이정도라는건 충분한 변명일지 모르나 필드에서는 내 준비 기간이 어쩐지는 궁금해하지 않는다. 3개월을 했든, 3년을 했든 회사가 요구하는 수준의 실력을 갖추어야만 한다. 부족하다는 사실은 인정하되, 자괴감에 빠지기보다 계속 부족함을 채워나아가야겠다. 이 글 덕분에 다시 작게나마 용기도 얻고, 동기부여도 얻게 되었다. “평생직장은 없다, 최고가 돼 떠나라”.. 新기업의 탄생 평소 좋아하는 회사인 우아한형제들에 대한 이야기인데, 회사에 대한 이야기보다는 창업자들에 대한 이야기이다. 난 평생직장이 없다고 믿는 사람이다. 결국 언젠간 회사와 구성원이 이별하는 순간이 올텐데 웃으면서 하는 유일한 이별은 창업을 하기위해 퇴사하는 방법이다. 창업은 누구나 할 수 있는 커리어 선택지가 아니다. 회사생활도 어려운데, 조직을 신설해서 운영하는건 훨씬 더 어려운 일이다. 이렇게 어려운 일을 하기위해서는 남다른 노력을 해야하며 준비도 철저히 해야한다. 창업을 하기위한 준비가 되었다는건 그 조직에서 남다른 성장을 했다는 증거이다. 창업 후 실패할 수도 있으나 처음 회사에 조인했을때보다 성장했기 때문에 창업이라는 더 큰 도전에 나설 수 있는거라고 생각한다. 우아한형제들의 경영진처럼 구성원들의 더 나은 커리어를 응원하고 장려하는 조직에서 커리어를 시작하고 싶다. 창업을 할 수 있든 없든 상관없이 직원들의 커리어를 이렇게 생각하는 회사라면 개인의 성장도 기대해볼 수 있을 것이며, 그렇게 성장하는 개인들로 구성된 조직의 수준도 기대가 된다. What I watched in this week.백기선 - 개발자 고민 상담, “개발자는 기술이 핵심인 회사가 아니면 가면 안되나요?” 이번에도 백기선님의 유튜브 영상이다…ㅋㅋ 스프링을 학습하고 있는 사람으로 백기선님 영상은 요즘 내가 가장 관심있는 채널이면서 또 유익한 채널이기도 하다. 알람 설정을 해두고 빠지지 않고 대부분의 영상을 시청하고 있는데, 이제 다음달부터 본격적인 구직을 앞두고 기존에 내가 갖고있던 생각을 허물어뜨리는(?) 영상이었다. 이 영상을 보기 전까지는 나도 기술이 중심이 회사에서 커리어를 시작해야 한다고 생각했다. 그러나 개발은 어디서나 필요한 영역이고, 사업이 어떻느냐보다 결국 내가 그 회사에서 무엇을 하는지, 그리고 누구와 일하는지가 중요하다고 생각이 바뀌었다. 영상 속에서 백기선님이 언급하셨듯이 백기선님이 아시는 훌륭한 개발자분들이 우아한형제들에 많다고 하시는데, 해당 회사에 개발자분들이 많은게 우아한형제들이 개발이 주된 회사이기 때문에 조인하셨는지는 확신할 수 없다. 그러나 우아한형제들에 훌륭한 개발자분들이 많기 때문에 이들과 함께 일하기 위해 조인했다고 한다면 납득이 간다. 개발이 주된 회사이지만 내가 함께 일하고 싶어하는 개발자가 없고, 또 거기서 내가 하는 일이 내 커리어 발전에 도움이 안되는 일이라면 그 회사는 나에게 좋은 회사라고 할 수 없을 것이다. 반면 개발이 주된 회사가 아니어도 그러니까 영상 속 사연의 주이공처럼 교육이 업인 학원에서 개발자로 일하게 된다하더라도 내가 거기서 웹 백엔드를 계속 할 수 있고, 곁에서 많이 배울수 있는 좋은 사수 분들이 계시다면 지금의 나에게 좋은 옵션이 될 수 있다고 생각이 든다. 운좋게도 구직 전에 이 영상을 본 덕분에 앞으로 구직에 도움이 될 것 같다. What I learned from this week.위클리 리뷰를 작성하기 시작한지 3주가 되었다. 처음엔 주말에 공부를 하거나 코딩을 하는것도 아닌 이렇게 리뷰하는게 귀찮기도 했고, 뭐가 달라질까 회의적이었던것도 사실이었다. 그런데 이렇게라도 내가 한 주간 무엇을 했는지 정리를 하니 그 다음주엔 무엇을 할지, 더 나은 방법은 없는지 고민도 할 수 있고, 이를 통해 더 나아졌는지 아닌지도 생각해볼 수 있어서 좋았다. 계속 꾸준하게 작성해서 연말즈음에 내가 얼마나 성장했는지를 파악해보고 싶다. 또 그때가서 실망하거나 부끄럽지 않도록 이 위클리 리뷰를 통해 계속 채찍질해서 계속 배우고 성장해야겠다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Oracle - 새 DB계정 생성하고 접속하기","slug":"oracle-create-new-account","date":"2019-07-14T09:53:22.000Z","updated":"2020-09-13T01:53:28.316Z","comments":true,"path":"2019/07/oracle-create-new-account/","link":"","permalink":"http://youngjinmo.github.io/2019/07/oracle-create-new-account/","excerpt":"","text":"데이터베이스 계정을 새로 만들어서 접속하는 법을 정리하고자 한다. 12345-- DB 계정 생성CREATE USER [new user] IDENTIFIED BY [password];-- 접근 권한 허용grant connect, resource, dba to [new user]; 이렇게 하면 DB 계정이 생성된다. 새로 생성한 계정에 접속하는 방법으로는 2가지가 있다. 기존에 접속한 DB를 로그아웃하고 접속하는 방법과 로그아웃하지않고 추가로 DB계정에 접속하는 방법이다. 먼저 로그아웃없이 새 계정에 접속하는 방법이다. 1234-- 기존 접속한 DB 로그아웃없이-- 생성한 계정으로 DB 전환ALTER USER [new user] IDENTIFIED BY [password] account unlock; 기존 접속을 해제하고 다른 계정에만 접속하고자 한다면 아래의 방식대로 입력하면된다. 12345-- 현재 접속된 계정 비활성화(disconnect)disc;-- 계정 접속CONN [new user]/[password];","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"}]},{"title":"Oracle - SET","slug":"oracle-set","date":"2019-07-11T14:11:49.000Z","updated":"2020-09-13T01:53:28.236Z","comments":true,"path":"2019/07/oracle-set/","link":"","permalink":"http://youngjinmo.github.io/2019/07/oracle-set/","excerpt":"","text":"목록 SET UNION UNION ALL INTERSECT MINUS SET두 가지 select문을 통해 얻어온 결과에 대해 집합 연산을 하는 명령문이다. 두 select문의 각 컬럼의 개수, 순서가 완전히 같아야만 한다. UNION중복을 허용하지 않는 합집합. 중복이 있다면 하나의 row(데이터)만 가져온다. 1234567SELECT empno, ename, job, deptnoFROM empWHERE deptno=10UNIONSELECT empno, ename, job, deptnoFROM empWHERE job=&#x27;CLERK&#x27;; 쿼리 A 3개의 row가 조회된 것을 알 수 있다. 쿼리 B 4개의 row가 조회된 것을 알 수 있다. 쿼리 A, B를 UNION을 통해 조회 앞서 조회된 두 개의 쿼리 결과에서 중복된 결과인 ename=&#39;MILLER&#39;를 제외한 나머지 7개의 row가 조회된 것을 알 수 있다. UNION ALLUNION과 달리 중복되더라도 모든 row의 데이터를 조회하는 합집합 1234567SELECT empno, ename, job, deptnoFROM empWHERE deptno=10UNION ALLSELECT empno, ename, job, deptnoFROM empWHERE job=&#x27;CLERK&#x27;; 쿼리 A 쿼리 B 쿼리 A, B를 UNION ALL로 조회 각각의 쿼리에 따른 결과가 중복을 포함하여 7개의 row로 조회된 것을 알 수 있다. (MILLER가 두 번 조회되었다.) INTERSECT두 가지 쿼리의 교집합을 구하는 쿼리이다. 1234567SELECT empno, ename, job, deptnoFROM empWHERE deptno=10INTERSECTSELECT empno, ename, job, deptnoFROM empWHERE job=&#x27;CLERK&#x27;; 쿼리 A 쿼리 B 쿼리 A, B를 INTERSECT로 조회 MINUS두 가지 쿼리의 차집합을 구하는 쿼리이다. 정확히는 A 조회문에서 B조회문의 결과를 제외한 조회를 의미한다. INTERSECT에서 사용한 쿼리를 재사용해보겠다. 1234567SELECT empno, ename, job, deptnoFROM empWHERE deptno=10MINUSSELECT empno, ename, job, deptnoFROM empWHERE job=&#x27;CLERK&#x27;; 쿼리 A 쿼리 B 쿼리 A,B를 MINUS를 이용한 조회 쿼리 A의 조회 결과에서 쿼리 B와 중복되는 결과, 즉 INTERSECT 결과만 빠진 나머지 쿼리 A의 조회 결과만 조회된 것을 알 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"}]},{"title":"Oracle - JOIN","slug":"oracle-join","date":"2019-07-10T09:27:20.000Z","updated":"2020-09-13T01:53:28.272Z","comments":true,"path":"2019/07/oracle-join/","link":"","permalink":"http://youngjinmo.github.io/2019/07/oracle-join/","excerpt":"","text":"목록 JOIN SELF JOIN OUTER JOIN JOIN두 개 이상의 테이블에 있는 컬럼의 값을 한 번에 가져오기 위해 사용하는 쿼리이다. 조회하는 컬럼 중 어떤 컬럼은 A테이블에, 어떤 컬럼은 B테이블에 있다면, FROM 절에 A테이블, B테이블을 join해야 원하는 데이터를 조회할 수 있다. 위 쿼리에 대한 조회를 보면, emp 테이블에 대한 전체 조회를 했을 경우, 출력되는 컬럼 수는 14개이다. 그리고 dept 테이블에 대한 전체 조회를 했을 경우, 출력되는 컬럼 수는 5개이다. join을 해서 조회하면 두 테이블에 대한 데이터를 중복검사 없이 조회를 하기 때문에 emp 테이블의 14개와 dept 테이블의 5개를 결합한 총 70개의 데이터가 조회되는 것을 확인할 수 있다. SQL Developer 통해서 join한 전체 데이터를 다시 조회해보면, 중복되는 컬럼을 확인할 수 있다. 이 중복된 데이터를 제거하고 조회하고 싶다면, emp 테이블의 deptno 컬럼과 dept 테이블의 deptno 컬럼이 같다는 것을 명시하면 될 것이다. 123SELECT *FROM emp, deptWHERE emp.deptno = dept.deptno; 이렇게 하면 잘못된 데이터는 제외되고 14개의 데이터만 조회된다. SELF JOIN같은 테이블을 두 번 이상 조인하는 것을 Self Join이라고 한다. 아래의 데이터를 조회해보자. 1&#39;SMITH&#39; 사원의 사원번호(empno), 이름(ename), 직속상관의 이름(ename)을 가져온다. ename을 두 번 조회해야 하는 문제이다. 당연히 같은 이름이 아니며, ename 중 하나는 ‘SMITH’ 이름에 해당하며, 다른 하나는 ‘SMITH’ 사원의 직속상관(mgr)과 같은 사원번호를 갖는 사원의 이름이 될 것이다. 쿼리를 작성해보면 다음과 같다. 1234SELECT e1.empno, e1.ename, e2.ename as &quot;직속상관&quot;FROM emp e1, emp e2WHERE e1.ename = &#x27;SMITH&#x27; AND e1.mgr = e2.empno; -- e1 테이블의 mgr과 일치하는 empno를 갖는 테이블 조회 emp 테이블을 두 개 가져와서 하나는 ‘SMITH’ 사원에 대한 테이블로, 다른 하나는 ‘SMITH’ 사원의 직속상관에 대한 데이터를 찾는 테이블로 사용했다. OUTER JOIN조인 조건에 만족하지 못해 제거되는 row까지 모두 가져오는 것을 Outer Join이라고 한다. 아래의 퀴즈를 해결하며 알아보자. 12각 사원의 이름(ename), 사원번호(empno), 직속상관(mgr) 이름(ename)을 가져온다. 단 직속상관이 없는 사원도 가져온다. 일반 사원에 대한 테이블과 각 사원에 대한 직속상관에 해당하는 테이블 2개를 조회해야 함을 알 수 있다. 123SELECT e1.ename, e1.empno, e2.enameFROM emp e1, emp e2WHERE e1.mgr = e2.empno; -- e1 테이블의 mgr과 일치하는 empno를 갖는 테이블 조회 이렇게만 하면, 아래처럼 조회할 수 있다. 퀴즈의 조건 중 직속상관이 없는 직원은 조회되지 않은걸 알 수 있다. 이 때 사용되는게 Outer Join이다. Join을 하는 테이블중 where 조건에 해당안하더라도 모든 데이터를 조회하고자 한다면, (+)를 붙여서 조회하면 된다. 쿼리를 수정해서 다시 조회해보았다. 123SELECT e1.ename, e1.empno, e2.enameFROM emp e1, emp e2WHERE e1.mgr = e2.empno(+); -- where조건에 부합하지 않더라도 e2 테이블 전체조회","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"오라클에서 전체 테이블 조회하기","slug":"oracle-show-all-tables","date":"2019-07-09T16:03:52.000Z","updated":"2020-09-13T01:53:28.232Z","comments":true,"path":"2019/07/oracle-show-all-tables/","link":"","permalink":"http://youngjinmo.github.io/2019/07/oracle-show-all-tables/","excerpt":"","text":"오라클을 하면서 몰랐던 쿼리가 있다. MySQL에서는 show tables; 라는 간단한 쿼리로 테이블 전체 조회를 할 수 있었는데 오라클에선 어떻게 모든 테이블을 조회할 수 있는지 알지 못했다. 내가 찾은 답은 이렇다. 12345678SELECT table_name, ownerFROM all_tablesWHERE owner=&#x27;ACCOUNT&#x27;ORDER BY owner, table_name; 위의 쿼리에서 조건절에서 &#39;ACCOUNT&#39; 대신 테이블 조회를 원하는 계정을 입력해서 해당 계정에 생성된 모든 테이블을 조회할 수 있다. ‘SCOTT’ 계정내 테이블 조회를 한 결과이다. 이렇게 전체 테이블을 조회하다 보면 더 이상 사용않는 쓸모없는/불필요한 테이블이 발견될 수 있는데, 이 때 DROP TABLE &#39;table&#39; 쿼리를 이용하여 테이블을 삭제할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"}]},{"title":"한글 깨진 파일 UTF-8 변환하기 (Iconv)","slug":"iconv","date":"2019-07-08T02:12:43.000Z","updated":"2020-09-13T01:53:28.680Z","comments":true,"path":"2019/07/iconv/","link":"","permalink":"http://youngjinmo.github.io/2019/07/iconv/","excerpt":"","text":"맥을 사용하면서 불편한 점 중 하나는 UTF-8으로 인코딩되지 않은 파일을 타 운영체제 사용자로부터 파일을 받을 때이다. 지금까지는 양해를 구하고 UTF-8 인코딩을 부탁하곤 했는데, 이제 그럴 필요가 없어졌다. php 코드 한 줄만으로 한글이 깨져서 전송된 파일을 UTF-8으로 인코딩해서 복구할 수 있기 때문이다. iconvphp엔 파일의 character encoding을 바꿀 수 있는 iconv 라는 함수가 존재한다. 이 함수를 사용해서 간단히 문제를 해결할 수 있다. 1iconv -f euc-kr -t utf-8 [file] &gt; [new file] -f : 원 문서의 인코딩 방식 -t : 새로 출력되는 파일의 인코딩 방식 인코딩 전 인코딩 후","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Others","slug":"Dev/Others","permalink":"http://youngjinmo.github.io/categories/Dev/Others/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"},{"name":"php","slug":"php","permalink":"http://youngjinmo.github.io/tags/php/"}]},{"title":"Weekly Review - 7월 1주차","slug":"WeeklyReview-2019-Jul-First","date":"2019-07-07T15:50:24.000Z","updated":"2020-09-13T01:53:29.740Z","comments":true,"path":"2019/07/WeeklyReview-2019-Jul-First/","link":"","permalink":"http://youngjinmo.github.io/2019/07/WeeklyReview-2019-Jul-First/","excerpt":"","text":"What I did in this week.이번주는 부족하다고 지난번부터 부족하다고 느낀 오라클을 공부했다. 오라클 뿐만 아니라 관계형 데이터베이스에 대한 학습이 궁극적 목표이다. 인프런에서 구입한 강의를 들으며 학습노트를 만들어서 아카이브 하고 있는데 이렇게 하니까 효율이 떨어지는 것 같다. 시간을 너무 잡아먹는 다랄까? 앞으로는 강의만 빠르게 듣고 나중에 중요하다고 생각하는 부분만 노트로 만들어야겠다. 그리고 토요일인 어제 부스트캠프 코딩테스트를 봤는데 결과가 좋지 않을 것 같다. 120분간 2문제를 푸는 테스트였는데, 알고리즘은 제대로 공부한적 없기 때문에 당연히 어려울거라 생각했지만 Java라는 언어에 대해 내가 정말 알고 있는지 의심들만큼 Java가 낯설게 느껴졌다. 최근 프로젝트 한답시고 JSP와 스프링을 하면서 Java의 기초적인 부분과 배열에 대한 부분이 너무 낯설게 느껴졌다. 배열을 공부하던 2월이나 자료구조를 공부한다고 스터디를 시도했던 4월에 끝내지 않고 지금까지 조금이라도 계속 유지했으면 어땠을까 후회가 들었다. 어쨋거나 작은 쇼크가 와서 코딩테스트를 마치고 급하게 다시 Java의 정석을 읽었다.. What I read in this week.리디북스에서 훌륭한 프로그래머가 되는 법 이라는 책을 구입했다. 언어에 대한 책이 아닌 순수 프로그래밍에 대한 책은 첫 구매였는데, 이 책을 읽을 때마다 뭔가 ‘좋은 개발자’가 되는듯한 착각을 주어서 기분좋게 읽고 있다..ㅋㅋ 아직 20% 정도 밖에 읽지 못했지만 한 번 읽고 끝내기보다는 2-3년차가 될 때까지 종종 꺼내 읽어보면 좋을 책 같다. 지인으로부터 코드스쿼드를 이수하다 그만둔 사람의 글(코드스쿼드 3달째(feat. 마지막 달))을 공유받아서 읽었다. 프로그래밍을 처음 시작한 사람이었지만, 프로그래밍에 흥미가 있어서 시작한게 아니었기 때문에 슬럼프가 왔을때 이를 극복못하고 포기한 이야기였다. 나도 올 초 한 두달간의 슬럼프를 겪었기 때문에 남일 같지가 않았다. 당시에 나 역시 ‘정말 내가 이 길을 걸어도 되는걸까’*라는 고민을 한 적이 있다. 그 질문에 *’응 걸어도 돼’ 라는 대답을 스스로 내놓지는 못했지만, 프로그래밍이 싫지는 않았다. 계속 하고 싶었고, 문제 해결이 안되는 것에 지쳤을뿐 문제를 해결했을때의 희열은 그 모든 고통을 한 번에 날려버릴만큼 통괘했다. 그렇게 하나가 해결되면 그 다음 문제를 어떻게 해결할지를 고민하는 것이 즐거웠다. 가장 힘들땐 타인과의 비교였다. 그 누구도 나를 다른 사람과 비교하지 않음에도 혼자서 다른 사람과 비교하여 ‘왜 저 사람만큼 퍼포먼스가 나오지 않을까’, ‘적성에 안맞는걸까?’ 라는 생각을 자주 하곤 한다. 그럴때마다 사람들의 성장속도는 다 다르다고 스스로를 이해시키고 있지만 그래도 이런 생각이 들때마다 자존감이 떨어지는건 어쩔 수 없다. 위에서 코드스쿼드 3달째(feat. 마지막 달)라는 글을 쓴 사람이 실패했다고는 생각하지 않는다. 프로그래머로서의 커리어가 시작해보기도 전에 종료되었을뿐 결국 이 분은 어떻게든 자신만의 길을 찾을 것이다. 실패없이 성공한다라는 달콤한 시나리오는 나는 믿지 않는다. 많은 실패는 점점 더 정교하게 성공의 길로 인도한다고 항상 생각한다. 그렇기에 이 분의 선택은 존중받아 마땅하다고 생각하며, 동시에 포기하지 않고 계속 이 길 위에 있는 내가 올바른 선택을 한 것인지 미래에 후회하지 않을 선택이 될지 매 순간 스스로에게 검증받아야 할 것 같다. 이번주에 학습법이 효율성이 떨어진다고 느꼈는데, 다른 방식으로 학습법을 바꿔보고 이게 안되면 또 바꿔보고 하는 방식으로 작은 실패를 끊임없이 경험해보며 조금씩 전진하고 싶다. What I watched in this week.요즘 구독하고 자주 보고있는 백기선님의 유튜브 고민상담 영상.개발자 고민 상담, 신입 개발자는 어떤 업무를 하냐구요? 정말 중요한 업무가 있습니다. 이제 구직 준비를 한달 여 앞두고 요즘 가장 큰 관심사이다. *'내가 정말 개발자로 취업 할 수 있을까'*가 궁금하면서도 만약 정말 구직이 된다면, *그래서 내가 회사에서 어떤 일을, 어떻게 해야하는걸까?* 가 궁금한데, 이 질문자도 그런 걱정과 호기심 때문에 질문한 것 같다. 개발자를 준비하는 입장에서 굉장히 현실적인 조언이었다고 느꼈다. 영상을 요약하면 다음과 같다. 회사에 사수를 지정해달라고 부탁한다. 필요할 때마다 가서 귀찮게 하기보다 질문 목록을 만들고 미팅을 잡아서 한 번에 몰아서 물어본다. 물어본 내용은 메뉴열로 만든다거나 노트에 정리해서 아카이브한다. What I learned from this week부스트캠프 코딩테스트를 통해 다시 큰 동기부여를 받았다. ‘’그냥 이 정도로만해도 취업은 할 수 있겠지?’ 라는 생각이 없지 않았었던 것 같다. 육체적으로 나태하진 않았지만 정신적으로 나태했다고 해야하나? 아무튼 내가 얼마나 부족한지 다시금 알 수 있었다. 이제 계속 필요하다는 이유로 주먹구구식으로 이것저것을 동시다발적으로 공부하기보다는 우선순위를 정하고 철저하게 지키면서 공부해야겠다. 일단은 데이터베이스가 당장 최우선이라고 생각한다.그래서 관계형 데이터베이스까지 한 번 훓고 가볍게라도 정리하는걸 목표로 끝내고 그 뒤에 또 다시 정말 중요하고 필요하다고 생각하는 공부를 해야겠다. 일단 지금으로는 DB 공부를 마치면 자바, 스프링 공부를 할 생각이다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Weekly Review - June 4th","slug":"WeeklyReview-2019-Jun-Fourth","date":"2019-07-04T06:10:24.000Z","updated":"2020-09-13T01:53:29.704Z","comments":true,"path":"2019/07/WeeklyReview-2019-Jun-Fourth/","link":"","permalink":"http://youngjinmo.github.io/2019/07/WeeklyReview-2019-Jun-Fourth/","excerpt":"","text":"What I did in this week.국비지원 학원의 마지막 커리큘럼인 Spring에 대한 강의를 듣고있다. 이 전에 자바 강의를 들을때 명확하게 이해하고 넘어오지 못해서 사실 Spring이 얼마나 편한지 아직까지 명확하게 느껴지지 않고 있다. 다만 지금 이 글을 작성하고 배포하고 있는 Hexo 프레임워크와 마찬가지로 Spring 역시 구조에 맞춰서 파일을 생성하고 코딩하면 프레임워크가 구조에 맞춰서 소스코드를 컴파일하고 작동하는듯하다. log4j와 root-context의 파일에 현재 작업중인 패키지를 넣어주면 프레임워크가 컴파일해주고 웹서버에서 실행할 수 있다. SQL쿼리가 아직 익숙치 않아서 오라클을 다시 공부하고 있다. 인프런에서 오라클 강의를 구입해서 시청하고 있는데 며칠 동안 정리하면서 강의를 동시에 들으려니 시간대비 효율이 떨어지는것 같다. 먼저 강의를 다 들은 후 내가 익숙치 않은 부분을 다시 들으면서 정리하는 방식으로 바꿔야겠다. What I read in this week.Slack에서 공유받은 글이다. 프레임워크와 라이브러리의 차이점Spring 강의가 시작하면서 기존에 배운 jQuery와 같은 라이브러리와 프레임워크가 어떻게 다른건지 알아보기 위해 찾고, 공유해준 것 같다. 위 글에선 라이브러리가 단순 활용가능한 도구들의 집합이라면, 프레임워크는 뼈대나 기반구조를 뜻하고, 제어의 역전 개념이 적용된 대표적인 기술이라고 언급했다. 또한 라이브러리와 프레임워크의 큰 차이는 **제어의 흐름이 누구에게 주도되어 있는가**라고 요약했다. 라이브러리는 개발자가 전체적인 흐름을 제어하며 라이브러리를 클라이언트 코드에 더하는 것이라면, 프레임워크는 해당 구조 속에서 개발자가 코딩하는 것이기 때문에 저 표현이 명료하게 요약한 표현이라는 생각이든다. 그리고 **제어의 역전**이란 프레임워크에 제어의 권한을 넘김으로써 클라이언트 코드가 신경써야 할 것을 줄이는 전략이라고 글쓴이는 설명하였다. What I watched in this week.스프링 강의가 시작하면서 인프런에서 또 강의를 찾아 보았다. 백기선 님이 공유중이신 스프링 입문 강의가 있어서 시청중이다. 아니 사실 셋팅하는 것까지만 시청하고 아직 본 강의는 듣지 못했다…ㅎㅎ 아무튼 이 강의를 통해 알게된 강의의 지식공유자이신 백기선님 유튜브 채널을 구독중인데, 여기서 올라오는 QnA 영상을 이동중 또는 혼밥할 때 보곤 한다. 한 주 동안 여러 영상을 시청했지만 그 중 유익했던 두 개를 남겨본다. 깃헙 더 잘쓰는 팁 세 가지 올해 초부터 Git을 배워서 요긴하게 쓰고 있다. 현재 이수중인 국비지원 학원에서 git을 잘다루는 수강생이 없어서 2월 정도부터 혼자 생활코딩을 통해 독학해두었더니 팀 프로젝트 시에 적어도 협업 부분에서만큼은 내가 주도할 수 있었다. 조원들이 충돌만 발생하면 찾아준 덕분에 많은 종류의 충돌을 경험할 수 있었는데 덕분에 프로젝트 한 달동안 git을 더 많이 알 수 있었다. 아무튼 그래서 타이틀만 보고 시청했는데 이 영상을 통해 Octotree를 알게되어 파이어폭스에 설치해서 요긴하게 잘쓰고 있다. 기존에 Github에서 코드를 구경할 때, 디렉토리 이동할 때마다 페이지를 reload해야 해서 불편했는데 Octotree를 이용하면 한 번에 원하는 디렉토리를 갈 수도 있고, 사이드바처럼 옆에 두고 프로젝트의 구조를 파악하기에도 용이하다. 파이어폭스 애드온즈 설치하기 크롬 익스텐션 설치하기 [개발자 고민] 긴 시간을 소비하고 남은 허물뿐인 경력 경력자는 아니지만 보게 된 영상이다. 남의 일이 아닐수도 있으니까..? 사연을 보내신 분은 3년-4년을 일하셨음에도 아직 자바를 모르는 것 같다고 고백하셨다. What I learned from this week처음으로 리뷰를 썼다. 이 글을 배포하는 날짜가 7월 4일일만큼 많이 늦었지만 어쨌거나 첫 번째 리뷰를 작성했다. 이렇게 한 주간 어떤걸 보았고, 어떤 걸 공부했는지 남기니까 해당 주를 완전히 소화하는 기분이 든다. 공부가 부족했든 아쉬웠든 꾸준히 남기는 습관을 들여봐야겠다.","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"}]},{"title":"Oracle - 문자열 함수","slug":"oracle-function-string","date":"2019-07-03T11:16:42.000Z","updated":"2020-09-13T01:53:28.296Z","comments":true,"path":"2019/07/oracle-function-string/","link":"","permalink":"http://youngjinmo.github.io/2019/07/oracle-function-string/","excerpt":"","text":"오라클에서 자주 사용하는 문자열 함수를 정리했다. 목차 lower : 소문자 반환 함수 upper : 대문자 반환 함수 initcap : 첫글자만 대문자, 나머지는 소문자로 반환 함수 concat : 문자열 결합 함수 length : 문자열 길이 반환 함수 substr : 문자열 잘라서 반환하는 함수 instr : 지정한 문자열의 인덱스 반환 함수 trim : 공백삭제후 문자열 반환 함수 replace : 다른문자열로 바꿔서 반환하는 함수 lower대문자를 소문자로 변환하는 문자열 함수이다. emp 테이블에 있는 사원이름을 전부 소문자화하는 쿼리이다. upper소문자를 대문자로 변환하는 문자열 함수이다. 대문자와 소문자를 각각 소문자와 대문자로 역 변환해서 조회하는 쿼리이다. initcap첫 글자만 대문자하고 나머지는 소문자하는 문자열 함수이다. 사원이름의 첫글자는 대문자로, 나머지 글자를 소문자로 조회하는 쿼리이다. concat문자열을 서로 더해주는 문자열 함수이다. 12SELECT concat(&#x27;CEO is&#x27;, &#x27;King&#x27;)FROM dual concat 함수의 파라미터는 2개로 제한되기 때문에 더 많은 문자열을 더하기 위해서는 아래처럼 작성해야 한다. 12SELECT ename, job, concat(concat(concat(ename,&#x27;의 직무는 &#x27;), job), &#x27;입니다.&#x27;)FROM emp 문자열을 더하는 함수는 ||도 있다. 12SELECT ename, job, ename||&#x27;의 직무는&#x27;||job||&#x27;입니다.&#x27;FROM emp; length문자열의 길이를 출력하는 문자열 함수이다. legnthb 함수는 바이트 단위로 문자열의 길이를 출력하는 문자열 함수이다. SQL Plus에서 한글 문자열을 입력하니 에러가 발생해서 SQL Developer에서 조회해보았다. substr문자열을 잘라내는 함수이다. 잘라내길 원하는 문자열의 범위를 지정할 수 있다.0번째 인덱스부터 5번째 인덱스의 데이터까지 잘라서 조회하고, 뒤에서 3번째 인덱스까지를 조회하는 쿼리이다. instr찾고자하는 문자열의 인덱스를 조회하는 함수이다. 몇번째 인덱스부터 몇번째로 등장하는 문자를 찾을수도 있다.참고로 아래의 문자열에서 인덱스 1의 문자는 ‘H’이다. 1SELECT instr(&#x27;HELLO BRO&#x27;, &#x27;O&#x27;, 6, 1) FROM dual; ‘HELLO BRO’ 문자열에서 6번째 인덱스부터 문자열 ‘O’가 1번째로 등장하는 문자열의 인덱스를 조회하는 쿼리이다. 해당 문자열에서 O는 두번 등장하는데, 6번째 인덱스 뒤로는 마지막 O 하나밖에 없기 때문에 조회되는 인덱스는 9가 될 것이다. ltrim, rtrim왼쪽 공백, 오른쪽 공백을 삭제하고 문자열을 조회하는 함수. 공백을 삭제할 수도 있지만, 아래의 경우처럼 특정 문자열을 제거할 수도 있다. 이때 입력할 수 있는 인자값(Argument)은 한 개로 제한된다. (=2개의 문자열을 제거할 수 없다.) replace문자열을 다른 문자열로 대체해서 조회하는 함수. &#39;Jack and Jue&#39; 라는 문자열에서 J 를 Bl 로 바꿈으로서 Black and Blue 라는 문자열로 변경했다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"Oracle - 숫자 함수","slug":"oracle-function-number","date":"2019-07-03T10:44:32.000Z","updated":"2020-09-13T01:53:28.300Z","comments":true,"path":"2019/07/oracle-function-number/","link":"","permalink":"http://youngjinmo.github.io/2019/07/oracle-function-number/","excerpt":"","text":"목차 dual : 임시 테이블 abs : 절대값 조회 함수 floor : 소숫점 이하 내림 함수 round : 반올림 함수 trunc : 버림 함수 mod : 나머지 반환 함수 dual어떠한 테이블 내의 데이터를 조회함이 목적이 아니라 단순 연산 정도의 값을 조회하고자 할 때 사용하는 임시 테이블 abs절대값을 구하는 함수이다. floor소숫점 이하의 수를 버리는 함수 급여가 1500 이상인 사원들의 급여를 15% 삭감해서 조회하는 쿼리 round정수자리까지 반올림하는 함수 이번엔 자릿수를 정해서 반올림을 해보았다. round 함수 사용시 , 옆에 양수를 입력하면 소숫점 이하 자릿수를 지정할 수 있고, 음수를 입력하면 십의자릿수를 지정하여 데이터를 조회(SELECT)할 수 있다. emp 테이블에서 급여가 2천 이하인 사원들의 급여를 20%씩 인상하는데, 십의 자릿수를 기준으로 반올림해서 데이터를 조회하는 쿼리이다. trunc이번엔 버림을 하는 함수이다. 왼쪽부터 입력한 수 그대로를 출력하였고, trunc 함수를 사용하여 소수점 둘째자리까지 버림, 백의자릿수까지 버림하여 조회(SELECT)하였다. mod나머지를 구하는 함수.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"Oracle -  Order By","slug":"oracle-orderby","date":"2019-07-03T09:13:35.000Z","updated":"2020-09-13T01:53:28.256Z","comments":true,"path":"2019/07/oracle-orderby/","link":"","permalink":"http://youngjinmo.github.io/2019/07/oracle-orderby/","excerpt":"","text":"목차 오름차순 내림차순 ASCColumn의 데이터를 오름차순으로 정렬해서 조회(SELECT)하는 쿼리 1234SELECT empno, ename, jobFROM empWHERE empno BETWEEN 7900 and 7950ORDER BY empno ASC; 사원번호가 7900과 7950 사이의 사원의 사원번호, 사원이름, 직업을 조회한 쿼리. DESCColumn의 데이터를 내림차순으로 정렬해서 조회(SELECT)하는 쿼리 1234SELECT empno, ename, jobFROM empWHERE empno BETWEEN 7900 and 7950ORDER BY empno DESC; 위의 ASC 의 쿼리에서 ORDER BY 조건을 DESC로 바꿔서 조회(SELECT)한 결과. BonusORDER BY에 WHERE 조건을 결합해서 활용하면, 상위 n개 등의 데이터 조회도 응용할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"Oracle - SELECT 조건절","slug":"oracle-select","date":"2019-07-01T12:43:04.000Z","updated":"2020-09-13T01:53:28.244Z","comments":true,"path":"2019/07/oracle-select/","link":"","permalink":"http://youngjinmo.github.io/2019/07/oracle-select/","excerpt":"","text":"목차 산술연산자 = &lt;&gt; NOT 논리조건 &lt;, &gt;, &lt;=, &gt;= BETWEEN IN LIKE NULL 산술연산자=조회하려는 column에 조건을 부여해서 선택적으로 column을 조회(SELECT) 할 수 있는 기능이다. 1SELECT * FROM emp WHERE deptno=10; 위의 쿼리를 입력하면 아래처럼 데이터가 분류되서 출력됨을 알 수 있다. &lt;&gt;조건에 반하는 결과만 조회(SELECT) 할 수도 있다. 1SELECT * FROM emp WHERE deptno &lt;&gt; 10; deptno가 10이 안되는 데이터만 출력됨을 알 수 있다. NOTNOT 키워드를 사용하여 작성할 수 있다. 1SELECT * FROM emp WHERE NOT deptno = 10 AND NOT deptno=20; WHERE 절 조건으로 deptno=10이 아니거나 deptno=20 이 아닌 조건으로 조회를 해보았다. deptno=30인 데이터만 조회된 것을 확인할 수 있다. 논리조건 &lt;, &gt;, &lt;=, &gt;=int형 또는 ASCII코드의 순서에 따라 데이터를 조회(SELECT)할 수도 있다. 12SELECT empno, ename, job, hiredate, sal FROM emp WHERE sal &gt; 2000; emp 테이블에서 empno, ename, job, hiredate, sal 컬럼을 조회(SELECT)하면서 sal 컬럼의 데이터가 2000을 초과할 경우를 조건으로 설정하면 아래의 결과처럼 sal의 데이터가 2000이 넘는 데이터만 조회된다. BETWEEN 범위를 지정하여 조회할 경우에는 between 을 사용하여 조회할 수 있다. 1234567SELECT empno, ename, job, hiredate, sal FROM emp WHERE sal &gt; 3000 and sal &lt; 4000;// 위의 쿼리를 BETWEEN 키워드를 사용하여 바꿔보았다.SELECT empno, ename, job, hiredate, salFROM emp WHERE (sal between 3000 and 4000); IN 조건 중 공통 column일 경우, 사용할 수 있는 sql 키워드 1234567SELECT empno, ename, jobFROM emp WHERE job = &#x27;salesman&#x27; or job = &#x27;analyst&#x27;;// 위의 쿼리를 in 키워드를 사용하여 바꿔보았다.SELECT empno, ename, jobFROM emp WHERE job in (&#x27;salesman&#x27;, &#x27;analyst&#x27;); LIKE 문자열에 대한 연산을 할 수 있다. ename 컬럼 데이터가 A로 시작하는 데이터 조회 12SELECT ename, empno FROM emp WHERE ename LIKE &#x27;A%&#x27;; ename 컬럼 데이터에 A가 포함되는 데이터 조회 1SELECT ename, empno FROM emp WHERE ename LIKE &#x27;%A%&#x27;; ename 컬럼의 데이터의 두번째 알파벳이 A인 데이터조회 언더바(_) 갯수만큼 조회하려는 알파벳의 해당 단어에서의 순위를 뒤로 미룰수 있다. 1SELECT ename, empno FROM emp WHERE ename LIKE &#x27;_A%&#x27;; ename의 데이터가 세글자인 데이터 조회 1SELECT ename, empno FROM emp WHERE ename LIKE &#x27;___&#x27;; NULL NULL은 연산처리할 수 없으므로 is NULL, is NOT NULL 을 통해 조회(SELECT)할 수 있다. 보너스(comm)가 없는 직원들의 사원번호, 이름, 임금, 임금과 보너스의 합 조회. 상관이 없는 사람, 즉 회사 대표를 조회하는 쿼리 null을 0으로 환산해서 연산하고 싶을 경우 Oracle 내부 함수인 nvl 함수를 통해 null에 해당하는 컬럼 데이터를 0으로 바꿔서 조회하고 연산할 수 있다. 실제 테이블 내 데이터를 변경하는게 아닌 조회시에만 변경해서 조회할 뿐이다. NVL함수 Oracle Document - nvl","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"Oracle - DML","slug":"oracle-dml","date":"2019-06-30T08:16:39.000Z","updated":"2020-09-13T01:53:28.304Z","comments":true,"path":"2019/06/oracle-dml/","link":"","permalink":"http://youngjinmo.github.io/2019/06/oracle-dml/","excerpt":"","text":"목차 SELECT INSERT UPDATE DELETE 산술 연산자 NVL함수 Concat ( || ) Distinct ( distinct ) SELECTSQL 쿼리는 일반적으로 아래와 같은 구성으로 작성한다. 123SELECT ename, salFROM empWHERE sal &gt;= 1000; DML은 여기서 SELECT 에 해당하는 언어이며, 데이터를 조작하는 의미를 갖는다. SELECT는 데이터를 조회할 때 사용하는 DML 쿼리이다. INSERTINSERT는 데이터를 추가할 때 사용하는 DML 쿼리이다. 12INSERT INTO [테이블명](column1, column2, column3)VALUES (&#x27;property1&#x27;,&#x27;property2&#x27;,&#x27;property3&#x27;) ##UPDATE 추가된 데이터를 수정할 때 사용하는 쿼리이다. 추가할 때 HIREDATE에 데이터를 입력하지 않았는데, 현재 날짜(SYSDATE)를 HIREDATE로 수정해서 넣어봤다. 123UPDATE [테이블명]SET [column1] = &#x27;property11&#x27;WHERE [column2] = &#x27;property2&#x27; ##DELETE 데이터를 삭제할 때 사용한다. 12DELETE FROM [테이블명]WHERE [column1] = &#x27;property11&#x27; 산술 연산자 산술 연산자(+, -, /, *) 를 이용하여 column의 데이터에 대한 연산결과를 출력할 수 있다. 123// emp 테이블에서 sal(임금)과 comm(보너스)를 추가한 실수령액을 조회하는 sql 쿼리SELECT ename, sal, nvl(comm, 0), sal+nvl(comm, 0)FROM emp; NVL 함수 NULL 을 처리하는 함수이다.만약 연산에 사용하는 column의 데이터가 null을 포함하고 있을 경우, null 대신에 특정 값으로 바꿔서 출력을 도와준다. 값이 없는 column의 경우 null 값을 출력하는데, 이렇게되면 연산시int + null의 연산에 의해 제대로된 데이터를 출력하지 않는다. 따라서 null 일 경우 특정 값(0)으로 바꾸도록 할 때 사용하는 함수이다. 오라클 공식문서 링크 NVL 함수 미적용 NVL함수 적용 Concat 연산자 ( || ) 문자열을 합치는 연산자이다. 12SELECT ename || &#x27;s job is &#x27; || jobFROM emp; Distinct 키워드 ( distinct) select 문을 통해 가져온 모든 row 중에서 중복된 row를 제거하는 키워드이다. 1SELECT distinct deptno FROM emp;","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"MacOS에서 오라클 사용하기 (a.k.a.Docker)","slug":"docker-for-oracle","date":"2019-06-29T05:00:13.000Z","updated":"2020-10-01T11:09:01.526Z","comments":true,"path":"2019/06/docker-for-oracle/","link":"","permalink":"http://youngjinmo.github.io/2019/06/docker-for-oracle/","excerpt":"","text":"맥OS를 사용중인 사람이 오라클을 다운받으려고 공식사이트에 접속해도 할 수 있는게 없을 것이다. 오라클은 윈도우와 리눅스용으로만 제공하고 있기 때문이다. 그렇다면 맥을 사용하는 개발자는 오라클을 사용할 수 없는걸까? 당연히 아니다. 가상OS를 사용해서 오라클을 사용할 수 있다. 가상 OS를 사용하는 방법으로는 Virtual Machine과 Docker 두 가지로 나뉠 수 있다. Docker를 처음들어본 사람은 이 유튜브 영상[얄팍한 코딩사전 - Docker가 뭐고 왜 쓰는건가요?]을 시청해보길 바란다. 개인적으로 구독하고 재미있게 시청하는 채널인데 4-5분 가량의 영상이며 개발을 처음 시작하는 사람들에게 쉽고 재미있게 설명하는 영상들을 올려주는 채널이다. 좋아요와 구독을 추천한다. Virtual Machine과 Docker의 차이는 여기서 설명하기보다는 공부할 때 참고한 링크[서강혁 - Docker와 VM]를 첨부하겠다. 사실 나도 계속 공부중이어서 해당 글을 작성한 작성자만큼 잘 정리해서 전달할 정도가 되지못한다.. 시간이 조금 더 쓰더라도 제대로 알고 배우고 싶다면 이 강의를 추천한다. 도커의 개념부터 명령어, 오라클, MySQL 설치하는 것까지 설명해주시며, 강의는 4개 영상, 러닝타임은 약 100분이 조금 넘는다. 목차 Docker 설치하고 실행하기 오라클 image 가져오기 Container 생성하고 포트 연결하기 Container 실행하기 Container 접속하기 오라클 접속하기 지금부터는 Docker를 이용하여 오라클을 사용하는 초간단 메뉴얼(?)을 정리해서 소개한다. 솔직히 Docker를 모르고 이해하지 못했어도 아래 방식대로 그대로 따라하기만 해도 간단하게 오라클을 시작할 수 있다. 1. Docker 설치하고 실행하기Docker 공식 사이트에서 Docker Desktop for Mac을 설치한다. 설치하고 나면 실행하면 상태바에 Docker가 실행되는걸 확인할 수 있다. Docker를 부팅하는데에는 몇 초간의 시간이 소요된다. 완전히 실행되면 클릭해서 열어본다. 회원가입을 하고, 회원가입된 이메일과 패스워드로 로그인한다. 2. 오라클 image 가져오기오라클이 설치된 이미지를 가져온다. Docker에서 말하는 image란 개발환경(?)을 의미하는 것으로 보인다. 기관이나 기업에서 공식적으로 Docker 이미지를 배포하기도 하지만, 개발자들이 자신의 개발환경에 맞는 컨테이너 이미지를 구축해서 DocketHub에 배포할 수 있다. 나는 개발자가 만들어놓은 이미지를 가져와서 사용했다. Docker 이미지를 가져오는 방법은 두 가지이다. 브라우저로 접속해서 DockerHub에서 이미지를 찾아와서 가져오는 방법, 터미널에서 명령어로 검색해서 가져오는 방법. 우린 터미널에서 명령어를 검색해서 가져오겠다. Docker를 사용하려면 결국 터미널을 이용해야하는데, 굳이 브라우저로 넘어가서 이미지를 찾기보다 터미널에서 이미지를 검색하고 가져오는 것까지 모두 마무리하겠다. Docker가 실행중인 상태에서 터미널을 실행한다. docker search [keyword] 형태로 입력을 해주면 된다. 우린 오라클을 사용할 수 있는 이미지를 찾고 있으므로 docker search oracle-xe 로 입력하면 된다. 그럼 아래와 같은 검색결과가 터미널 콘솔에 출력될 거다. 1$ docker search oracle-xe 왼쪽의 NAME이 해당 이미지의 이름이고, DESCRIPTION은 해당 이미지를 배포한 개발자가 작성한 이미지의 설명이다. 오라클의 버전이나 이미지에 대한 짧은 설명이 첨부되었으니 읽어보고 가져오면 된다. 위에 검색결과는 STARS 순으로 정렬되는데 가장 위에 노출되는 이미지가 가장 많은 STARS를 받은 이미지이다. 신뢰도가 높다고 할 수 있다. 공교롭게도 가장 위에 검색결과로 출력된 이미지 oracleinanutshell/oracle-xe-11g 가 description이 없지만 stars가 높으므로 이걸 가져와보자. Gitub에서 repository를 가져오는 방식처럼 docker pull [image name] 을 입력하면 이미지를 가져온다. 우리가 입력해야할 명령어는 다음과 같다. 1$ docker pull oracleinanutshell&#x2F;oracle-xe-11g 이미지가 잘 설치한지 확인하고 싶다면, docker images 라는 Docker 명령어를 입력해보자. 설치한 이미지들을 볼 수 있다. 이 글을 작성한 시점은 2019년 6월이다. 이후에 이 글을 보시는 분들은 우리가 사용한 오라클 이미지를 찾지 못할 수 있다. 꼭 똑같은걸 쓸 필요는 없으니 위의 방식대로 또 검색해서 찾아서 가져오면 된다. 3. Container 생성하고 포트 연결하기오라클 사용에 필요한 이미지를 설치했으나 이미지만으로는 오라클을 사용할 수 없다. dmg 포맷의 파일을 설치했다고 해서 즉시 어플리케이션을 실행할 수는 없지않은가. 이제 우리가 사용할 수 있는 형태로 만들어야 한다. 설치한 이미지로 컨테이너를 생성하는 것이다. 1$ docker run -d -p 1521:1521 [docker image] 오라클 Docker 컨테이너의 1521 포트를 로컬호스트의 1521 포트로 포워딩한다는 의미의 명령어이다. 위의 명령어를 터미널에서 입력하면 컨테이너가 생성될 것이다. 이제 이 컨테이너를 실행함으로써 오라클을 실행할 수 있다. 그럼 이제 오라클을 잘 실행되는지 확인해보자. 4. Container 실행하기현재 어떤 컨테이너가 실행중인지 확인하려면 docker ps 를 입력하면 알 수 있다. 실행중인 컨테이너의 목록을 보여주는 Docker 명령어인데, 아래처럼 보인다면 컨테이너가 실행중인 것이다. 위 이미지는 아까 설치한 이미지로 생성한 컨테이너가 실행중임을 알 수 있다. 생성시기는 2주 전이고 현재 실행된지는 1시간이 넘었다는 것까지 알려준다. 만약 아무것도 보이지 않는다면, 실행중인 컨테이너가 없다는건데 실행여부와 상관없이 모든 컨테이너를 볼 수 있는 명령어는 docker ps -a 이다. 1$ docker ps -a 컨테이너가 언제 생성되었고, 언제 종료되었는지 알 수 있다. 실행중인 컨테이너는 어디 포트에 연결되어 실행되고 있음도 docker ps 명령어와 마찬가지로 알 수 있다. 실행되고 있는 컨테이너가 없다면, 이제 컨테이너를 실행해야한다. 1$ docker start [container ID] 위의 Docker 명령어를 입력하면 해당 컨테이너를 실행한다. 잘 실행되고 있는지 알고 싶다면 docker ps 를 입력하여 확인해보면 된다. 만약 컨테이너를 종료하고 싶다면, 아래 Docker 명령어로 컨테이너를 종료할 수 있다. 1$ docker stop [Container ID] 5. Container 접속하기 글에서 언급하지 않았지만 우리가 설치한 오라클 Docker 이미지는 우분투 기반으로 생성된 이미지이다. 그렇다면 해당 컨테이너가 정말 우분투 환경으로 만들어진건지 어떻게 알 수 있을까? 컨테이너에 직접 접속해보면 알 수 있다. 컨테이너가 실행중인 상황에서 아래 명령어를 입력하면 컨테이너에 접속할 수 있다. 1$ docker exec -it [Container ID] bash 접속한 컨테이너의 운영체제 버전을 확인하려면 아래의 리눅스 명령어를 입력해야 한다. 1$ cat &#x2F;etc&#x2F;issue 우분투의 버전을 알 수 있다. 새로운 터미널 창(cmd+n)을 열어서 같은 명령어를 입력하면 아무 결과도 보이지 않을 것이다. cat /etc/issue 는 리눅스에서만 작동되는 명령어이기 때문이다. Docker를 사용하게 된걸 환영한다! 6. 오라클 접속하기우리의 본 목적이었던 오라클을 접속해보자. 오라클을 접속하기 위한 방법도 두 가지가 있다. CLI방식의 SQLPlus와 SQLDeveloper. 첫 시작부에 언급했듯 본 포스트는 처음부터 끝까지 터미널로 하기로 했으므로 SQLPlus를 실행하여 오라클에 접속하겠다. 간단하다. 컨테이너에 접속한 상태에서 터미널 입력창에 sqlplus 만 입력하면 된다. 접속할 계정의 user-name와 password를 입력하면 오라클 데이터베이스에 접속했음을 알 수 있다. 학습용도로 사용할 수 있는 임의의 데이터베이스가 있다. user-name으로 scott, password로 tiger를 입력하면 따로 데이터베이스를 만들지 않아도 쿼리를 작성해볼 수 있다. 만약 오라클 사용을 중단하고 싶다면 exit 명령어로 SQLPlus를 종료할 수 있다. 마찬가지로 접속한 컨테이너에서 빠져나오고 싶을 때에도exit 명령어로 컨테이너를 빠져나올 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"DevOps","slug":"Dev/DevOps","permalink":"http://youngjinmo.github.io/categories/Dev/DevOps/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"docker","slug":"docker","permalink":"http://youngjinmo.github.io/tags/docker/"}]},{"title":"데이터베이스 - Oracle","slug":"oracle-intro","date":"2019-06-28T11:21:50.000Z","updated":"2020-10-04T02:26:12.297Z","comments":true,"path":"2019/06/oracle-intro/","link":"","permalink":"http://youngjinmo.github.io/2019/06/oracle-intro/","excerpt":"","text":"이번엔 데이터베이스를 정리하고자 한다. 사실 정리라기보다는 이제 막 발을 떼고 공부를 시작했다는 표현이 더 맞을 것 같다. 데이터를 어떻게 관리하는지를 어느정도 머릿속에 정리하기위해 작성해본다. 본 포스트는 인프런 - Oracle SQL Database 11g PL/SQL Developer를 수강하고 작성했다. 목차 Intro Features Advantage Disadventage DDL DML DCL DBMS RDBMS Database데이터베이스는 여러 사람이 공유하고 사용할 목적으로 통합 관리되는 정보의 집합이다. 복수의 데이터를 조직적으로 통합하여 중복을 없애고 데이터를 구조화하여 기억시켜 놓은 자료의 집합체이다. 일반적으로 응용 프로그램과는 별개의 미들웨어를 통해서 관리된다. 데이터베이스 자체만으로는 아무것도 할 수 없기 때문에 소프트웨어 관리 시스템과 통합돼 제공된다. 정확한 명칭은 데이터베이스 관리 시스템(DBMS, DataBase Management System)이다. 나무위키에 작성된 내용을 첨부하면 아래와 같다. 데이터베이스 자체는 화물(데이터)을 저장할 수 있는 창고 그 자체의 역할만 수행하고, 화물을 적재하거나 적재된 화물을 처리할 수 있는 능력은 없다. 이 때문에 DBMS라는 관리자들을 고용하여 화물을 적재하거나 이동시키는 등 여러가지 업무를 수행하도록 하는 것이다. 관계형 데이터베이스(Relational Database)를 이용하기 위해 만들어진 언어로 SQL(Structured Query Language) 이 있는데, SQL을 통해 데이터 추가/탐색/수정/삭제 등의 작업을 할 수 있다. 특징 실시간 접근성 지속적인 변화 동시 공유 내용에 대한 참조 데이터 논리적 독립성 장점 데이터 중복 최소화 데이터 공유 일관성, 무결성, 보안성 유지 최신의 데이터 유지 데이터의 표준화 기능 데이터의 논리적, 물리적 독립성 데이터 저장 공간 절약 단점 데이터베이스 전문가 필요 비용 부담 데이터 백업과 복구가 어렵다 그러나 최근엔 많이 개선됨 시스템의 복잡함 대용량 디스크로 액세스가 집중되면 과부화 발생 DDLData Definition Language 데이터를 정의하는 언어이다. 테이블을 생성하거나 삭제 등 데이터베이스 스키마(Scheme)를 정의또는 관리 하는 언어이다. CREATE : 정의 ALTER : 수정 DROP : 삭제 TRUNCATE : DROP 후, CREATE DMLData Manipulation Language 테이블 등의 데이터를 조작(추가/조회/수정/삭제) 하는 언어이다. 응용 프로그램과 데이터베이스 사이에서 실질적인 데이터 처리를 위해 사용된다. INSERT : 추가 SELECT : 조회 UPDATE : 수정 DELETE : 삭제 연관 포스트 : Oracle - DML 명령어 DCLData Control Language 데이터를 제어 하는 언어이다. 사용자 권한, 작업의 취소 등 DML과 비교하여 상위 개념(?)의 언어라고 생각한다. COMMIT : 작업 결과 반영 ROLLBACK : 트랜잭션의 작업을 취소 / 복구(undo) GRANT : 사용자에게 권한 부여 REVOKE : 권한 취소 DBMS데이터베이스 그 자체로는 아무것도 할 수 없다. 데이터베이스를 사용하기 위해서는 관리 시스템이 필요하다고 했는데, 그 역할을 하는 소프트웨어를 DBMS라 한다. Oracle, MySQL, MS-SQL등이 여기에 속한다. DataBase Management System 데이터베이스를 관리하는 소프트웨어 Oracle, MS-SQL,MySQL 등이 DBMS에 속한다. RDBMS가장 많이 사용되는 데이터베이스 모델이다. 관계형 데이터베이스(Relational Database Management System)라고 해서 RDBMS라고 줄여서 말한다. 강의에서 강사님이 든 예를 인용하겠다. SQL RDBMS Description Row Tuplr, Record 하나의 항목을 대표하는 데이터 Column Attribute 튜플의 이름 요소 Table Relation 같은 속성을 공유하는 튜플의 모임 중간고사를 마치고 학생들의 성적을 분류하기 위해서 정렬한 학생 데이터가 있다고 가정하자. 연관된 학생들 즉, 같은 반 학생들끼리만 모아둔 형태 를 데이터베이스에서는 **테이블, 또는 Relation**이라고 한다. 그리고 그 반을 구성하는 학생들 은 데이터베이스에서 Tuple 로 비유할 수 있다. 그리고 해당 학생들이 각각 갖는 이름, 성적 등의 속성 은 Attribute 가 될 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"}]},{"title":"jQuery - DOM, CDN","slug":"jquery-dom-cdn","date":"2019-06-01T12:35:21.000Z","updated":"2020-12-03T08:35:13.467Z","comments":true,"path":"2019/06/jquery-dom-cdn/","link":"","permalink":"http://youngjinmo.github.io/2019/06/jquery-dom-cdn/","excerpt":"","text":"목차 intro $ DOM CDN IntrojQuery는 특별한 기술이나 프로그래밍 언어가 아니라 Java Script의 라이브러리이다. 라이브러리는 자주 사용하는 로직들을 재사용(Reuse)을 가능하도록 만든 로직들의 묶음이다. 자바스크립트는 이런 라이브러리가 많은데, 그 중 가장 많이 쓰이는 라이브러리가 jQuery이다. 웹에서 Element를 선택하는 방법과 선택된 Element를 효율적으로 제어할 수 있는 **JavaScript 라이브러리**이다. jQuery 라이브러리를 사용하기 위해서는 jQuery 공식 사이트에서 코드를 다운받아서 웹서버에 올려서 사용하거나 아래 코드처럼 구글에서 제공하는 라이브러리를 불러와서 사용할 수 있다. 이렇게 사용하는 방식을 CDN이라고 한다. 12345// Google Hosted Library&lt;script src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt;// jQuery CDN&lt;script src=&quot;https://code.jquery.com/jquery-2.2.4.min.js&quot; &gt;&lt;/script&gt; CDN에 대한 설명은 아래에 정리했다. jQuery의 구조는 다음과 같다. 제어할 Element를 선택하고, 선택된 Element에 전달할 제어 명령어를 . 으로 이어서 작성하는 방식이다. 한 줄에 한 가지 제어만 가능한게 아니고, . 으로 여러개의 제어를 동시에 입력할 수 있다. jQuery의 데이터타입은 Function이면서 Object이다. 1$(&#x27;#div-section_1&#x27;).setAlign(); 위 코드에서 $ 가 jQuery의 객체, &#39;#div-section_1&#39;이 selector에 해당한다. 이 문자열들을 jQuery 선택자(selector)라고 한다. 참고로 Element를 선택할 때는 어떤걸 선택하느냐에 따라 사용법이 조금 다른데, DOM구조의 기본 Element라면 그냥 $(&#39;body&#39;) 이런 식으로 사용이 가능하나 class를 선택하려면, $(&#39;#classSelector&#39;), id를 선택하려면 $(&#39;.idSelector&#39;) 로 사용해야 한다. $앞서 jQuery는 Element를 선택해서 효율적으로 제어하는 JavaScript 라이브러리라고 했다. 이를 선택자(Selector)라고 한다. 따라서 jQuery가 HTML에서 하는 역할은 선택자에 해당한다고 이야기 할 수 있다. 여기서 Element를 선택할 때 사용하는 선택자를 jQuery 또는 $ 라고 한다. 일반적으로는 jQuery보다 사용하기 편하고, 가독성이 높아서$ 를 사용한다. $ 는 정확히 jQuery와 역할이 일치하므로 $ 의 데이터타입 또한 Function이면서 Object라는 특징을 갖는다. 123456789101112&lt;html&gt; &lt;body&gt; &lt;div class=&quot;welcome&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javscript&quot;&gt; // &quot;welcome&quot; class를 선택해서 html코드와 css코드를 명령한다. $(&quot;welcome&quot;).html(&quot;hello world!&quot;).css(&quot;background-color&quot;, &quot;yellow&quot;); // 아래 코드와 정확히 일치한다. // jQuery(&quot;welcome&quot;).html(&quot;hello world!&quot;).css(&quot;background-color&quot;, &quot;yellow&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; DOM웹 문서의 구조를 표현하는 개념이다. 데이터 스트럭쳐와 유사하다. DOM은 Document Object Model의 약자로써 문서 객체 모델을 의미한다. 웹 페이지의 객체 지향적 표현이며, HTML, XML문서를 구조화함으로써 **자바스크립트와 같은 프로그래밍 언어로 보다 쉽게 제어할 수 있도록 돕는 모델**이다. DOM을 구현하는 기준을 ‘웹 표준’이라고 하는데, 그동안 W3C, WHATWG 이라는 단체에서 웹 표준에 대한 문서를 발간했었고, 전 세계 웹 개발자들이 이를 적용하여 개발하고 있었다. 그런데 2019년 5월 28일 W3C 블로그에 WHATWG와 W3C가 이제 하나의 웹 표준을 지향할 수 있게 되었다는 글이 올라오면서 변화를 맞이하게 되었다. 원문을 읽어보면, WHATWG는 HTML과 DOM에 대한 기준을 유지하며, W3C는 독립적인 문서 발간을 중지한다고 밝혔다. 두 단체간의 웹 표준 전쟁에서 WHATWG가 이긴 것처럼 보인다. 아래 한글 기사를 첨부하지만, 내용이 어수선한 관계로 꼭 원문도 함께 읽기를 바란다. 지디넷 기사 : 둘로 나뉜 웹 표준, 하나로 합쳐진다. 원문 : W3C and WHATWG to work together to advance the open Web platform CDNCDN은 Content Delivery Network의 약자로써 다양한 컨텐츠를 복잡한 네트워크 환경에서 사용자에게 안정적으로 전송해주는 서비스라고 이해 할 수 있다. 네이버 지식백과를 인용하면 다음과 같다. 인터넷 사용자들로부터 멀리 떨어져 있는 컨텐츠 제공자의 웹 서버에 집중되어 있는 컨텐츠들 중 그림, 배너, 비디오, 오디오와 같이 용량이 크거나 사용자들의 요구가 많은 컨텐츠를 여러 인터넷 서비스 사업자(ISP)의 POP들에 설치한 CDN 서버에 미리 저장해 놓고, 컨텐츠 요구 발생 시 가장 최적의 CDN 서버로부터 신속한 경로를 통해 사용자에게 컨텐츠를 전달해주는 새로운 개념의 데이터 전송 서비스를 의미한다. 컨텐츠(자료)를 효율적으로 전달하기 위해 준비된 네트워크 클라이언트의 컨텐츠 요청의 병목현상을 해결한다 서버의 불필요한 트래픽을 주링고 반복작업을 줄여준다 자주 사용디는 컨텐트를 네트워크 중간중간에 복사해두고 클라이언트의 요청을 받으면 적절한 위치의 컨텐츠를 전송하는 시스템 jQuery CDN을 이용하면 자체 서로 호스팅하는 것보다 빠르고, 브라우저 캐싱을 지원한다는 장점이 있다. 브라우저 캐싱이란, 웹 페이지를 로드할 때마다 페이지를 표시하기 위해 필요한 웹 파일을 다운받게 되는데 매 번 웹 페이지에 접속할 때마다 모든 웹 파일을 다운받으면 통신 속도에 부담을 줄수도 있고, 비효율적이기도 하다. 따라서 한 번 접속해서 다운받은 웹 파일을 로컬에 유지시켜서 다음에 해당 웹 페이지에 접속할때마다 새로 다운받을 필요없이 로컬에 저장된 웹 파일을 이용하여 보다 빠르게 웹 페이지에 접속할 수 있다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"http://youngjinmo.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"http://youngjinmo.github.io/tags/javascript/"}]},{"title":"JavaScript - Object","slug":"javascript-object","date":"2019-05-14T09:00:29.000Z","updated":"2020-12-03T08:34:34.998Z","comments":true,"path":"2019/05/javascript-object/","link":"","permalink":"http://youngjinmo.github.io/2019/05/javascript-object/","excerpt":"","text":"목차 Intro 객체 프로퍼티 표기법 객체 프로퍼티 네이밍 Object자바스크립트 변수에 대해 정리한 포스트에서 자바스크립트는 기본타입(number, String, Boolean, undefined, null)을 제외하곤 나머지 모든 데이터 타입이 객체라고 정리한 바 있다. 객체라는 표현은 추상적인 표현이기 때문에 모호하게 느껴질 수 있으나 사실 현실의 세계를 프로그래밍화 하려는 시도(?)라고 해석할 수 있다. 세상 모든건 객체로 구성되어 있기 때문이다. 자동차를 예로 들면, 아래 이미지의 자동차들은 ‘자동차’라는 범주에 똑같이 속하지만 색상, 차 종(type), 충전 상태 등 서로 다른 특징을 보유하고 있기 때문에 우리는 이들을 각각의 차로 구별할 수 있다. 위의 차를 자바스크립트 코드로 구현하면 아래와 같다. 1234567891011121314151617181920212223var automobile_n1 = &#123; brand : &quot;Tesla&quot;, color : &quot;blue&quot;, type : &quot;Sports Utility&quot;, isCharging : true&#125;;var automobile_n2 = &#123; brand : &quot;Tesla&quot;, color : &quot;red&quot;, type : &quot;Sedan&quot;, isCharging : true&#125;;var automobile_n3 = &#123; brand : &quot;Tesla&quot;, color : &quot;white&quot;, type : &quot;Sports Utility&quot;, isCharging : false&#125;;console.log(automobile_n1.color); // blueconsole.log(automobile_n3.isCharging); // false 객체는 키(key)와 값(property)로 이루어져있다. 위의 코드처럼 중괄호로 감싸고 세미콜론(;) 대신 , 로 각각의 property를 구분한다. 세미콜론은 중괄호를 닫을 때 작성함으로써 객체를 완성한다. 객체 프로퍼티 표현법 객체의 프로퍼티를 호출하는 방법은 두가지가 있다. object[&quot;property&quot;] : Bracket Notation object.property : Dot Notation Dot 표기법이 Bracket 표기법보다 엄격하게 key를 구별하기 때문에 Dot 표기법으로 객체의 프로퍼티, Key를 작성하는 것을 권장한다. 추가로 객체의 프로퍼티로 함수나 배열을 포함시킬 수도 있다. 123456789101112131415var myCar = &#123; brand : &quot;Tesla&quot;, color : [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;white&#x27;, &#x27;black&#x27;], type : &quot;Sports Utility&quot;, isCharging : true, charged : function() &#123; if(myCar.isCharging === true)&#123; return &quot;This car is already charging.&quot;; &#125; else &#123; return &quot;This car will be charged&quot;; &#125; &#125;&#125;;myCar.charged();// &quot;This car is already charging.&quot; 프로퍼티 네이밍 규칙객체의 프로퍼티명을 작성하는 조건이 몇 가지 있다. &quot;&quot; 을 사용하지 않는다. 숫자를 첫 글자로 사용하지 않는다. 띄어쓰기 대신 camel 표기법을 사용한다. 이제 Udacity - Intro to Javascript 강의를 완강했다. 그러나 말 그대로 intro를 끝냈을뿐 여전히 자바스크립트에 알지 못한다고 생각한다. 사실상 모든 프로그래밍 언어의 기초적인 부분을 배운 느낌이다. 그래도 완강은 기분좋다. 이제는 Udacity에서 jQuery에 대한 강의를 들으려고 한다. DOM객체가 무엇인지, selector 태그에 대한 연습도 해보고 싶다. 얼른 강의 듣고 또 정리해보겠다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://youngjinmo.github.io/tags/javascript/"}]},{"title":"JavaScript - 배열","slug":"javascript-array","date":"2019-05-14T04:53:07.000Z","updated":"2020-12-03T08:34:57.494Z","comments":true,"path":"2019/05/javascript-array/","link":"","permalink":"http://youngjinmo.github.io/2019/05/javascript-array/","excerpt":"","text":"목차 Intro Most Used Methods Loop for Array For Loop forEach( ) Map( ) Array자바스크립트에서 배열을 선언할 땐 Java와 달리 배열의 크기를 지정하지 않아도 된다. 12var donuts = new Array();var coffee = [&quot;Espresso&quot;, &quot;Latte&quot;, &quot;Mocca&quot;]; Most Used Methods자주 사용하는 Array의 메서드들이다. Length : 배열이 갖고있는 대표적인 Property이다. 12var coffee = [&quot;Espresso&quot;, &quot;Latte&quot;, &quot;Mocca&quot;]; coffee.length(); // 3 Push : 데이터를 추가할 때 사용하는 method이다. 배열의 마지막 인덱스에 추가된다. 1234var coffee = [&quot;Espresso&quot;, &quot;Latte&quot;, &quot;Mocca&quot;]; coffee.push(&quot;Americano&quot;);console.log(coffee);// [&#x27;Espresso&#x27;, &#x27;Latte&#x27;, &#x27;Mocca&#x27;, &#x27;Americano&#x27;] Pop : 데이터를 삭제할 때 사용하는 method이다. 배열의 마지막 인덱스의 element가 삭제된다. 1234var coffee = [&quot;Espresso&quot;, &quot;Latte&quot;, &quot;Mocca&quot;]; coffee.pop();console.log(coffee);// [&#x27;Espresso&#x27;, &#x27;Latte&#x27;, &#x27;Mocca&#x27;] Splice : 원하는 인덱스에 데이터를 추가/삭제를 할 수 있는 method. Array.splice([method가 실행될 Index], [삭제될 Index 수], [새로운 element]) 123456789101112131415var coffee = [&quot;Espresso&quot;, &quot;Latte&quot;, &quot;Mocca&quot;]; coffee.splice(1, 1, &quot;Americano&quot;); // Index 1로부터 element 1개를 삭제하고 &quot;Americano&quot; 추가console.log(coffee); // [&#x27;Espresso&#x27;, &#x27;Americano&#x27;, &#x27;Latte&#x27;, &#x27;Mocca&#x27;]coffee.splice(0, 0, &quot;Nitro Coffee&quot;);// Index 0으로부터 element를 0개 삭제하고 &quot;Nitro Coffee&quot; 추가console.log(coffee);// [&#x27;Nitro Coffee&#x27;, &#x27;Espresso&#x27;, &#x27;Americano&#x27;, &#x27;Latte&#x27;, &#x27;Mocca&#x27;]coffee.splice(-1, 1, &quot;Cafe Mocca&quot;);// Index-1(뒤)로부터 element 1개를 삭제하고 &quot;Cafe Mocca&quot; 추가console.log(coffee);// [&#x27;Nitro Coffee&#x27;, &#x27;Espresso&#x27;, &#x27;Americano&#x27;, &#x27;Latte&#x27;, &#x27;Cafe Mocca&#x27;] 그 외 자바스크립트에서 배열 객체가 갖는 Properties와 Methods는 공식문서에서 더 찾아볼 수 있다. Array Loops배열도 Loop를 사용할 수 있다. For Loop와 함께 forEach Loop, Map을 사용할 수 있다. For Loop 1234567891011121314var coffee = [&quot;Espresso&quot;, &quot;Latte&quot;, &quot;Mocca&quot;]; function orderCoffee(func) &#123; // 문구를 완성할 함수 작성 for(var i=0; i&lt;func.length; i++) &#123; func[i] += &quot; please.&quot;; // 각 element 뒤에 &quot; please&quot; 추가 func[i] = func[i].toUpperCase(); // method 사용해서 모든 문자 Capitalize console.log(func[i]); // 각 element 출력 &#125;&#125;orderCoffee(coffee); // 함수 사용// ESPRESSO PLEASE.// LATTE PLEASE.// MOCCA PLEASE. forEach Loop 12345678910var coffee = [&quot;Espresso&quot;, &quot;Latte&quot;, &quot;Mocca&quot;]; coffee.forEach(function(drink) &#123; drink = &quot;A cup of &quot; + drink + &quot;.&quot;; console.log(drink);&#125;);// A cup of Espresso.// A cup of Latte.// A cup of Mocca. Map 1234567891011var coffee = [&quot;Espresso&quot;, &quot;Latte&quot;, &quot;Mocca&quot;]; var orderCoffee = coffee.map(function(drink) &#123; drink = &quot;A cup of &quot; + drink + &quot; please.&quot;; return drink;&#125;);console.log(orderCoffee);// [ &#x27;A cup of Espresso please.&#x27;, // &#x27;A cup of Latte please.&#x27;// &#x27;A cup of Mocca please.&#x27; ] forEach 와 달리 Map은 method를 사용할 때 새로운 객체를 선언한다는 점이 다르다. 주의하자.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://youngjinmo.github.io/tags/javascript/"}]},{"title":"JavaScript - 변수, 조건문","slug":"javascript-variable","date":"2019-05-10T08:11:11.000Z","updated":"2020-12-03T08:34:44.756Z","comments":true,"path":"2019/05/javascript-variable/","link":"","permalink":"http://youngjinmo.github.io/2019/05/javascript-variable/","excerpt":"","text":"학원 교육을 이수중인데 자바스크립트 객체에 대한 모호함때문에 자바스크립트를 정리해보고자 한다. 본 포스트는 지난해 말에 Udacity에서 들었던 Intro to JavaScript로 공부한 부분을 정리했다. 당시 Object에 대한 부분을 듣지 못하고 어영부영 끝냈는데, 이번 기회에 끝까지 이수하려고 한다. Udacity 강의와 인사이드 자바스크립트를 참고하여 정리했다. 목차 Intro to JavaScript Variables Null &amp; Undefined Equality Conditional The list of False value Ternary Operator Loop &amp; Array Intro to JavaScript 자바스크립트는 Firefox, Safari, Chrome같은 브라우저에서 작동하는 언어이다. 웹의 3대 언어로 HTML, CSS, Javascript가 있는데 HTML과 CSS가 정적인 언어라면, 자바스크립트는 동적인 언어라고 할 수 있다. 애니메이션과 같은 효과, 사용자의 행동에 따른 이벤트 등의 기능을 다룬다. 자바스크립트의 아빠, Brendan Eich. 이름때문에 Java와 혼란스러울수도 있지만, 자바스크립트와 Java는 전혀 무관한 언어이다. 자바스크립트는 1995년 Brendan Eich가 만들었는데, 원래 초창기 Eich가 개발한 언어의 이름은 LiveScript였다고 한다. 그러나 당시 잘 나가던 언어인 Java의 인기에 편승하고자 이름을 지금의 JavaScript로 바꿨다고 한다. (piggyback 전략) Variables 자바스크립트에서는 모든 변수를 데이터타입에 상관없이 var로 선언한다. 이를 느슨한 데이터 타입(Loosely data type)이라고 한다. 그러나 모든 변수를 var 로 선언한다고해서 모든 변수의 데이터 타입이 똑같은건 아니다. typeof 라는 연산자를 이용하여 확인해보면 다음과 같다. 1234567891011var exNum = 123;var exString = &quot;javascript&quot;;var exNull = null;var exUndefined;var exBoolean = true;typeof exNum; // numbertypeof exString; // stringtypeof exNull; // nulltypeof exUndefined; // undefinedtypeof exBoolean; // boolean 아마 자바스크립트 엔진이 데이터를 자동 분류하는게 아닐까 싶다. 이부분은 나중에 더 공부해보고 보충하는걸로.. 자바스크립트의 데이터 타입은 크게 **기본 타입(숫자, 문자, 비교, undefined, null)**과 **참조 타입(객체)**으로 나뉜다. 5가지 기본타입을 제외하면 자바 스크립트는 모든 것이 객체로 구성되는 언어라고 할 수 있다. Null, Undefined null : 아무런 값이 없지만 데이터가 존재하는 상태 undefined : 아무런 값이 없고, 데이터가 존재하지 않는 상태 null과 undefined는 둘 다 값이 없다는 점에서 같다고 착각할 수 있다. 실제로 == 연산자를 이용하여 둘을 비교하면 같다고 출력된다. 그러나 엄격한 비교 연산자 === 를 이용하면 다르다고 출력된다.비교 연산자에 대한 설명은 아래 이어진다. 정리하면.. datatype description null - 아무런 값이 없지만 데이터가 존재하는 상태- value of nothing undefined - 변수는 선언되었지만 초기값조차 선언되지 않은 아무런 값이 없는 상태- absence of value 자바스크립트의 변수 중에서도 기본타입에 대해서만 정리해보았다. 사실 자바스크립트의 변수에 대한 공부는 더할 필요가 있어 보인다. 하지만 현재 필요한 부분은 아니므로 일단 여기까지만 알고 넘어가겠다. Equality변수와 변수를 비교한다고 가정할 때, value만 비교한다면 == 으로 비교할 수 있지만, 이 방법은 옳은 방법이라고 할 수는 없다. 데이터 타입까지 엄격한 비교 기호로 ===를 쓸수 있는데, 이 방법으로 해야 모호함을 피할 수 있다. 예로 위에서 null과 undefined를 비교할 때 어떤 연산자를 쓰느냐에 따라 다른 boolean값이 출력됨을 알 수 있었다. 이와 비슷하게 number 타입 1과 boolean 타입 true 를 비교시, 어떤 동등 연산자를 사용하느냐에 true를 출력하기도, false를 출력하기도 한다. 하지만 엄밀히 비교한다면 당연히 false가 출력되어야 한다. 때문에 === 를 기본적으로 사용하고 특수한 경우에만 == 를 사용하는 습관을 들여야 할 것같다. Conditional Java와 마찬가지로 자바 스크립트에서의 조건문도 코드 스타일이 거의 비슷하다. 알아둬야할 부분만 정리해보았다. False 값을 반환하는 조건 false를 갖는 boolean 값 null 타입 undefined 타입 number 타입의 0 String 타입의 “” NaN 당연히 위 6가지 조건이 아닌 모든 조건은 true가 된다. 이를 활용하여 조건식을 만들면 된다. Ternary OperatorJava에서도 사용했던 삼항 연산자인데 익혀두면 좋아서 다시 정리해본다. conditionals ? (if its true) : (if its false); 형태로 구성된다. 이항 연산자만을 사용한 조건문과 같은 조건을 삼항 연산자로 사용했을 때의 코드를 비교해보자. 1234567891011121314var isGoing = true;var lightColor;// 이항 연산자 사용if(isGoing)&#123; lightColor = &quot;green&quot;;&#125; else &#123; lightColor = &quot;red&quot;;&#125;console.log(lightColor); // green// 삼항 연산자 사용isGoing ? lightColor=&quot;green&quot; : lightColor=&quot;red&quot;;console.log(lightColor); // green 똑같이 green을 출력했는데, 어떤게 더 간단해 보이는가? Loop &amp; Array 자바스크립트에서 반복문과 배열은 Java와 다른게 없어보인다. 향후 자바스크립트를 더 깊히 공부한다면 그 때 정리해보겠다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"}],"tags":[{"name":"javscript","slug":"javscript","permalink":"http://youngjinmo.github.io/tags/javscript/"}]},{"title":"자료구조 - 리스트","slug":"datastructure-list","date":"2019-05-04T06:25:25.000Z","updated":"2020-09-13T01:53:29.052Z","comments":true,"path":"2019/05/datastructure-list/","link":"","permalink":"http://youngjinmo.github.io/2019/05/datastructure-list/","excerpt":"","text":"목차 리스트 특징 각 언어별 리스트 특징 배열과 리스트 비교 추가할 때 삭제할 때 ArrayList와 LinkedList 비교 ArrayList LinkedList 리스트의 특징은 다음과 같다. 순서대로 저장 중복을 허용 비어있는 데이터(null)를 허용하지 않는다. 처음, 끝, 중간에 element를 추가/삭제하는 기능이 포함되어야 함. For each Languages 최근의 프로그래밍 언어는 리스트를 기본적으로 지원한다. 비교적 오래된 언어의 경우 리스트를 지원하지 않기도하다. C는 list를 지원하지 않는다. 따라서 개발자가 직접 리스트를 구현해야 한다. Python은 리스트를 지원하지만 배열을 지원하지 않는다. 하지만 List는 Array라고도 볼 수 있기 때문에 자바만큼은 아니지만 리스트를 이용하여 배열처럼 사용할 수 있다(?) Java 는 엄격하게 배열과 리스트를 구분한다. Array : int[] numbers = new int[10]; List : ArrayList numbers = new ArrayList(); Java API 호출 필요 import java.util.ArrayList; Java에서 List는 ArrayList와 LinkedList로 다시 나뉘어진다. ArrayList와 LinkedList에 대해서도 알아보자. 결과적으로 데이터 스트럭쳐는 모든 언어마다 다르다는 것이다. 따라서 각각의 언어에 맞게 개발자의 선호에 맞게 데이터 스트럭쳐를 구현해서 사용할 수 있다. Array vs ListInsert 출처 : 생활코딩 Array에선 기존에 존재하는 element의 index에 다른 value를 삽입하면 기존 value를 덮어씌우는 방식으로 데이터가 추가된다. 새 값은 이식되었지만, 기존의 값은 사라졌으므로 length는 그대로 유지된다. 사실 Array는 애초에 크기를 변경할 수 없는 자료구조이기도하다. List에서는 기존의 index의 element가 뒤로 밀리면서 새로운 element가 그 사이에 삽입된다. Array처럼 기존의 값에 덮어씌어진게 아니라 추가되었으므로 전체 데이터의 length가 증가한다. Remove 출처 : 생활코딩 Array에선 element를 삭제하면 해당 element가 null로 유지된다.따라서 해당 인덱스에 value(실제 데이터)가 있는지 없는지에 대한 체크가 필요하다. (메모리 누수 가능성) List에선 element를 삭제하면 뒤의 index의 element가 앞으로 당겨온다.모든 데이터가 연속되어지므로 null이 존재하지 않는다. 때문에 데이터를 추가/삭제 할 때 데이터가 있는지 여부를 체크할 필요가 없다. 이를 바탕으로 Array와 List에서 index의 의미가 다르게 해석된다. List에서 index는 몇 번째 데이터 인지를 알려주는 정도라면, Array에서 index는 그 값 자체를 의미하는 식별자가 될 수 있다. 아직 정리하지는 않았지만, List에는 ArrayList와 LinkedList가 있는데, 둘을 비교해보았다. 그냥 이렇다는것만 알아두고 다음 포스트로 넘어가서 ArrayList에 대해 정리한 글을 읽어보도록 하자. ArrayList vs LinkedList 출처 : 생활코딩 인덱스 조회ArrayList는 데이터 탐색 시, 메모리에 적재된 Array의 주소에서 Index를 통해 상대적인 위치를 찾아서 주소를 전달하기 때문에 빠르다. 반면 LinkedList는 HEAD에서 부터 연결된 다음 노드를 하나씩 찾아가야 하기 때문에 탐색 속도가 느리다는 단점이 있다. 데이터 관리 (추가/삭제)ArrayList에서 데이터를 추가하기 위해서는 새로운 데이터가 추가될 인덱스의 element부터 뒤의 모든 데이터를 뒤로 밀어서 빈 값을 만들어내고, 그 빈 값에 새로운 데이터를 추가하는 방식이다. 삭제하는 방법 역시 데이터를 삭제하면, 뒤의 모든 데이터를 삭제한 데이터만큼 앞으로 당겨와야 한다. 이 때문에 추가/삭제시 느리다는 단점이 있다. 반면 LinkedList는 element가 연결된 앞 뒤의 노드의 주소값만 변경하면 되기 때문에 ArrayList와 비교해서 훨씬 빠르다는 장점이 있다. 본격적으로 ArrayList는 다음 포스트에서 정리했다. 자료구조 글 목록 자료구조-배열 (이전글) 자료구조-리스트 (현재글)","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Algorithm","slug":"Dev/Algorithm","permalink":"http://youngjinmo.github.io/categories/Dev/Algorithm/"}],"tags":[{"name":"datastructure","slug":"datastructure","permalink":"http://youngjinmo.github.io/tags/datastructure/"}]},{"title":"핏빗 버사를 구입하다.","slug":"review-fitbit","date":"2019-05-03T08:20:24.000Z","updated":"2020-09-13T01:53:28.196Z","comments":true,"path":"2019/05/review-fitbit/","link":"","permalink":"http://youngjinmo.github.io/2019/05/review-fitbit/","excerpt":"","text":"Fitbit Versa 착용샷 3년간 착용중이던 Fitbit Charge HR을 대신해 지난해 출시한 Fitbit의 스마트 워치 Fitbit Versa를 구입했다. 새 제품을 구매한 이유는 Charge HR이 고장났기 때문이다. 사실 고장이 나고나서는 며칠동안 그냥 외출을 했는데, 3년동안 들었던 습관때문에 공허함을 좀처럼 해결할 수 없었다. Charge HR을 착용하던 왼쪽 손목을 수시로 들어올려서 시간을 확인하곤 했는데 이제 더 이상 왼쪽 손목을 들어올려도 아무것도 볼 수 없었다. 아이폰이라는 백만원짜리 고급시계(?)가 있긴 했으나 나는 좀 더 저렴하고 양 손을 사용하지 못하는 순간에도 사용할 수 있는 직관적인 시계가 필요했다. 애플워치를 생각안한건 아니었으나 결국 내 선택은 또 핏빗이었다. 이로써 나는 1세대 Fitbit 모델이었던 Fitbit Flex, 심박수 체크 기능이 처음으로 도입된 모델 Fitbit ChargeHR에 이어 5년만에 세 번째 Fitbit모델을 손에 얻게 되었다. Pebble 혹시나 이 글을 읽는 사람 중에 안드로이드/iOS 에서 모두 사용가능했던 스마트워치 제조사 Pebble을 기억하는 사람이 있으려나. Fitbit Versa는 Fitbit이 Pebble의 스마트워치 개발 자산 일부를 인수[기사]하여 개발한 Fitbit OS 3.0이 탑재된 스마트워치이다. 이 Fitbit OS 3.0을 말할 것 같으면, 지금은 세련된 애플워치와 갤럭시 기어가 시장을 주도하고 있지만 이런 제품이 없던 시절 안드로이드와 아이폰에서 모두 사용가능하면서 큰 사랑을 받았던 Pebble의 레거시라고 할 수 있겠다. 아이폰 사용자로써 애플워치를 구입할 수 있었음에도 불구하고 난 왜 이번에도 Fitbit을 선택한걸까? 이제 그 이야기를 해보도록 하자. Why FitbitFitbit과의 인연은 5년이란 시간을 거슬러 올라가야 한다. 2014년 봄, 친구들과 맥주를 마시면서 웨어러블 컴퓨팅 기술에 대한 전망에 대해 토론을 하고 있었다. 군대를 막 전역한 나는 당시 웨어러블 컴퓨팅이라는 개념이 지나치게 모호하게 느껴져서 그 토론에 참여하지 못하고 구경만 했던 기억이 있다. 어떠한 역할을 할 수 있을지도 모르면서 십만원이 넘는 기기를 구입하는게 당시 큰 부담이었음에도 호기심을 이기지못해 돈을 탈탈 털어 Fitbit Plex를 이마트몰에서 구입했다. 당시만 하더라도 웨어러블 디바이스를 판매하는 온라인몰이 극히 적었다. 그도 그럴게 제품 자체가 적었으니.. 내 첫 Fitbit제품이었던 Flex. (출처: iMore) 당시 이마트를 운영하는 신세계 그룹의 정용진 부회장이 Jawbone을 착용하고 올린 트윗이 화제가 된 적이 있다. 부회장님의 관심덕분인지(?) 당시 이마트몰은 국내에 다양한 웨어러블 디바이스를 판매했다. 나도 여기서 Flex를 구입했다. 그리고 2015년 Heart Rate의 약자를 딴 HR 모델이 처음으로 등장했다. 단순히 걸음수만 체크하던 트래커에서 이제 심박수까지 체크하게 되면서 헬스케어 디바이스에 한 걸음 다가가게 된 것이다. 이제 “값 비싼 만보기” 라는 수식어에서는 벗어날 수 있었다. 만보기는 심박수 체크 못하니까… 두번째 Fitbit 제품, Charge HR. (출처:Gizmodo) 난 지금도 이 제품이 현존하는 최고의 피트니스 트래커라고 생각한다. 우레탄 재질의 밴드는 가볍고 방수에 강했다. 가죽의 경우 물이 묻거나 하면 부담스러울수 있으나 우레탄 재질은 저렴하고 방수가 되는 덕분에 선호하는 재질의 밴드이다. 이 때문에 샤워할 때를 제외하곤 정말 하루종일 착용하고 다녔던 제품이다. 축구할 때도 착용하면 내가 오늘 얼마나 뛰었는지를 눈으로 확인할 수 있었다. Charge HR은 공식적으로 밴드 교체를 지원하지 않는다. Charge HR 2부터 악세서리를 판매한걸로 기억하는데.. 아무튼 그래도 방법이 아주 없지는 않았다. 나는 3년동안 Charge HR을 착용하면서 3번 밴드를 교체했다. 알리 익스프레스에서 Charge HR 교체용 밴드를 판매하는데 여기에서 $6-7 정도의 가격으로 주문해서 바꿔차곤 했다. 한 번 뺀 밴드는 다시 사용할 수는 없었다. 밴드에서 기기를 분리할 때 재사용이 불가능해질만큼 밴드에 손상이 가해지기 때문이다. 아니 그래서 왜 애플워치가 아니라 또 Fitbit이냐고? 이제 진짜 써보겠다 ㅋㅋㅋㅋ 1. Price 우선 애플워치보다 훨씬 저렴하다. 애플에서 판매하는 가장 저렴한 모델의 애플워치와 Fitbit에서 판매하는 Versa 모델중 가격이 가장 높은 Special Edition과 비교해도 20만원이 차이난다. 내가 구입한 모델은 기본 모델이어서 이것보다도 더 저렴했다. Special Edition은 우레탄 밴드 대신 다른 소재의 밴드가 기본 적용되며 우레탄 밴드도 추가로 주는걸로 알고 있다. 이외에 기능적으로는 NFC기반의 Fitbit Pay(한국지원X)가 지원된다고 한다. 둘 다 필요없는 나는 기본 모델을 구입했다. 2. Battery Life Fitbit의 Sleep monitoring 기능 애플 워치의 배터리 수명은 약 하루라고 한다. 이건 내가 감당할 수 있는 스펙이 아니다. 배터리 수명이 24시간이라면 사실상 수면측정 불가능하다. 수면중에 꺼진다면 누가 수면체크에 애플워치를 사용할까. 아마 대부분의 애플 워치 사용자들은 자신이 거주하는 모든 공간(방/사무실) 등에 애플워치 충전기를 놓아두거나 수면중에 충전을 할 것으로 생각한다. 수면측정은 내가 피트니스 트래커를 사용하는 주된 이유중 하나이기 때문에 애플워치가 배터리 수명을 최소 30시간 이상 확보하지 못한다면, 영원히 구매하지 않을 것 같다. 아니 못할 것 같다. 3. What does we reall need? 이게 가장 큰 포인트이다. 난 처음 애플워치가 공개됬던 날부터 지금까지 스마트 워치에 관심이 있으면서도 늘 부정적으로 보는 이중적인 사람이다. 시계가 인터넷과 통신할 수 있게되면서 “혁신”이라는 단어를 난잡하게 사용하고 있지만, 현재까지 시장에서 손꼽을만한 혁신적인 스마트워치는 없다고 단언한다. 스마트폰으로 충분히 할 수 있는 일을 하면서 그저 주머니에서 스마트폰을 꺼내지 않아도 된다는 점을 장점으로 어필하는건 과장에 불과하다고 생각한다. 사람들이 주머니에서 꺼내는 것을 귀찮아한다는게 정말 행동에 대한 귀찮음일까? 과거에 애플 워치가 처음 출시했을 때 얼마 안되서 구입한 사람을 본 적이 있다. 본인은 매우 만족하면서 썼지만 난 몇 개월간 그 사람의 사용 패턴을 보면서 애플 워치를 구입하지 않기로 결정했다. 당시 그 사람은 아이폰을 자주 확인하지 않아도 된다며 만족했지만, 오히려 애플워치에 인해 더 많이 간섭을 받고 있었다. 수시로 워치를 확인하는 바람에 회의에 참여하는 모습이 방해되었고, 그것으로 인해 생산성이 오르기는 커녕 오히려 필요하지 않은 정보까지 손목으로 받음으로써 오히려 손목 위의 그 작은 디바이스에 구속되는듯 보였다. 애플워치로 카카오톡 메세지를 받을 수 있다는 것에 만족하다고 했지만 카카오톡을 통한 대화의 대부분이 Trash Talk임을 생각해보면 그게 정말 장점이 될수있을까? 더 많은 정보를 전달받기 보다는 이제는 내게 정말 필요한 정보만을 추출해야할 시대라고 생각한다. 참고로 난 카카오톡 시스템 알람을 끄고 생활한지 3년이 되어간다. 그리고 전혀 불편하지 않다. 개인적으로 커뮤니케이션 수단으로서의 중요성은 인스턴트 메신저(카카오톡/라인) &lt;&lt; 메일 &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 전화 라고 생각하기 때문이다. 난 여전히 스마트 워치의 존재 자체가 불필요한 존재라고 생각한다. 적어도 스마트폰의 일부 기능을 대체하는 정도로는 말이다. 최근 몇 년동안 스마트 워치를 포함한 전체 웨어러블 시장이 침체되는 이유도 여기에 있다고 생각한다. 그런데 최근 애플의 실적 발표에서 하드웨어 부문에서 아이패드와 함께 괄목한 성적을 기록한 디바이스가 애플 워치이다. 왜 애플워치는 시장과 반대로 반응했을까? 심전도(ECG, Electrocardiogram) 측정 기능이 애플워치4에 도입하기 시작했는데 이후부터 애플워치에 대한 인기가 높아지지 않았을까 생각한다. 이전까지는 스마트 워치에 대한 단순한 호기심만 있었다면 이젠 이 기기가 필요한 분명한 이유가 하나 늘었기 때문이다. 심전도 측정 기능은 단지 분당 심장이 몇 번뛰는지를 체크하는 심박수 체크 기능과 달리 심장의 비정상적인 리듬을 측정하고 진단하는 기능이라고 한다. 이 기능을 통해 심근경색 등 심장의 건강을 체크할 수 있다고 한다. 내가 생각하는 스마트워치가 앞으로 갈 길이 애플워치 4세대 모델이라고 생각한다. 그저 스마트워치 OS를 개발하거나 이식하는 것만으로는 필요성을 전혀 느끼지 못한다. 가격을 낮춘다고 해서 해결될 문제도 아니다. 스마트워치가 아니라 피트니스 트래커로서 이걸 착용한 사람들에게 특별한 가치를 제공해야만 한다. 내 건강을 확인할 수 있다는 점은 스마트폰이 대체할 수 없는 역할이다. 또 위와 같은 이유로 Fitbit이 아쉽기도 하다. Fitbit은 애플보다 먼저 시장을 선점했고, 애플워치가 론칭되고 나서도 한동안 북미 시장에서 1등 사업자는 Fitbit이었다. 그러나 최근 들어서는 비교하기가 민망할만큼 점유율 격차가 커졌다. 위에서 부터 아래로 시간이 최신순이며, 파란색이 애플워치, 빨간색이 Fitbit의 Market share이다. 애플워치가 본격적으로 판매되기 시작한 15년 분기(1Q ‘15)부터 애플워치의 share가 보이기 시작한다. Fitbit의 share는 17년부터 하향세를 보임이 분명하게 보인다. 통계 데이터 사이트 Statista에서 가져왔다. 그러나 애플워치 4세대 모델과 Fitbit Versa 간의 차이가 내가 생각하기에 위의 ECG 측정 외엔 없어보였다. 그렇다면 내게 ECG 측정 기능에 대한 기회비용은 20만원이었다. 20만원을 더 지불하고 ECG 기능이 측정되는 애플워치를 구입할 것이냐, ECG 측정을 포기하고 20만원을 절약할 것이느냐. 난 절약을 선택했다. 음.. 지금 별다른 소득이 없어서 그럴수도 있겠으나 아마도 소득이 있었어도 내 선택은 달라지지 않았을것 같다. 물론 소득이 엄청나게 높았다면, 애플워치 에르메스 에디션을 구매했을 것이다. 엄청나게 높았다면 말이다.. Fitbit Versa를 착용한지 며칠 되지 않았지만 생각보다 디자인도 이쁘고 가벼워서 착용감이 뛰어나다는 생각이 든다. 아이폰과의 궁합은 사실 전혀 기대하지 않았는데 아이폰 화면에 켜지는 Notification을 인식해서 Fitbit versa로 전송을 해주기도 한다. 보너스를 받은 기분이다 ㅋㅋ 실시간 정보가 필요한 날씨나 미세먼지 이외에 헬스케어 관련한 앱의 notification을 Fitbit Versa를 통해 전달받고 있다. 음악을 제어할 수 있는 기능도 있는데, 이것도 쏠쏠한 것 같다. 개인적인 선호와 별개로 주변 사람들에겐 Fitbit을 추천하지 않는 편이다. 심박수와 걸음수를 체크하는데 십만원 넘는 비용을 지불하고자 하는 사람이 별로 없기 때문이다. 심박수와 걸음수 체크는 샤오미의 미밴드를 통해서도 가능한데 미밴드는 5만원도 되지 않는 가격에 판매하고 있다. 이 글을 읽고 Fitbit Versa에 대해 관심이 생긴 사람이 있다면, 그냥 애플워치를 사라고 얘기하고 싶다. Fitbit은 위에서 언급했듯 서비스가 좋지 않다. 가격에 비해 보증기간이 1년으로 짧은데 기가막히게 1년이 지나자마자 크고 작은 에러가 발생한다. 그리고 국내 지사로부터는 그 어떤 서비스도 받을 수 없기 때문에 미 본사 CS팀에 직접 문의해야하는 경우가 많다. 그렇다고 해서 크게 달라지는 없으나 난 본사와 직접 커뮤니케이션해서 보증기간이 지나고나서도 리퍼 제품을 받은 적이 있었다. 무엇보다 자신이 왜 이런 피트니스 트래커를 원하는지에 대해 분명하게 정의하고 제품을 찾아봤으면 좋겠다. 그저 신기해보여서 구입한다면, 얼마 지나지 않아 충전기에 꽂힌채로 책상 서랍에 들어가거나 A+급 상태로 중고나라에 올라갈지도 모른다. 당신의 제품이 여기 추가될지도 모른다..","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Review","slug":"Life/Review","permalink":"http://youngjinmo.github.io/categories/Life/Review/"}],"tags":[{"name":"gadget","slug":"gadget","permalink":"http://youngjinmo.github.io/tags/gadget/"},{"name":"healthcare","slug":"healthcare","permalink":"http://youngjinmo.github.io/tags/healthcare/"},{"name":"IoT","slug":"IoT","permalink":"http://youngjinmo.github.io/tags/IoT/"}]},{"title":"자료구조 - 배열","slug":"datastructure-array","date":"2019-04-30T08:55:25.000Z","updated":"2020-09-13T01:53:29.084Z","comments":true,"path":"2019/04/datastructure-array/","link":"","permalink":"http://youngjinmo.github.io/2019/04/datastructure-array/","excerpt":"","text":"목차 자료구조, 왜 배워야할까? 배열 요소, Element Data Structure왜 자료구조를 알아야 할까? 원하는 데이터를 가장 효율적으로 탐색하는 방법이 알고리즘이라면, 자료구조는 그런 탐색이 용이하도록 돕는 인프라라고 생각한다. 위의 이미지처럼 정리되어 있으면 특정 음료수를 찾으라고 할 때, 쉽게 찾을 수 있다. 위와 같은 식료품 매장에서 우유를 찾는다고 가정해보자. 다음과 같은 절차를 통해 우유를 찾을것이다. 먼저 음료가 모아진 코너를 간다. 그리고 유제품끼리 정렬된 쪽으로 간다. 제조사에 맞춰 우유를 찾는다. 위의 절차가 알고리즘이라고 생각한다. 그리고 사진 속처럼 같은 제품으로 분류한 방식이 자료구조인 셈이다. 따라서 자료구조는 알고리즘을 공부하기 위해서 반드시 필요한 개념이라고 할 수 있다. 자료 구조는 크게 배열과 리스트가 있다. 배열부터 살펴보도록 하자. Array배열은 비슷한 속성을 갖는 데이터끼리 패키징하는 방식의 Data Structure(자료 구조)이다. 연관된 데이터끼리 묶기 때문에 데이터가 많아졌을 때 데이터를 찾기에 용이하다는 장점이 있다. 프로그래밍에서 배열을 사용하면 다음과 같다. 언어는 Java를 사용했다. 1234567891011121314public class DataStructureEx &#123; public static void main() &#123; String country[][] = &#123; &#123;&quot;Korea&quot;, &quot;Japan&quot;, &quot;China&quot;, &quot;india&quot;, &quot;Vietnam&quot;&#125;, &#123;&quot;Canada&quot;, &quot;United States&quot;, &quot;Mexico&quot;, &quot;Costa-Rika&quot;&#125;, &#123;&quot;Brazil&quot;, &quot;Argentina&quot;, &quot;Chile&quot;, &quot;Uruguay&quot;, &quot;Colombia&quot;&#125;, &#123;&quot;France&quot;, &quot;United Kingdom&quot;, &quot;Italy&quot;, &quot;Germany&quot;, &quot;Netherland&quot;&#125;, &#123;&quot;Ghana&quot;, &quot;South Africa&quot;, &quot;Nigeria&quot;, &quot;Egypt&quot;, &quot;Cameroon&quot;&#125; &#125;; // 영국 출력 System.out.println(country[3][1]); &#125;&#125; String형 2차 배열 country[][]를 생성했다. 코드를 보면 알겠지만, country[1][]은 Asia 국가들로만, country[2][]은 북중미 국가들로만 묶는 식으로 대륙별 2차 배열을 생성했다. 이렇게 데이터를 분류하면 총 25개의 국가이지만 빠르게 국가를 찾을 수 있다. 물론 데이터가 많아질수록 배열로 인한 편리함은 극대화된다. 잠깐, 배열을 구성하는 요소는 어떻게 구성되어 있는걸까? Element데이터의 가장 작은 구성 단위를 요소, Element라고 한다. Element는 value(값)와 index(인덱스)로 구성되는데, 여기서 중요한 개념이 index이다. index는 해당 전체 데이터에서 element를 나타내는 식별자이다. Element(요소) = Index(인덱스) + Value(값) 출처 : 생활코딩 자 이제 배열과 함께 자료구조로 쓰이는 리스트에 대해 알아보도록 하자. 자료구조 글 목록 자료구조-배열 (현재글) 자료구조-리스트 (다음글)","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Algorithm","slug":"Dev/Algorithm","permalink":"http://youngjinmo.github.io/categories/Dev/Algorithm/"}],"tags":[{"name":"datastructure","slug":"datastructure","permalink":"http://youngjinmo.github.io/tags/datastructure/"}]},{"title":"Git - Commit","slug":"git-commit","date":"2019-04-30T05:30:11.000Z","updated":"2020-09-13T01:53:28.912Z","comments":true,"path":"2019/04/git-commit/","link":"","permalink":"http://youngjinmo.github.io/2019/04/git-commit/","excerpt":"","text":"본 포스트는 코드 스쿼드의 커밋하면 스테이지의 내용은 어디로 갈까를 시청하고 정리한 포스트입니다. 목차 Intro git status git commit 버전관리 소트트웨어인 Git은 객체로 구성되어 있다. Git을 구성하는 객체는 다음과 같다. Commit 우리가 가장 신경써야할 Commit(커밋) 이다. Tree 커밋에 포함된 파일 목록. Blob 파일의 내용 파일 내용 변경되면, 객체주소 변경되면서 git status 에서 modified 메세지 출력. git hash-object file.txt 로 file의 객체주소 확인 가능 Tag reference branch HEAD Git statusCLI 환경에서 git status 명령어를 입력하면 알 수 있는 것들이다. 작업 디렉토리 스테이지 Commit &lt;HEAD&gt; status 명령어를 통해서는 local repo에 어떤 파일이 올라갔고, 어떤 파일이 아직 local repo에 동기화되지 않은지를 볼 수 있다. 이를 위해서는 우선 Git에서 데이터가 어떻게 이동되는지 경로를 먼저 보도록 하자. workspace는 프로그래머가 작업하고 있는 공간을 의미한다. git이 추적하지 않는 상태이다. git을 설치하고, git에 의해 추적하길 원한다면 git add &lt;file&gt; 명령어를 통해 파일들을 index에 올려두어야 한다. index에 있는 파일들만 local repository로 커밋할 수 있기 때문이다. local repository는 작업이 끝난 파일들이 저장된 최종 저장소라고 할 수 있다. 이를 원격 저장소와 연동하여 push 명령어로 서버에 git을 보낼 수 있다. 터미널에서 직접 보도록 하자. opentutorials_git 이라는 폴더를 생성 후, code.txt, code2.txt, code3.txt 파일을 각각 생성하여 각기 다른 상황을 만들어보았다. 현재 파일들의 상태는 다음과 같다. code.txt 파일 생성 vim code.txt stage에 add후, 커밋 git add code.txt git commit -m &quot;add code.txt&quot; 파일 수정 다시 stage에 올려둠 git add code.txt code2.txt 파일 생성 vim code2.txt stage에 add후, 커밋 git add code2.txt git commit -m &quot;add code2.txt&quot; 파일 수정 code3.txt 파일 생성 파일 수정 위 이미지를 보면 의도한대로 세 파일 모두 전부 다르게 git에 의해 tracking(추적)되고 있음을 알 수 있다. 먼저 code.txt부터 살펴보도록 하자. code.txt는 커밋한 이후 파일에 변경이 발생하여, 다시 stage에 올려두어 커밋할 준비가 되어있는 상태의 파일이다. 커밋할 준비가 되어 있는 파일, 즉 stage에 올라가 있고 변경사항이없는 최신상태일 경우 파일이름은 초록색으로 표시된다. code2.txt는 커밋한 이후 파일에 변경이 발생했지만 아직 stage에 올려두진 않은 상태다. 변경이 발생한 파일이 커밋할 준비가 되어 있지 않기 때문에 code.txt와 달리 빨간색으로 파일 이름이 표시됨을 알 수 있다. code3.txt는 파일 생성 직후, git 명령어를 입력하지않은 상태에서 한 차례 수정한 파일이다. git에 의해 추적되지 않고 있기 때문에 code.txt나 code2.txt와 달리 파일에 변경사항이 발생했음에도 불구하고 modified라는 표시가 출력되지 않는다. 그래서 (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) 라는 메세지를 친절하게 출력하여 git에 의해 파일이 추적되도록 stage에 파일을 올릴것을 의도한다. 위의 이야기를 제대로 이해하기 위해서는 커밋(Commit)이 객체라는 사실을 숙지해야만 한다. 괜찮다. 포기할거면 지금 포기해도 좋다.나중에 다시 필요해졌을 때 돌아오자.. Git Commit커밋(Commit)은 Git에서 작업단위를 의미한다. 파일 하나를 수정할 때마다 커밋을 하는게 아니라, login기능을 구현했다면 login 기능을 구현하는데 사용한 파일들을 묶어서 하나의 커밋 객체를 생성하는 방식이다. git commit 이라는 명령어를 통한 제어는 다음과 같은 일을 수행한다. 스테이지에 있는 내용을 가지고 새로운 커밋 객체를 생성 이전 HEAD가 가리키는 커밋이 새로운 커밋의 부모가 됨 Commit에 포함된 정보 Commit Message Tree-blobs Parent Commit 커밋 이후엔 작업 디렉토리와 스테이지, HEAD 커밋의 내용이 모두 같아진다 git의 원리를 파악하는데 유용한 소프트웨어, Gistory를 통해 위에서 만든 git의 객체들을 구경해보자. Gistory로 git의 객체를 확인하려면, 당연하게도 git의 객체를 생성해야 한다. 따라서 위의 예제 상황에서 code.txt를 “changed code.txt”라는 메세지와 함께 커밋하였다. 이미지를 보면, 객체가 생성되었음을 알 수 있다. 커밋 메세지도 볼 수 있다. 여기서 tree와 parent를 살펴볼건데, 위의 이미지는 해당 객체의 tree를 클릭했을 때 볼 수 있는 화면이다. 해당 객체가 어떤 파일들을 포함하고 있는지를 보여준다. blob은 위에서 파일 객체라고 하였다. 이를 클릭하면 아래처럼 파일의 내용을 볼 수 있다. code.txt에 입력한 코드 두 줄이 보인다. 12code1changed 이제 parent를 클릭해보자. 해당 커밋 객체의 부모 객체를 보여준다. code.txt를 커밋하기 전의 커밋은 code.txt와 code2.txt를 “add code.txt and code2.txt” 라는 메세지와 함께 커밋을 한 것이다. 이 메세지를 부모 객체에서 확인할 수 있다. 그리고 ./logs/HEAD/를 들어가면 git으로 제어하고 있는 워크스페이스 즉 local repository에서 생성된 모든 커밋 객체를 확인할 수 있다. 커밋 객체들이 HEAD의 노드임을 알 수 있다. 오래 전 커밋한 객체도 보이고, 멘 아래 방금 커밋한 메세지의 커밋 객체도 볼 수 있다. 다소 복잡하지만 git을 이해하기 위해 필요한 필수 과정이라고 생각한다. 원리를 이해해야 협업과정에서 발생할 수 있는 여러가지 충돌에 대응할 수 있다고 생각한다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"System.out.print의 정체","slug":"java-systemoutprint","date":"2019-04-16T11:19:15.000Z","updated":"2020-10-14T05:57:17.467Z","comments":true,"path":"2019/04/java-systemoutprint/","link":"","permalink":"http://youngjinmo.github.io/2019/04/java-systemoutprint/","excerpt":"","text":"자바에서는 이클립스 콘솔 창에 출력 할 때, System.out.println(); 이라는 코드로 출력을 한다. 그런데 이 코드는 어떻게 구성되어 있는걸까? 생각없이 출력을 위해서만 작성하다가 문뜩 생각나서 정리해보았다. 자바가 내장하고 있는 기본 패키지인 java.lang 패키지에는 System 이라는 클래스가 포함되어 있다고 한다. 그러니 System은 자바의 내장 객체 인 셈이다. 그럼 out.println은? System 클래스엔 표준 입출력을 위한 3가지 클래스 변수(static variable) 가 포함되어 있는데, 이게 System.in, System.out, System.err 이다. 이들을 PrintStream 이라고도 한다. 표준 입력 작업을 수행할 때엔 System.in,표준 출력 작업을 수행할 때엔 System.out을 사용한다. 그리고 파일에 직접 입력할 때엔 System.err을 사용한다. 그리고 다시 out 이라는 클래스 변수에 출력에 필요한 print(), println() 의 메서드가 포함되어 있는 것이다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"(번역) Java로 코딩을 배우는 방법","slug":"how-to-learn-to-code-in-java","date":"2019-03-08T09:27:19.000Z","updated":"2020-09-13T01:53:28.716Z","comments":true,"path":"2019/03/how-to-learn-to-code-in-java/","link":"","permalink":"http://youngjinmo.github.io/2019/03/how-to-learn-to-code-in-java/","excerpt":"","text":"How to learn to code in Java.: why you should and where to start 출처 : How to learn to code in Java: why you should and where to start 👎 지양해야 하는 것. 🚫 특별한 목표없이 공부하기 프로그래밍 공부에 앞서 스스로에게 질문하기“나는 왜 프로그래밍이 필요하지?” 한번에 여러 가지 기술을 공부하기 학습 계획에 너무 많은 언어나 기술을 포함하지 않도록 주의하여 번아웃을 피하자. 이론에만 몰두하기 프로그래밍이라는 기술은 많은 연습을 통해서 얻을 수 있는 기술이다. 배경에 대한 이론이 필요할 수 있지만, 거기에만 너무 몰두하면 코딩을 할 수 없다. 혼자 공부하기 누구도 당신이 안되길 바라는 사람은 없다. 개발자 커뮤니티나 행사에 참여해서 도움을 얻자. 당장 오프라인 커뮤니티에 참여하기 어렵다면, 온라인부터 시작하자. 단체 카카오톡 채팅방 또는 페이스북 그룹 등에서 찾아 볼 수 있다. 언젠간 프로그래밍을 마스터할 수 있다는 착각 프로그래밍의 세계는 급격하게 변하는 세상이다. 당신이 개발자가 되기로 마음먹었다면, 개발자가 된 그 순간까지도 학습을 멈춰서는 안된다. 🙏 지향해야 하는 것 📌 공부 목적 설정과 프로그래밍 언어 선택 개발자가 되기위해 프로그래밍 언어의 모든 걸 학습할 필요는 없다. 어떤 목적으로 학습하고자 하는지에 따라 분명한 학습 영역을 생각해보자. 학습 플랜 설계 평일엔 최소 2-3시간, 주말엔 5시간 이상 학습,이렇게 3개월에서 6개월을 학습하면 주니어 개발자에 이를 수 있음 학습 절차를 나눠서 설계 ex) JDK 설치 및 자바 실행 환경(Eclipse, IntelliJ IDEA) 구축 Java 문법 학습 Java Core 학습 컬렉션 학습 유명한 라이브러리와 프레임워크 학습 자주 쓰이는 API 학습 (ex. servlets, JSP 등) Git 프로그래밍은 매일 해야하는 **’스킬’**이므로 이론과 실습을 적절히 병행해야 한다. 프로그래밍 학습에 필요한 커뮤니티를 골라라. Java 코딩을 하다가 어떤 것이든 질문을 할 수 있는 커뮤니티에 가입해라. 그리고 당신의 생각을 공유하고 마음에 맞는 사람을 찾아라. Java 개발자들에게 최고의 커뮤니티를 아래에 리스팅해놓았다. 💻 Java를 공부하는데 유용한 사이트 💡 CodeAcademy 가장 유명한 프로그래밍 교육 웹사이트이다. 입문자에게 적합한 웹사이트이다. 주어진 과제를 읽고, 과제를 해결하는 코드를 작성하고 결과를 체크한다. 다음 step으로 넘어갈수록 어려워진다. CodeGym Codegym은 게임을 하면서 Java를 학습할 수 있는 웹사이트이다. Codewars ‘초보’딱지를 뗀 프로그래밍에 대한 기본 지식이 있는 사람들에게 적합한 웹사이트이다. EdX 개발자라고 할 수 있는 ‘프로’ 레벨의 사람들에게 적합한 웹사이트이다. EdX는 하버드 대학과 MIT에 의해 설립된 교육 플랫폼이다. Java를 포함하여 다양한 강좌가 있으며, 대학들로부터 제공받은 인증된 강좌들이 많이 있다. Certification을 제공하는 프로그램도 있다. 출처 : Medium, Johan Selawsky 처음으로 번역을 해 본 글이다. 프로그래밍 실력만큼이나 부족한 영어 실력이기에 발번역이 된 것 같지만.. Medium에서 좋은 글을 발견하면 꾸준히 번역해서 아카이브 해둬야겠다. Medium 무료계정은 한 달에 글을 5개 밖에 볼 수 없는걸 알았다. 좋은 글이고, 번역할 생각이 있는 글은 에버노트에 클리핑해둬야겠다.","categories":[{"name":"Articles","slug":"Articles","permalink":"http://youngjinmo.github.io/categories/Articles/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"},{"name":"career","slug":"career","permalink":"http://youngjinmo.github.io/tags/career/"}]},{"title":"개발자가 질문하는 법","slug":"how-to-ask-question","date":"2019-03-06T00:23:48.000Z","updated":"2020-09-13T01:53:28.748Z","comments":true,"path":"2019/03/how-to-ask-question/","link":"","permalink":"http://youngjinmo.github.io/2019/03/how-to-ask-question/","excerpt":"","text":"프로그래밍을 공부하다 보면, 스스로 해결 하지 못하는 상황이 발생하곤 한다. 이 때엔 온라인이나 오프라인을 통해 도움을 요청해야 하는데, 이 때 질문을 어떻게 하느냐에 따라 내가 원하는 솔루션을 효율적으로 접근할 수 있다. 여기에 좋은 글과 영상을 하나 씩 공유하고자 한다. 질문을 잘하는 개발자 는 토스를 서비스하는 비바 리퍼블리카에서 프론트 엔드 개발자로 계신 JBee님이 블로그에 작성하신 글이며, 유튜브 영상 동기부여 - 질문 잘 하는 법 은 코드스쿼드에서 백엔드 교육 담당을 맡고 계신 정호영님의 영상이다. 질문을 잘하는 개발자출처 : JBee님 블로그 문제가 발생했을 때 또는 모르는 것이 생겼을 때, 이를 해결할 수 있는 가장 빠른 방법은 자신의 상황을 잘 알고 있는 누군가에게 질문하는 것입니다. 그 누군가는 옆 동료가 될 수도 있고 멘토나 사수 등이 될 수 있습니다. 충분한 구글링을 우선 선행당연히 위에서 말한 ‘문제’와 ‘모르는 것’은 구글링으로 해결되는 문제를 의미하지 않습니다. 우리가 마주하게 되는 대부분의 문제는 이미 웹 상에 그 해결책이 있습니다. 아쉽게도 구글링을 잘하면 나올법한 질문들이 종종 보이거나 그런 질문들을 받게 됩니다. 구글링 또한 의식적으로 해야 한다고 생각합니다. 웹 상에 공유된 해결책으로 문제가 해결되지 않거나 여러 해결책들을 기반으로 새로운 해결책을 도출해야할 경우, ‘모르는 것’이 생겨납니다. 나 이거 모르는데, 알려주세요. 동료의 시간을 낭비하지 마세요.무턱대고 ‘A’을 모른다고 하면 질문을 받는 사람 입장에서는 난처할 수 밖에 없습니다. 그 이유는 다음과 같기 때문입니다. ‘A’와 관련된 내용을 정말 전부 모르는 것인가 그것이 아니라면 정확히 무엇이 문제인 것인가 무엇을 하다가 A까지 갔을까 현재 A로 무엇까지 해보았을까 (trial) 질문에 위 내용에 대한 질문이 전혀 없기 때문입니다. 당연히 이러한 정보가 포함된 질문이 좋은 질문입니다. 옆의 동료도 자신의 개발, 업무를 하고 있을 겁니다. 질문을 받는 옆 동료의 Context와 자신의 Context가 다르다는 것을 인지해야 합니다. 문제가 빨리 해결되길 원한다면 Context를 맞추는 작업이 선행되어야 합니다. 그리고 이 작업이 빠르게 선행되기 위해서는 질문자가 질문을 정리해야 합니다. Two Question질문에는 다음 두 가지 종류가 있습니다. 정답이 있는 질문 정답이 없는 질문 정답이 있는 질문에는 ‘예/아니오’로 대답할 수 있도록 질문하는 것이 좋습니다. 정답이 없는 질문에는 토론으로 이어지게 끔 자신의 입장을 정리하여 질문을 정리하는 것이 좋습니다. 추상적인 것 같으니 간단한 예를 들어볼까요? Example 1. “Jbee님, QA 중 올라온 이슈인데요, 보던 화면이 유지가 안 되는데 이거 어떻게 해야하죠?”여기에서 제가 역으로 질문할 내용은 다음과 같습니다. 모든 디바이스, 브라우저에서 발생하는 이슈인가요? 어떤 상황에서 보던 화면이 유지가 안되나요? 기존에는 어떠한 방식으로 보던 화면을 복원하고 있었나요? 이슈를 받고 어떠한 시도들을 해봤나요? Example 2. “Jbee님, 이 로직은 A에 들어가는게 맞나요, B에 들어가는게 맞나요?”여기에서 제가 역으로 질문할 내용은 다음과 같습니다. 이 로직은 왜 필요한건가요? A에 들어가야 한다고 생각하는 이유는 무엇인가요? B에 들어가야 한다고 생각하는 이유는 무엇인가요? 두 방법을 고민하는 이유는 무엇인가요? 1번부터 4번까지 역으로 질문하다가 1시간은 흘러가겠네요. 서로 피곤해질 것이 뻔합니다. 그리고 답변을 해주는 사람도 1~4번 내용을 모르고서는 쓸모있는 답변을 하기 힘듭니다. 질문 정리하기위와 같은 상황이 발생하지 않도록 질문을 하려면 어떻게 해야 할까요? Context를 맞추는 작업은 무엇을 말할까요? 모르는 것이 생겨서 질문을 해야 겠다는 생각이 들면, 아래 내용을 정리해보세요. 정리를 하다가 스스로 해결이 되는 경우도 많습니다. 지금 이슈가 된 것이 무엇인가?정확한 상황 설명을 추가하면 좋습니다. 이러한 부연 설명을 최대한 줄이기 위해 최소한 자신이 무슨 프로젝트를 하고 있는지 알고 있는, 또는 자신의 수준을 알고 있는 동료 개발에게 질문을 하는 것이 좋습니다. 지금 개발 중인지, QA 중인지, 배포 후 긴급 대응인지 이슈가 발생한 환경은 무엇인지 (OS, 브라우저 등) 어떠한 상황에서 이슈가 발생했는지 어디까지 해보았나?발생한 이슈에 대해서 자신이 어느 정도까지 파악을 했고 어떠한 시도를 해봤는지 공유를 하면 좋습니다. 질문을 받는 사람이 이미 자신이 아는 것을 설명해주거나 이미 시도해본 방법을 제시한다면 서로 시간 낭비가 됩니다. 발생한 이슈의 원인이 무엇이라고 생각하는가? 그 원인을 토대로 내린 결론은 무엇인가 결론대로 시도를 해보았는가 이러한 내용들이 담긴 질문을 한다면 답변자는 약간의 시간만 들여서 수월하게 문제를 함께 해결해볼 수 있습니다. 즉 답변자는 다음과 같은 액션을 취할 수 있습니다. 이슈의 원인을 다시 짚고 그에 따른 새로운 해결 방안을 제안 파악된 원인을 기반으로 다른 시도를 제안 올바른 방향의 결론이었다면 함께 디버깅을 진행 질문 정리하다가 답을 찾아서 질문할 필요가 없어지겠네요. 스스로 해결하는 경우가 당연 베스트이지 않을까요? 😁 온라인에 질문 올리기 다음 내용은 코드스쿼드의 정호영 마스터님의 발표 영상(동기부여 - 질문 잘하는 법)을 참고하여 작성하였습니다. 페이스북 그룹에 종종 질문 글이 올라옵니다. 하지만 답변을 받지 못하는 경우도 많이 봤고 답변해주고 싶어도 이해가 안 가는 질문글이 많았습니다. 다음과 같은 부분들을 고려해보면 어떨까 싶습니다. 질문의 제목에! 질문의 status를 추가하자 답변 대기, 해결됨 등 질문의 본문에! API , 핵심 에러메시지을 포함하기 - 발생한 에러 메세지는 정확히 예의바르게, 깔끔하게, 맞춤법을 맞춰서 코드는 스크린샷이 아닌, 텍스트 그 자체가 아닌 code share 툴을 사용. Gist, code sandbox, jsbin 등 질문을 올리고 반드시 tracking 마지막 ‘질문을 올리고 반드시 tracking’ 부분은 개인적으로 정말 중요하다고 생각합니다. 질문을 올리고나서 답변이 달려도 아무 반응이 없는 질문글들이 보이면 마음이 아픕니다. 답변이 원하는 내용이 아니더라도 도움을 주시려는 분에게 최소한의 예의가 아닐까 생각합니다. 한 걸음 더 나아가기질문에 대한 답을 듣고 문제를 해결했습니다. 여기서 한 발 더 나아가서 그것을 공유해보는 것은 어떨까요? 답변을 해준 사람이 ‘감히 내 소중한 지식을 너가 공유해?’라고 하진 않을 겁니다. 이거 별거 아닌데… 굳이 공유까지 하나요? 대부분 공유를 부탁하면 이런 반응입니다. 질문을 하고 답변을 듣기 전 이 이슈는 자신에게 굉장히 힘겨운 문제였는데도 까맣게 잊어버립니다. 누군가는 같은 이슈로 고통받고 있지 않을까요? 블로그가 없어요! 블로그가 없어도 공유는 가능합니다. 간단히 정리하여 페이스북 커뮤니티 그룹에 올려도 되구요, 요즘 많이 사용하시는 notion은 정리한 내용을 바로 웹 상으로 공유도 할 수 있습니다. 우리는 개발자이니 GitHub 저장소를 활용할 수도 있겠습니다. 저는 tip-archive라는 GitHub 저장소를 하나두고 블로그에 올리기에는 너무 짧은 snippet 성의 지식들을 이슈로 정리하고 있습니다. 마무리질문자는 질문하기 전 조금만 시간을 더 투자해서 서로의 시간을 아끼고 함께 성장할 수 있지 않을까요? 감사합니다. 동기부여 - 질문 잘 하는 법출처 : 코드스쿼드 유튜브 - 동기부여 질문 잘 하는 법 ### 질문 작성하기 맞춤법은 정확하게 / 질문은 예의바르게 / 포맷은 깔끔하게! 코드보다 상황 설명을 먼저 하자 재현 가능하도록 매우 구체적으로 상황을 기술한다. 코드를 스크린샷으로 첨부하지 않는다! https://pastebin.com 또는 https://gist.github.com 을 이용 발생한 에러 메세지는 정확하게 첨부한다. 적절한 스크린샷을 첨부한다. Example BAD 프로그램이 안돌아가요 GOOD int 나누기 int 결과값이 이상하게 나오는 이유가 뭘까요? BAD [node] 세션 문제 도와주세요ㅜㅜ GOOD [node] 페이지 리다이렉트를 해도 세션을 유지하려면?","categories":[{"name":"Articles","slug":"Articles","permalink":"http://youngjinmo.github.io/categories/Articles/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"},{"name":"career","slug":"career","permalink":"http://youngjinmo.github.io/tags/career/"}]},{"title":"Java API Documentation","slug":"why-we-should-to-read-document","date":"2019-03-04T02:42:44.000Z","updated":"2020-09-13T01:53:28.012Z","comments":true,"path":"2019/03/why-we-should-to-read-document/","link":"","permalink":"http://youngjinmo.github.io/2019/03/why-we-should-to-read-document/","excerpt":"","text":"Examples1) Math.random()123456789101112131415public class Example_01 &#123; public static int rollDice() &#123; // random num between 0 and (almost) 1 double randomNumber = Math.random(); // change range to 0 to (almost) 10 randomNumber = randomNumber * 10; // convert datatype from double to integer int randomInt = (int)randomNumber; // returns return randomInt; &#125; &#125; Math 클래스의 random() 사용법이다. 랜덤으로 수를 반환하는 메서드이다. Math.random()은 0부터 1까지의 double형 랜덤 상수를 추출한다. 여기에 다른 상수를 곱하면 (min) 0은 그대로지만 (max) 1이 상수와 연산되어 랜덤 값의 범위를 조정할 수 있다. random()가 실행될 때마다 서로 다른 값을 추출하게 되므로 변수를 선언하여 값을 여러개 생성할 수 있다. 12int ran1 = randomInt; // 3int ran2 = randomInt; // 7 2) Math.max()12345678910111213141516171819public class Example_02 extends Example_01 &#123; public static void main(String[] args) &#123; // save random number to a int a = rollDice(); System.out.println(&quot;a is &quot;+a); // shows what is number of a // save random number to b int b = rollDice(); System.out.println(&quot;b is &quot;+b); // shows what is number of a // compare which is the larger between a and b int largeNum = Math.max(a, b); System.out.println(&quot;Largest is &quot;+largeNum); &#125;&#125;// 출력 결과 // a is 2(random)// b is 4(random)// Largest is 4 Math 클래스의 max() 사용법이다. argument로 받은 두 수중 어느 수가 더 큰지를 판별할 때 사용하는 메서드이다. 앞서 상속을 배워서 깨알처럼 이용해봤다 ㅋㅋ Example_01 클래스를 상속받아서 rollDice() 를 사용했다. 변수를 선언하여 각각 rollDice() 가 반환하는 값을 저장하고, max()를 사용하여 두 수중 어느 수가 더 큰 수인지를 비교했다. Why?공부하는데에 빠질 수 없는 부분이다. 위에서 소개한 Math.random() 은 Java의 내장 객체 Math 클래스의 random() 를 사용한 것이다. 개발자는 그저 호출하여 사용할 뿐이고, 내부에서 어떤 동작을 하는지 원리에 대해선 알 수 없다. 이를 알기 위해서는 Java API Documentation을 봐야 한다. 그런데 왜 Java API Documentation을 봐야할까?어떻게 작동되는지 여부를 꼭 알아야 하는 걸까? 몰라도 상관없다면 좋겠지만, Example_01에서 사용한 Math.random()만 하더라도 이게 int형을 반환하는지, double형을 반환하는지 Java API Documentation을 보기 전까지는 알 수 없다. 그래도 이 정도는 친절하신 Eclipse께서 알려주실거다. 그러나 반환값의 범위가 0부터 1인것은 어덯게 알 수 있을까? 마찬가지로 Exmapl_02에서 사용한 Math.max() 역시 Java API Documentation에서 상세하게 설명되어지고 있다. argument로 어떤 값이 들어와야 하고, 그럼 어떤 값이 return되는지. 자바에 있는 모든 개념을 알 수 없기 때문에 필요할 때마다 Java API Documentation을 보는 훈련을 꾸준히 하는 것이 중요할 것 같다. 블로그를 운영하는 목적도 이와 비슷하다. 내 머리는 하드 드라이브처럼 비휘발성 메모리가 아닌 RAM과 같은 휘발성 메모리이기 때문에, 이 블로그를 하드 드라이브로 운영하고, 이 블로그를 다시 찾아봄으로써 필요한 지식을 RAM으로 끌어와서 코딩(CPU)을 할 생각이다. updated.트위터에서 좋은 글을 발견해서 남겨본다.경험 사례를 통해 왜 공식문서를 봐야 하는지를 정리한 포스팅이다.이소영 - 공식문서에서 시작하기","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[{"name":"api","slug":"api","permalink":"http://youngjinmo.github.io/tags/api/"}]},{"title":"별찍기(2).java","slug":"startree-02","date":"2019-03-02T13:28:29.000Z","updated":"2020-09-13T01:53:28.072Z","comments":true,"path":"2019/03/startree-02/","link":"","permalink":"http://youngjinmo.github.io/2019/03/startree-02/","excerpt":"","text":"별찍기(1).java 보고오기 5) bottom-up 하프 별 트리 크리스마스 트리모양으로 별이 아래로 갈수록 2개씩 증가하는 형태이다. 반복문은 중첩반복문 2개가 필요해보인다. 왼쪽에서 부터 공백을 채우는 중첩반복문과 *을 찍는 중첩반복문. 먼저 별 트리의 왼쪽 공백을 채우는 코드이다. 123456for (int i = 0; i &lt; len; i++) &#123; for (int j = 1; j &lt; len-i; j++) &#123; System.out.print(&quot; &quot;); &#125; ...&#125; 별을 찍는 조건은 조금 복잡하다(?) 별의 갯수가 하나씩 증가하는게 아니라 (len*i)-1만큼 증가하기 때문에 중첩반복문의 조건에도 이 조건을 포함해야 한다. 다만, (len*i)-1의 조건을 그대로 사용할 경우 len층 트리가 아니라 len-1층 트리가 출력된다. 첫번째 줄에서 별이 출력되지 않았기 때문이다. 따라서 i에 1을 추가하여 (len*(i+1))-1로 조건을 변경해야 한다. 1234567for (int i = 0; i &lt; len; i++) &#123; ... for (int j = 1; j &lt; (2*(i+1))-1; j++) &#123; System.out.print(&quot;*&quot;); &#125; ...&#125; 그리고 이 공백이 끝나는 지점에서부터 (i2)+1까지 증가하는 반복문으로 \\를 채워나간다. 마지막으로 줄을 띄우는 print문을 함으로써 반복문 작성을 마친다. 123456789101112131415161718192021222324252627import java.util.Scanner;public class star_5 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;Input star length: &quot;); int len = sc.nextInt(); for (int i = 0; i &lt; len; i++) &#123; for (int j = 1; j &lt; num-i; j++) &#123; System.out.print(&quot; &quot;); &#125; for (int j = 1; j &lt; (2*(i+1))-1; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot; &quot;); &#125; &#125;&#125;// Input star length: 5// *// ***// *****// *******// ********* 6) top-down 하프 별 트리 중첩반복문 2개가 사용된다. 먼저 왼쪽의 공백을 작성하는 중첩반복문을 보자. 0에서부터 시작해서 전체 반복문의 iterator만큼 증가시킨다. 123456for (int i = 0; i &lt; len; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.print(&quot; &quot;); &#125; ...&#125; 그리고 이 지점에서부터 *을 찍어야 한다. *은 0부터 시작해서 (2*len)-1까지 증가시키며 row가 하나씩 늘어날수록 *이 (i*2)만큼 줄어들어야 하므로 조건식에 들어갈 식은 (2*len)-1-(i*2)가 되어야한다. 1234567for (int i = 0; i &lt; len; i++) &#123; ... for (int j = 0; j &lt; (2*len)-1-(i*2); j++) &#123; System.out.print(&quot;*&quot;); &#125; ...&#125; 전체 작성은 아래와 같다. 1234567891011121314151617181920212223242526import java.util.Scanner;public class star_6 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;Input star length: &quot;); int len = sc.nextInt(); for(int i=0; i&lt;len; i++) &#123; for(int j=0; j&lt;i; j++) &#123; System.out.print(&quot; &quot;); &#125; for(int j = 0; j &lt; (2*len)-1-(i*2); j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125;// Input star length: 5// *********// *******// *****// ***// * 7) 다이아몬드형 별 다이아몬드 형태의 별은 두개로 나뉘어서 보면 좋다. 별 트리의 허리에 해당하는 별의 길이가 이 트리의 전체 row에 해당하는데, 이 row를 기준으로 나누어서 보면 편하다. 1234567891011121314151617181920212223242526272829303132333435363738import java.util.Scanner;public class star_7 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int num = sc.nextInt(); for (int i = 0; i &lt; num; i++) &#123; for (int j = 1; j &lt; num-i; j++) &#123; System.out.print(&quot; &quot;); &#125; for (int j = 1; j &lt;= (2*(i+1))-1; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; for (int i = 1; i &lt; num; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; System.out.print(&quot; &quot;); &#125; for (int j = 0; j &lt; (2*num)-1-(2*i); j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(); &#125; &#125;&#125;// Input star length: 5// *// ***// *****// *******// *********// *******// *****// ***// * 8. 모래시계형 별 이번에도 5)의 트리와 6)의 트리를 활용해서 만들 수 있다. 이번에도 입력값을 수정해서 출력해야 하는데, 7)과는 달리 입력값을 2로 나눈후 +1을 해야한다. 이렇게 해야 트리의 위/아래에 입력값으로 받은만큼의 별 문자열을 출력할 수 있다. 그리고 어떤 길이를 받던 결국 중간의 별 문자열은 별 하나만 와야 하는데, 이 때 5)와 6)의 코드를 그대로 가져다 사용하면 별 하나짜리 문자열이 2개가 중복될 수 있다. 따라서 5)또는 6)의 코드를 수정해야 한다. 아래 코드는 5)의 코드를 수정해서 작성해보았다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.util.Scanner;public class star_8 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;Input star length: &quot;); int len = sc.nextInt(); int n = (len/2)+1; // 6) top-down 별 트리 for(int i=0; i&lt;n; i++) &#123; for(int j=0; j&lt;i+1; j++) &#123; System.out.print(&quot; &quot;); &#125; for(int j=0; j&lt;n-i; j++) &#123; System.out.print(&quot;*&quot;); &#125; for(int j=1; j&lt;n-i; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot;&quot;); &#125; // 5) bottom-up 별 트리 for(int i=1; i&lt;n; i++) &#123; // iterator의 시작을 1에서 시작함으로써 중간 중복을 제거 for(int j=n-i; j&gt;0; j--) &#123; System.out.print(&quot; &quot;); &#125; for(int j=0; j&lt;i+1; j++) &#123; System.out.print(&quot;*&quot;); &#125; for(int j=0; j&lt;i; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125;// Input star length: 5// *****// ***// *// ***// *****","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"별찍기(1).java","slug":"startree-01","date":"2019-03-02T06:03:15.000Z","updated":"2020-09-13T01:53:28.088Z","comments":true,"path":"2019/03/startree-01/","link":"","permalink":"http://youngjinmo.github.io/2019/03/startree-01/","excerpt":"","text":"중첩 for문에 익숙해지기위해 별찍기를 연습해봤다. 1) 왼쪽, 상단에서 하단으로 1234567891011121314151617181920212223import java.util.Scanner;public class star_1 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;Input star length : &quot;); int len = sc.nextInt(); for(int i=0; i&lt;len; i++) &#123; for(int j=0; j&lt;i+1; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125;// 출력 결과 // Input star length : 5// *// **// ***// ****// ***** 왼쪽에 붙어있으면서 상단에서 하단으로 내려갈수록 별이 많아지는 별 트리이다. 첫번째 for문, 즉 바깥쪽 for문은 Column에 해당한다. 입력받은 정수만큼의 별을 그대로 출력하면 되기 때문에 for(int i=0; i&lt;len; i++) &#123;&#125; 를 사용했다. 두번째 for문이자 안쪽 for문은 Column을 작성하는 부분에 해당한다. 첫번째 줄(Row)부터 별이 하나씩 증가(row)하는 형태인데, 증가하는 별은 Row 수에 비례해서 증가하고 있다. 따라서 두번째 for문의 반복조건은 첫번째 for문에서 사용한 iterator i만큼 반복되어야 한다. for문 조건식에서 &lt;= 을 사용하지 않고, &lt; 를 사용했기 때문에 반복조건에 +1을 해서 for(int j=0; j&lt;i+1; j++) &#123;&#125; 로 작성했다. 별을 찍었으면, iterator i가 증가할 때마다 줄을 바꿔야 하기 때문에 System.out.println(&quot;&quot;); 을 바깥쪽 for문과 안쪽 for문 사이에 작성해준다. 2) 오른쪽, 상단에서 하단으로 123456789101112131415161718192021222324252627import java.util.Scanner;public class star_3 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;Input star length: &quot;); int len = sc.nextInt(); for(int i=0; i&lt;len; i++) &#123; for(int j=1; j&lt;len-i; j++) &#123; System.out.print(&quot; &quot;); &#125; for(int j=0; j&lt;i+1; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125; // 출력 결과// Input star length: 5// (1) *// (2) **// (3) ***// (4) ****// (5) ***** 이번엔 1) 에서 했던 별을 오른쪽으로 밀어넣은 형태의 별 트리이다. 1)의 반복문이 2개를 중첩함으로써 구현했다면, 2) 부터는 반복문 1 개에 2 개의 반복문을 중첩시킴으로써 구현해야 한다. 1)에서는 신경쓰지 않아도 되었던 빈 칸을 임의로 만들어서 별의 위치를 오른쪽으로 고정시켜야 하기 때문이다. 빈 칸을 만들어내는 코드이다. 12345for(int i=0; i&lt;len; i++) &#123; for(int j=1; j&lt;len-i; j++) &#123; System.out.print(&quot; &quot;); &#125;&#125; 여기서 반복문의 조건식이 중요하다. 빈 칸은 시작점은 0에서 똑같이 시작하나, 갯수가 점차 적어지는 형조건이어야한다. 따라서 iterator j 에 사용자로부터 입력받은 최댓값(len)을 선언해주어야 한다. 그리고 한 줄씩 내려갈수록 빈칸의 갯수는 하나씩 줄어야 하므로 빈칸을 생성하는 안쪽 for문의 iterator j 의 시작 값을 j=len-i 로 만들어준다. 그러면 한 줄이 바뀔때마다 i의 값이 1씩 커지므로 이와반대로 j의 값은 1씩 줄어들면서 그 다음 for문으로 생성되는 별을 하나씩 앞당겨준다. 3) 왼쪽, 하단에서 상단으로 1234567891011121314151617181920212223import java.util.Scanner;public class star_3 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;Input star length: &quot;); int len = sc.nextInt(); for(int i=0; i&lt;len; i++) &#123; for(int j=n; j&gt;i; j--) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125;// Input star length: 5// (1) *****// (2) **** // (3) *** // (4) ** // (5) * 별을 사용자로부터 입력된 값만큼 출력하고 빈칸을 출력하는 프로그램이다. 따라서 별을 출력하는 안쪽 첫번째 반복문은 0에서 시작해서 len-i가 될 때까지 별 출력을 반복한다. 반복조건을 len-i로 작성한 이유는 바깥쪽 반복문의 iterator i가 하나씩 증가할 때마다 별이 하나씩 줄어야 하기 때문이다. 4) 오른쪽, 하단에서 상단으로 1234567891011121314151617181920212223242526272829import java.util.Scanner;public class star_2 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.print(&quot;Input star length : &quot;); int len = sc.nextInt(); for(int i=0; i&lt;len; i++) &#123; System.out.print(&quot;(&quot;+(i+1)+&quot;) &quot;); // printout line number for(int j=0; j&lt;i; j++) &#123; System.out.print(&quot; &quot;); &#125; for(int j=0; j&lt;len-i; j++) &#123; System.out.print(&quot;*&quot;); &#125; System.out.println(&quot;&quot;); &#125; &#125;&#125;// 출력 결과 // Input star length : 5// (1) *****// (2) ****// (3) ***// (4) **// (5) * 이번엔 반대로 3)의 별 트리를 오른쪽으로 밀어붙인 형태이다. 왼쪽이 빈 칸, 오른쪽이 별인 형태이다. 안쪽 첫번째 반복문은 빈 칸을 작성하는 반복문이고, 안쪽 두번째 반복문은 별을 작성하는 반복문이다. 안쪽 첫 번째 반복문부터 보면, 왼쪽이 빈 칸이므로 빈 칸을 작성하는 반복문을 작성하였다. 0에서 시작해서 바깥쪽 iterator i가 될 때까지 1씩 증가하는 조건으로 작성하였다. 안쪽 두 번째 반복문은 빈 칸에 이어 별이 입력되는 반복문인데, 0에서 반복조건을 k&lt;len-i 로 작성하였다. 별 트리의 넓이를 사용자로부터 입력받은 len 에 맞추고, 줄이 바뀔 때마다 별의 갯수가 하나씩 줄어들기 때문이다. 진짜 별사진으로 눈정화하고 별찍기(2) 보러가기","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"개발자에게 공부란.","slug":"how-to-learn-programming","date":"2019-03-02T01:35:22.000Z","updated":"2020-09-13T01:53:28.716Z","comments":true,"path":"2019/03/how-to-learn-programming/","link":"","permalink":"http://youngjinmo.github.io/2019/03/how-to-learn-programming/","excerpt":"","text":"개발자 단톡방에서 공유받은 개발자들의 공부방법에 대한 글을 아카이브 목적으로 남겨둔다. 지금 다니고 있는 회사에서 하는 일을 잘하기 위해서 노력하는 것이 가장 좋은 공부다. 회사에서 하는 일과 개인적으로 공부하는 내용을 최대한 근접시키기 위해서 노력하라. 새로운 기술을 익히는 최선의 방법은 스스로 문제를 정의한 다음, 새로운 기술을 이용해서 그 문제를 풀어보는 것이다. 책을 읽거나 동영상을 보는 것은 그보다 하위수준의 방법이다. 신기술을 좇는 메뚜기가 되지 말라. 모든 것을 알아야 한다는 강박을 버려라. 미리 획득하는 지식의 99%는 무용지물이다. 필요할 때 필요한 기술을 익힐 수 있는 것이 능력이다. 그 능력을 키워라. 이상한 나라의 앨리스에 나오는 토끼굴(rabbit hole)을 피하라. 카테고리이론을 알아야 함수형 언어를 쓸 수 있는게 아니고, 선형대수학을 공부해야 머신러닝을 할 수 있는게 아니다. 토끼굴에 빠져서 한없이 들어가다보면 비본질적인 공부에 시간을 허비하게 된다. 겉만 핥는 것은 경박하지만 토끼굴에 빠지는 것은 우매하다. 둘 사이의 적당한 지점에서 균형을 잡는 것이 개발자의 능력이다. 머리에 들어오지 않는 어려운 개념이나 용어는 자투리 시간을 이용해서 반복적으로 읽고 암기하라. 나중에 큰 그림을 공부할 때 도움이 된다. 항상 겸손해야 하지만 동시에 자긍심을 가져라. 그대가 지금 작성한 코드, 지금 읽은 책, 지금 공부한 내용을 그대보다 잘 아는 사람은 지구상에 없다. 모든걸 알고 있는 것처럼 보이는 다른 사람들도 그대와 마찬가지로 불안해하고, 위축되고, 두려워하면서 살아가고 있다. 자긍심이란 그런 타인을 돕고자 하는 마음가짐의 다른 이름이다.","categories":[{"name":"Articles","slug":"Articles","permalink":"http://youngjinmo.github.io/categories/Articles/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"},{"name":"career","slug":"career","permalink":"http://youngjinmo.github.io/tags/career/"}]},{"title":"내가 받아보는 뉴스레터","slug":"newsletters-in-my-inbox","date":"2019-02-26T10:50:44.000Z","updated":"2020-09-13T01:53:28.320Z","comments":true,"path":"2019/02/newsletters-in-my-inbox/","link":"","permalink":"http://youngjinmo.github.io/2019/02/newsletters-in-my-inbox/","excerpt":"","text":"블로그에 처음으로 프로그래밍 관련하지 않은 포스팅을 남겨본다. 가끔 만나는 사람들을 통해 “그런 정보는 어디서 들으시나요?” 라는 질문을 종종 받는다. 불과 지난달까지 학생이었고, 이제 공식적인 백수가 된 내가 아는 정보가 고급정보일리 만무하다. 그저 어딘가에 공개되어 있는 정보를 내 메일박스로 받아볼 뿐인데, 오늘 그 정보처(?)를 공개한다 ㅋㅋ 1. 스타트업 위클리, Startup Weekly 몇 년전만 하더라도 나도 힙하고 잘나가는 스타트업을 꿈꾸던 스타텁 피플 중 하나였다. 물론 지금도 그런 스타트업을 꿈꾸고 있긴 하지만.. 스타트업 관련한 소식을 전달받는 뉴스레터이다. 국내 스타트업들의 서비스 소식과 투자 유치 소식, 정책지원 관련 소식, 업계 인플루언서의 새로운 블로그 포스트, 해외 뉴스까지. 국내에서 스타트업을 준비중이거나 재직 또는 취업을 준비중인 사람들에게 더 없이 좋은 뉴스레터라고 생각한다. 일주일에 한 번 월요일에 발송되기 때문에 지난 한 주간 있었던 국내외 소식을 한 번에 정리하기 좋다. 또한 돌아오는 한 주의 이벤트를 정리해두었기 때문에 참석할만한 이벤트를 알아보기에도 좋다. 우리나라에 어떤 스타트업들이 존재하는지, 또 그들이 어떤 서비스를 운영중이고 그래서 성과가 어떤지 알아보기에 좋다. 특히 Startup Weekly에 다뤄지는 회사들의 경우, 상장사에 비하면 규모가 작을 지언정 성과를 내는, 소위 이 바닥에서 엘리트로 취급되는 회사들이 많기 때문에 스타트업 취업을 준비중인 구직자들에게 특히 추천하고 싶다. 스타트업 취업과 관련해서는 다음에 간략하게 정리해서 다시 한 번 남길 생각. 구독은 여기서 할 수 있다. 2. 스넥, SNEK SNEK은 금융/증권 관련 정보 소식지이다. 산업과 회사에 대해 인사이트있는 리포트를 발행한다. 투자한 회사 또는 잠재적 투자 대상 기업을 구독하면, 해당 회사에 대한 최신 소식이나 리포트를 놓치지않고 구독할 수 있다. 평소 투자에도 관심이 있어서 재미삼아 소액으로 국내외 주식투자를 하곤하는데, SNEK에서 제공되는 리포트를 읽으면서 아이디어를 얻곤 한다. SNEK은 프리미엄(Freemium)서비스이다. 유료로 구독하면 더 많은 글들을 읽을 수 있다. 그러나 무료 컨텐츠도 다 읽지못할만큼 많으며, 일부 컨텐츠는 기다리면 무료로 읽을 수 있기 때문에 무료만으로 충분하다. 단 가입을 해야 무료로 이용이 가능하다. 회원가입은 여기서 할 수 있다. 3. 뉴닉, Newneek 스타트업 위클리(Startup Weekly)가 스타트업 위주의 뉴스 레터였고, 스넥(Snek)이 금융관련 뉴스 레터였다면, 뉴닉(Newneek)은 종합 선물 세트다. 정치/사회를 망라하는 국내에서 발생하는 다양한 이슈들을 정리해서 발송하는 뉴스 레터인데, 한 번에 Follow하기 어려운 이슈들을 읽기 쉽게 정리해놓은게 특징이다. 포털에서 검색해서 여러 매체의 기사를 볼 것 없이 기다렸다가 뉴닉이 정리해준 걸로 이해하곤 한다. 아침에 지하철에서 스마트폰으로 구독하기 딱 좋은 컨텐츠이다. 뉴닉 구독은 여기서 할 수 있다. 다른 서비스들과 달리 구독 페이지마저 뉴닉의 컬러가 입혀져있다. 일단 구독 페이지에 들어오면 구독안하고 갈 수가 없을 것 같다 :) 4. 모닝 브루, Morning Brew 친구로부터 추천받아서 Morning Brew를 알게 되었는데, 사실상 정보구독을 목적으로 구독한 첫 뉴스레터 서비스였다. 너무 깔끔하게 정리를 해주었고, 다양한 분야의 소식을 발행해서 애정하는 서비스이다. Morning Brew는 실리콘 밸리부터 월 스트리트까지 미국의 다양한 소식을 전달해주는 뉴스레터이다. 나처럼 미국을 한 번도 방문한 적없는 사람들에게 꽤나 유익한 뉴스 레터라고 할 수 있다. 이렇게만 쓰면.. 아마 나를 모르는 분들은 내가 영어에 굉장히 능통한줄 알거다. 하지만 난 영어가 정말 꽝이다.. 지난해에 처음으로 토익시험에 응시하고 받아본 점수에 크게 충격을 받은 바 있다.. 난 영어를 못함에도 불구하고 영어 울렁증이 없는 이상한 놈(?)이다. 덕분에 영어로 된 컨텐츠도 크게 부담을 갖지는 않는 편이다. 다만 이해력이 필요한 난해한 이슈를 다룬 컨텐츠는 스킵을 하는 편이다.. Morning Brew는 매일 발행되는 뉴스 레터이다. 바쁘게 지내다보면 못 읽고 메일 박스에 몇 개씩 쌓이곤 하는데, 그럴 때엔 그냥 타이틀만 보고 읽고 싶은 컨텐츠만 골라 읽고 있다. Referral 이벤트를 하고 있는데, 내 계정으로 발행된 링크로 Morning Brew를 구독하는 사람 수에 따라 Morning Brew만의 굿즈를 받을 수 있다. 지금까지 5명의 구독자를 만들어서 랩탑 스티커를 받아서 지금까지 잘 붙이고 다니고 있다^^ Morning Brew 구독은 여기서 할 수 있다. 5. 생각노트 지금까지 소개한 뉴스레터 중 가장 감각적인 뉴스레터이다. 뭐랄까, 지메일보다는 인스타그램이 더 잘어울릴것 같은.. 그런 느낌적인 느낌이랄까..? 생각노트님의 블로그는 인사이트를 전달하는 블로그이다. 뉴스레터는 생각노트님의 신규 컨텐츠와 생각노트님께서 흥미롭게 읽은 컨텐츠에 대한 인사이트 및 소셜 미디어에서 본 흥미로운 컨텐츠들을 배달한다. 아는 사람은 알겠지만, 전체적인 분위기가 퍼블리와 굉장히 잘 어울린다. 잘어울리는 이 조합은 이미 협업을 한 바 있다 ㅎㅎ 퍼블리는 인사이트 있는 다양한 리포트를 시리즈물로 발행하는 플랫폼이다. 넷플릭스처럼 월 정액 구독을 하면, 퍼블리 내 컨텐츠를 무제한으로 읽을 수 있다. 퍼블리가 아니면 접할 수 없는 고퀄리티 컨텐츠들이 많아서 애정하는 서비스 중 하나다. 생각노트님은 퍼블리를 통해 컨텐츠를 성공적으로 판매하시고 종이책 출판까지 이어졌는데 퍼블리에서도 손꼽히는 성공적인 프로젝트 중 하나가 아닐까 싶다. 책도 다른 책들과 달리 디자인이 이뻐서 소장용으로 최근 구입해두었다 ^^ 마케팅을 하거나 또는 인사이트를 얻고자 하는 분들께 추천하는 뉴스레터이다. 여기서 구독할 수 있다. 이 외에도 다양한 뉴스레터를 구독하지만, 특히 추천할만한 다섯가지의 뉴스레터를 정리해봤다. 취준생 중에 이메일을 이용하지 않는 사람들이 꽤나 볼 수 있는데, 위 서비스들을 구독하기 위해서라도 꼭 이용하길 바란다. 전화번호와 이메일은 사용목적이 다르다. 구직을 준비중인 산업에 따라 다르겠지만, 블로그에 방문한 분들이라면 아마도 이메일 주소가 필요한 산업에 종사하고 계시거나 앞으로 필요할 분들로 생각된다. 꼭 이용하시길!","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Review","slug":"Life/Review","permalink":"http://youngjinmo.github.io/categories/Life/Review/"}],"tags":[{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"}]},{"title":"Repository 생성.Git","slug":"git-create-repo","date":"2019-02-19T12:04:24.000Z","updated":"2020-09-13T01:53:28.908Z","comments":true,"path":"2019/02/git-create-repo/","link":"","permalink":"http://youngjinmo.github.io/2019/02/git-create-repo/","excerpt":"","text":"git의 원격 저장소를 github으로 사용하였으며, MacOS에서 실행하였습니다. Github에 가입했다면, 프로필 사진 옆의 + 버튼을 클릭해서 저장소(Repository)를 생성하자. 버튼을 누르면 아래와 같은 화면을 만날 수 있다. 저장소 이름을 입력하고, 저장소를 설명하는 글도 간단하게 작성할 수 있다.이전 포스트에서도 이야기했지만, public / private은 저장소의 접근 권한을 이야기한다. 상업적인 목적의 프로젝트라면 private, 오픈소스 프로젝트나 개인 포트폴리오라면 public으로 권한 설정을 하면 된다. 접근 권한 설정은 저장소 생성 이후에 변경 할 수 있다. 이 화면까지 나왔다면 이제 브라우저에서 할 작업은 끝난걸 의미한다. 이제 터미널로 이동한다. 버전 관리를 할 디렉토리로 이동하고 git을 초기화한다. 1git init 위와 같은 명령어를 입력하고 파일 내 목록을 확인하는 명령어를 입력한다. 1ls -al 해당 디렉토리에 .git 이라는 폴더가 생성되었음을 확인할 수 있다. 이 폴더가 git이 저장되는 로컬 저장소이다. 여기까지만 해도 로컬 저장소를 바탕으로 버전 관리가 가능하다. 그러나 협업을 하기 위해서는 서버가 필요하다. 이 서버를 제공하는게 우리가 아까 가입하고 저장소를 생성했던 Github과 같은 git 호스팅 서비스이다. **Github에 만들어둔 저장소는 원격 저장소 (Remote Repository), 로컬에 있는 저장소는 로컬 저장소 (Local Repository)**이다. 이제부터는 원격 저장소와 로컬 저장소를 동기화하는 작업을 할 것이다. 다시 터미널로 돌아가자. 12git config --global user.name &quot;Username&quot;git config --global user.email &quot;Your Github Email&quot; 이름과 이메일을 입력하는건데, 이메일은 Github에 가입된 이메일이어야 한다. 그리고 버전관리 할 이 프로젝트를 설명하는 설명서를 간단히 만들어보자. 마크다운(Markdown) 포맷의 README라는 이름의 파일을 생성해보자. 이 파일은 위의 이미지와 같은 역할을 하게 된다. 마크다운에 대해선 다음에 다뤄보도록 하겠다. 일단 형식만 갖추기 위해 vi 명령어로 파일만 만들어보겠다. 1vim README.md 검은 화면이 열리면 아무 i 를 입력한다. i 는 insert를 의미한다. 이 화면에서 해당 프로젝트가 어떤 프로젝트를 의미하는지 간단히 한 줄로 작성한다. 이후 esc를 누르고, :wq 를 입력하고 빠져나오자. w는 저장, q는 vi 에디터 종료를 의미한다. 이제 다시 Github 원격 저장소와 연동을 마무리하자. 터미널로 돌아가서 다음과 같은 명령어를 입력하자. 12git remote add origin https:&#x2F;&#x2F;github.com&#x2F;username&#x2F;repository.gitgit push -u origin master 여기서 입력하는 저장소 주소는 아까 Github에서 본 주소를 입력하면 된다. 다시 Github으로 돌아가서 refresh하면 이제 페이지에 README 파일이 생성된걸 확인할 수 있을 것이다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"버전 관리의 시작.Git","slug":"git-started","date":"2019-02-19T10:53:37.000Z","updated":"2020-09-13T01:53:28.876Z","comments":true,"path":"2019/02/git-started/","link":"","permalink":"http://youngjinmo.github.io/2019/02/git-started/","excerpt":"","text":"스마트폰을 이용하다 보면, 모바일 앱 업데이트를 경험하게 된다.아래 이미지는 명함관리 앱, 리멤버 앱의 앱스토어 버전 기록이다. 리멤버는 2.8.2 버전에서는 마이너 버그를 수정했고, 2.8.3에서는 ‘명함 지도’ 라는 기능을 추가했다. 이렇게 파일이나 프로그램을 수정하고, 각 수정 파일을 버전에 맞게 저장하고 관리하는 일을 **버전 관리(Version Control)**이라 한다. 이렇게 파일을 관리하면 돌아가고 싶은 버전으로 언제든지 돌아갈 수도 있다. 멋지지 않은가! 그럼 버전 관리를 하면, 타임 머신같은 기능만 사용할 수 있는걸까? 당연히 아니다. 버전 관리를 하게 되면, 효율적인 **협업 (Collaboration)**이 가능하다. 먼저 아래의 이미지부터 보자. 이런 파일을 한 번도 본적이 없다면, 당신은 거짓말을 하고 있거나 매우 불성실한 사람일게다. 분명 최종본을 만들었건만 최종본의 최종본은 얼마 지나지 않아 탄생하고, 에일리언 영화에서나 볼법한 엄청난 번식력으로 우리를 새벽까지 컴퓨터 앞에서 뜬 눈으로 지새게 한 바로 이 경험. 버전 관리를 하게 되면, 이 과정을 최소화하여 효율적으로 코워킹 할 수 있다. 자, 이제 상상을 해보자. A, B, C 세 사람이 있다고 가정하자.A가 작업을 마치고, B가 작업을 하고, 마지막으로 C가 하는 순차적인 작업은 지나치게 비효율적이다. 심지어 C가 작업을 하고 있는데, A가 수정해야할 부분을 발견한다면 끔찍한 상황이 연출된다. 그냥 각자 맡은 부분을 작성, 수정하고 이 파일들의 중복되지 않는 부분만 **병합(merge)**한다면 어떨까? 그걸 가능케하는 마법같으면서도 지옥같은 Git의 이야기이다. 버전관리에 대한 자세한 내용은 git 여기에서 확인바란다. Git 설치하기 Mac http://git-scm.com/download/mac Windows http://git-scm.com/download/win 이외 리눅스거나 CLI 환경에서 명령어를 통해 설치를 원한다면, 여기를 확인바란다. Git 호스팅git을 사용하면서 각 버전, 즉 파일을 관리할 서버가 필요하다. 이런 서버를 무료로 서비스해주는 제품들이 있는데, 대표적인 Github이다. 혹시 Github 대신 다른 호스팅 서비스를 쓰고 싶다면, 링크를 통해 비교해보고 자신에게 맞는 서비스를 이용하면 된다. 원래 몇 개월 전만 하더라도 Github에서 무료 계정은 private repository를 이용할 수 없었다. 그러나 Microsoft가 무려 8조원에 달하는 거금으로 인수하면서 얼마 전 무료 계정에도 private repository를 만들수 있도록 허용해주었다. Repository는 저장소를 의미한다. 줄여서 그냥 repo라고도 한다. private repo는 접근 권한을 갖고 있는 사람들만 소스코드에 접근 할 수 있는 권한을 의미하며, public repo는 누구나 해당 저장소에 접근해서 소스코드를 볼 수 있다. 따라서 오픈 소스의 경우에는 public repo를 이용하고, 상업적인 목적을 지닌 프로젝트를 할 경우에는 private repo에서 하면 된다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"}],"tags":[]},{"title":"Intro .Java","slug":"java-intro","date":"2019-02-12T10:05:18.000Z","updated":"2020-09-13T01:53:28.572Z","comments":true,"path":"2019/02/java-intro/","link":"","permalink":"http://youngjinmo.github.io/2019/02/java-intro/","excerpt":"","text":"목차 Java의 특징 Java의 철학 정리 주석 Write once, **Run anywhere. Java의 특징 Java는 ‘Java의 아버지’로 불리우는 James Gosling가 1995년, Sun Microsystems.Inc,(이하 Sun)에서 다른 연구원들과 함께 개발한 프로그래밍 언어이다. 1995년에 Java 1.0을 발표했다. 2009년 Oracle이 Sun을 56억불에 Oracle에 인수하면서 모든 권리가 Oracle로 이전되었다. Java는 객체지향언어(Object Oriented Language)1이다. Java가 등정하기 이전의 객체지향언어인 C++ 문법을 기본으로 개발되었다. Java가 다른 언어와 다른 가장 큰 특징은 JVM2 위에서 작동되기 때문에 플랫폼 독립적3 이라는 점이다. HW에 맞게 완전하게 컴파일된 상태가 아니라 실행 시에 해석(Interpreter)되기 때문에 속도가 느리다는 단점을 가지고 있었다. 그러나 최근엔 JIT 컴파일러와 최적화된 기술로 인해 속도의 격차가 크게 줄었다. Java는 C/C++와 달리 메모리를 자동으로 관리해준다. Garbage Collector(이하 GC)가 사용하지 않는 메모리를 자동으로 정리해준다. Java의 철학 객체 지향 방법론1을 사용해야 한다. 프로그램(바이트 코드)가 여러 운영체제에서 실행될 수 있어야 한다. (플랫폼 독립성3) 컴퓨터 네트워크 접근 기능이 기본으로 탑재되어 있어야 한다. 원격 코드를 안전하게 실행할 수 있어야 한다. 다른 객체 지향 언어들의 좋은 부분만 가지고 와서 사용하기 편해야 한다. 정리하면.. Java는 객체지향언어1이다. 애플리케이션이 운영체제에 직접 실행되지 않고, JVM을 거치기 때문에 어떤 운영체제에서든 실행할 수 있다는 장점(플랫폼 독립성3)이 있다. 수동으로 메모리를 관리하는 C/C++와 달리 Java에는 Garbage Collector가 있어서 GC가 자동으로 메모리를 관리해준다. 1 객체지향 언어 (Object Oriented Programming) : 말 그대로 객체지향은 객체를 만드는 일이다. 현실 세계에 있는 것들을 프로그래밍화 한다고 할 수 있다. 더 자세히는 프로그램의 로직을 상태(state)와 행위(behave)로 이루어진 객체로 만드는 것이다. 반복되는 구문을 객체화하여 작성하는 프로그래밍 기법이다. = Modularization or Encapsulation 2 JVM (Java Virtual Machine) : 컴파일된 소스코드인 바이트 코드를 운영체제에서 실행시키기 위한 가상의 기계. Java로 작성된 프로그램은 반드시 JVM에서 실행되어야만 한다. 3 플랫폼 독립적 : 바이트 코드가 JVM에 의해서 실행되기 때문에 특정 운영체제에 종속되지 않고, 같은 바이트 코드로 여러 운영체제에서 실행할 수 있다는 장점이 있다. Java 프로그램은 운영체제에 종속되지 않지만, 대신 JVM을 운영체제에 맞게 설치해야 한다.","categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"}],"tags":[]},{"title":"내가 블로그를 시작하는 이유","slug":"first","date":"2019-02-10T05:57:19.000Z","updated":"2020-09-13T01:53:28.936Z","comments":true,"path":"2019/02/first/","link":"","permalink":"http://youngjinmo.github.io/2019/02/first/","excerpt":"","text":"공부를 할 땐 누군가를 설명할 수 있는정도로 공부를 하라는 이야기를 자주 들었다. 나도 잘 못하는데, 대체 누굴 가르키란 말인가. 그런데 프로그래밍 공부를 하면서 생각이 바뀌었다. 생활코딩, 인프런, Udacity 등 동영상 강의를 찾아 듣긴 하지만 실상 강의를 시청하는 시간보다 구글링하는 시간이 더 길었다. 구글링해서 발견하는 대부분의 포스트는 Stackoverflow거나 개발자 블로그들이었다. 개발자들이 공부하면서 알게 된 걸 블로그에 남기는 것을 알았다. 그리고 언제부턴가 그렇게 방문하게 된 개발자들의 블로그를 보면서 그 분의 프로필은 모르지만 이 분이 어디에 관심이 있으며, 어떤 언어/공부를 했는지를 블로그만으로 판단하고 있다는 사실을 자각했다. 누군가를 알려준다기엔 지금의 내가 너무 많이 부족하지만, 공부하고 있는걸 기록차원에서 남기고 또 이렇게 기록을 남기기 위해서 한 번 더 정리하는 과정이 필요하다고 생각했다. 그래서 연휴 기간동안 Hexo를 이용해서 깃헙 페이지로 블로그를 만들었다. Hexo는 지인이 추천해준 프레임워크이다. Nodejs 기반이긴 하지만, Nodejs가 뭔지 몰라도 만들수 있을만큼 간단하다. 다음 포스트에서 Hexo로 깃헙 페이지에 블로그를 만드는 법을 작성할 예정이다. 네이버 블로그나 Medium, 브런치가 있음에도 깃헙 페이지에 블로그를 만든 이유는 github.io라는 충분히 개발자스러운 도메인에 대한 욕심도 있었고, 무엇보다 새해부터 에버노트 1를 대신해서 노트 테이킹에 쓰고 있는 Markdown으로 포스트를 작성할 수 있다는 점이 가장 컸다. 네이버 블로그나 티스토리 등은 각자 포스팅에 편하도록 각자의 플랫폼에 맞춰서 에디터를 잘 만들어주긴 했으나, Markdown 문법 2 만큼의 높은 자유도를 보장하지는 않았다. 깃헙 블로그이므로 아마 내가 충분히 컨텐츠를 많이 만들거나 SEO에 신경쓰지 않는 이상 네이버, 구글과 같은 검색엔진 플랫폼에서 잘 검색되기도 힘들것이다. 그러나 이 점이 단점이라기보다는 오히려 누구도 보지 않는다는 점에서 시작하기에 더 수월했다. 앞으로 이 곳에 공부의 흔적을 남기고, 나처럼 뭘 모르는지 모르는 분들께 조금이나마 도움이 되는 블로그를 운영해보겠다. 1에버노트 : 모바일과 데스크톱에서 동기화하여 사용가능한 노트 앱. 전 세계에서 가장 인기가 많은 노트 서비스지만, tag를 이용한 노트 관리 때문에 처음 시작하는 사람들에겐 약간의 허들이 있는 서비스. 에버노트에서는 ‘노트’ &lt; ‘노트북’ &lt; ‘스택’ 3단계 형태로 노트를 수직 관리할 수 있다. 때문에 많은 노트를 관리하기 위해서는 태그, 링크 사용이 필수이다. 2Markdown : 일반 텍스트 문서의 양식을 편집하는 문법. README 파일이나 온라인 문서 등의 양식을 편집할 때 쓰인다. 마크다운을 이용해 작성된 문서는 쉽게 HTML 등 다른 문서형태로 전환이 가능하다 (출처: 위키)","categories":[{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"}],"tags":[]}],"categories":[{"name":"Dev","slug":"Dev","permalink":"http://youngjinmo.github.io/categories/Dev/"},{"name":"Front-end","slug":"Dev/Front-end","permalink":"http://youngjinmo.github.io/categories/Dev/Front-end/"},{"name":"Life","slug":"Life","permalink":"http://youngjinmo.github.io/categories/Life/"},{"name":"Thought","slug":"Life/Thought","permalink":"http://youngjinmo.github.io/categories/Life/Thought/"},{"name":"Others","slug":"Dev/Others","permalink":"http://youngjinmo.github.io/categories/Dev/Others/"},{"name":"Springboot","slug":"Dev/Springboot","permalink":"http://youngjinmo.github.io/categories/Dev/Springboot/"},{"name":"Git","slug":"Dev/Git","permalink":"http://youngjinmo.github.io/categories/Dev/Git/"},{"name":"Database","slug":"Dev/Database","permalink":"http://youngjinmo.github.io/categories/Dev/Database/"},{"name":"Java","slug":"Dev/Java","permalink":"http://youngjinmo.github.io/categories/Dev/Java/"},{"name":"Quiz","slug":"Quiz","permalink":"http://youngjinmo.github.io/categories/Quiz/"},{"name":"DevOps","slug":"Dev/DevOps","permalink":"http://youngjinmo.github.io/categories/Dev/DevOps/"},{"name":"Web","slug":"Dev/Web","permalink":"http://youngjinmo.github.io/categories/Dev/Web/"},{"name":"Linux","slug":"Dev/Linux","permalink":"http://youngjinmo.github.io/categories/Dev/Linux/"},{"name":"Review","slug":"Life/Review","permalink":"http://youngjinmo.github.io/categories/Life/Review/"},{"name":"Hexo","slug":"Dev/Hexo","permalink":"http://youngjinmo.github.io/categories/Dev/Hexo/"},{"name":"Algorithm","slug":"Dev/Algorithm","permalink":"http://youngjinmo.github.io/categories/Dev/Algorithm/"},{"name":"Articles","slug":"Articles","permalink":"http://youngjinmo.github.io/categories/Articles/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://youngjinmo.github.io/tags/javascript/"},{"name":"vue","slug":"vue","permalink":"http://youngjinmo.github.io/tags/vue/"},{"name":"weekly-review","slug":"weekly-review","permalink":"http://youngjinmo.github.io/tags/weekly-review/"},{"name":"documentation","slug":"documentation","permalink":"http://youngjinmo.github.io/tags/documentation/"},{"name":"readme","slug":"readme","permalink":"http://youngjinmo.github.io/tags/readme/"},{"name":"java","slug":"java","permalink":"http://youngjinmo.github.io/tags/java/"},{"name":"oracle","slug":"oracle","permalink":"http://youngjinmo.github.io/tags/oracle/"},{"name":"docker","slug":"docker","permalink":"http://youngjinmo.github.io/tags/docker/"},{"name":"springboot","slug":"springboot","permalink":"http://youngjinmo.github.io/tags/springboot/"},{"name":"mybatis","slug":"mybatis","permalink":"http://youngjinmo.github.io/tags/mybatis/"},{"name":"github","slug":"github","permalink":"http://youngjinmo.github.io/tags/github/"},{"name":"blacklivesmatter","slug":"blacklivesmatter","permalink":"http://youngjinmo.github.io/tags/blacklivesmatter/"},{"name":"stock","slug":"stock","permalink":"http://youngjinmo.github.io/tags/stock/"},{"name":"contribution","slug":"contribution","permalink":"http://youngjinmo.github.io/tags/contribution/"},{"name":"xml","slug":"xml","permalink":"http://youngjinmo.github.io/tags/xml/"},{"name":"json","slug":"json","permalink":"http://youngjinmo.github.io/tags/json/"},{"name":"XMLHttpRequest","slug":"XMLHttpRequest","permalink":"http://youngjinmo.github.io/tags/XMLHttpRequest/"},{"name":"servlet","slug":"servlet","permalink":"http://youngjinmo.github.io/tags/servlet/"},{"name":"algorithms","slug":"algorithms","permalink":"http://youngjinmo.github.io/tags/algorithms/"},{"name":"mysql","slug":"mysql","permalink":"http://youngjinmo.github.io/tags/mysql/"},{"name":"database","slug":"database","permalink":"http://youngjinmo.github.io/tags/database/"},{"name":"generic","slug":"generic","permalink":"http://youngjinmo.github.io/tags/generic/"},{"name":"git","slug":"git","permalink":"http://youngjinmo.github.io/tags/git/"},{"name":"error","slug":"error","permalink":"http://youngjinmo.github.io/tags/error/"},{"name":"jvm","slug":"jvm","permalink":"http://youngjinmo.github.io/tags/jvm/"},{"name":"enumeration","slug":"enumeration","permalink":"http://youngjinmo.github.io/tags/enumeration/"},{"name":"iterator","slug":"iterator","permalink":"http://youngjinmo.github.io/tags/iterator/"},{"name":"interface","slug":"interface","permalink":"http://youngjinmo.github.io/tags/interface/"},{"name":"http","slug":"http","permalink":"http://youngjinmo.github.io/tags/http/"},{"name":"java8","slug":"java8","permalink":"http://youngjinmo.github.io/tags/java8/"},{"name":"lambda","slug":"lambda","permalink":"http://youngjinmo.github.io/tags/lambda/"},{"name":"functional interface","slug":"functional-interface","permalink":"http://youngjinmo.github.io/tags/functional-interface/"},{"name":"io","slug":"io","permalink":"http://youngjinmo.github.io/tags/io/"},{"name":"api","slug":"api","permalink":"http://youngjinmo.github.io/tags/api/"},{"name":"architecture","slug":"architecture","permalink":"http://youngjinmo.github.io/tags/architecture/"},{"name":"rest","slug":"rest","permalink":"http://youngjinmo.github.io/tags/rest/"},{"name":"jar","slug":"jar","permalink":"http://youngjinmo.github.io/tags/jar/"},{"name":"war","slug":"war","permalink":"http://youngjinmo.github.io/tags/war/"},{"name":"webserver","slug":"webserver","permalink":"http://youngjinmo.github.io/tags/webserver/"},{"name":"stash","slug":"stash","permalink":"http://youngjinmo.github.io/tags/stash/"},{"name":"string","slug":"string","permalink":"http://youngjinmo.github.io/tags/string/"},{"name":"stringbuffer","slug":"stringbuffer","permalink":"http://youngjinmo.github.io/tags/stringbuffer/"},{"name":"exception","slug":"exception","permalink":"http://youngjinmo.github.io/tags/exception/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://youngjinmo.github.io/tags/ubuntu/"},{"name":"object","slug":"object","permalink":"http://youngjinmo.github.io/tags/object/"},{"name":"sql","slug":"sql","permalink":"http://youngjinmo.github.io/tags/sql/"},{"name":"oop","slug":"oop","permalink":"http://youngjinmo.github.io/tags/oop/"},{"name":"datastructure","slug":"datastructure","permalink":"http://youngjinmo.github.io/tags/datastructure/"},{"name":"inner class","slug":"inner-class","permalink":"http://youngjinmo.github.io/tags/inner-class/"},{"name":"intellij","slug":"intellij","permalink":"http://youngjinmo.github.io/tags/intellij/"},{"name":"ide","slug":"ide","permalink":"http://youngjinmo.github.io/tags/ide/"},{"name":"gradle","slug":"gradle","permalink":"http://youngjinmo.github.io/tags/gradle/"},{"name":"jquery","slug":"jquery","permalink":"http://youngjinmo.github.io/tags/jquery/"},{"name":"baekjoon","slug":"baekjoon","permalink":"http://youngjinmo.github.io/tags/baekjoon/"},{"name":"cookie","slug":"cookie","permalink":"http://youngjinmo.github.io/tags/cookie/"},{"name":"session","slug":"session","permalink":"http://youngjinmo.github.io/tags/session/"},{"name":"cache","slug":"cache","permalink":"http://youngjinmo.github.io/tags/cache/"},{"name":"array","slug":"array","permalink":"http://youngjinmo.github.io/tags/array/"},{"name":"tutorial","slug":"tutorial","permalink":"http://youngjinmo.github.io/tags/tutorial/"},{"name":"eclipse","slug":"eclipse","permalink":"http://youngjinmo.github.io/tags/eclipse/"},{"name":"netflix","slug":"netflix","permalink":"http://youngjinmo.github.io/tags/netflix/"},{"name":"extension","slug":"extension","permalink":"http://youngjinmo.github.io/tags/extension/"},{"name":"chrome","slug":"chrome","permalink":"http://youngjinmo.github.io/tags/chrome/"},{"name":"mustache","slug":"mustache","permalink":"http://youngjinmo.github.io/tags/mustache/"},{"name":"tip","slug":"tip","permalink":"http://youngjinmo.github.io/tags/tip/"},{"name":"macos","slug":"macos","permalink":"http://youngjinmo.github.io/tags/macos/"},{"name":"aws","slug":"aws","permalink":"http://youngjinmo.github.io/tags/aws/"},{"name":"cloud","slug":"cloud","permalink":"http://youngjinmo.github.io/tags/cloud/"},{"name":"python","slug":"python","permalink":"http://youngjinmo.github.io/tags/python/"},{"name":"blockchain","slug":"blockchain","permalink":"http://youngjinmo.github.io/tags/blockchain/"},{"name":"alphago","slug":"alphago","permalink":"http://youngjinmo.github.io/tags/alphago/"},{"name":"leesedol","slug":"leesedol","permalink":"http://youngjinmo.github.io/tags/leesedol/"},{"name":"go","slug":"go","permalink":"http://youngjinmo.github.io/tags/go/"},{"name":"ai","slug":"ai","permalink":"http://youngjinmo.github.io/tags/ai/"},{"name":"databse","slug":"databse","permalink":"http://youngjinmo.github.io/tags/databse/"},{"name":"security","slug":"security","permalink":"http://youngjinmo.github.io/tags/security/"},{"name":"hexo","slug":"hexo","permalink":"http://youngjinmo.github.io/tags/hexo/"},{"name":"license","slug":"license","permalink":"http://youngjinmo.github.io/tags/license/"},{"name":"reg","slug":"reg","permalink":"http://youngjinmo.github.io/tags/reg/"},{"name":"fill","slug":"fill","permalink":"http://youngjinmo.github.io/tags/fill/"},{"name":"indexof","slug":"indexof","permalink":"http://youngjinmo.github.io/tags/indexof/"},{"name":"spring-security","slug":"spring-security","permalink":"http://youngjinmo.github.io/tags/spring-security/"},{"name":"ios","slug":"ios","permalink":"http://youngjinmo.github.io/tags/ios/"},{"name":"ipad","slug":"ipad","permalink":"http://youngjinmo.github.io/tags/ipad/"},{"name":"homebrew","slug":"homebrew","permalink":"http://youngjinmo.github.io/tags/homebrew/"},{"name":"vim","slug":"vim","permalink":"http://youngjinmo.github.io/tags/vim/"},{"name":"compiler","slug":"compiler","permalink":"http://youngjinmo.github.io/tags/compiler/"},{"name":"interpreter","slug":"interpreter","permalink":"http://youngjinmo.github.io/tags/interpreter/"},{"name":"casting","slug":"casting","permalink":"http://youngjinmo.github.io/tags/casting/"},{"name":"markup","slug":"markup","permalink":"http://youngjinmo.github.io/tags/markup/"},{"name":"math","slug":"math","permalink":"http://youngjinmo.github.io/tags/math/"},{"name":"normalization","slug":"normalization","permalink":"http://youngjinmo.github.io/tags/normalization/"},{"name":"php","slug":"php","permalink":"http://youngjinmo.github.io/tags/php/"},{"name":"javscript","slug":"javscript","permalink":"http://youngjinmo.github.io/tags/javscript/"},{"name":"gadget","slug":"gadget","permalink":"http://youngjinmo.github.io/tags/gadget/"},{"name":"healthcare","slug":"healthcare","permalink":"http://youngjinmo.github.io/tags/healthcare/"},{"name":"IoT","slug":"IoT","permalink":"http://youngjinmo.github.io/tags/IoT/"},{"name":"career","slug":"career","permalink":"http://youngjinmo.github.io/tags/career/"}]}